/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "generateCodeFrame": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_0__.generateCodeFrame),
/* harmony export */   "BASE_TRANSITION": () => (/* binding */ BASE_TRANSITION),
/* harmony export */   "CAMELIZE": () => (/* binding */ CAMELIZE),
/* harmony export */   "CAPITALIZE": () => (/* binding */ CAPITALIZE),
/* harmony export */   "CREATE_BLOCK": () => (/* binding */ CREATE_BLOCK),
/* harmony export */   "CREATE_COMMENT": () => (/* binding */ CREATE_COMMENT),
/* harmony export */   "CREATE_SLOTS": () => (/* binding */ CREATE_SLOTS),
/* harmony export */   "CREATE_STATIC": () => (/* binding */ CREATE_STATIC),
/* harmony export */   "CREATE_TEXT": () => (/* binding */ CREATE_TEXT),
/* harmony export */   "CREATE_VNODE": () => (/* binding */ CREATE_VNODE),
/* harmony export */   "FRAGMENT": () => (/* binding */ FRAGMENT),
/* harmony export */   "IS_REF": () => (/* binding */ IS_REF),
/* harmony export */   "KEEP_ALIVE": () => (/* binding */ KEEP_ALIVE),
/* harmony export */   "MERGE_PROPS": () => (/* binding */ MERGE_PROPS),
/* harmony export */   "OPEN_BLOCK": () => (/* binding */ OPEN_BLOCK),
/* harmony export */   "POP_SCOPE_ID": () => (/* binding */ POP_SCOPE_ID),
/* harmony export */   "PUSH_SCOPE_ID": () => (/* binding */ PUSH_SCOPE_ID),
/* harmony export */   "RENDER_LIST": () => (/* binding */ RENDER_LIST),
/* harmony export */   "RENDER_SLOT": () => (/* binding */ RENDER_SLOT),
/* harmony export */   "RESOLVE_COMPONENT": () => (/* binding */ RESOLVE_COMPONENT),
/* harmony export */   "RESOLVE_DIRECTIVE": () => (/* binding */ RESOLVE_DIRECTIVE),
/* harmony export */   "RESOLVE_DYNAMIC_COMPONENT": () => (/* binding */ RESOLVE_DYNAMIC_COMPONENT),
/* harmony export */   "RESOLVE_FILTER": () => (/* binding */ RESOLVE_FILTER),
/* harmony export */   "SET_BLOCK_TRACKING": () => (/* binding */ SET_BLOCK_TRACKING),
/* harmony export */   "SUSPENSE": () => (/* binding */ SUSPENSE),
/* harmony export */   "TELEPORT": () => (/* binding */ TELEPORT),
/* harmony export */   "TO_DISPLAY_STRING": () => (/* binding */ TO_DISPLAY_STRING),
/* harmony export */   "TO_HANDLERS": () => (/* binding */ TO_HANDLERS),
/* harmony export */   "TO_HANDLER_KEY": () => (/* binding */ TO_HANDLER_KEY),
/* harmony export */   "UNREF": () => (/* binding */ UNREF),
/* harmony export */   "WITH_CTX": () => (/* binding */ WITH_CTX),
/* harmony export */   "WITH_DIRECTIVES": () => (/* binding */ WITH_DIRECTIVES),
/* harmony export */   "WITH_SCOPE_ID": () => (/* binding */ WITH_SCOPE_ID),
/* harmony export */   "advancePositionWithClone": () => (/* binding */ advancePositionWithClone),
/* harmony export */   "advancePositionWithMutation": () => (/* binding */ advancePositionWithMutation),
/* harmony export */   "assert": () => (/* binding */ assert),
/* harmony export */   "baseCompile": () => (/* binding */ baseCompile),
/* harmony export */   "baseParse": () => (/* binding */ baseParse),
/* harmony export */   "buildProps": () => (/* binding */ buildProps),
/* harmony export */   "buildSlots": () => (/* binding */ buildSlots),
/* harmony export */   "checkCompatEnabled": () => (/* binding */ checkCompatEnabled),
/* harmony export */   "createArrayExpression": () => (/* binding */ createArrayExpression),
/* harmony export */   "createAssignmentExpression": () => (/* binding */ createAssignmentExpression),
/* harmony export */   "createBlockStatement": () => (/* binding */ createBlockStatement),
/* harmony export */   "createCacheExpression": () => (/* binding */ createCacheExpression),
/* harmony export */   "createCallExpression": () => (/* binding */ createCallExpression),
/* harmony export */   "createCompilerError": () => (/* binding */ createCompilerError),
/* harmony export */   "createCompoundExpression": () => (/* binding */ createCompoundExpression),
/* harmony export */   "createConditionalExpression": () => (/* binding */ createConditionalExpression),
/* harmony export */   "createForLoopParams": () => (/* binding */ createForLoopParams),
/* harmony export */   "createFunctionExpression": () => (/* binding */ createFunctionExpression),
/* harmony export */   "createIfStatement": () => (/* binding */ createIfStatement),
/* harmony export */   "createInterpolation": () => (/* binding */ createInterpolation),
/* harmony export */   "createObjectExpression": () => (/* binding */ createObjectExpression),
/* harmony export */   "createObjectProperty": () => (/* binding */ createObjectProperty),
/* harmony export */   "createReturnStatement": () => (/* binding */ createReturnStatement),
/* harmony export */   "createRoot": () => (/* binding */ createRoot),
/* harmony export */   "createSequenceExpression": () => (/* binding */ createSequenceExpression),
/* harmony export */   "createSimpleExpression": () => (/* binding */ createSimpleExpression),
/* harmony export */   "createStructuralDirectiveTransform": () => (/* binding */ createStructuralDirectiveTransform),
/* harmony export */   "createTemplateLiteral": () => (/* binding */ createTemplateLiteral),
/* harmony export */   "createTransformContext": () => (/* binding */ createTransformContext),
/* harmony export */   "createVNodeCall": () => (/* binding */ createVNodeCall),
/* harmony export */   "findDir": () => (/* binding */ findDir),
/* harmony export */   "findProp": () => (/* binding */ findProp),
/* harmony export */   "generate": () => (/* binding */ generate),
/* harmony export */   "getBaseTransformPreset": () => (/* binding */ getBaseTransformPreset),
/* harmony export */   "getInnerRange": () => (/* binding */ getInnerRange),
/* harmony export */   "hasDynamicKeyVBind": () => (/* binding */ hasDynamicKeyVBind),
/* harmony export */   "hasScopeRef": () => (/* binding */ hasScopeRef),
/* harmony export */   "helperNameMap": () => (/* binding */ helperNameMap),
/* harmony export */   "injectProp": () => (/* binding */ injectProp),
/* harmony export */   "isBindKey": () => (/* binding */ isBindKey),
/* harmony export */   "isBuiltInType": () => (/* binding */ isBuiltInType),
/* harmony export */   "isCoreComponent": () => (/* binding */ isCoreComponent),
/* harmony export */   "isMemberExpression": () => (/* binding */ isMemberExpression),
/* harmony export */   "isSimpleIdentifier": () => (/* binding */ isSimpleIdentifier),
/* harmony export */   "isSlotOutlet": () => (/* binding */ isSlotOutlet),
/* harmony export */   "isStaticExp": () => (/* binding */ isStaticExp),
/* harmony export */   "isTemplateNode": () => (/* binding */ isTemplateNode),
/* harmony export */   "isText": () => (/* binding */ isText),
/* harmony export */   "isVSlot": () => (/* binding */ isVSlot),
/* harmony export */   "locStub": () => (/* binding */ locStub),
/* harmony export */   "noopDirectiveTransform": () => (/* binding */ noopDirectiveTransform),
/* harmony export */   "processExpression": () => (/* binding */ processExpression),
/* harmony export */   "processFor": () => (/* binding */ processFor),
/* harmony export */   "processIf": () => (/* binding */ processIf),
/* harmony export */   "processSlotOutlet": () => (/* binding */ processSlotOutlet),
/* harmony export */   "registerRuntimeHelpers": () => (/* binding */ registerRuntimeHelpers),
/* harmony export */   "resolveComponentType": () => (/* binding */ resolveComponentType),
/* harmony export */   "toValidAssetId": () => (/* binding */ toValidAssetId),
/* harmony export */   "trackSlotScopes": () => (/* binding */ trackSlotScopes),
/* harmony export */   "trackVForSlotScopes": () => (/* binding */ trackVForSlotScopes),
/* harmony export */   "transform": () => (/* binding */ transform),
/* harmony export */   "transformBind": () => (/* binding */ transformBind),
/* harmony export */   "transformElement": () => (/* binding */ transformElement),
/* harmony export */   "transformExpression": () => (/* binding */ transformExpression),
/* harmony export */   "transformModel": () => (/* binding */ transformModel),
/* harmony export */   "transformOn": () => (/* binding */ transformOn),
/* harmony export */   "traverseNode": () => (/* binding */ traverseNode),
/* harmony export */   "warnDeprecation": () => (/* binding */ warnDeprecation)
/* harmony export */ });
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");
var _errorMessages, _helperNameMap, _deprecationData;

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




function defaultOnError(error) {
  throw error;
}

function defaultOnWarn(msg) {
   true && console.warn("[Vue warn] ".concat(msg.message));
}

function createCompilerError(code, loc, messages, additionalMessage) {
  var msg =  true ? (messages || errorMessages)[code] + (additionalMessage || "") : 0;
  var error = new SyntaxError(String(msg));
  error.code = code;
  error.loc = loc;
  return error;
}

var errorMessages = (_errorMessages = {}, _defineProperty(_errorMessages, 0
/* ABRUPT_CLOSING_OF_EMPTY_COMMENT */
, 'Illegal comment.'), _defineProperty(_errorMessages, 1
/* CDATA_IN_HTML_CONTENT */
, 'CDATA section is allowed only in XML context.'), _defineProperty(_errorMessages, 2
/* DUPLICATE_ATTRIBUTE */
, 'Duplicate attribute.'), _defineProperty(_errorMessages, 3
/* END_TAG_WITH_ATTRIBUTES */
, 'End tag cannot have attributes.'), _defineProperty(_errorMessages, 4
/* END_TAG_WITH_TRAILING_SOLIDUS */
, "Illegal '/' in tags."), _defineProperty(_errorMessages, 5
/* EOF_BEFORE_TAG_NAME */
, 'Unexpected EOF in tag.'), _defineProperty(_errorMessages, 6
/* EOF_IN_CDATA */
, 'Unexpected EOF in CDATA section.'), _defineProperty(_errorMessages, 7
/* EOF_IN_COMMENT */
, 'Unexpected EOF in comment.'), _defineProperty(_errorMessages, 8
/* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */
, 'Unexpected EOF in script.'), _defineProperty(_errorMessages, 9
/* EOF_IN_TAG */
, 'Unexpected EOF in tag.'), _defineProperty(_errorMessages, 10
/* INCORRECTLY_CLOSED_COMMENT */
, 'Incorrectly closed comment.'), _defineProperty(_errorMessages, 11
/* INCORRECTLY_OPENED_COMMENT */
, 'Incorrectly opened comment.'), _defineProperty(_errorMessages, 12
/* INVALID_FIRST_CHARACTER_OF_TAG_NAME */
, "Illegal tag name. Use '&lt;' to print '<'."), _defineProperty(_errorMessages, 13
/* MISSING_ATTRIBUTE_VALUE */
, 'Attribute value was expected.'), _defineProperty(_errorMessages, 14
/* MISSING_END_TAG_NAME */
, 'End tag name was expected.'), _defineProperty(_errorMessages, 15
/* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */
, 'Whitespace was expected.'), _defineProperty(_errorMessages, 16
/* NESTED_COMMENT */
, "Unexpected '<!--' in comment."), _defineProperty(_errorMessages, 17
/* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */
, 'Attribute name cannot contain U+0022 ("), U+0027 (\'), and U+003C (<).'), _defineProperty(_errorMessages, 18
/* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */
, 'Unquoted attribute value cannot contain U+0022 ("), U+0027 (\'), U+003C (<), U+003D (=), and U+0060 (`).'), _defineProperty(_errorMessages, 19
/* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */
, "Attribute name cannot start with '='."), _defineProperty(_errorMessages, 21
/* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */
, "'<?' is allowed only in XML context."), _defineProperty(_errorMessages, 20
/* UNEXPECTED_NULL_CHARACTER */
, "Unexpected null cahracter."), _defineProperty(_errorMessages, 22
/* UNEXPECTED_SOLIDUS_IN_TAG */
, "Illegal '/' in tags."), _defineProperty(_errorMessages, 23
/* X_INVALID_END_TAG */
, 'Invalid end tag.'), _defineProperty(_errorMessages, 24
/* X_MISSING_END_TAG */
, 'Element is missing end tag.'), _defineProperty(_errorMessages, 25
/* X_MISSING_INTERPOLATION_END */
, 'Interpolation end sign was not found.'), _defineProperty(_errorMessages, 26
/* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */
, 'End bracket for dynamic directive argument was not found. ' + 'Note that dynamic directive argument cannot contain spaces.'), _defineProperty(_errorMessages, 27
/* X_V_IF_NO_EXPRESSION */
, "v-if/v-else-if is missing expression."), _defineProperty(_errorMessages, 28
/* X_V_IF_SAME_KEY */
, "v-if/else branches must use unique keys."), _defineProperty(_errorMessages, 29
/* X_V_ELSE_NO_ADJACENT_IF */
, "v-else/v-else-if has no adjacent v-if."), _defineProperty(_errorMessages, 30
/* X_V_FOR_NO_EXPRESSION */
, "v-for is missing expression."), _defineProperty(_errorMessages, 31
/* X_V_FOR_MALFORMED_EXPRESSION */
, "v-for has invalid expression."), _defineProperty(_errorMessages, 32
/* X_V_FOR_TEMPLATE_KEY_PLACEMENT */
, "<template v-for> key should be placed on the <template> tag."), _defineProperty(_errorMessages, 33
/* X_V_BIND_NO_EXPRESSION */
, "v-bind is missing expression."), _defineProperty(_errorMessages, 34
/* X_V_ON_NO_EXPRESSION */
, "v-on is missing expression."), _defineProperty(_errorMessages, 35
/* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */
, "Unexpected custom directive on <slot> outlet."), _defineProperty(_errorMessages, 36
/* X_V_SLOT_MIXED_SLOT_USAGE */
, "Mixed v-slot usage on both the component and nested <template>." + "When there are multiple named slots, all slots should use <template> " + "syntax to avoid scope ambiguity."), _defineProperty(_errorMessages, 37
/* X_V_SLOT_DUPLICATE_SLOT_NAMES */
, "Duplicate slot names found. "), _defineProperty(_errorMessages, 38
/* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */
, "Extraneous children found when component already has explicitly named " + "default slot. These children will be ignored."), _defineProperty(_errorMessages, 39
/* X_V_SLOT_MISPLACED */
, "v-slot can only be used on components or <template> tags."), _defineProperty(_errorMessages, 40
/* X_V_MODEL_NO_EXPRESSION */
, "v-model is missing expression."), _defineProperty(_errorMessages, 41
/* X_V_MODEL_MALFORMED_EXPRESSION */
, "v-model value must be a valid JavaScript member expression."), _defineProperty(_errorMessages, 42
/* X_V_MODEL_ON_SCOPE_VARIABLE */
, "v-model cannot be used on v-for or v-slot scope variables because they are not writable."), _defineProperty(_errorMessages, 43
/* X_INVALID_EXPRESSION */
, "Error parsing JavaScript expression: "), _defineProperty(_errorMessages, 44
/* X_KEEP_ALIVE_INVALID_CHILDREN */
, "<KeepAlive> expects exactly one child component."), _defineProperty(_errorMessages, 45
/* X_PREFIX_ID_NOT_SUPPORTED */
, "\"prefixIdentifiers\" option is not supported in this build of compiler."), _defineProperty(_errorMessages, 46
/* X_MODULE_MODE_NOT_SUPPORTED */
, "ES module mode is not supported in this build of compiler."), _defineProperty(_errorMessages, 47
/* X_CACHE_HANDLER_NOT_SUPPORTED */
, "\"cacheHandlers\" option is only supported when the \"prefixIdentifiers\" option is enabled."), _defineProperty(_errorMessages, 48
/* X_SCOPE_ID_NOT_SUPPORTED */
, "\"scopeId\" option is only supported in module mode."), _defineProperty(_errorMessages, 49
/* __EXTEND_POINT__ */
, ""), _errorMessages);
var FRAGMENT = Symbol( true ? "Fragment" : 0);
var TELEPORT = Symbol( true ? "Teleport" : 0);
var SUSPENSE = Symbol( true ? "Suspense" : 0);
var KEEP_ALIVE = Symbol( true ? "KeepAlive" : 0);
var BASE_TRANSITION = Symbol( true ? "BaseTransition" : 0);
var OPEN_BLOCK = Symbol( true ? "openBlock" : 0);
var CREATE_BLOCK = Symbol( true ? "createBlock" : 0);
var CREATE_VNODE = Symbol( true ? "createVNode" : 0);
var CREATE_COMMENT = Symbol( true ? "createCommentVNode" : 0);
var CREATE_TEXT = Symbol( true ? "createTextVNode" : 0);
var CREATE_STATIC = Symbol( true ? "createStaticVNode" : 0);
var RESOLVE_COMPONENT = Symbol( true ? "resolveComponent" : 0);
var RESOLVE_DYNAMIC_COMPONENT = Symbol( true ? "resolveDynamicComponent" : 0);
var RESOLVE_DIRECTIVE = Symbol( true ? "resolveDirective" : 0);
var RESOLVE_FILTER = Symbol( true ? "resolveFilter" : 0);
var WITH_DIRECTIVES = Symbol( true ? "withDirectives" : 0);
var RENDER_LIST = Symbol( true ? "renderList" : 0);
var RENDER_SLOT = Symbol( true ? "renderSlot" : 0);
var CREATE_SLOTS = Symbol( true ? "createSlots" : 0);
var TO_DISPLAY_STRING = Symbol( true ? "toDisplayString" : 0);
var MERGE_PROPS = Symbol( true ? "mergeProps" : 0);
var TO_HANDLERS = Symbol( true ? "toHandlers" : 0);
var CAMELIZE = Symbol( true ? "camelize" : 0);
var CAPITALIZE = Symbol( true ? "capitalize" : 0);
var TO_HANDLER_KEY = Symbol( true ? "toHandlerKey" : 0);
var SET_BLOCK_TRACKING = Symbol( true ? "setBlockTracking" : 0);
var PUSH_SCOPE_ID = Symbol( true ? "pushScopeId" : 0);
var POP_SCOPE_ID = Symbol( true ? "popScopeId" : 0);
var WITH_SCOPE_ID = Symbol( true ? "withScopeId" : 0);
var WITH_CTX = Symbol( true ? "withCtx" : 0);
var UNREF = Symbol( true ? "unref" : 0);
var IS_REF = Symbol( true ? "isRef" : 0); // Name mapping for runtime helpers that need to be imported from 'vue' in
// generated code. Make sure these are correctly exported in the runtime!
// Using `any` here because TS doesn't allow symbols as index type.

var helperNameMap = (_helperNameMap = {}, _defineProperty(_helperNameMap, FRAGMENT, "Fragment"), _defineProperty(_helperNameMap, TELEPORT, "Teleport"), _defineProperty(_helperNameMap, SUSPENSE, "Suspense"), _defineProperty(_helperNameMap, KEEP_ALIVE, "KeepAlive"), _defineProperty(_helperNameMap, BASE_TRANSITION, "BaseTransition"), _defineProperty(_helperNameMap, OPEN_BLOCK, "openBlock"), _defineProperty(_helperNameMap, CREATE_BLOCK, "createBlock"), _defineProperty(_helperNameMap, CREATE_VNODE, "createVNode"), _defineProperty(_helperNameMap, CREATE_COMMENT, "createCommentVNode"), _defineProperty(_helperNameMap, CREATE_TEXT, "createTextVNode"), _defineProperty(_helperNameMap, CREATE_STATIC, "createStaticVNode"), _defineProperty(_helperNameMap, RESOLVE_COMPONENT, "resolveComponent"), _defineProperty(_helperNameMap, RESOLVE_DYNAMIC_COMPONENT, "resolveDynamicComponent"), _defineProperty(_helperNameMap, RESOLVE_DIRECTIVE, "resolveDirective"), _defineProperty(_helperNameMap, RESOLVE_FILTER, "resolveFilter"), _defineProperty(_helperNameMap, WITH_DIRECTIVES, "withDirectives"), _defineProperty(_helperNameMap, RENDER_LIST, "renderList"), _defineProperty(_helperNameMap, RENDER_SLOT, "renderSlot"), _defineProperty(_helperNameMap, CREATE_SLOTS, "createSlots"), _defineProperty(_helperNameMap, TO_DISPLAY_STRING, "toDisplayString"), _defineProperty(_helperNameMap, MERGE_PROPS, "mergeProps"), _defineProperty(_helperNameMap, TO_HANDLERS, "toHandlers"), _defineProperty(_helperNameMap, CAMELIZE, "camelize"), _defineProperty(_helperNameMap, CAPITALIZE, "capitalize"), _defineProperty(_helperNameMap, TO_HANDLER_KEY, "toHandlerKey"), _defineProperty(_helperNameMap, SET_BLOCK_TRACKING, "setBlockTracking"), _defineProperty(_helperNameMap, PUSH_SCOPE_ID, "pushScopeId"), _defineProperty(_helperNameMap, POP_SCOPE_ID, "popScopeId"), _defineProperty(_helperNameMap, WITH_SCOPE_ID, "withScopeId"), _defineProperty(_helperNameMap, WITH_CTX, "withCtx"), _defineProperty(_helperNameMap, UNREF, "unref"), _defineProperty(_helperNameMap, IS_REF, "isRef"), _helperNameMap);

function registerRuntimeHelpers(helpers) {
  Object.getOwnPropertySymbols(helpers).forEach(function (s) {
    helperNameMap[s] = helpers[s];
  });
} // AST Utilities ---------------------------------------------------------------
// Some expressions, e.g. sequence and conditional expressions, are never
// associated with template nodes, so their source locations are just a stub.
// Container types like CompoundExpression also don't need a real location.


var locStub = {
  source: '',
  start: {
    line: 1,
    column: 1,
    offset: 0
  },
  end: {
    line: 1,
    column: 1,
    offset: 0
  }
};

function createRoot(children) {
  var loc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : locStub;
  return {
    type: 0
    /* ROOT */
    ,
    children: children,
    helpers: [],
    components: [],
    directives: [],
    hoists: [],
    imports: [],
    cached: 0,
    temps: 0,
    codegenNode: undefined,
    loc: loc
  };
}

function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives) {
  var isBlock = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
  var disableTracking = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;
  var loc = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : locStub;

  if (context) {
    if (isBlock) {
      context.helper(OPEN_BLOCK);
      context.helper(CREATE_BLOCK);
    } else {
      context.helper(CREATE_VNODE);
    }

    if (directives) {
      context.helper(WITH_DIRECTIVES);
    }
  }

  return {
    type: 13
    /* VNODE_CALL */
    ,
    tag: tag,
    props: props,
    children: children,
    patchFlag: patchFlag,
    dynamicProps: dynamicProps,
    directives: directives,
    isBlock: isBlock,
    disableTracking: disableTracking,
    loc: loc
  };
}

function createArrayExpression(elements) {
  var loc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : locStub;
  return {
    type: 17
    /* JS_ARRAY_EXPRESSION */
    ,
    loc: loc,
    elements: elements
  };
}

function createObjectExpression(properties) {
  var loc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : locStub;
  return {
    type: 15
    /* JS_OBJECT_EXPRESSION */
    ,
    loc: loc,
    properties: properties
  };
}

function createObjectProperty(key, value) {
  return {
    type: 16
    /* JS_PROPERTY */
    ,
    loc: locStub,
    key: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(key) ? createSimpleExpression(key, true) : key,
    value: value
  };
}

function createSimpleExpression(content, isStatic)
/* NOT_CONSTANT */
{
  var loc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : locStub;
  var constType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  return {
    type: 4
    /* SIMPLE_EXPRESSION */
    ,
    loc: loc,
    content: content,
    isStatic: isStatic,
    constType: isStatic ? 3
    /* CAN_STRINGIFY */
    : constType
  };
}

function createInterpolation(content, loc) {
  return {
    type: 5
    /* INTERPOLATION */
    ,
    loc: loc,
    content: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(content) ? createSimpleExpression(content, false, loc) : content
  };
}

function createCompoundExpression(children) {
  var loc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : locStub;
  return {
    type: 8
    /* COMPOUND_EXPRESSION */
    ,
    loc: loc,
    children: children
  };
}

function createCallExpression(callee) {
  var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var loc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : locStub;
  return {
    type: 14
    /* JS_CALL_EXPRESSION */
    ,
    loc: loc,
    callee: callee,
    arguments: args
  };
}

function createFunctionExpression(params) {
  var returns = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  var newline = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var isSlot = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var loc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : locStub;
  return {
    type: 18
    /* JS_FUNCTION_EXPRESSION */
    ,
    params: params,
    returns: returns,
    newline: newline,
    isSlot: isSlot,
    loc: loc
  };
}

function createConditionalExpression(test, consequent, alternate) {
  var newline = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  return {
    type: 19
    /* JS_CONDITIONAL_EXPRESSION */
    ,
    test: test,
    consequent: consequent,
    alternate: alternate,
    newline: newline,
    loc: locStub
  };
}

function createCacheExpression(index, value) {
  var isVNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return {
    type: 20
    /* JS_CACHE_EXPRESSION */
    ,
    index: index,
    value: value,
    isVNode: isVNode,
    loc: locStub
  };
}

function createBlockStatement(body) {
  return {
    type: 21
    /* JS_BLOCK_STATEMENT */
    ,
    body: body,
    loc: locStub
  };
}

function createTemplateLiteral(elements) {
  return {
    type: 22
    /* JS_TEMPLATE_LITERAL */
    ,
    elements: elements,
    loc: locStub
  };
}

function createIfStatement(test, consequent, alternate) {
  return {
    type: 23
    /* JS_IF_STATEMENT */
    ,
    test: test,
    consequent: consequent,
    alternate: alternate,
    loc: locStub
  };
}

function createAssignmentExpression(left, right) {
  return {
    type: 24
    /* JS_ASSIGNMENT_EXPRESSION */
    ,
    left: left,
    right: right,
    loc: locStub
  };
}

function createSequenceExpression(expressions) {
  return {
    type: 25
    /* JS_SEQUENCE_EXPRESSION */
    ,
    expressions: expressions,
    loc: locStub
  };
}

function createReturnStatement(returns) {
  return {
    type: 26
    /* JS_RETURN_STATEMENT */
    ,
    returns: returns,
    loc: locStub
  };
}

var isStaticExp = function isStaticExp(p) {
  return p.type === 4
  /* SIMPLE_EXPRESSION */
  && p.isStatic;
};

var isBuiltInType = function isBuiltInType(tag, expected) {
  return tag === expected || tag === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hyphenate)(expected);
};

function isCoreComponent(tag) {
  if (isBuiltInType(tag, 'Teleport')) {
    return TELEPORT;
  } else if (isBuiltInType(tag, 'Suspense')) {
    return SUSPENSE;
  } else if (isBuiltInType(tag, 'KeepAlive')) {
    return KEEP_ALIVE;
  } else if (isBuiltInType(tag, 'BaseTransition')) {
    return BASE_TRANSITION;
  }
}

var nonIdentifierRE = /^\d|[^\$\w]/;

var isSimpleIdentifier = function isSimpleIdentifier(name) {
  return !nonIdentifierRE.test(name);
};

var memberExpRE = /^[A-Za-z_$\xA0-\uFFFF][\w$\xA0-\uFFFF]*(?:\s*\.\s*[A-Za-z_$\xA0-\uFFFF][\w$\xA0-\uFFFF]*|\[(.+)\])*$/;

var isMemberExpression = function isMemberExpression(path) {
  if (!path) return false;
  var matched = memberExpRE.exec(path.trim());
  if (!matched) return false;
  if (!matched[1]) return true;
  if (!/[\[\]]/.test(matched[1])) return true;
  return isMemberExpression(matched[1].trim());
};

function getInnerRange(loc, offset, length) {
  var source = loc.source.substr(offset, length);
  var newLoc = {
    source: source,
    start: advancePositionWithClone(loc.start, loc.source, offset),
    end: loc.end
  };

  if (length != null) {
    newLoc.end = advancePositionWithClone(loc.start, loc.source, offset + length);
  }

  return newLoc;
}

function advancePositionWithClone(pos, source) {
  var numberOfCharacters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : source.length;
  return advancePositionWithMutation((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, pos), source, numberOfCharacters);
} // advance by mutation without cloning (for performance reasons), since this
// gets called a lot in the parser


function advancePositionWithMutation(pos, source) {
  var numberOfCharacters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : source.length;
  var linesCount = 0;
  var lastNewLinePos = -1;

  for (var i = 0; i < numberOfCharacters; i++) {
    if (source.charCodeAt(i) === 10
    /* newline char code */
    ) {
        linesCount++;
        lastNewLinePos = i;
      }
  }

  pos.offset += numberOfCharacters;
  pos.line += linesCount;
  pos.column = lastNewLinePos === -1 ? pos.column + numberOfCharacters : numberOfCharacters - lastNewLinePos;
  return pos;
}

function assert(condition, msg) {
  /* istanbul ignore if */
  if (!condition) {
    throw new Error(msg || "unexpected compiler condition");
  }
}

function findDir(node, name) {
  var allowEmpty = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  for (var i = 0; i < node.props.length; i++) {
    var p = node.props[i];

    if (p.type === 7
    /* DIRECTIVE */
    && (allowEmpty || p.exp) && ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(name) ? p.name === name : name.test(p.name))) {
      return p;
    }
  }
}

function findProp(node, name) {
  var dynamicOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var allowEmpty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  for (var i = 0; i < node.props.length; i++) {
    var p = node.props[i];

    if (p.type === 6
    /* ATTRIBUTE */
    ) {
        if (dynamicOnly) continue;

        if (p.name === name && (p.value || allowEmpty)) {
          return p;
        }
      } else if (p.name === 'bind' && (p.exp || allowEmpty) && isBindKey(p.arg, name)) {
      return p;
    }
  }
}

function isBindKey(arg, name) {
  return !!(arg && isStaticExp(arg) && arg.content === name);
}

function hasDynamicKeyVBind(node) {
  return node.props.some(function (p) {
    return p.type === 7
    /* DIRECTIVE */
    && p.name === 'bind' && (!p.arg || // v-bind="obj"
    p.arg.type !== 4
    /* SIMPLE_EXPRESSION */
    || // v-bind:[_ctx.foo]
    !p.arg.isStatic);
  } // v-bind:[foo]
  );
}

function isText(node) {
  return node.type === 5
  /* INTERPOLATION */
  || node.type === 2
  /* TEXT */
  ;
}

function isVSlot(p) {
  return p.type === 7
  /* DIRECTIVE */
  && p.name === 'slot';
}

function isTemplateNode(node) {
  return node.type === 1
  /* ELEMENT */
  && node.tagType === 3
  /* TEMPLATE */
  ;
}

function isSlotOutlet(node) {
  return node.type === 1
  /* ELEMENT */
  && node.tagType === 2
  /* SLOT */
  ;
}

function injectProp(node, prop, context) {
  var propsWithInjection;
  var props = node.type === 13
  /* VNODE_CALL */
  ? node.props : node.arguments[2];

  if (props == null || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(props)) {
    propsWithInjection = createObjectExpression([prop]);
  } else if (props.type === 14
  /* JS_CALL_EXPRESSION */
  ) {
      // merged props... add ours
      // only inject key to object literal if it's the first argument so that
      // if doesn't override user provided keys
      var first = props.arguments[0];

      if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(first) && first.type === 15
      /* JS_OBJECT_EXPRESSION */
      ) {
          first.properties.unshift(prop);
        } else {
        if (props.callee === TO_HANDLERS) {
          // #2366
          propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [createObjectExpression([prop]), props]);
        } else {
          props.arguments.unshift(createObjectExpression([prop]));
        }
      }

      !propsWithInjection && (propsWithInjection = props);
    } else if (props.type === 15
  /* JS_OBJECT_EXPRESSION */
  ) {
      var alreadyExists = false; // check existing key to avoid overriding user provided keys

      if (prop.key.type === 4
      /* SIMPLE_EXPRESSION */
      ) {
          var propKeyName = prop.key.content;
          alreadyExists = props.properties.some(function (p) {
            return p.key.type === 4
            /* SIMPLE_EXPRESSION */
            && p.key.content === propKeyName;
          });
        }

      if (!alreadyExists) {
        props.properties.unshift(prop);
      }

      propsWithInjection = props;
    } else {
    // single v-bind with expression, return a merged replacement
    propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [createObjectExpression([prop]), props]);
  }

  if (node.type === 13
  /* VNODE_CALL */
  ) {
      node.props = propsWithInjection;
    } else {
    node.arguments[2] = propsWithInjection;
  }
}

function toValidAssetId(name, type) {
  return "_".concat(type, "_").concat(name.replace(/[^\w]/g, '_'));
} // Check if a node contains expressions that reference current context scope ids


function hasScopeRef(node, ids) {
  if (!node || Object.keys(ids).length === 0) {
    return false;
  }

  switch (node.type) {
    case 1
    /* ELEMENT */
    :
      for (var i = 0; i < node.props.length; i++) {
        var p = node.props[i];

        if (p.type === 7
        /* DIRECTIVE */
        && (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) {
          return true;
        }
      }

      return node.children.some(function (c) {
        return hasScopeRef(c, ids);
      });

    case 11
    /* FOR */
    :
      if (hasScopeRef(node.source, ids)) {
        return true;
      }

      return node.children.some(function (c) {
        return hasScopeRef(c, ids);
      });

    case 9
    /* IF */
    :
      return node.branches.some(function (b) {
        return hasScopeRef(b, ids);
      });

    case 10
    /* IF_BRANCH */
    :
      if (hasScopeRef(node.condition, ids)) {
        return true;
      }

      return node.children.some(function (c) {
        return hasScopeRef(c, ids);
      });

    case 4
    /* SIMPLE_EXPRESSION */
    :
      return !node.isStatic && isSimpleIdentifier(node.content) && !!ids[node.content];

    case 8
    /* COMPOUND_EXPRESSION */
    :
      return node.children.some(function (c) {
        return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(c) && hasScopeRef(c, ids);
      });

    case 5
    /* INTERPOLATION */
    :
    case 12
    /* TEXT_CALL */
    :
      return hasScopeRef(node.content, ids);

    case 2
    /* TEXT */
    :
    case 3
    /* COMMENT */
    :
      return false;

    default:
      if (true) ;
      return false;
  }
}

var deprecationData = (_deprecationData = {}, _defineProperty(_deprecationData, "COMPILER_IS_ON_ELEMENT"
/* COMPILER_IS_ON_ELEMENT */
, {
  message: "Platform-native elements with \"is\" prop will no longer be " + "treated as components in Vue 3 unless the \"is\" value is explicitly " + "prefixed with \"vue:\".",
  link: "https://v3.vuejs.org/guide/migration/custom-elements-interop.html"
}), _defineProperty(_deprecationData, "COMPILER_V_BIND_SYNC"
/* COMPILER_V_BIND_SYNC */
, {
  message: function message(key) {
    return ".sync modifier for v-bind has been removed. Use v-model with " + "argument instead. `v-bind:".concat(key, ".sync` should be changed to ") + "`v-model:".concat(key, "`.");
  },
  link: "https://v3.vuejs.org/guide/migration/v-model.html"
}), _defineProperty(_deprecationData, "COMPILER_V_BIND_PROP"
/* COMPILER_V_BIND_PROP */
, {
  message: ".prop modifier for v-bind has been removed and no longer necessary. " + "Vue 3 will automatically set a binding as DOM property when appropriate."
}), _defineProperty(_deprecationData, "COMPILER_V_BIND_OBJECT_ORDER"
/* COMPILER_V_BIND_OBJECT_ORDER */
, {
  message: "v-bind=\"obj\" usage is now order sensitive and behaves like JavaScript " + "object spread: it will now overwrite an existing non-mergeable attribute " + "that appears before v-bind in the case of conflict. " + "To retain 2.x behavior, move v-bind to make it the first attribute. " + "You can also suppress this warning if the usage is intended.",
  link: "https://v3.vuejs.org/guide/migration/v-bind.html"
}), _defineProperty(_deprecationData, "COMPILER_V_ON_NATIVE"
/* COMPILER_V_ON_NATIVE */
, {
  message: ".native modifier for v-on has been removed as is no longer necessary.",
  link: "https://v3.vuejs.org/guide/migration/v-on-native-modifier-removed.html"
}), _defineProperty(_deprecationData, "COMPILER_V_IF_V_FOR_PRECEDENCE"
/* COMPILER_V_IF_V_FOR_PRECEDENCE */
, {
  message: "v-if / v-for precedence when used on the same element has changed " + "in Vue 3: v-if now takes higher precedence and will no longer have " + "access to v-for scope variables. It is best to avoid the ambiguity " + "with <template> tags or use a computed property that filters v-for " + "data source.",
  link: "https://v3.vuejs.org/guide/migration/v-if-v-for.html"
}), _defineProperty(_deprecationData, "COMPILER_V_FOR_REF"
/* COMPILER_V_FOR_REF */
, {
  message: "Ref usage on v-for no longer creates array ref values in Vue 3. " + "Consider using function refs or refactor to avoid ref usage altogether.",
  link: "https://v3.vuejs.org/guide/migration/array-refs.html"
}), _defineProperty(_deprecationData, "COMPILER_NATIVE_TEMPLATE"
/* COMPILER_NATIVE_TEMPLATE */
, {
  message: "<template> with no special directives will render as a native template " + "element instead of its inner content in Vue 3."
}), _defineProperty(_deprecationData, "COMPILER_INLINE_TEMPLATE"
/* COMPILER_INLINE_TEMPLATE */
, {
  message: "\"inline-template\" has been removed in Vue 3.",
  link: "https://v3.vuejs.org/guide/migration/inline-template-attribute.html"
}), _defineProperty(_deprecationData, "COMPILER_FILTER"
/* COMPILER_FILTERS */
, {
  message: "filters have been removed in Vue 3. " + "The \"|\" symbol will be treated as native JavaScript bitwise OR operator. " + "Use method calls or computed properties instead.",
  link: "https://v3.vuejs.org/guide/migration/filters.html"
}), _deprecationData);

function getCompatValue(key, context) {
  var config = context.options ? context.options.compatConfig : context.compatConfig;
  var value = config && config[key];

  if (key === 'MODE') {
    return value || 3; // compiler defaults to v3 behavior
  } else {
    return value;
  }
}

function isCompatEnabled(key, context) {
  var mode = getCompatValue('MODE', context);
  var value = getCompatValue(key, context); // in v3 mode, only enable if explicitly set to true
  // otherwise enable for any non-false value

  return mode === 3 ? value === true : value !== false;
}

function checkCompatEnabled(key, context, loc) {
  var enabled = isCompatEnabled(key, context);

  if ( true && enabled) {
    for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      args[_key - 3] = arguments[_key];
    }

    warnDeprecation.apply(void 0, [key, context, loc].concat(args));
  }

  return enabled;
}

function warnDeprecation(key, context, loc) {
  var val = getCompatValue(key, context);

  if (val === 'suppress-warning') {
    return;
  }

  var _deprecationData$key = deprecationData[key],
      message = _deprecationData$key.message,
      link = _deprecationData$key.link;

  for (var _len2 = arguments.length, args = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
    args[_key2 - 3] = arguments[_key2];
  }

  var msg = "(deprecation ".concat(key, ") ").concat(typeof message === 'function' ? message.apply(void 0, args) : message).concat(link ? "\n  Details: ".concat(link) : "");
  var err = new SyntaxError(msg);
  err.code = key;
  if (loc) err.loc = loc;
  context.onWarn(err);
} // The default decoder only provides escapes for characters reserved as part of
// the template syntax, and is only used if the custom renderer did not provide
// a platform-specific decoder.


var decodeRE = /&(gt|lt|amp|apos|quot);/g;
var decodeMap = {
  gt: '>',
  lt: '<',
  amp: '&',
  apos: "'",
  quot: '"'
};
var defaultParserOptions = {
  delimiters: ["{{", "}}"],
  getNamespace: function getNamespace() {
    return 0;
  }
  /* HTML */
  ,
  getTextMode: function getTextMode() {
    return 0;
  }
  /* DATA */
  ,
  isVoidTag: _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NO,
  isPreTag: _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NO,
  isCustomElement: _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NO,
  decodeEntities: function decodeEntities(rawText) {
    return rawText.replace(decodeRE, function (_, p1) {
      return decodeMap[p1];
    });
  },
  onError: defaultOnError,
  onWarn: defaultOnWarn,
  comments: false
};

function baseParse(content) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var context = createParserContext(content, options);
  var start = getCursor(context);
  return createRoot(parseChildren(context, 0
  /* DATA */
  , []), getSelection(context, start));
}

function createParserContext(content, rawOptions) {
  var options = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, defaultParserOptions);

  for (var key in rawOptions) {
    // @ts-ignore
    options[key] = rawOptions[key] || defaultParserOptions[key];
  }

  return {
    options: options,
    column: 1,
    line: 1,
    offset: 0,
    originalSource: content,
    source: content,
    inPre: false,
    inVPre: false,
    onWarn: options.onWarn
  };
}

function parseChildren(context, mode, ancestors) {
  var parent = last(ancestors);
  var ns = parent ? parent.ns : 0
  /* HTML */
  ;
  var nodes = [];

  while (!isEnd(context, mode, ancestors)) {
    var s = context.source;
    var node = undefined;

    if (mode === 0
    /* DATA */
    || mode === 1
    /* RCDATA */
    ) {
        if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {
          // '{{'
          node = parseInterpolation(context, mode);
        } else if (mode === 0
        /* DATA */
        && s[0] === '<') {
          // https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state
          if (s.length === 1) {
            emitError(context, 5
            /* EOF_BEFORE_TAG_NAME */
            , 1);
          } else if (s[1] === '!') {
            // https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state
            if (startsWith(s, '<!--')) {
              node = parseComment(context);
            } else if (startsWith(s, '<!DOCTYPE')) {
              // Ignore DOCTYPE by a limitation.
              node = parseBogusComment(context);
            } else if (startsWith(s, '<![CDATA[')) {
              if (ns !== 0
              /* HTML */
              ) {
                  node = parseCDATA(context, ancestors);
                } else {
                emitError(context, 1
                /* CDATA_IN_HTML_CONTENT */
                );
                node = parseBogusComment(context);
              }
            } else {
              emitError(context, 11
              /* INCORRECTLY_OPENED_COMMENT */
              );
              node = parseBogusComment(context);
            }
          } else if (s[1] === '/') {
            // https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state
            if (s.length === 2) {
              emitError(context, 5
              /* EOF_BEFORE_TAG_NAME */
              , 2);
            } else if (s[2] === '>') {
              emitError(context, 14
              /* MISSING_END_TAG_NAME */
              , 2);
              advanceBy(context, 3);
              continue;
            } else if (/[a-z]/i.test(s[2])) {
              emitError(context, 23
              /* X_INVALID_END_TAG */
              );
              parseTag(context, 1
              /* End */
              , parent);
              continue;
            } else {
              emitError(context, 12
              /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */
              , 2);
              node = parseBogusComment(context);
            }
          } else if (/[a-z]/i.test(s[1])) {
            node = parseElement(context, ancestors); // 2.x <template> with no directive compat

            if (isCompatEnabled("COMPILER_NATIVE_TEMPLATE"
            /* COMPILER_NATIVE_TEMPLATE */
            , context) && node && node.tag === 'template' && !node.props.some(function (p) {
              return p.type === 7
              /* DIRECTIVE */
              && isSpecialTemplateDirective(p.name);
            })) {
               true && warnDeprecation("COMPILER_NATIVE_TEMPLATE"
              /* COMPILER_NATIVE_TEMPLATE */
              , context, node.loc);
              node = node.children;
            }
          } else if (s[1] === '?') {
            emitError(context, 21
            /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */
            , 1);
            node = parseBogusComment(context);
          } else {
            emitError(context, 12
            /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */
            , 1);
          }
        }
      }

    if (!node) {
      node = parseText(context, mode);
    }

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(node)) {
      for (var i = 0; i < node.length; i++) {
        pushNode(nodes, node[i]);
      }
    } else {
      pushNode(nodes, node);
    }
  } // Whitespace handling strategy like v2


  var removedWhitespace = false;

  if (mode !== 2
  /* RAWTEXT */
  && mode !== 1
  /* RCDATA */
  ) {
      var preserve = context.options.whitespace === 'preserve';

      for (var _i = 0; _i < nodes.length; _i++) {
        var _node2 = nodes[_i];

        if (!context.inPre && _node2.type === 2
        /* TEXT */
        ) {
            if (!/[^\t\r\n\f ]/.test(_node2.content)) {
              var prev = nodes[_i - 1];
              var next = nodes[_i + 1]; // Remove if:
              // - the whitespace is the first or last node, or:
              // - (condense mode) the whitespace is adjacent to a comment, or:
              // - (condense mode) the whitespace is between two elements AND contains newline

              if (!prev || !next || !preserve && (prev.type === 3
              /* COMMENT */
              || next.type === 3
              /* COMMENT */
              || prev.type === 1
              /* ELEMENT */
              && next.type === 1
              /* ELEMENT */
              && /[\r\n]/.test(_node2.content))) {
                removedWhitespace = true;
                nodes[_i] = null;
              } else {
                // Otherwise, the whitespace is condensed into a single space
                _node2.content = ' ';
              }
            } else if (!preserve) {
              // in condense mode, consecutive whitespaces in text are condensed
              // down to a single space.
              _node2.content = _node2.content.replace(/[\t\r\n\f ]+/g, ' ');
            }
          } // also remove comment nodes in prod by default


        if (false) {}
      }

      if (context.inPre && parent && context.options.isPreTag(parent.tag)) {
        // remove leading newline per html spec
        // https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element
        var first = nodes[0];

        if (first && first.type === 2
        /* TEXT */
        ) {
            first.content = first.content.replace(/^\r?\n/, '');
          }
      }
    }

  return removedWhitespace ? nodes.filter(Boolean) : nodes;
}

function pushNode(nodes, node) {
  if (node.type === 2
  /* TEXT */
  ) {
      var prev = last(nodes); // Merge if both this and the previous node are text and those are
      // consecutive. This happens for cases like "a < b".

      if (prev && prev.type === 2
      /* TEXT */
      && prev.loc.end.offset === node.loc.start.offset) {
        prev.content += node.content;
        prev.loc.end = node.loc.end;
        prev.loc.source += node.loc.source;
        return;
      }
    }

  nodes.push(node);
}

function parseCDATA(context, ancestors) {
  advanceBy(context, 9);
  var nodes = parseChildren(context, 3
  /* CDATA */
  , ancestors);

  if (context.source.length === 0) {
    emitError(context, 6
    /* EOF_IN_CDATA */
    );
  } else {
    advanceBy(context, 3);
  }

  return nodes;
}

function parseComment(context) {
  var start = getCursor(context);
  var content; // Regular comment.

  var match = /--(\!)?>/.exec(context.source);

  if (!match) {
    content = context.source.slice(4);
    advanceBy(context, context.source.length);
    emitError(context, 7
    /* EOF_IN_COMMENT */
    );
  } else {
    if (match.index <= 3) {
      emitError(context, 0
      /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */
      );
    }

    if (match[1]) {
      emitError(context, 10
      /* INCORRECTLY_CLOSED_COMMENT */
      );
    }

    content = context.source.slice(4, match.index); // Advancing with reporting nested comments.

    var s = context.source.slice(0, match.index);
    var prevIndex = 1,
        nestedIndex = 0;

    while ((nestedIndex = s.indexOf('<!--', prevIndex)) !== -1) {
      advanceBy(context, nestedIndex - prevIndex + 1);

      if (nestedIndex + 4 < s.length) {
        emitError(context, 16
        /* NESTED_COMMENT */
        );
      }

      prevIndex = nestedIndex + 1;
    }

    advanceBy(context, match.index + match[0].length - prevIndex + 1);
  }

  return {
    type: 3
    /* COMMENT */
    ,
    content: content,
    loc: getSelection(context, start)
  };
}

function parseBogusComment(context) {
  var start = getCursor(context);
  var contentStart = context.source[1] === '?' ? 1 : 2;
  var content;
  var closeIndex = context.source.indexOf('>');

  if (closeIndex === -1) {
    content = context.source.slice(contentStart);
    advanceBy(context, context.source.length);
  } else {
    content = context.source.slice(contentStart, closeIndex);
    advanceBy(context, closeIndex + 1);
  }

  return {
    type: 3
    /* COMMENT */
    ,
    content: content,
    loc: getSelection(context, start)
  };
}

function parseElement(context, ancestors) {
  // Start tag.
  var wasInPre = context.inPre;
  var wasInVPre = context.inVPre;
  var parent = last(ancestors);
  var element = parseTag(context, 0
  /* Start */
  , parent);
  var isPreBoundary = context.inPre && !wasInPre;
  var isVPreBoundary = context.inVPre && !wasInVPre;

  if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {
    return element;
  } // Children.


  ancestors.push(element);
  var mode = context.options.getTextMode(element, parent);
  var children = parseChildren(context, mode, ancestors);
  ancestors.pop(); // 2.x inline-template compat

  {
    var inlineTemplateProp = element.props.find(function (p) {
      return p.type === 6
      /* ATTRIBUTE */
      && p.name === 'inline-template';
    });

    if (inlineTemplateProp && checkCompatEnabled("COMPILER_INLINE_TEMPLATE"
    /* COMPILER_INLINE_TEMPLATE */
    , context, inlineTemplateProp.loc)) {
      var loc = getSelection(context, element.loc.end);
      inlineTemplateProp.value = {
        type: 2
        /* TEXT */
        ,
        content: loc.source,
        loc: loc
      };
    }
  }
  element.children = children; // End tag.

  if (startsWithEndTagOpen(context.source, element.tag)) {
    parseTag(context, 1
    /* End */
    , parent);
  } else {
    emitError(context, 24
    /* X_MISSING_END_TAG */
    , 0, element.loc.start);

    if (context.source.length === 0 && element.tag.toLowerCase() === 'script') {
      var first = children[0];

      if (first && startsWith(first.loc.source, '<!--')) {
        emitError(context, 8
        /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */
        );
      }
    }
  }

  element.loc = getSelection(context, element.loc.start);

  if (isPreBoundary) {
    context.inPre = false;
  }

  if (isVPreBoundary) {
    context.inVPre = false;
  }

  return element;
}

var isSpecialTemplateDirective = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.makeMap)("if,else,else-if,for,slot");

function parseTag(context, type, parent) {
  // Tag open.
  var start = getCursor(context);
  var match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);
  var tag = match[1];
  var ns = context.options.getNamespace(tag, parent);
  advanceBy(context, match[0].length);
  advanceSpaces(context); // save current state in case we need to re-parse attributes with v-pre

  var cursor = getCursor(context);
  var currentSource = context.source; // Attributes.

  var props = parseAttributes(context, type); // check <pre> tag

  if (context.options.isPreTag(tag)) {
    context.inPre = true;
  } // check v-pre


  if (type === 0
  /* Start */
  && !context.inVPre && props.some(function (p) {
    return p.type === 7
    /* DIRECTIVE */
    && p.name === 'pre';
  })) {
    context.inVPre = true; // reset context

    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)(context, cursor);
    context.source = currentSource; // re-parse attrs and filter out v-pre itself

    props = parseAttributes(context, type).filter(function (p) {
      return p.name !== 'v-pre';
    });
  } // Tag close.


  var isSelfClosing = false;

  if (context.source.length === 0) {
    emitError(context, 9
    /* EOF_IN_TAG */
    );
  } else {
    isSelfClosing = startsWith(context.source, '/>');

    if (type === 1
    /* End */
    && isSelfClosing) {
      emitError(context, 4
      /* END_TAG_WITH_TRAILING_SOLIDUS */
      );
    }

    advanceBy(context, isSelfClosing ? 2 : 1);
  }

  if (type === 1
  /* End */
  ) {
      return;
    } // 2.x deprecation checks


  if ( true && isCompatEnabled("COMPILER_V_IF_V_FOR_PRECEDENCE"
  /* COMPILER_V_IF_V_FOR_PRECEDENCE */
  , context)) {
    var hasIf = false;
    var hasFor = false;

    for (var i = 0; i < props.length; i++) {
      var p = props[i];

      if (p.type === 7
      /* DIRECTIVE */
      ) {
          if (p.name === 'if') {
            hasIf = true;
          } else if (p.name === 'for') {
            hasFor = true;
          }
        }

      if (hasIf && hasFor) {
        warnDeprecation("COMPILER_V_IF_V_FOR_PRECEDENCE"
        /* COMPILER_V_IF_V_FOR_PRECEDENCE */
        , context, getSelection(context, start));
      }
    }
  }

  var tagType = 0
  /* ELEMENT */
  ;
  var options = context.options;

  if (!context.inVPre && !options.isCustomElement(tag)) {
    var hasVIs = props.some(function (p) {
      if (p.name !== 'is') return; // v-is="xxx" (TODO: deprecate)

      if (p.type === 7
      /* DIRECTIVE */
      ) {
          return true;
        } // is="vue:xxx"


      if (p.value && p.value.content.startsWith('vue:')) {
        return true;
      } // in compat mode, any is usage is considered a component


      if (checkCompatEnabled("COMPILER_IS_ON_ELEMENT"
      /* COMPILER_IS_ON_ELEMENT */
      , context, p.loc)) {
        return true;
      }
    });

    if (options.isNativeTag && !hasVIs) {
      if (!options.isNativeTag(tag)) tagType = 1
      /* COMPONENT */
      ;
    } else if (hasVIs || isCoreComponent(tag) || options.isBuiltInComponent && options.isBuiltInComponent(tag) || /^[A-Z]/.test(tag) || tag === 'component') {
      tagType = 1
      /* COMPONENT */
      ;
    }

    if (tag === 'slot') {
      tagType = 2
      /* SLOT */
      ;
    } else if (tag === 'template' && props.some(function (p) {
      return p.type === 7
      /* DIRECTIVE */
      && isSpecialTemplateDirective(p.name);
    })) {
      tagType = 3
      /* TEMPLATE */
      ;
    }
  }

  return {
    type: 1
    /* ELEMENT */
    ,
    ns: ns,
    tag: tag,
    tagType: tagType,
    props: props,
    isSelfClosing: isSelfClosing,
    children: [],
    loc: getSelection(context, start),
    codegenNode: undefined // to be created during transform phase

  };
}

function parseAttributes(context, type) {
  var props = [];
  var attributeNames = new Set();

  while (context.source.length > 0 && !startsWith(context.source, '>') && !startsWith(context.source, '/>')) {
    if (startsWith(context.source, '/')) {
      emitError(context, 22
      /* UNEXPECTED_SOLIDUS_IN_TAG */
      );
      advanceBy(context, 1);
      advanceSpaces(context);
      continue;
    }

    if (type === 1
    /* End */
    ) {
        emitError(context, 3
        /* END_TAG_WITH_ATTRIBUTES */
        );
      }

    var attr = parseAttribute(context, attributeNames);

    if (type === 0
    /* Start */
    ) {
        props.push(attr);
      }

    if (/^[^\t\r\n\f />]/.test(context.source)) {
      emitError(context, 15
      /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */
      );
    }

    advanceSpaces(context);
  }

  return props;
}

function parseAttribute(context, nameSet) {
  // Name.
  var start = getCursor(context);
  var match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source);
  var name = match[0];

  if (nameSet.has(name)) {
    emitError(context, 2
    /* DUPLICATE_ATTRIBUTE */
    );
  }

  nameSet.add(name);

  if (name[0] === '=') {
    emitError(context, 19
    /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */
    );
  }

  {
    var pattern = /["'<]/g;
    var m;

    while (m = pattern.exec(name)) {
      emitError(context, 17
      /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */
      , m.index);
    }
  }
  advanceBy(context, name.length); // Value

  var value = undefined;

  if (/^[\t\r\n\f ]*=/.test(context.source)) {
    advanceSpaces(context);
    advanceBy(context, 1);
    advanceSpaces(context);
    value = parseAttributeValue(context);

    if (!value) {
      emitError(context, 13
      /* MISSING_ATTRIBUTE_VALUE */
      );
    }
  }

  var loc = getSelection(context, start);

  if (!context.inVPre && /^(v-|:|@|#)/.test(name)) {
    var _match = /(?:^v-([a-z0-9-]+))?(?:(?::|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(name);

    var dirName = _match[1] || (startsWith(name, ':') ? 'bind' : startsWith(name, '@') ? 'on' : 'slot');
    var arg;

    if (_match[2]) {
      var isSlot = dirName === 'slot';
      var startOffset = name.lastIndexOf(_match[2]);

      var _loc = getSelection(context, getNewPosition(context, start, startOffset), getNewPosition(context, start, startOffset + _match[2].length + (isSlot && _match[3] || '').length));

      var content = _match[2];
      var isStatic = true;

      if (content.startsWith('[')) {
        isStatic = false;

        if (!content.endsWith(']')) {
          emitError(context, 26
          /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */
          );
        }

        content = content.substr(1, content.length - 2);
      } else if (isSlot) {
        // #1241 special case for v-slot: vuetify relies extensively on slot
        // names containing dots. v-slot doesn't have any modifiers and Vue 2.x
        // supports such usage so we are keeping it consistent with 2.x.
        content += _match[3] || '';
      }

      arg = {
        type: 4
        /* SIMPLE_EXPRESSION */
        ,
        content: content,
        isStatic: isStatic,
        constType: isStatic ? 3
        /* CAN_STRINGIFY */
        : 0
        /* NOT_CONSTANT */
        ,
        loc: _loc
      };
    }

    if (value && value.isQuoted) {
      var valueLoc = value.loc;
      valueLoc.start.offset++;
      valueLoc.start.column++;
      valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);
      valueLoc.source = valueLoc.source.slice(1, -1);
    }

    var modifiers = _match[3] ? _match[3].substr(1).split('.') : []; // 2.x compat v-bind:foo.sync -> v-model:foo

    if (dirName === 'bind' && arg) {
      if (modifiers.includes('sync') && checkCompatEnabled("COMPILER_V_BIND_SYNC"
      /* COMPILER_V_BIND_SYNC */
      , context, loc, arg.loc.source)) {
        dirName = 'model';
        modifiers.splice(modifiers.indexOf('sync'), 1);
      }

      if ( true && modifiers.includes('prop')) {
        checkCompatEnabled("COMPILER_V_BIND_PROP"
        /* COMPILER_V_BIND_PROP */
        , context, loc);
      }
    }

    return {
      type: 7
      /* DIRECTIVE */
      ,
      name: dirName,
      exp: value && {
        type: 4
        /* SIMPLE_EXPRESSION */
        ,
        content: value.content,
        isStatic: false,
        // Treat as non-constant by default. This can be potentially set to
        // other values by `transformExpression` to make it eligible for hoisting.
        constType: 0
        /* NOT_CONSTANT */
        ,
        loc: value.loc
      },
      arg: arg,
      modifiers: modifiers,
      loc: loc
    };
  }

  return {
    type: 6
    /* ATTRIBUTE */
    ,
    name: name,
    value: value && {
      type: 2
      /* TEXT */
      ,
      content: value.content,
      loc: value.loc
    },
    loc: loc
  };
}

function parseAttributeValue(context) {
  var start = getCursor(context);
  var content;
  var quote = context.source[0];
  var isQuoted = quote === "\"" || quote === "'";

  if (isQuoted) {
    // Quoted value.
    advanceBy(context, 1);
    var endIndex = context.source.indexOf(quote);

    if (endIndex === -1) {
      content = parseTextData(context, context.source.length, 4
      /* ATTRIBUTE_VALUE */
      );
    } else {
      content = parseTextData(context, endIndex, 4
      /* ATTRIBUTE_VALUE */
      );
      advanceBy(context, 1);
    }
  } else {
    // Unquoted
    var match = /^[^\t\r\n\f >]+/.exec(context.source);

    if (!match) {
      return undefined;
    }

    var unexpectedChars = /["'<=`]/g;
    var m;

    while (m = unexpectedChars.exec(match[0])) {
      emitError(context, 18
      /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */
      , m.index);
    }

    content = parseTextData(context, match[0].length, 4
    /* ATTRIBUTE_VALUE */
    );
  }

  return {
    content: content,
    isQuoted: isQuoted,
    loc: getSelection(context, start)
  };
}

function parseInterpolation(context, mode) {
  var _context$options$deli = _slicedToArray(context.options.delimiters, 2),
      open = _context$options$deli[0],
      close = _context$options$deli[1];

  var closeIndex = context.source.indexOf(close, open.length);

  if (closeIndex === -1) {
    emitError(context, 25
    /* X_MISSING_INTERPOLATION_END */
    );
    return undefined;
  }

  var start = getCursor(context);
  advanceBy(context, open.length);
  var innerStart = getCursor(context);
  var innerEnd = getCursor(context);
  var rawContentLength = closeIndex - open.length;
  var rawContent = context.source.slice(0, rawContentLength);
  var preTrimContent = parseTextData(context, rawContentLength, mode);
  var content = preTrimContent.trim();
  var startOffset = preTrimContent.indexOf(content);

  if (startOffset > 0) {
    advancePositionWithMutation(innerStart, rawContent, startOffset);
  }

  var endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);
  advancePositionWithMutation(innerEnd, rawContent, endOffset);
  advanceBy(context, close.length);
  return {
    type: 5
    /* INTERPOLATION */
    ,
    content: {
      type: 4
      /* SIMPLE_EXPRESSION */
      ,
      isStatic: false,
      // Set `isConstant` to false by default and will decide in transformExpression
      constType: 0
      /* NOT_CONSTANT */
      ,
      content: content,
      loc: getSelection(context, innerStart, innerEnd)
    },
    loc: getSelection(context, start)
  };
}

function parseText(context, mode) {
  var endTokens = ['<', context.options.delimiters[0]];

  if (mode === 3
  /* CDATA */
  ) {
      endTokens.push(']]>');
    }

  var endIndex = context.source.length;

  for (var i = 0; i < endTokens.length; i++) {
    var index = context.source.indexOf(endTokens[i], 1);

    if (index !== -1 && endIndex > index) {
      endIndex = index;
    }
  }

  var start = getCursor(context);
  var content = parseTextData(context, endIndex, mode);
  return {
    type: 2
    /* TEXT */
    ,
    content: content,
    loc: getSelection(context, start)
  };
}
/**
 * Get text data with a given length from the current location.
 * This translates HTML entities in the text data.
 */


function parseTextData(context, length, mode) {
  var rawText = context.source.slice(0, length);
  advanceBy(context, length);

  if (mode === 2
  /* RAWTEXT */
  || mode === 3
  /* CDATA */
  || rawText.indexOf('&') === -1) {
    return rawText;
  } else {
    // DATA or RCDATA containing "&"". Entity decoding required.
    return context.options.decodeEntities(rawText, mode === 4
    /* ATTRIBUTE_VALUE */
    );
  }
}

function getCursor(context) {
  var column = context.column,
      line = context.line,
      offset = context.offset;
  return {
    column: column,
    line: line,
    offset: offset
  };
}

function getSelection(context, start, end) {
  end = end || getCursor(context);
  return {
    start: start,
    end: end,
    source: context.originalSource.slice(start.offset, end.offset)
  };
}

function last(xs) {
  return xs[xs.length - 1];
}

function startsWith(source, searchString) {
  return source.startsWith(searchString);
}

function advanceBy(context, numberOfCharacters) {
  var source = context.source;
  advancePositionWithMutation(context, source, numberOfCharacters);
  context.source = source.slice(numberOfCharacters);
}

function advanceSpaces(context) {
  var match = /^[\t\r\n\f ]+/.exec(context.source);

  if (match) {
    advanceBy(context, match[0].length);
  }
}

function getNewPosition(context, start, numberOfCharacters) {
  return advancePositionWithClone(start, context.originalSource.slice(start.offset, numberOfCharacters), numberOfCharacters);
}

function emitError(context, code, offset) {
  var loc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : getCursor(context);

  if (offset) {
    loc.offset += offset;
    loc.column += offset;
  }

  context.options.onError(createCompilerError(code, {
    start: loc,
    end: loc,
    source: ''
  }));
}

function isEnd(context, mode, ancestors) {
  var s = context.source;

  switch (mode) {
    case 0
    /* DATA */
    :
      if (startsWith(s, '</')) {
        // TODO: probably bad performance
        for (var i = ancestors.length - 1; i >= 0; --i) {
          if (startsWithEndTagOpen(s, ancestors[i].tag)) {
            return true;
          }
        }
      }

      break;

    case 1
    /* RCDATA */
    :
    case 2
    /* RAWTEXT */
    :
      {
        var parent = last(ancestors);

        if (parent && startsWithEndTagOpen(s, parent.tag)) {
          return true;
        }

        break;
      }

    case 3
    /* CDATA */
    :
      if (startsWith(s, ']]>')) {
        return true;
      }

      break;
  }

  return !s;
}

function startsWithEndTagOpen(source, tag) {
  return startsWith(source, '</') && source.substr(2, tag.length).toLowerCase() === tag.toLowerCase() && /[\t\r\n\f />]/.test(source[2 + tag.length] || '>');
}

function hoistStatic(root, context) {
  walk(root, context, // Root node is unfortunately non-hoistable due to potential parent
  // fallthrough attributes.
  isSingleElementRoot(root, root.children[0]));
}

function isSingleElementRoot(root, child) {
  var children = root.children;
  return children.length === 1 && child.type === 1
  /* ELEMENT */
  && !isSlotOutlet(child);
}

function walk(node, context) {
  var doNotHoistNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var hasHoistedNode = false; // Some transforms, e.g. transformAssetUrls from @vue/compiler-sfc, replaces
  // static bindings with expressions. These expressions are guaranteed to be
  // constant so they are still eligible for hoisting, but they are only
  // available at runtime and therefore cannot be evaluated ahead of time.
  // This is only a concern for pre-stringification (via transformHoist by
  // @vue/compiler-dom), but doing it here allows us to perform only one full
  // walk of the AST and allow `stringifyStatic` to stop walking as soon as its
  // stringficiation threshold is met.

  var canStringify = true;
  var children = node.children;

  for (var i = 0; i < children.length; i++) {
    var child = children[i]; // only plain elements & text calls are eligible for hoisting.

    if (child.type === 1
    /* ELEMENT */
    && child.tagType === 0
    /* ELEMENT */
    ) {
        var constantType = doNotHoistNode ? 0
        /* NOT_CONSTANT */
        : getConstantType(child, context);

        if (constantType > 0
        /* NOT_CONSTANT */
        ) {
            if (constantType < 3
            /* CAN_STRINGIFY */
            ) {
                canStringify = false;
              }

            if (constantType >= 2
            /* CAN_HOIST */
            ) {
                child.codegenNode.patchFlag = -1
                /* HOISTED */
                + ( true ? " /* HOISTED */" : 0);
                child.codegenNode = context.hoist(child.codegenNode);
                hasHoistedNode = true;
                continue;
              }
          } else {
          // node may contain dynamic children, but its props may be eligible for
          // hoisting.
          var codegenNode = child.codegenNode;

          if (codegenNode.type === 13
          /* VNODE_CALL */
          ) {
              var flag = getPatchFlag(codegenNode);

              if ((!flag || flag === 512
              /* NEED_PATCH */
              || flag === 1
              /* TEXT */
              ) && getGeneratedPropsConstantType(child, context) >= 2
              /* CAN_HOIST */
              ) {
                  var props = getNodeProps(child);

                  if (props) {
                    codegenNode.props = context.hoist(props);
                  }
                }
            }
        }
      } else if (child.type === 12
    /* TEXT_CALL */
    ) {
        var contentType = getConstantType(child.content, context);

        if (contentType > 0) {
          if (contentType < 3
          /* CAN_STRINGIFY */
          ) {
              canStringify = false;
            }

          if (contentType >= 2
          /* CAN_HOIST */
          ) {
              child.codegenNode = context.hoist(child.codegenNode);
              hasHoistedNode = true;
            }
        }
      } // walk further


    if (child.type === 1
    /* ELEMENT */
    ) {
        var isComponent = child.tagType === 1
        /* COMPONENT */
        ;

        if (isComponent) {
          context.scopes.vSlot++;
        }

        walk(child, context);

        if (isComponent) {
          context.scopes.vSlot--;
        }
      } else if (child.type === 11
    /* FOR */
    ) {
        // Do not hoist v-for single child because it has to be a block
        walk(child, context, child.children.length === 1);
      } else if (child.type === 9
    /* IF */
    ) {
        for (var _i2 = 0; _i2 < child.branches.length; _i2++) {
          // Do not hoist v-if single child because it has to be a block
          walk(child.branches[_i2], context, child.branches[_i2].children.length === 1);
        }
      }
  }

  if (canStringify && hasHoistedNode && context.transformHoist) {
    context.transformHoist(children, context, node);
  }
}

function getConstantType(node, context) {
  var constantCache = context.constantCache;

  switch (node.type) {
    case 1
    /* ELEMENT */
    :
      if (node.tagType !== 0
      /* ELEMENT */
      ) {
          return 0
          /* NOT_CONSTANT */
          ;
        }

      var cached = constantCache.get(node);

      if (cached !== undefined) {
        return cached;
      }

      var codegenNode = node.codegenNode;

      if (codegenNode.type !== 13
      /* VNODE_CALL */
      ) {
          return 0
          /* NOT_CONSTANT */
          ;
        }

      var flag = getPatchFlag(codegenNode);

      if (!flag) {
        var _returnType = 3
        /* CAN_STRINGIFY */
        ; // Element itself has no patch flag. However we still need to check:
        // 1. Even for a node with no patch flag, it is possible for it to contain
        // non-hoistable expressions that refers to scope variables, e.g. compiler
        // injected keys or cached event handlers. Therefore we need to always
        // check the codegenNode's props to be sure.

        var generatedPropsType = getGeneratedPropsConstantType(node, context);

        if (generatedPropsType === 0
        /* NOT_CONSTANT */
        ) {
            constantCache.set(node, 0
            /* NOT_CONSTANT */
            );
            return 0
            /* NOT_CONSTANT */
            ;
          }

        if (generatedPropsType < _returnType) {
          _returnType = generatedPropsType;
        } // 2. its children.


        for (var i = 0; i < node.children.length; i++) {
          var childType = getConstantType(node.children[i], context);

          if (childType === 0
          /* NOT_CONSTANT */
          ) {
              constantCache.set(node, 0
              /* NOT_CONSTANT */
              );
              return 0
              /* NOT_CONSTANT */
              ;
            }

          if (childType < _returnType) {
            _returnType = childType;
          }
        } // 3. if the type is not already CAN_SKIP_PATCH which is the lowest non-0
        // type, check if any of the props can cause the type to be lowered
        // we can skip can_patch because it's guaranteed by the absence of a
        // patchFlag.


        if (_returnType > 1
        /* CAN_SKIP_PATCH */
        ) {
            for (var _i3 = 0; _i3 < node.props.length; _i3++) {
              var p = node.props[_i3];

              if (p.type === 7
              /* DIRECTIVE */
              && p.name === 'bind' && p.exp) {
                var expType = getConstantType(p.exp, context);

                if (expType === 0
                /* NOT_CONSTANT */
                ) {
                    constantCache.set(node, 0
                    /* NOT_CONSTANT */
                    );
                    return 0
                    /* NOT_CONSTANT */
                    ;
                  }

                if (expType < _returnType) {
                  _returnType = expType;
                }
              }
            }
          } // only svg/foreignObject could be block here, however if they are
        // static then they don't need to be blocks since there will be no
        // nested updates.


        if (codegenNode.isBlock) {
          context.removeHelper(OPEN_BLOCK);
          context.removeHelper(CREATE_BLOCK);
          codegenNode.isBlock = false;
          context.helper(CREATE_VNODE);
        }

        constantCache.set(node, _returnType);
        return _returnType;
      } else {
        constantCache.set(node, 0
        /* NOT_CONSTANT */
        );
        return 0
        /* NOT_CONSTANT */
        ;
      }

    case 2
    /* TEXT */
    :
    case 3
    /* COMMENT */
    :
      return 3
      /* CAN_STRINGIFY */
      ;

    case 9
    /* IF */
    :
    case 11
    /* FOR */
    :
    case 10
    /* IF_BRANCH */
    :
      return 0
      /* NOT_CONSTANT */
      ;

    case 5
    /* INTERPOLATION */
    :
    case 12
    /* TEXT_CALL */
    :
      return getConstantType(node.content, context);

    case 4
    /* SIMPLE_EXPRESSION */
    :
      return node.constType;

    case 8
    /* COMPOUND_EXPRESSION */
    :
      var returnType = 3
      /* CAN_STRINGIFY */
      ;

      for (var _i4 = 0; _i4 < node.children.length; _i4++) {
        var child = node.children[_i4];

        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(child) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(child)) {
          continue;
        }

        var _childType = getConstantType(child, context);

        if (_childType === 0
        /* NOT_CONSTANT */
        ) {
            return 0
            /* NOT_CONSTANT */
            ;
          } else if (_childType < returnType) {
          returnType = _childType;
        }
      }

      return returnType;

    default:
      if (true) ;
      return 0
      /* NOT_CONSTANT */
      ;
  }
}

function getGeneratedPropsConstantType(node, context) {
  var returnType = 3
  /* CAN_STRINGIFY */
  ;
  var props = getNodeProps(node);

  if (props && props.type === 15
  /* JS_OBJECT_EXPRESSION */
  ) {
      var properties = props.properties;

      for (var i = 0; i < properties.length; i++) {
        var _properties$i = properties[i],
            key = _properties$i.key,
            value = _properties$i.value;
        var keyType = getConstantType(key, context);

        if (keyType === 0
        /* NOT_CONSTANT */
        ) {
            return keyType;
          }

        if (keyType < returnType) {
          returnType = keyType;
        }

        if (value.type !== 4
        /* SIMPLE_EXPRESSION */
        ) {
            return 0
            /* NOT_CONSTANT */
            ;
          }

        var valueType = getConstantType(value, context);

        if (valueType === 0
        /* NOT_CONSTANT */
        ) {
            return valueType;
          }

        if (valueType < returnType) {
          returnType = valueType;
        }
      }
    }

  return returnType;
}

function getNodeProps(node) {
  var codegenNode = node.codegenNode;

  if (codegenNode.type === 13
  /* VNODE_CALL */
  ) {
      return codegenNode.props;
    }
}

function getPatchFlag(node) {
  var flag = node.patchFlag;
  return flag ? parseInt(flag, 10) : undefined;
}

function createTransformContext(root, _ref) {
  var _ref$filename = _ref.filename,
      filename = _ref$filename === void 0 ? '' : _ref$filename,
      _ref$prefixIdentifier = _ref.prefixIdentifiers,
      prefixIdentifiers = _ref$prefixIdentifier === void 0 ? false : _ref$prefixIdentifier,
      _ref$hoistStatic = _ref.hoistStatic,
      hoistStatic = _ref$hoistStatic === void 0 ? false : _ref$hoistStatic,
      _ref$cacheHandlers = _ref.cacheHandlers,
      cacheHandlers = _ref$cacheHandlers === void 0 ? false : _ref$cacheHandlers,
      _ref$nodeTransforms = _ref.nodeTransforms,
      nodeTransforms = _ref$nodeTransforms === void 0 ? [] : _ref$nodeTransforms,
      _ref$directiveTransfo = _ref.directiveTransforms,
      directiveTransforms = _ref$directiveTransfo === void 0 ? {} : _ref$directiveTransfo,
      _ref$transformHoist = _ref.transformHoist,
      transformHoist = _ref$transformHoist === void 0 ? null : _ref$transformHoist,
      _ref$isBuiltInCompone = _ref.isBuiltInComponent,
      isBuiltInComponent = _ref$isBuiltInCompone === void 0 ? _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NOOP : _ref$isBuiltInCompone,
      _ref$isCustomElement = _ref.isCustomElement,
      isCustomElement = _ref$isCustomElement === void 0 ? _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NOOP : _ref$isCustomElement,
      _ref$expressionPlugin = _ref.expressionPlugins,
      expressionPlugins = _ref$expressionPlugin === void 0 ? [] : _ref$expressionPlugin,
      _ref$scopeId = _ref.scopeId,
      scopeId = _ref$scopeId === void 0 ? null : _ref$scopeId,
      _ref$slotted = _ref.slotted,
      slotted = _ref$slotted === void 0 ? true : _ref$slotted,
      _ref$ssr = _ref.ssr,
      ssr = _ref$ssr === void 0 ? false : _ref$ssr,
      _ref$ssrCssVars = _ref.ssrCssVars,
      ssrCssVars = _ref$ssrCssVars === void 0 ? "" : _ref$ssrCssVars,
      _ref$bindingMetadata = _ref.bindingMetadata,
      bindingMetadata = _ref$bindingMetadata === void 0 ? _vue_shared__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJ : _ref$bindingMetadata,
      _ref$inline = _ref.inline,
      inline = _ref$inline === void 0 ? false : _ref$inline,
      _ref$isTS = _ref.isTS,
      isTS = _ref$isTS === void 0 ? false : _ref$isTS,
      _ref$onError = _ref.onError,
      onError = _ref$onError === void 0 ? defaultOnError : _ref$onError,
      _ref$onWarn = _ref.onWarn,
      onWarn = _ref$onWarn === void 0 ? defaultOnWarn : _ref$onWarn,
      compatConfig = _ref.compatConfig;
  var nameMatch = filename.replace(/\?.*$/, '').match(/([^/\\]+)\.\w+$/);
  var context = {
    // options
    selfName: nameMatch && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(nameMatch[1])),
    prefixIdentifiers: prefixIdentifiers,
    hoistStatic: hoistStatic,
    cacheHandlers: cacheHandlers,
    nodeTransforms: nodeTransforms,
    directiveTransforms: directiveTransforms,
    transformHoist: transformHoist,
    isBuiltInComponent: isBuiltInComponent,
    isCustomElement: isCustomElement,
    expressionPlugins: expressionPlugins,
    scopeId: scopeId,
    slotted: slotted,
    ssr: ssr,
    ssrCssVars: ssrCssVars,
    bindingMetadata: bindingMetadata,
    inline: inline,
    isTS: isTS,
    onError: onError,
    onWarn: onWarn,
    compatConfig: compatConfig,
    // state
    root: root,
    helpers: new Map(),
    components: new Set(),
    directives: new Set(),
    hoists: [],
    imports: [],
    constantCache: new Map(),
    temps: 0,
    cached: 0,
    identifiers: Object.create(null),
    scopes: {
      vFor: 0,
      vSlot: 0,
      vPre: 0,
      vOnce: 0
    },
    parent: null,
    currentNode: root,
    childIndex: 0,
    // methods
    helper: function helper(name) {
      var count = context.helpers.get(name) || 0;
      context.helpers.set(name, count + 1);
      return name;
    },
    removeHelper: function removeHelper(name) {
      var count = context.helpers.get(name);

      if (count) {
        var currentCount = count - 1;

        if (!currentCount) {
          context.helpers.delete(name);
        } else {
          context.helpers.set(name, currentCount);
        }
      }
    },
    helperString: function helperString(name) {
      return "_".concat(helperNameMap[context.helper(name)]);
    },
    replaceNode: function replaceNode(node) {
      /* istanbul ignore if */
      if (true) {
        if (!context.currentNode) {
          throw new Error("Node being replaced is already removed.");
        }

        if (!context.parent) {
          throw new Error("Cannot replace root node.");
        }
      }

      context.parent.children[context.childIndex] = context.currentNode = node;
    },
    removeNode: function removeNode(node) {
      if ( true && !context.parent) {
        throw new Error("Cannot remove root node.");
      }

      var list = context.parent.children;
      var removalIndex = node ? list.indexOf(node) : context.currentNode ? context.childIndex : -1;
      /* istanbul ignore if */

      if ( true && removalIndex < 0) {
        throw new Error("node being removed is not a child of current parent");
      }

      if (!node || node === context.currentNode) {
        // current node removed
        context.currentNode = null;
        context.onNodeRemoved();
      } else {
        // sibling node removed
        if (context.childIndex > removalIndex) {
          context.childIndex--;
          context.onNodeRemoved();
        }
      }

      context.parent.children.splice(removalIndex, 1);
    },
    onNodeRemoved: function onNodeRemoved() {},
    addIdentifiers: function addIdentifiers(exp) {},
    removeIdentifiers: function removeIdentifiers(exp) {},
    hoist: function hoist(exp) {
      context.hoists.push(exp);
      var identifier = createSimpleExpression("_hoisted_".concat(context.hoists.length), false, exp.loc, 2
      /* CAN_HOIST */
      );
      identifier.hoisted = exp;
      return identifier;
    },
    cache: function cache(exp) {
      var isVNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      return createCacheExpression(++context.cached, exp, isVNode);
    }
  };
  {
    context.filters = new Set();
  }
  return context;
}

function transform(root, options) {
  var context = createTransformContext(root, options);
  traverseNode(root, context);

  if (options.hoistStatic) {
    hoistStatic(root, context);
  }

  if (!options.ssr) {
    createRootCodegen(root, context);
  } // finalize meta information


  root.helpers = _toConsumableArray(context.helpers.keys());
  root.components = _toConsumableArray(context.components);
  root.directives = _toConsumableArray(context.directives);
  root.imports = context.imports;
  root.hoists = context.hoists;
  root.temps = context.temps;
  root.cached = context.cached;
  {
    root.filters = _toConsumableArray(context.filters);
  }
}

function createRootCodegen(root, context) {
  var helper = context.helper,
      removeHelper = context.removeHelper;
  var children = root.children;

  if (children.length === 1) {
    var child = children[0]; // if the single child is an element, turn it into a block.

    if (isSingleElementRoot(root, child) && child.codegenNode) {
      // single element root is never hoisted so codegenNode will never be
      // SimpleExpressionNode
      var codegenNode = child.codegenNode;

      if (codegenNode.type === 13
      /* VNODE_CALL */
      ) {
          if (!codegenNode.isBlock) {
            removeHelper(CREATE_VNODE);
            codegenNode.isBlock = true;
            helper(OPEN_BLOCK);
            helper(CREATE_BLOCK);
          }
        }

      root.codegenNode = codegenNode;
    } else {
      // - single <slot/>, IfNode, ForNode: already blocks.
      // - single text node: always patched.
      // root codegen falls through via genNode()
      root.codegenNode = child;
    }
  } else if (children.length > 1) {
    // root has multiple nodes - return a fragment block.
    var patchFlag = 64
    /* STABLE_FRAGMENT */
    ;
    var patchFlagText = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[64]; // check if the fragment actually contains a single valid child with
    // the rest being comments

    if ( true && children.filter(function (c) {
      return c.type !== 3;
    }
    /* COMMENT */
    ).length === 1) {
      patchFlag |= 2048
      /* DEV_ROOT_FRAGMENT */
      ;
      patchFlagText += ", ".concat(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[2048]);
    }

    root.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, root.children, patchFlag + ( true ? " /* ".concat(patchFlagText, " */") : 0), undefined, undefined, true);
  } else ;
}

function traverseChildren(parent, context) {
  var i = 0;

  var nodeRemoved = function nodeRemoved() {
    i--;
  };

  for (; i < parent.children.length; i++) {
    var child = parent.children[i];
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(child)) continue;
    context.parent = parent;
    context.childIndex = i;
    context.onNodeRemoved = nodeRemoved;
    traverseNode(child, context);
  }
}

function traverseNode(node, context) {
  context.currentNode = node; // apply transform plugins

  var nodeTransforms = context.nodeTransforms;
  var exitFns = [];

  for (var _i5 = 0; _i5 < nodeTransforms.length; _i5++) {
    var onExit = nodeTransforms[_i5](node, context);

    if (onExit) {
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(onExit)) {
        exitFns.push.apply(exitFns, _toConsumableArray(onExit));
      } else {
        exitFns.push(onExit);
      }
    }

    if (!context.currentNode) {
      // node was removed
      return;
    } else {
      // node may have been replaced
      node = context.currentNode;
    }
  }

  switch (node.type) {
    case 3
    /* COMMENT */
    :
      if (!context.ssr) {
        // inject import for the Comment symbol, which is needed for creating
        // comment nodes with `createVNode`
        context.helper(CREATE_COMMENT);
      }

      break;

    case 5
    /* INTERPOLATION */
    :
      // no need to traverse, but we need to inject toString helper
      if (!context.ssr) {
        context.helper(TO_DISPLAY_STRING);
      }

      break;
    // for container types, further traverse downwards

    case 9
    /* IF */
    :
      for (var _i6 = 0; _i6 < node.branches.length; _i6++) {
        traverseNode(node.branches[_i6], context);
      }

      break;

    case 10
    /* IF_BRANCH */
    :
    case 11
    /* FOR */
    :
    case 1
    /* ELEMENT */
    :
    case 0
    /* ROOT */
    :
      traverseChildren(node, context);
      break;
  } // exit transforms


  context.currentNode = node;
  var i = exitFns.length;

  while (i--) {
    exitFns[i]();
  }
}

function createStructuralDirectiveTransform(name, fn) {
  var matches = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(name) ? function (n) {
    return n === name;
  } : function (n) {
    return name.test(n);
  };
  return function (node, context) {
    if (node.type === 1
    /* ELEMENT */
    ) {
        var props = node.props; // structural directive transforms are not concerned with slots
        // as they are handled separately in vSlot.ts

        if (node.tagType === 3
        /* TEMPLATE */
        && props.some(isVSlot)) {
          return;
        }

        var exitFns = [];

        for (var i = 0; i < props.length; i++) {
          var prop = props[i];

          if (prop.type === 7
          /* DIRECTIVE */
          && matches(prop.name)) {
            // structural directives are removed to avoid infinite recursion
            // also we remove them *before* applying so that it can further
            // traverse itself in case it moves the node around
            props.splice(i, 1);
            i--;
            var onExit = fn(node, prop, context);
            if (onExit) exitFns.push(onExit);
          }
        }

        return exitFns;
      }
  };
}

var PURE_ANNOTATION = "/*#__PURE__*/";

function createCodegenContext(ast, _ref2) {
  var _ref2$mode = _ref2.mode,
      mode = _ref2$mode === void 0 ? 'function' : _ref2$mode,
      _ref2$prefixIdentifie = _ref2.prefixIdentifiers,
      prefixIdentifiers = _ref2$prefixIdentifie === void 0 ? mode === 'module' : _ref2$prefixIdentifie,
      _ref2$sourceMap = _ref2.sourceMap,
      sourceMap = _ref2$sourceMap === void 0 ? false : _ref2$sourceMap,
      _ref2$filename = _ref2.filename,
      filename = _ref2$filename === void 0 ? "template.vue.html" : _ref2$filename,
      _ref2$scopeId = _ref2.scopeId,
      scopeId = _ref2$scopeId === void 0 ? null : _ref2$scopeId,
      _ref2$optimizeImports = _ref2.optimizeImports,
      optimizeImports = _ref2$optimizeImports === void 0 ? false : _ref2$optimizeImports,
      _ref2$runtimeGlobalNa = _ref2.runtimeGlobalName,
      runtimeGlobalName = _ref2$runtimeGlobalNa === void 0 ? "Vue" : _ref2$runtimeGlobalNa,
      _ref2$runtimeModuleNa = _ref2.runtimeModuleName,
      runtimeModuleName = _ref2$runtimeModuleNa === void 0 ? "vue" : _ref2$runtimeModuleNa,
      _ref2$ssr = _ref2.ssr,
      ssr = _ref2$ssr === void 0 ? false : _ref2$ssr;
  var context = {
    mode: mode,
    prefixIdentifiers: prefixIdentifiers,
    sourceMap: sourceMap,
    filename: filename,
    scopeId: scopeId,
    optimizeImports: optimizeImports,
    runtimeGlobalName: runtimeGlobalName,
    runtimeModuleName: runtimeModuleName,
    ssr: ssr,
    source: ast.loc.source,
    code: "",
    column: 1,
    line: 1,
    offset: 0,
    indentLevel: 0,
    pure: false,
    map: undefined,
    helper: function helper(key) {
      return "_".concat(helperNameMap[key]);
    },
    push: function push(code, node) {
      context.code += code;
    },
    indent: function indent() {
      _newline(++context.indentLevel);
    },
    deindent: function deindent() {
      var withoutNewLine = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (withoutNewLine) {
        --context.indentLevel;
      } else {
        _newline(--context.indentLevel);
      }
    },
    newline: function newline() {
      _newline(context.indentLevel);
    }
  };

  function _newline(n) {
    context.push('\n' + "  ".repeat(n));
  }

  return context;
}

function generate(ast) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var context = createCodegenContext(ast, options);
  if (options.onContextCreated) options.onContextCreated(context);
  var mode = context.mode,
      push = context.push,
      prefixIdentifiers = context.prefixIdentifiers,
      indent = context.indent,
      deindent = context.deindent,
      newline = context.newline,
      scopeId = context.scopeId,
      ssr = context.ssr;
  var hasHelpers = ast.helpers.length > 0;
  var useWithBlock = !prefixIdentifiers && mode !== 'module'; // preambles
  // in setup() inline mode, the preamble is generated in a sub context
  // and returned separately.

  var preambleContext = context;
  {
    genFunctionPreamble(ast, preambleContext);
  } // enter render function

  var functionName = ssr ? "ssrRender" : "render";
  var args = ssr ? ['_ctx', '_push', '_parent', '_attrs'] : ['_ctx', '_cache'];
  var signature = args.join(', ');
  {
    push("function ".concat(functionName, "(").concat(signature, ") {"));
  }
  indent();

  if (useWithBlock) {
    push("with (_ctx) {");
    indent(); // function mode const declarations should be inside with block
    // also they should be renamed to avoid collision with user properties

    if (hasHelpers) {
      push("const { ".concat(ast.helpers.map(function (s) {
        return "".concat(helperNameMap[s], ": _").concat(helperNameMap[s]);
      }).join(', '), " } = _Vue"));
      push("\n");
      newline();
    }
  } // generate asset resolution statements


  if (ast.components.length) {
    genAssets(ast.components, 'component', context);

    if (ast.directives.length || ast.temps > 0) {
      newline();
    }
  }

  if (ast.directives.length) {
    genAssets(ast.directives, 'directive', context);

    if (ast.temps > 0) {
      newline();
    }
  }

  if (ast.filters && ast.filters.length) {
    newline();
    genAssets(ast.filters, 'filter', context);
    newline();
  }

  if (ast.temps > 0) {
    push("let ");

    for (var i = 0; i < ast.temps; i++) {
      push("".concat(i > 0 ? ", " : "", "_temp").concat(i));
    }
  }

  if (ast.components.length || ast.directives.length || ast.temps) {
    push("\n");
    newline();
  } // generate the VNode tree expression


  if (!ssr) {
    push("return ");
  }

  if (ast.codegenNode) {
    genNode(ast.codegenNode, context);
  } else {
    push("null");
  }

  if (useWithBlock) {
    deindent();
    push("}");
  }

  deindent();
  push("}");
  return {
    ast: ast,
    code: context.code,
    preamble: "",
    // SourceMapGenerator does have toJSON() method but it's not in the types
    map: context.map ? context.map.toJSON() : undefined
  };
}

function genFunctionPreamble(ast, context) {
  var ssr = context.ssr,
      prefixIdentifiers = context.prefixIdentifiers,
      push = context.push,
      newline = context.newline,
      runtimeModuleName = context.runtimeModuleName,
      runtimeGlobalName = context.runtimeGlobalName;
  var VueBinding = runtimeGlobalName;

  var aliasHelper = function aliasHelper(s) {
    return "".concat(helperNameMap[s], ": _").concat(helperNameMap[s]);
  }; // Generate const declaration for helpers
  // In prefix mode, we place the const declaration at top so it's done
  // only once; But if we not prefixing, we place the declaration inside the
  // with block so it doesn't incur the `in` check cost for every helper access.


  if (ast.helpers.length > 0) {
    {
      // "with" mode.
      // save Vue in a separate variable to avoid collision
      push("const _Vue = ".concat(VueBinding, "\n")); // in "with" mode, helpers are declared inside the with block to avoid
      // has check cost, but hoists are lifted out of the function - we need
      // to provide the helper here.

      if (ast.hoists.length) {
        var staticHelpers = [CREATE_VNODE, CREATE_COMMENT, CREATE_TEXT, CREATE_STATIC].filter(function (helper) {
          return ast.helpers.includes(helper);
        }).map(aliasHelper).join(', ');
        push("const { ".concat(staticHelpers, " } = _Vue\n"));
      }
    }
  }

  genHoists(ast.hoists, context);
  newline();
  push("return ");
}

function genAssets(assets, type, _ref3) {
  var helper = _ref3.helper,
      push = _ref3.push,
      newline = _ref3.newline;
  var resolver = helper(type === 'filter' ? RESOLVE_FILTER : type === 'component' ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE);

  for (var i = 0; i < assets.length; i++) {
    var id = assets[i]; // potential component implicit self-reference inferred from SFC filename

    var maybeSelfReference = id.endsWith('__self');

    if (maybeSelfReference) {
      id = id.slice(0, -6);
    }

    push("const ".concat(toValidAssetId(id, type), " = ").concat(resolver, "(").concat(JSON.stringify(id)).concat(maybeSelfReference ? ", true" : "", ")"));

    if (i < assets.length - 1) {
      newline();
    }
  }
}

function genHoists(hoists, context) {
  if (!hoists.length) {
    return;
  }

  context.pure = true;
  var push = context.push,
      newline = context.newline,
      helper = context.helper,
      scopeId = context.scopeId,
      mode = context.mode;
  newline();
  hoists.forEach(function (exp, i) {
    if (exp) {
      push("const _hoisted_".concat(i + 1, " = "));
      genNode(exp, context);
      newline();
    }
  });
  context.pure = false;
}

function isText$1(n) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(n) || n.type === 4
  /* SIMPLE_EXPRESSION */
  || n.type === 2
  /* TEXT */
  || n.type === 5
  /* INTERPOLATION */
  || n.type === 8
  /* COMPOUND_EXPRESSION */
  ;
}

function genNodeListAsArray(nodes, context) {
  var multilines = nodes.length > 3 ||  true && nodes.some(function (n) {
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(n) || !isText$1(n);
  });
  context.push("[");
  multilines && context.indent();
  genNodeList(nodes, context, multilines);
  multilines && context.deindent();
  context.push("]");
}

function genNodeList(nodes, context) {
  var multilines = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var comma = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var push = context.push,
      newline = context.newline;

  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(node)) {
      push(node);
    } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(node)) {
      genNodeListAsArray(node, context);
    } else {
      genNode(node, context);
    }

    if (i < nodes.length - 1) {
      if (multilines) {
        comma && push(',');
        newline();
      } else {
        comma && push(', ');
      }
    }
  }
}

function genNode(node, context) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(node)) {
    context.push(node);
    return;
  }

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(node)) {
    context.push(context.helper(node));
    return;
  }

  switch (node.type) {
    case 1
    /* ELEMENT */
    :
    case 9
    /* IF */
    :
    case 11
    /* FOR */
    :
       true && assert(node.codegenNode != null, "Codegen node is missing for element/if/for node. " + "Apply appropriate transforms first.");
      genNode(node.codegenNode, context);
      break;

    case 2
    /* TEXT */
    :
      genText(node, context);
      break;

    case 4
    /* SIMPLE_EXPRESSION */
    :
      genExpression(node, context);
      break;

    case 5
    /* INTERPOLATION */
    :
      genInterpolation(node, context);
      break;

    case 12
    /* TEXT_CALL */
    :
      genNode(node.codegenNode, context);
      break;

    case 8
    /* COMPOUND_EXPRESSION */
    :
      genCompoundExpression(node, context);
      break;

    case 3
    /* COMMENT */
    :
      genComment(node, context);
      break;

    case 13
    /* VNODE_CALL */
    :
      genVNodeCall(node, context);
      break;

    case 14
    /* JS_CALL_EXPRESSION */
    :
      genCallExpression(node, context);
      break;

    case 15
    /* JS_OBJECT_EXPRESSION */
    :
      genObjectExpression(node, context);
      break;

    case 17
    /* JS_ARRAY_EXPRESSION */
    :
      genArrayExpression(node, context);
      break;

    case 18
    /* JS_FUNCTION_EXPRESSION */
    :
      genFunctionExpression(node, context);
      break;

    case 19
    /* JS_CONDITIONAL_EXPRESSION */
    :
      genConditionalExpression(node, context);
      break;

    case 20
    /* JS_CACHE_EXPRESSION */
    :
      genCacheExpression(node, context);
      break;
    // SSR only types

    case 21
    /* JS_BLOCK_STATEMENT */
    :
      break;

    case 22
    /* JS_TEMPLATE_LITERAL */
    :
      break;

    case 23
    /* JS_IF_STATEMENT */
    :
      break;

    case 24
    /* JS_ASSIGNMENT_EXPRESSION */
    :
      break;

    case 25
    /* JS_SEQUENCE_EXPRESSION */
    :
      break;

    case 26
    /* JS_RETURN_STATEMENT */
    :
      break;

    /* istanbul ignore next */

    case 10
    /* IF_BRANCH */
    :
      // noop
      break;

    default:
      if (true) {
        assert(false, "unhandled codegen node type: ".concat(node.type)); // make sure we exhaust all possible types

        var exhaustiveCheck = node;
        return exhaustiveCheck;
      }

  }
}

function genText(node, context) {
  context.push(JSON.stringify(node.content), node);
}

function genExpression(node, context) {
  var content = node.content,
      isStatic = node.isStatic;
  context.push(isStatic ? JSON.stringify(content) : content, node);
}

function genInterpolation(node, context) {
  var push = context.push,
      helper = context.helper,
      pure = context.pure;
  if (pure) push(PURE_ANNOTATION);
  push("".concat(helper(TO_DISPLAY_STRING), "("));
  genNode(node.content, context);
  push(")");
}

function genCompoundExpression(node, context) {
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(child)) {
      context.push(child);
    } else {
      genNode(child, context);
    }
  }
}

function genExpressionAsPropertyKey(node, context) {
  var push = context.push;

  if (node.type === 8
  /* COMPOUND_EXPRESSION */
  ) {
      push("[");
      genCompoundExpression(node, context);
      push("]");
    } else if (node.isStatic) {
    // only quote keys if necessary
    var text = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content);
    push(text, node);
  } else {
    push("[".concat(node.content, "]"), node);
  }
}

function genComment(node, context) {
  var push = context.push,
      helper = context.helper,
      pure = context.pure;

  if (pure) {
    push(PURE_ANNOTATION);
  }

  push("".concat(helper(CREATE_COMMENT), "(").concat(JSON.stringify(node.content), ")"), node);
}

function genVNodeCall(node, context) {
  var push = context.push,
      helper = context.helper,
      pure = context.pure;
  var tag = node.tag,
      props = node.props,
      children = node.children,
      patchFlag = node.patchFlag,
      dynamicProps = node.dynamicProps,
      directives = node.directives,
      isBlock = node.isBlock,
      disableTracking = node.disableTracking;

  if (directives) {
    push(helper(WITH_DIRECTIVES) + "(");
  }

  if (isBlock) {
    push("(".concat(helper(OPEN_BLOCK), "(").concat(disableTracking ? "true" : "", "), "));
  }

  if (pure) {
    push(PURE_ANNOTATION);
  }

  push(helper(isBlock ? CREATE_BLOCK : CREATE_VNODE) + "(", node);
  genNodeList(genNullableArgs([tag, props, children, patchFlag, dynamicProps]), context);
  push(")");

  if (isBlock) {
    push(")");
  }

  if (directives) {
    push(", ");
    genNode(directives, context);
    push(")");
  }
}

function genNullableArgs(args) {
  var i = args.length;

  while (i--) {
    if (args[i] != null) break;
  }

  return args.slice(0, i + 1).map(function (arg) {
    return arg || "null";
  });
} // JavaScript


function genCallExpression(node, context) {
  var push = context.push,
      helper = context.helper,
      pure = context.pure;
  var callee = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(node.callee) ? node.callee : helper(node.callee);

  if (pure) {
    push(PURE_ANNOTATION);
  }

  push(callee + "(", node);
  genNodeList(node.arguments, context);
  push(")");
}

function genObjectExpression(node, context) {
  var push = context.push,
      indent = context.indent,
      deindent = context.deindent,
      newline = context.newline;
  var properties = node.properties;

  if (!properties.length) {
    push("{}", node);
    return;
  }

  var multilines = properties.length > 1 ||  true && properties.some(function (p) {
    return p.value.type !== 4;
  }
  /* SIMPLE_EXPRESSION */
  );
  push(multilines ? "{" : "{ ");
  multilines && indent();

  for (var i = 0; i < properties.length; i++) {
    var _properties$i2 = properties[i],
        key = _properties$i2.key,
        value = _properties$i2.value; // key

    genExpressionAsPropertyKey(key, context);
    push(": "); // value

    genNode(value, context);

    if (i < properties.length - 1) {
      // will only reach this if it's multilines
      push(",");
      newline();
    }
  }

  multilines && deindent();
  push(multilines ? "}" : " }");
}

function genArrayExpression(node, context) {
  genNodeListAsArray(node.elements, context);
}

function genFunctionExpression(node, context) {
  var push = context.push,
      indent = context.indent,
      deindent = context.deindent,
      scopeId = context.scopeId,
      mode = context.mode;
  var params = node.params,
      returns = node.returns,
      body = node.body,
      newline = node.newline,
      isSlot = node.isSlot;

  if (isSlot) {
    // wrap slot functions with owner context
    push("_".concat(helperNameMap[WITH_CTX], "("));
  }

  push("(", node);

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(params)) {
    genNodeList(params, context);
  } else if (params) {
    genNode(params, context);
  }

  push(") => ");

  if (newline || body) {
    push("{");
    indent();
  }

  if (returns) {
    if (newline) {
      push("return ");
    }

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(returns)) {
      genNodeListAsArray(returns, context);
    } else {
      genNode(returns, context);
    }
  } else if (body) {
    genNode(body, context);
  }

  if (newline || body) {
    deindent();
    push("}");
  }

  if (isSlot) {
    if (node.isNonScopedSlot) {
      push(", undefined, true");
    }

    push(")");
  }
}

function genConditionalExpression(node, context) {
  var test = node.test,
      consequent = node.consequent,
      alternate = node.alternate,
      needNewline = node.newline;
  var push = context.push,
      indent = context.indent,
      deindent = context.deindent,
      newline = context.newline;

  if (test.type === 4
  /* SIMPLE_EXPRESSION */
  ) {
      var needsParens = !isSimpleIdentifier(test.content);
      needsParens && push("(");
      genExpression(test, context);
      needsParens && push(")");
    } else {
    push("(");
    genNode(test, context);
    push(")");
  }

  needNewline && indent();
  context.indentLevel++;
  needNewline || push(" ");
  push("? ");
  genNode(consequent, context);
  context.indentLevel--;
  needNewline && newline();
  needNewline || push(" ");
  push(": ");
  var isNested = alternate.type === 19
  /* JS_CONDITIONAL_EXPRESSION */
  ;

  if (!isNested) {
    context.indentLevel++;
  }

  genNode(alternate, context);

  if (!isNested) {
    context.indentLevel--;
  }

  needNewline && deindent(true
  /* without newline */
  );
}

function genCacheExpression(node, context) {
  var push = context.push,
      helper = context.helper,
      indent = context.indent,
      deindent = context.deindent,
      newline = context.newline;
  push("_cache[".concat(node.index, "] || ("));

  if (node.isVNode) {
    indent();
    push("".concat(helper(SET_BLOCK_TRACKING), "(-1),"));
    newline();
  }

  push("_cache[".concat(node.index, "] = "));
  genNode(node.value, context);

  if (node.isVNode) {
    push(",");
    newline();
    push("".concat(helper(SET_BLOCK_TRACKING), "(1),"));
    newline();
    push("_cache[".concat(node.index, "]"));
    deindent();
  }

  push(")");
} // these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed


var prohibitedKeywordRE = new RegExp('\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments,typeof,void').split(',').join('\\b|\\b') + '\\b'); // strip strings in expressions

var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
/**
 * Validate a non-prefixed expression.
 * This is only called when using the in-browser runtime compiler since it
 * doesn't prefix expressions.
 */

function validateBrowserExpression(node, context) {
  var asParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var asRawStatements = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var exp = node.content; // empty expressions are validated per-directive since some directives
  // do allow empty expressions.

  if (!exp.trim()) {
    return;
  }

  try {
    new Function(asRawStatements ? " ".concat(exp, " ") : "return ".concat(asParams ? "(".concat(exp, ") => {}") : "(".concat(exp, ")")));
  } catch (e) {
    var message = e.message;
    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);

    if (keywordMatch) {
      message = "avoid using JavaScript keyword as property name: \"".concat(keywordMatch[0], "\"");
    }

    context.onError(createCompilerError(43
    /* X_INVALID_EXPRESSION */
    , node.loc, undefined, message));
  }
}

var transformExpression = function transformExpression(node, context) {
  if (node.type === 5
  /* INTERPOLATION */
  ) {
      node.content = processExpression(node.content, context);
    } else if (node.type === 1
  /* ELEMENT */
  ) {
      // handle directives on element
      for (var i = 0; i < node.props.length; i++) {
        var dir = node.props[i]; // do not process for v-on & v-for since they are special handled

        if (dir.type === 7
        /* DIRECTIVE */
        && dir.name !== 'for') {
          var exp = dir.exp;
          var arg = dir.arg; // do not process exp if this is v-on:arg - we need special handling
          // for wrapping inline statements.

          if (exp && exp.type === 4
          /* SIMPLE_EXPRESSION */
          && !(dir.name === 'on' && arg)) {
            dir.exp = processExpression(exp, context, // slot args must be processed as function params
            dir.name === 'slot');
          }

          if (arg && arg.type === 4
          /* SIMPLE_EXPRESSION */
          && !arg.isStatic) {
            dir.arg = processExpression(arg, context);
          }
        }
      }
    }
}; // Important: since this function uses Node.js only dependencies, it should
// always be used with a leading !true check so that it can be
// tree-shaken from the browser build.


function processExpression(node, context) {
  var asParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var asRawStatements = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  {
    if (true) {
      // simple in-browser validation (same logic in 2.x)
      validateBrowserExpression(node, context, asParams, asRawStatements);
    }

    return node;
  }
}

var transformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, function (node, dir, context) {
  return processIf(node, dir, context, function (ifNode, branch, isRoot) {
    // #1587: We need to dynamically increment the key based on the current
    // node's sibling nodes, since chained v-if/else branches are
    // rendered at the same depth
    var siblings = context.parent.children;
    var i = siblings.indexOf(ifNode);
    var key = 0;

    while (i-- >= 0) {
      var sibling = siblings[i];

      if (sibling && sibling.type === 9
      /* IF */
      ) {
          key += sibling.branches.length;
        }
    } // Exit callback. Complete the codegenNode when all children have been
    // transformed.


    return function () {
      if (isRoot) {
        ifNode.codegenNode = createCodegenNodeForBranch(branch, key, context);
      } else {
        // attach this branch's codegen node to the v-if root.
        var parentCondition = getParentCondition(ifNode.codegenNode);
        parentCondition.alternate = createCodegenNodeForBranch(branch, key + ifNode.branches.length - 1, context);
      }
    };
  });
}); // target-agnostic transform used for both Client and SSR

function processIf(node, dir, context, processCodegen) {
  if (dir.name !== 'else' && (!dir.exp || !dir.exp.content.trim())) {
    var loc = dir.exp ? dir.exp.loc : node.loc;
    context.onError(createCompilerError(27
    /* X_V_IF_NO_EXPRESSION */
    , dir.loc));
    dir.exp = createSimpleExpression("true", false, loc);
  }

  if ( true && dir.exp) {
    validateBrowserExpression(dir.exp, context);
  }

  if (dir.name === 'if') {
    var branch = createIfBranch(node, dir);
    var ifNode = {
      type: 9
      /* IF */
      ,
      loc: node.loc,
      branches: [branch]
    };
    context.replaceNode(ifNode);

    if (processCodegen) {
      return processCodegen(ifNode, branch, true);
    }
  } else {
    // locate the adjacent v-if
    var siblings = context.parent.children;
    var comments = [];
    var i = siblings.indexOf(node);

    while (i-- >= -1) {
      var sibling = siblings[i];

      if ( true && sibling && sibling.type === 3
      /* COMMENT */
      ) {
          context.removeNode(sibling);
          comments.unshift(sibling);
          continue;
        }

      if (sibling && sibling.type === 2
      /* TEXT */
      && !sibling.content.trim().length) {
        context.removeNode(sibling);
        continue;
      }

      if (sibling && sibling.type === 9
      /* IF */
      ) {
          (function () {
            // move the node to the if node's branches
            context.removeNode();
            var branch = createIfBranch(node, dir);

            if ( true && comments.length && // #3619 ignore comments if the v-if is direct child of <transition>
            !(context.parent && context.parent.type === 1
            /* ELEMENT */
            && isBuiltInType(context.parent.tag, 'transition'))) {
              branch.children = [].concat(comments, _toConsumableArray(branch.children));
            } // check if user is forcing same key on different branches


            if (true) {
              var key = branch.userKey;

              if (key) {
                sibling.branches.forEach(function (_ref4) {
                  var userKey = _ref4.userKey;

                  if (isSameKey(userKey, key)) {
                    context.onError(createCompilerError(28
                    /* X_V_IF_SAME_KEY */
                    , branch.userKey.loc));
                  }
                });
              }
            }

            sibling.branches.push(branch);
            var onExit = processCodegen && processCodegen(sibling, branch, false); // since the branch was removed, it will not be traversed.
            // make sure to traverse here.

            traverseNode(branch, context); // call on exit

            if (onExit) onExit(); // make sure to reset currentNode after traversal to indicate this
            // node has been removed.

            context.currentNode = null;
          })();
        } else {
        context.onError(createCompilerError(29
        /* X_V_ELSE_NO_ADJACENT_IF */
        , node.loc));
      }

      break;
    }
  }
}

function createIfBranch(node, dir) {
  return {
    type: 10
    /* IF_BRANCH */
    ,
    loc: node.loc,
    condition: dir.name === 'else' ? undefined : dir.exp,
    children: node.tagType === 3
    /* TEMPLATE */
    && !findDir(node, 'for') ? node.children : [node],
    userKey: findProp(node, "key")
  };
}

function createCodegenNodeForBranch(branch, keyIndex, context) {
  if (branch.condition) {
    return createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, keyIndex, context), // make sure to pass in asBlock: true so that the comment node call
    // closes the current block.
    createCallExpression(context.helper(CREATE_COMMENT), [ true ? '"v-if"' : 0, 'true']));
  } else {
    return createChildrenCodegenNode(branch, keyIndex, context);
  }
}

function createChildrenCodegenNode(branch, keyIndex, context) {
  var helper = context.helper,
      removeHelper = context.removeHelper;
  var keyProperty = createObjectProperty("key", createSimpleExpression("".concat(keyIndex), false, locStub, 2
  /* CAN_HOIST */
  ));
  var children = branch.children;
  var firstChild = children[0];
  var needFragmentWrapper = children.length !== 1 || firstChild.type !== 1
  /* ELEMENT */
  ;

  if (needFragmentWrapper) {
    if (children.length === 1 && firstChild.type === 11
    /* FOR */
    ) {
        // optimize away nested fragments when child is a ForNode
        var vnodeCall = firstChild.codegenNode;
        injectProp(vnodeCall, keyProperty, context);
        return vnodeCall;
      } else {
      var patchFlag = 64
      /* STABLE_FRAGMENT */
      ;
      var patchFlagText = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[64]; // check if the fragment actually contains a single valid child with
      // the rest being comments

      if ( true && children.filter(function (c) {
        return c.type !== 3;
      }
      /* COMMENT */
      ).length === 1) {
        patchFlag |= 2048
        /* DEV_ROOT_FRAGMENT */
        ;
        patchFlagText += ", ".concat(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[2048]);
      }

      return createVNodeCall(context, helper(FRAGMENT), createObjectExpression([keyProperty]), children, patchFlag + ( true ? " /* ".concat(patchFlagText, " */") : 0), undefined, undefined, true, false, branch.loc);
    }
  } else {
    var _vnodeCall = firstChild.codegenNode; // Change createVNode to createBlock.

    if (_vnodeCall.type === 13
    /* VNODE_CALL */
    && !_vnodeCall.isBlock) {
      removeHelper(CREATE_VNODE);
      _vnodeCall.isBlock = true;
      helper(OPEN_BLOCK);
      helper(CREATE_BLOCK);
    } // inject branch key


    injectProp(_vnodeCall, keyProperty, context);
    return _vnodeCall;
  }
}

function isSameKey(a, b) {
  if (!a || a.type !== b.type) {
    return false;
  }

  if (a.type === 6
  /* ATTRIBUTE */
  ) {
      if (a.value.content !== b.value.content) {
        return false;
      }
    } else {
    // directive
    var exp = a.exp;
    var branchExp = b.exp;

    if (exp.type !== branchExp.type) {
      return false;
    }

    if (exp.type !== 4
    /* SIMPLE_EXPRESSION */
    || exp.isStatic !== branchExp.isStatic || exp.content !== branchExp.content) {
      return false;
    }
  }

  return true;
}

function getParentCondition(node) {
  while (true) {
    if (node.type === 19
    /* JS_CONDITIONAL_EXPRESSION */
    ) {
        if (node.alternate.type === 19
        /* JS_CONDITIONAL_EXPRESSION */
        ) {
            node = node.alternate;
          } else {
          return node;
        }
      } else if (node.type === 20
    /* JS_CACHE_EXPRESSION */
    ) {
        node = node.value;
      }
  }
}

var transformFor = createStructuralDirectiveTransform('for', function (node, dir, context) {
  var helper = context.helper,
      removeHelper = context.removeHelper;
  return processFor(node, dir, context, function (forNode) {
    // create the loop render function expression now, and add the
    // iterator on exit after all children have been traversed
    var renderExp = createCallExpression(helper(RENDER_LIST), [forNode.source]);
    var keyProp = findProp(node, "key");
    var keyProperty = keyProp ? createObjectProperty("key", keyProp.type === 6
    /* ATTRIBUTE */
    ? createSimpleExpression(keyProp.value.content, true) : keyProp.exp) : null;
    var isStableFragment = forNode.source.type === 4
    /* SIMPLE_EXPRESSION */
    && forNode.source.constType > 0
    /* NOT_CONSTANT */
    ;
    var fragmentFlag = isStableFragment ? 64
    /* STABLE_FRAGMENT */
    : keyProp ? 128
    /* KEYED_FRAGMENT */
    : 256
    /* UNKEYED_FRAGMENT */
    ;
    forNode.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, renderExp, fragmentFlag + ( true ? " /* ".concat(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[fragmentFlag], " */") : 0), undefined, undefined, true
    /* isBlock */
    , !isStableFragment
    /* disableTracking */
    , node.loc);
    return function () {
      // finish the codegen now that all children have been traversed
      var childBlock;
      var isTemplate = isTemplateNode(node);
      var children = forNode.children; // check <template v-for> key placement

      if (( true) && isTemplate) {
        node.children.some(function (c) {
          if (c.type === 1
          /* ELEMENT */
          ) {
              var key = findProp(c, 'key');

              if (key) {
                context.onError(createCompilerError(32
                /* X_V_FOR_TEMPLATE_KEY_PLACEMENT */
                , key.loc));
                return true;
              }
            }
        });
      }

      var needFragmentWrapper = children.length !== 1 || children[0].type !== 1
      /* ELEMENT */
      ;
      var slotOutlet = isSlotOutlet(node) ? node : isTemplate && node.children.length === 1 && isSlotOutlet(node.children[0]) ? node.children[0] // api-extractor somehow fails to infer this
      : null;

      if (slotOutlet) {
        // <slot v-for="..."> or <template v-for="..."><slot/></template>
        childBlock = slotOutlet.codegenNode;

        if (isTemplate && keyProperty) {
          // <template v-for="..." :key="..."><slot/></template>
          // we need to inject the key to the renderSlot() call.
          // the props for renderSlot is passed as the 3rd argument.
          injectProp(childBlock, keyProperty, context);
        }
      } else if (needFragmentWrapper) {
        // <template v-for="..."> with text or multi-elements
        // should generate a fragment block for each loop
        childBlock = createVNodeCall(context, helper(FRAGMENT), keyProperty ? createObjectExpression([keyProperty]) : undefined, node.children, 64
        /* STABLE_FRAGMENT */
        + ( true ? " /* ".concat(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[64], " */") : 0), undefined, undefined, true);
      } else {
        // Normal element v-for. Directly use the child's codegenNode
        // but mark it as a block.
        childBlock = children[0].codegenNode;

        if (isTemplate && keyProperty) {
          injectProp(childBlock, keyProperty, context);
        }

        if (childBlock.isBlock !== !isStableFragment) {
          if (childBlock.isBlock) {
            // switch from block to vnode
            removeHelper(OPEN_BLOCK);
            removeHelper(CREATE_BLOCK);
          } else {
            // switch from vnode to block
            removeHelper(CREATE_VNODE);
          }
        }

        childBlock.isBlock = !isStableFragment;

        if (childBlock.isBlock) {
          helper(OPEN_BLOCK);
          helper(CREATE_BLOCK);
        } else {
          helper(CREATE_VNODE);
        }
      }

      renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult), childBlock, true
      /* force newline */
      ));
    };
  });
}); // target-agnostic transform used for both Client and SSR

function processFor(node, dir, context, processCodegen) {
  if (!dir.exp) {
    context.onError(createCompilerError(30
    /* X_V_FOR_NO_EXPRESSION */
    , dir.loc));
    return;
  }

  var parseResult = parseForExpression( // can only be simple expression because vFor transform is applied
  // before expression transform.
  dir.exp, context);

  if (!parseResult) {
    context.onError(createCompilerError(31
    /* X_V_FOR_MALFORMED_EXPRESSION */
    , dir.loc));
    return;
  }

  var addIdentifiers = context.addIdentifiers,
      removeIdentifiers = context.removeIdentifiers,
      scopes = context.scopes;
  var source = parseResult.source,
      value = parseResult.value,
      key = parseResult.key,
      index = parseResult.index;
  var forNode = {
    type: 11
    /* FOR */
    ,
    loc: dir.loc,
    source: source,
    valueAlias: value,
    keyAlias: key,
    objectIndexAlias: index,
    parseResult: parseResult,
    children: isTemplateNode(node) ? node.children : [node]
  };
  context.replaceNode(forNode); // bookkeeping

  scopes.vFor++;
  var onExit = processCodegen && processCodegen(forNode);
  return function () {
    scopes.vFor--;
    if (onExit) onExit();
  };
}

var forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/; // This regex doesn't cover the case if key or index aliases have destructuring,
// but those do not make sense in the first place, so this works in practice.

var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
var stripParensRE = /^\(|\)$/g;

function parseForExpression(input, context) {
  var loc = input.loc;
  var exp = input.content;
  var inMatch = exp.match(forAliasRE);
  if (!inMatch) return;

  var _inMatch = _slicedToArray(inMatch, 3),
      LHS = _inMatch[1],
      RHS = _inMatch[2];

  var result = {
    source: createAliasExpression(loc, RHS.trim(), exp.indexOf(RHS, LHS.length)),
    value: undefined,
    key: undefined,
    index: undefined
  };

  if (true) {
    validateBrowserExpression(result.source, context);
  }

  var valueContent = LHS.trim().replace(stripParensRE, '').trim();
  var trimmedOffset = LHS.indexOf(valueContent);
  var iteratorMatch = valueContent.match(forIteratorRE);

  if (iteratorMatch) {
    valueContent = valueContent.replace(forIteratorRE, '').trim();
    var keyContent = iteratorMatch[1].trim();
    var keyOffset;

    if (keyContent) {
      keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
      result.key = createAliasExpression(loc, keyContent, keyOffset);

      if (true) {
        validateBrowserExpression(result.key, context, true);
      }
    }

    if (iteratorMatch[2]) {
      var indexContent = iteratorMatch[2].trim();

      if (indexContent) {
        result.index = createAliasExpression(loc, indexContent, exp.indexOf(indexContent, result.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length));

        if (true) {
          validateBrowserExpression(result.index, context, true);
        }
      }
    }
  }

  if (valueContent) {
    result.value = createAliasExpression(loc, valueContent, trimmedOffset);

    if (true) {
      validateBrowserExpression(result.value, context, true);
    }
  }

  return result;
}

function createAliasExpression(range, content, offset) {
  return createSimpleExpression(content, false, getInnerRange(range, offset, content.length));
}

function createForLoopParams(_ref5) {
  var value = _ref5.value,
      key = _ref5.key,
      index = _ref5.index;
  var params = [];

  if (value) {
    params.push(value);
  }

  if (key) {
    if (!value) {
      params.push(createSimpleExpression("_", false));
    }

    params.push(key);
  }

  if (index) {
    if (!key) {
      if (!value) {
        params.push(createSimpleExpression("_", false));
      }

      params.push(createSimpleExpression("__", false));
    }

    params.push(index);
  }

  return params;
}

var defaultFallback = createSimpleExpression("undefined", false); // A NodeTransform that:
// 1. Tracks scope identifiers for scoped slots so that they don't get prefixed
//    by transformExpression. This is only applied in non-browser builds with
//    { prefixIdentifiers: true }.
// 2. Track v-slot depths so that we know a slot is inside another slot.
//    Note the exit callback is executed before buildSlots() on the same node,
//    so only nested slots see positive numbers.

var trackSlotScopes = function trackSlotScopes(node, context) {
  if (node.type === 1
  /* ELEMENT */
  && (node.tagType === 1
  /* COMPONENT */
  || node.tagType === 3
  /* TEMPLATE */
  )) {
    // We are only checking non-empty v-slot here
    // since we only care about slots that introduce scope variables.
    var vSlot = findDir(node, 'slot');

    if (vSlot) {
      vSlot.exp;
      context.scopes.vSlot++;
      return function () {
        context.scopes.vSlot--;
      };
    }
  }
}; // A NodeTransform that tracks scope identifiers for scoped slots with v-for.
// This transform is only applied in non-browser builds with { prefixIdentifiers: true }


var trackVForSlotScopes = function trackVForSlotScopes(node, context) {
  var vFor;

  if (isTemplateNode(node) && node.props.some(isVSlot) && (vFor = findDir(node, 'for'))) {
    var result = vFor.parseResult = parseForExpression(vFor.exp, context);

    if (result) {
      var value = result.value,
          key = result.key,
          index = result.index;
      var addIdentifiers = context.addIdentifiers,
          removeIdentifiers = context.removeIdentifiers;
      value && addIdentifiers(value);
      key && addIdentifiers(key);
      index && addIdentifiers(index);
      return function () {
        value && removeIdentifiers(value);
        key && removeIdentifiers(key);
        index && removeIdentifiers(index);
      };
    }
  }
};

var buildClientSlotFn = function buildClientSlotFn(props, children, loc) {
  return createFunctionExpression(props, children, false
  /* newline */
  , true
  /* isSlot */
  , children.length ? children[0].loc : loc);
}; // Instead of being a DirectiveTransform, v-slot processing is called during
// transformElement to build the slots object for a component.


function buildSlots(node, context) {
  var buildSlotFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : buildClientSlotFn;
  context.helper(WITH_CTX);
  var children = node.children,
      loc = node.loc;
  var slotsProperties = [];
  var dynamicSlots = []; // If the slot is inside a v-for or another v-slot, force it to be dynamic
  // since it likely uses a scope variable.

  var hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0; // 1. Check for slot with slotProps on component itself.
  //    <Comp v-slot="{ prop }"/>

  var onComponentSlot = findDir(node, 'slot', true);

  if (onComponentSlot) {
    var arg = onComponentSlot.arg,
        exp = onComponentSlot.exp;

    if (arg && !isStaticExp(arg)) {
      hasDynamicSlots = true;
    }

    slotsProperties.push(createObjectProperty(arg || createSimpleExpression('default', true), buildSlotFn(exp, children, loc)));
  } // 2. Iterate through children and check for template slots
  //    <template v-slot:foo="{ prop }">


  var hasTemplateSlots = false;
  var hasNamedDefaultSlot = false;
  var implicitDefaultChildren = [];
  var seenSlotNames = new Set();

  for (var i = 0; i < children.length; i++) {
    var slotElement = children[i];
    var slotDir = void 0;

    if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, 'slot', true))) {
      // not a <template v-slot>, skip.
      if (slotElement.type !== 3
      /* COMMENT */
      ) {
          implicitDefaultChildren.push(slotElement);
        }

      continue;
    }

    if (onComponentSlot) {
      // already has on-component slot - this is incorrect usage.
      context.onError(createCompilerError(36
      /* X_V_SLOT_MIXED_SLOT_USAGE */
      , slotDir.loc));
      break;
    }

    hasTemplateSlots = true;
    var slotChildren = slotElement.children,
        slotLoc = slotElement.loc;
    var _slotDir = slotDir,
        _slotDir$arg = _slotDir.arg,
        slotName = _slotDir$arg === void 0 ? createSimpleExpression("default", true) : _slotDir$arg,
        slotProps = _slotDir.exp,
        dirLoc = _slotDir.loc; // check if name is dynamic.

    var staticSlotName = void 0;

    if (isStaticExp(slotName)) {
      staticSlotName = slotName ? slotName.content : "default";
    } else {
      hasDynamicSlots = true;
    }

    var slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc); // check if this slot is conditional (v-if/v-for)

    var vIf = void 0;
    var vElse = void 0;
    var vFor = void 0;

    if (vIf = findDir(slotElement, 'if')) {
      hasDynamicSlots = true;
      dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback));
    } else if (vElse = findDir(slotElement, /^else(-if)?$/, true
    /* allowEmpty */
    )) {
      // find adjacent v-if
      var j = i;
      var prev = void 0;

      while (j--) {
        prev = children[j];

        if (prev.type !== 3
        /* COMMENT */
        ) {
            break;
          }
      }

      if (prev && isTemplateNode(prev) && findDir(prev, 'if')) {
        // remove node
        children.splice(i, 1);
        i--; // attach this slot to previous conditional

        var conditional = dynamicSlots[dynamicSlots.length - 1];

        while (conditional.alternate.type === 19
        /* JS_CONDITIONAL_EXPRESSION */
        ) {
          conditional = conditional.alternate;
        }

        conditional.alternate = vElse.exp ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback) : buildDynamicSlot(slotName, slotFunction);
      } else {
        context.onError(createCompilerError(29
        /* X_V_ELSE_NO_ADJACENT_IF */
        , vElse.loc));
      }
    } else if (vFor = findDir(slotElement, 'for')) {
      hasDynamicSlots = true;
      var parseResult = vFor.parseResult || parseForExpression(vFor.exp, context);

      if (parseResult) {
        // Render the dynamic slots as an array and add it to the createSlot()
        // args. The runtime knows how to handle it appropriately.
        dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST), [parseResult.source, createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true
        /* force newline */
        )]));
      } else {
        context.onError(createCompilerError(31
        /* X_V_FOR_MALFORMED_EXPRESSION */
        , vFor.loc));
      }
    } else {
      // check duplicate static names
      if (staticSlotName) {
        if (seenSlotNames.has(staticSlotName)) {
          context.onError(createCompilerError(37
          /* X_V_SLOT_DUPLICATE_SLOT_NAMES */
          , dirLoc));
          continue;
        }

        seenSlotNames.add(staticSlotName);

        if (staticSlotName === 'default') {
          hasNamedDefaultSlot = true;
        }
      }

      slotsProperties.push(createObjectProperty(slotName, slotFunction));
    }
  }

  if (!onComponentSlot) {
    var buildDefaultSlotProperty = function buildDefaultSlotProperty(props, children) {
      var fn = buildSlotFn(props, children, loc);

      if (context.compatConfig) {
        fn.isNonScopedSlot = true;
      }

      return createObjectProperty("default", fn);
    };

    if (!hasTemplateSlots) {
      // implicit default slot (on component)
      slotsProperties.push(buildDefaultSlotProperty(undefined, children));
    } else if (implicitDefaultChildren.length && // #3766
    // with whitespace: 'preserve', whitespaces between slots will end up in
    // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
    implicitDefaultChildren.some(function (node) {
      return isNonWhitespaceContent(node);
    })) {
      // implicit default slot (mixed with named slots)
      if (hasNamedDefaultSlot) {
        context.onError(createCompilerError(38
        /* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */
        , implicitDefaultChildren[0].loc));
      } else {
        slotsProperties.push(buildDefaultSlotProperty(undefined, implicitDefaultChildren));
      }
    }
  }

  var slotFlag = hasDynamicSlots ? 2
  /* DYNAMIC */
  : hasForwardedSlots(node.children) ? 3
  /* FORWARDED */
  : 1
  /* STABLE */
  ;
  var slots = createObjectExpression(slotsProperties.concat(createObjectProperty("_", // 2 = compiled but dynamic = can skip normalization, but must run diff
  // 1 = compiled and static = can skip normalization AND diff as optimized
  createSimpleExpression(slotFlag + ( true ? " /* ".concat(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.slotFlagsText[slotFlag], " */") : 0), false))), loc);

  if (dynamicSlots.length) {
    slots = createCallExpression(context.helper(CREATE_SLOTS), [slots, createArrayExpression(dynamicSlots)]);
  }

  return {
    slots: slots,
    hasDynamicSlots: hasDynamicSlots
  };
}

function buildDynamicSlot(name, fn) {
  return createObjectExpression([createObjectProperty("name", name), createObjectProperty("fn", fn)]);
}

function hasForwardedSlots(children) {
  for (var i = 0; i < children.length; i++) {
    var child = children[i];

    switch (child.type) {
      case 1
      /* ELEMENT */
      :
        if (child.tagType === 2
        /* SLOT */
        || child.tagType === 0
        /* ELEMENT */
        && hasForwardedSlots(child.children)) {
          return true;
        }

        break;

      case 9
      /* IF */
      :
        if (hasForwardedSlots(child.branches)) return true;
        break;

      case 10
      /* IF_BRANCH */
      :
      case 11
      /* FOR */
      :
        if (hasForwardedSlots(child.children)) return true;
        break;
    }
  }

  return false;
}

function isNonWhitespaceContent(node) {
  if (node.type !== 2
  /* TEXT */
  && node.type !== 12
  /* TEXT_CALL */
  ) return true;
  return node.type === 2
  /* TEXT */
  ? !!node.content.trim() : isNonWhitespaceContent(node.content);
} // some directive transforms (e.g. v-model) may return a symbol for runtime
// import, which should be used instead of a resolveDirective call.


var directiveImportMap = new WeakMap(); // generate a JavaScript AST for this element's codegen

var transformElement = function transformElement(node, context) {
  // perform the work on exit, after all child expressions have been
  // processed and merged.
  return function postTransformElement() {
    node = context.currentNode;

    if (!(node.type === 1
    /* ELEMENT */
    && (node.tagType === 0
    /* ELEMENT */
    || node.tagType === 1
    /* COMPONENT */
    ))) {
      return;
    }

    var _node3 = node,
        tag = _node3.tag,
        props = _node3.props;
    var isComponent = node.tagType === 1
    /* COMPONENT */
    ; // The goal of the transform is to create a codegenNode implementing the
    // VNodeCall interface.

    var vnodeTag = isComponent ? resolveComponentType(node, context) : "\"".concat(tag, "\"");
    var isDynamicComponent = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
    var vnodeProps;
    var vnodeChildren;
    var vnodePatchFlag;
    var patchFlag = 0;
    var vnodeDynamicProps;
    var dynamicPropNames;
    var vnodeDirectives;
    var shouldUseBlock = // dynamic component may resolve to plain elements
    isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent && ( // <svg> and <foreignObject> must be forced into blocks so that block
    // updates inside get proper isSVG flag at runtime. (#639, #643)
    // This is technically web-specific, but splitting the logic out of core
    // leads to too much unnecessary complexity.
    tag === 'svg' || tag === 'foreignObject' || // #938: elements with dynamic keys should be forced into blocks
    findProp(node, 'key', true)); // props

    if (props.length > 0) {
      var propsBuildResult = buildProps(node, context);
      vnodeProps = propsBuildResult.props;
      patchFlag = propsBuildResult.patchFlag;
      dynamicPropNames = propsBuildResult.dynamicPropNames;
      var directives = propsBuildResult.directives;
      vnodeDirectives = directives && directives.length ? createArrayExpression(directives.map(function (dir) {
        return buildDirectiveArgs(dir, context);
      })) : undefined;
    } // children


    if (node.children.length > 0) {
      if (vnodeTag === KEEP_ALIVE) {
        // Although a built-in component, we compile KeepAlive with raw children
        // instead of slot functions so that it can be used inside Transition
        // or other Transition-wrapping HOCs.
        // To ensure correct updates with block optimizations, we need to:
        // 1. Force keep-alive into a block. This avoids its children being
        //    collected by a parent block.
        shouldUseBlock = true; // 2. Force keep-alive to always be updated, since it uses raw children.

        patchFlag |= 1024
        /* DYNAMIC_SLOTS */
        ;

        if ( true && node.children.length > 1) {
          context.onError(createCompilerError(44
          /* X_KEEP_ALIVE_INVALID_CHILDREN */
          , {
            start: node.children[0].loc.start,
            end: node.children[node.children.length - 1].loc.end,
            source: ''
          }));
        }
      }

      var shouldBuildAsSlots = isComponent && // Teleport is not a real component and has dedicated runtime handling
      vnodeTag !== TELEPORT && // explained above.
      vnodeTag !== KEEP_ALIVE;

      if (shouldBuildAsSlots) {
        var _buildSlots = buildSlots(node, context),
            slots = _buildSlots.slots,
            hasDynamicSlots = _buildSlots.hasDynamicSlots;

        vnodeChildren = slots;

        if (hasDynamicSlots) {
          patchFlag |= 1024
          /* DYNAMIC_SLOTS */
          ;
        }
      } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
        var child = node.children[0];
        var type = child.type; // check for dynamic text children

        var hasDynamicTextChild = type === 5
        /* INTERPOLATION */
        || type === 8
        /* COMPOUND_EXPRESSION */
        ;

        if (hasDynamicTextChild && getConstantType(child, context) === 0
        /* NOT_CONSTANT */
        ) {
            patchFlag |= 1
            /* TEXT */
            ;
          } // pass directly if the only child is a text node
        // (plain / interpolation / expression)


        if (hasDynamicTextChild || type === 2
        /* TEXT */
        ) {
            vnodeChildren = child;
          } else {
          vnodeChildren = node.children;
        }
      } else {
        vnodeChildren = node.children;
      }
    } // patchFlag & dynamicPropNames


    if (patchFlag !== 0) {
      if (true) {
        if (patchFlag < 0) {
          // special flags (negative and mutually exclusive)
          vnodePatchFlag = patchFlag + " /* ".concat(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[patchFlag], " */");
        } else {
          // bitwise flags
          var flagNames = Object.keys(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames).map(Number).filter(function (n) {
            return n > 0 && patchFlag & n;
          }).map(function (n) {
            return _vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[n];
          }).join(", ");
          vnodePatchFlag = patchFlag + " /* ".concat(flagNames, " */");
        }
      } else {}

      if (dynamicPropNames && dynamicPropNames.length) {
        vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
      }
    }

    node.codegenNode = createVNodeCall(context, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false
    /* disableTracking */
    , node.loc);
  };
};

function resolveComponentType(node, context) {
  var ssr = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var tag = node.tag; // 1. dynamic component

  var isExplicitDynamic = isComponentTag(tag);
  var isProp = findProp(node, 'is') || !isExplicitDynamic && findDir(node, 'is');

  if (isProp) {
    if (!isExplicitDynamic && isProp.type === 6
    /* ATTRIBUTE */
    ) {
        // <button is="vue:xxx">
        // if not <component>, only is value that starts with "vue:" will be
        // treated as component by the parse phase and reach here, unless it's
        // compat mode where all is values are considered components
        tag = isProp.value.content.replace(/^vue:/, '');
      } else {
      var exp = isProp.type === 6
      /* ATTRIBUTE */
      ? isProp.value && createSimpleExpression(isProp.value.content, true) : isProp.exp;

      if (exp) {
        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [exp]);
      }
    }
  } // 2. built-in components (Teleport, Transition, KeepAlive, Suspense...)


  var builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);

  if (builtIn) {
    // built-ins are simply fallthroughs / have special handling during ssr
    // so we don't need to import their runtime equivalents
    if (!ssr) context.helper(builtIn);
    return builtIn;
  } // 5. user component (resolve)


  context.helper(RESOLVE_COMPONENT);
  context.components.add(tag);
  return toValidAssetId(tag, "component");
}

function buildProps(node, context) {
  var props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : node.props;
  var ssr = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var tag = node.tag,
      elementLoc = node.loc;
  var isComponent = node.tagType === 1
  /* COMPONENT */
  ;
  var properties = [];
  var mergeArgs = [];
  var runtimeDirectives = []; // patchFlag analysis

  var patchFlag = 0;
  var hasRef = false;
  var hasClassBinding = false;
  var hasStyleBinding = false;
  var hasHydrationEventBinding = false;
  var hasDynamicKeys = false;
  var hasVnodeHook = false;
  var dynamicPropNames = [];

  var analyzePatchFlag = function analyzePatchFlag(_ref6) {
    var key = _ref6.key,
        value = _ref6.value;

    if (isStaticExp(key)) {
      var name = key.content;
      var isEventHandler = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isOn)(name);

      if (!isComponent && isEventHandler && // omit the flag for click handlers because hydration gives click
      // dedicated fast path.
      name.toLowerCase() !== 'onclick' && // omit v-model handlers
      name !== 'onUpdate:modelValue' && // omit onVnodeXXX hooks
      !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isReservedProp)(name)) {
        hasHydrationEventBinding = true;
      }

      if (isEventHandler && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isReservedProp)(name)) {
        hasVnodeHook = true;
      }

      if (value.type === 20
      /* JS_CACHE_EXPRESSION */
      || (value.type === 4
      /* SIMPLE_EXPRESSION */
      || value.type === 8
      /* COMPOUND_EXPRESSION */
      ) && getConstantType(value, context) > 0) {
        // skip if the prop is a cached handler or has constant value
        return;
      }

      if (name === 'ref') {
        hasRef = true;
      } else if (name === 'class' && !isComponent) {
        hasClassBinding = true;
      } else if (name === 'style' && !isComponent) {
        hasStyleBinding = true;
      } else if (name !== 'key' && !dynamicPropNames.includes(name)) {
        dynamicPropNames.push(name);
      }
    } else {
      hasDynamicKeys = true;
    }
  };

  for (var i = 0; i < props.length; i++) {
    // static attribute
    var prop = props[i];

    if (prop.type === 6
    /* ATTRIBUTE */
    ) {
        var loc = prop.loc,
            name = prop.name,
            value = prop.value;
        var isStatic = true;

        if (name === 'ref') {
          hasRef = true;
        } // skip is on <component>, or is="vue:xxx"


        if (name === 'is' && (isComponentTag(tag) || value && value.content.startsWith('vue:'))) {
          continue;
        }

        properties.push(createObjectProperty(createSimpleExpression(name, true, getInnerRange(loc, 0, name.length)), createSimpleExpression(value ? value.content : '', isStatic, value ? value.loc : loc)));
      } else {
      // directives
      var _name = prop.name,
          arg = prop.arg,
          exp = prop.exp,
          _loc2 = prop.loc;
      var isVBind = _name === 'bind';
      var isVOn = _name === 'on'; // skip v-slot - it is handled by its dedicated transform.

      if (_name === 'slot') {
        if (!isComponent) {
          context.onError(createCompilerError(39
          /* X_V_SLOT_MISPLACED */
          , _loc2));
        }

        continue;
      } // skip v-once - it is handled by its dedicated transform.


      if (_name === 'once') {
        continue;
      } // skip v-is and :is on <component>


      if (_name === 'is' || isVBind && isComponentTag(tag) && isBindKey(arg, 'is')) {
        continue;
      } // skip v-on in SSR compilation


      if (isVOn && ssr) {
        continue;
      } // special case for v-bind and v-on with no argument


      if (!arg && (isVBind || isVOn)) {
        hasDynamicKeys = true;

        if (exp) {
          if (properties.length) {
            mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
            properties = [];
          }

          if (isVBind) {
            {
              // 2.x v-bind object order compat
              if (true) {
                var hasOverridableKeys = mergeArgs.some(function (arg) {
                  if (arg.type === 15
                  /* JS_OBJECT_EXPRESSION */
                  ) {
                      return arg.properties.some(function (_ref7) {
                        var key = _ref7.key;

                        if (key.type !== 4
                        /* SIMPLE_EXPRESSION */
                        || !key.isStatic) {
                          return true;
                        }

                        return key.content !== 'class' && key.content !== 'style' && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isOn)(key.content);
                      });
                    } else {
                    // dynamic expression
                    return true;
                  }
                });

                if (hasOverridableKeys) {
                  checkCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER"
                  /* COMPILER_V_BIND_OBJECT_ORDER */
                  , context, _loc2);
                }
              }

              if (isCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER"
              /* COMPILER_V_BIND_OBJECT_ORDER */
              , context)) {
                mergeArgs.unshift(exp);
                continue;
              }
            }
            mergeArgs.push(exp);
          } else {
            // v-on="obj" -> toHandlers(obj)
            mergeArgs.push({
              type: 14
              /* JS_CALL_EXPRESSION */
              ,
              loc: _loc2,
              callee: context.helper(TO_HANDLERS),
              arguments: [exp]
            });
          }
        } else {
          context.onError(createCompilerError(isVBind ? 33
          /* X_V_BIND_NO_EXPRESSION */
          : 34
          /* X_V_ON_NO_EXPRESSION */
          , _loc2));
        }

        continue;
      }

      var directiveTransform = context.directiveTransforms[_name];

      if (directiveTransform) {
        var _properties;

        // has built-in directive transform.
        var _directiveTransform = directiveTransform(prop, node, context),
            _props = _directiveTransform.props,
            needRuntime = _directiveTransform.needRuntime;

        !ssr && _props.forEach(analyzePatchFlag);

        (_properties = properties).push.apply(_properties, _toConsumableArray(_props));

        if (needRuntime) {
          runtimeDirectives.push(prop);

          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(needRuntime)) {
            directiveImportMap.set(prop, needRuntime);
          }
        }
      } else {
        // no built-in transform, this is a user custom directive.
        runtimeDirectives.push(prop);
      }
    }

    if (prop.type === 6
    /* ATTRIBUTE */
    && prop.name === 'ref' && context.scopes.vFor > 0 && checkCompatEnabled("COMPILER_V_FOR_REF"
    /* COMPILER_V_FOR_REF */
    , context, prop.loc)) {
      properties.push(createObjectProperty(createSimpleExpression('refInFor', true), createSimpleExpression('true', false)));
    }
  }

  var propsExpression = undefined; // has v-bind="object" or v-on="object", wrap with mergeProps

  if (mergeArgs.length) {
    if (properties.length) {
      mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
    }

    if (mergeArgs.length > 1) {
      propsExpression = createCallExpression(context.helper(MERGE_PROPS), mergeArgs, elementLoc);
    } else {
      // single v-bind with nothing else - no need for a mergeProps call
      propsExpression = mergeArgs[0];
    }
  } else if (properties.length) {
    propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);
  } // patchFlag analysis


  if (hasDynamicKeys) {
    patchFlag |= 16
    /* FULL_PROPS */
    ;
  } else {
    if (hasClassBinding) {
      patchFlag |= 2
      /* CLASS */
      ;
    }

    if (hasStyleBinding) {
      patchFlag |= 4
      /* STYLE */
      ;
    }

    if (dynamicPropNames.length) {
      patchFlag |= 8
      /* PROPS */
      ;
    }

    if (hasHydrationEventBinding) {
      patchFlag |= 32
      /* HYDRATE_EVENTS */
      ;
    }
  }

  if ((patchFlag === 0 || patchFlag === 32
  /* HYDRATE_EVENTS */
  ) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
    patchFlag |= 512
    /* NEED_PATCH */
    ;
  }

  return {
    props: propsExpression,
    directives: runtimeDirectives,
    patchFlag: patchFlag,
    dynamicPropNames: dynamicPropNames
  };
} // Dedupe props in an object literal.
// Literal duplicated attributes would have been warned during the parse phase,
// however, it's possible to encounter duplicated `onXXX` handlers with different
// modifiers. We also need to merge static and dynamic class / style attributes.
// - onXXX handlers / style: merge into array
// - class: merge into single expression with concatenation


function dedupeProperties(properties) {
  var knownProps = new Map();
  var deduped = [];

  for (var i = 0; i < properties.length; i++) {
    var prop = properties[i]; // dynamic keys are always allowed

    if (prop.key.type === 8
    /* COMPOUND_EXPRESSION */
    || !prop.key.isStatic) {
      deduped.push(prop);
      continue;
    }

    var name = prop.key.content;
    var existing = knownProps.get(name);

    if (existing) {
      if (name === 'style' || name === 'class' || name.startsWith('on')) {
        mergeAsArray(existing, prop);
      } // unexpected duplicate, should have emitted error during parse

    } else {
      knownProps.set(name, prop);
      deduped.push(prop);
    }
  }

  return deduped;
}

function mergeAsArray(existing, incoming) {
  if (existing.value.type === 17
  /* JS_ARRAY_EXPRESSION */
  ) {
      existing.value.elements.push(incoming.value);
    } else {
    existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);
  }
}

function buildDirectiveArgs(dir, context) {
  var dirArgs = [];
  var runtime = directiveImportMap.get(dir);

  if (runtime) {
    // built-in directive with runtime
    dirArgs.push(context.helperString(runtime));
  } else {
    {
      // inject statement for resolving directive
      context.helper(RESOLVE_DIRECTIVE);
      context.directives.add(dir.name);
      dirArgs.push(toValidAssetId(dir.name, "directive"));
    }
  }

  var loc = dir.loc;
  if (dir.exp) dirArgs.push(dir.exp);

  if (dir.arg) {
    if (!dir.exp) {
      dirArgs.push("void 0");
    }

    dirArgs.push(dir.arg);
  }

  if (Object.keys(dir.modifiers).length) {
    if (!dir.arg) {
      if (!dir.exp) {
        dirArgs.push("void 0");
      }

      dirArgs.push("void 0");
    }

    var trueExpression = createSimpleExpression("true", false, loc);
    dirArgs.push(createObjectExpression(dir.modifiers.map(function (modifier) {
      return createObjectProperty(modifier, trueExpression);
    }), loc));
  }

  return createArrayExpression(dirArgs, dir.loc);
}

function stringifyDynamicPropNames(props) {
  var propsNamesString = "[";

  for (var i = 0, l = props.length; i < l; i++) {
    propsNamesString += JSON.stringify(props[i]);
    if (i < l - 1) propsNamesString += ', ';
  }

  return propsNamesString + "]";
}

function isComponentTag(tag) {
  return tag[0].toLowerCase() + tag.slice(1) === 'component';
}

 true ? Object.freeze({}) : 0;
 true ? Object.freeze([]) : 0;

var cacheStringFunction = function cacheStringFunction(fn) {
  var cache = Object.create(null);
  return function (str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};

var camelizeRE = /-(\w)/g;
/**
 * @private
 */

var camelize = cacheStringFunction(function (str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : '';
  });
});

var transformSlotOutlet = function transformSlotOutlet(node, context) {
  if (isSlotOutlet(node)) {
    var children = node.children,
        loc = node.loc;

    var _processSlotOutlet = processSlotOutlet(node, context),
        slotName = _processSlotOutlet.slotName,
        slotProps = _processSlotOutlet.slotProps;

    var slotArgs = [context.prefixIdentifiers ? "_ctx.$slots" : "$slots", slotName];

    if (slotProps) {
      slotArgs.push(slotProps);
    }

    if (children.length) {
      if (!slotProps) {
        slotArgs.push("{}");
      }

      slotArgs.push(createFunctionExpression([], children, false, false, loc));
    }

    if (context.scopeId && !context.slotted) {
      if (!slotProps) {
        slotArgs.push("{}");
      }

      if (!children.length) {
        slotArgs.push("undefined");
      }

      slotArgs.push("true");
    }

    node.codegenNode = createCallExpression(context.helper(RENDER_SLOT), slotArgs, loc);
  }
};

function processSlotOutlet(node, context) {
  var slotName = "\"default\"";
  var slotProps = undefined;
  var nonNameProps = [];

  for (var i = 0; i < node.props.length; i++) {
    var p = node.props[i];

    if (p.type === 6
    /* ATTRIBUTE */
    ) {
        if (p.value) {
          if (p.name === 'name') {
            slotName = JSON.stringify(p.value.content);
          } else {
            p.name = camelize(p.name);
            nonNameProps.push(p);
          }
        }
      } else {
      if (p.name === 'bind' && isBindKey(p.arg, 'name')) {
        if (p.exp) slotName = p.exp;
      } else {
        if (p.name === 'bind' && p.arg && isStaticExp(p.arg)) {
          p.arg.content = camelize(p.arg.content);
        }

        nonNameProps.push(p);
      }
    }
  }

  if (nonNameProps.length > 0) {
    var _buildProps = buildProps(node, context, nonNameProps),
        props = _buildProps.props,
        directives = _buildProps.directives;

    slotProps = props;

    if (directives.length) {
      context.onError(createCompilerError(35
      /* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */
      , directives[0].loc));
    }
  }

  return {
    slotName: slotName,
    slotProps: slotProps
  };
}

var fnExpRE = /^\s*([\w$_]+|\([^)]*?\))\s*=>|^\s*function(?:\s+[\w$]+)?\s*\(/;

var transformOn = function transformOn(dir, node, context, augmentor) {
  var loc = dir.loc,
      modifiers = dir.modifiers,
      arg = dir.arg;

  if (!dir.exp && !modifiers.length) {
    context.onError(createCompilerError(34
    /* X_V_ON_NO_EXPRESSION */
    , loc));
  }

  var eventName;

  if (arg.type === 4
  /* SIMPLE_EXPRESSION */
  ) {
      if (arg.isStatic) {
        var rawName = arg.content; // for all event listeners, auto convert it to camelCase. See issue #2249

        eventName = createSimpleExpression((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(rawName)), true, arg.loc);
      } else {
        // #2388
        eventName = createCompoundExpression(["".concat(context.helperString(TO_HANDLER_KEY), "("), arg, ")"]);
      }
    } else {
    // already a compound expression.
    eventName = arg;
    eventName.children.unshift("".concat(context.helperString(TO_HANDLER_KEY), "("));
    eventName.children.push(")");
  } // handler processing


  var exp = dir.exp;

  if (exp && !exp.content.trim()) {
    exp = undefined;
  }

  var shouldCache = context.cacheHandlers && !exp;

  if (exp) {
    var isMemberExp = isMemberExpression(exp.content);
    var isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));
    var hasMultipleStatements = exp.content.includes(";");

    if (true) {
      validateBrowserExpression(exp, context, false, hasMultipleStatements);
    }

    if (isInlineStatement || shouldCache && isMemberExp) {
      // wrap inline statement in a function expression
      exp = createCompoundExpression(["".concat(isInlineStatement ? "$event" : "".concat("", "(...args)"), " => ").concat(hasMultipleStatements ? "{" : "("), exp, hasMultipleStatements ? "}" : ")"]);
    }
  }

  var ret = {
    props: [createObjectProperty(eventName, exp || createSimpleExpression("() => {}", false, loc))]
  }; // apply extended compiler augmentor

  if (augmentor) {
    ret = augmentor(ret);
  }

  if (shouldCache) {
    // cache handlers so that it's always the same handler being passed down.
    // this avoids unnecessary re-renders when users use inline handlers on
    // components.
    ret.props[0].value = context.cache(ret.props[0].value);
  }

  return ret;
}; // v-bind without arg is handled directly in ./transformElements.ts due to it affecting
// codegen for the entire props object. This transform here is only for v-bind
// *with* args.


var transformBind = function transformBind(dir, _node, context) {
  var exp = dir.exp,
      modifiers = dir.modifiers,
      loc = dir.loc;
  var arg = dir.arg;

  if (arg.type !== 4
  /* SIMPLE_EXPRESSION */
  ) {
      arg.children.unshift("(");
      arg.children.push(") || \"\"");
    } else if (!arg.isStatic) {
    arg.content = "".concat(arg.content, " || \"\"");
  } // .prop is no longer necessary due to new patch behavior
  // .sync is replaced by v-model:arg


  if (modifiers.includes('camel')) {
    if (arg.type === 4
    /* SIMPLE_EXPRESSION */
    ) {
        if (arg.isStatic) {
          arg.content = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(arg.content);
        } else {
          arg.content = "".concat(context.helperString(CAMELIZE), "(").concat(arg.content, ")");
        }
      } else {
      arg.children.unshift("".concat(context.helperString(CAMELIZE), "("));
      arg.children.push(")");
    }
  }

  if (!exp || exp.type === 4
  /* SIMPLE_EXPRESSION */
  && !exp.content.trim()) {
    context.onError(createCompilerError(33
    /* X_V_BIND_NO_EXPRESSION */
    , loc));
    return {
      props: [createObjectProperty(arg, createSimpleExpression('', true, loc))]
    };
  }

  return {
    props: [createObjectProperty(arg, exp)]
  };
}; // Merge adjacent text nodes and expressions into a single expression
// e.g. <div>abc {{ d }} {{ e }}</div> should have a single expression node as child.


var transformText = function transformText(node, context) {
  if (node.type === 0
  /* ROOT */
  || node.type === 1
  /* ELEMENT */
  || node.type === 11
  /* FOR */
  || node.type === 10
  /* IF_BRANCH */
  ) {
      // perform the transform on node exit so that all expressions have already
      // been processed.
      return function () {
        var children = node.children;
        var currentContainer = undefined;
        var hasText = false;

        for (var i = 0; i < children.length; i++) {
          var child = children[i];

          if (isText(child)) {
            hasText = true;

            for (var j = i + 1; j < children.length; j++) {
              var next = children[j];

              if (isText(next)) {
                if (!currentContainer) {
                  currentContainer = children[i] = {
                    type: 8
                    /* COMPOUND_EXPRESSION */
                    ,
                    loc: child.loc,
                    children: [child]
                  };
                } // merge adjacent text node into current


                currentContainer.children.push(" + ", next);
                children.splice(j, 1);
                j--;
              } else {
                currentContainer = undefined;
                break;
              }
            }
          }
        }

        if (!hasText || // if this is a plain element with a single text child, leave it
        // as-is since the runtime has dedicated fast path for this by directly
        // setting textContent of the element.
        // for component root it's always normalized anyway.
        children.length === 1 && (node.type === 0
        /* ROOT */
        || node.type === 1
        /* ELEMENT */
        && node.tagType === 0
        /* ELEMENT */
        && // #3756
        // custom directives can potentially add DOM elements arbitrarily,
        // we need to avoid setting textContent of the element at runtime
        // to avoid accidentally overwriting the DOM elements added
        // by the user through custom directives.
        !node.props.find(function (p) {
          return p.type === 7
          /* DIRECTIVE */
          && !context.directiveTransforms[p.name];
        }) && // in compat mode, <template> tags with no special directives
        // will be rendered as a fragment so its children must be
        // converted into vnodes.
        !(node.tag === 'template'))) {
          return;
        } // pre-convert text nodes into createTextVNode(text) calls to avoid
        // runtime normalization.


        for (var _i7 = 0; _i7 < children.length; _i7++) {
          var _child = children[_i7];

          if (isText(_child) || _child.type === 8
          /* COMPOUND_EXPRESSION */
          ) {
              var callArgs = []; // createTextVNode defaults to single whitespace, so if it is a
              // single space the code could be an empty call to save bytes.

              if (_child.type !== 2
              /* TEXT */
              || _child.content !== ' ') {
                callArgs.push(_child);
              } // mark dynamic text with flag so it gets patched inside a block


              if (!context.ssr && getConstantType(_child, context) === 0
              /* NOT_CONSTANT */
              ) {
                  callArgs.push(1
                  /* TEXT */
                  + ( true ? " /* ".concat(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[1], " */") : 0));
                }

              children[_i7] = {
                type: 12
                /* TEXT_CALL */
                ,
                content: _child,
                loc: _child.loc,
                codegenNode: createCallExpression(context.helper(CREATE_TEXT), callArgs)
              };
            }
        }
      };
    }
};

var seen = new WeakSet();

var transformOnce = function transformOnce(node, context) {
  if (node.type === 1
  /* ELEMENT */
  && findDir(node, 'once', true)) {
    if (seen.has(node)) {
      return;
    }

    seen.add(node);
    context.helper(SET_BLOCK_TRACKING);
    return function () {
      var cur = context.currentNode;

      if (cur.codegenNode) {
        cur.codegenNode = context.cache(cur.codegenNode, true
        /* isVNode */
        );
      }
    };
  }
};

var transformModel = function transformModel(dir, node, context) {
  var exp = dir.exp,
      arg = dir.arg;

  if (!exp) {
    context.onError(createCompilerError(40
    /* X_V_MODEL_NO_EXPRESSION */
    , dir.loc));
    return createTransformProps();
  }

  var rawExp = exp.loc.source;
  var expString = exp.type === 4
  /* SIMPLE_EXPRESSION */
  ? exp.content : rawExp; // im SFC <script setup> inline mode, the exp may have been transformed into
  // _unref(exp)

  context.bindingMetadata[rawExp];
  var maybeRef = !true
  /* SETUP_CONST */
  ;

  if (!isMemberExpression(expString) && !maybeRef) {
    context.onError(createCompilerError(41
    /* X_V_MODEL_MALFORMED_EXPRESSION */
    , exp.loc));
    return createTransformProps();
  }

  var propName = arg ? arg : createSimpleExpression('modelValue', true);
  var eventName = arg ? isStaticExp(arg) ? "onUpdate:".concat(arg.content) : createCompoundExpression(['"onUpdate:" + ', arg]) : "onUpdate:modelValue";
  var assignmentExp;
  var eventArg = context.isTS ? "($event: any)" : "$event";
  {
    assignmentExp = createCompoundExpression(["".concat(eventArg, " => ("), exp, " = $event)"]);
  }
  var props = [// modelValue: foo
  createObjectProperty(propName, dir.exp), // "onUpdate:modelValue": $event => (foo = $event)
  createObjectProperty(eventName, assignmentExp)]; // modelModifiers: { foo: true, "bar-baz": true }

  if (dir.modifiers.length && node.tagType === 1
  /* COMPONENT */
  ) {
      var modifiers = dir.modifiers.map(function (m) {
        return (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + ": true";
      }).join(", ");
      var modifiersKey = arg ? isStaticExp(arg) ? "".concat(arg.content, "Modifiers") : createCompoundExpression([arg, ' + "Modifiers"']) : "modelModifiers";
      props.push(createObjectProperty(modifiersKey, createSimpleExpression("{ ".concat(modifiers, " }"), false, dir.loc, 2
      /* CAN_HOIST */
      )));
    }

  return createTransformProps(props);
};

function createTransformProps() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return {
    props: props
  };
}

var validDivisionCharRE = /[\w).+\-_$\]]/;

var transformFilter = function transformFilter(node, context) {
  if (!isCompatEnabled("COMPILER_FILTER"
  /* COMPILER_FILTERS */
  , context)) {
    return;
  }

  if (node.type === 5
  /* INTERPOLATION */
  ) {
      // filter rewrite is applied before expression transform so only
      // simple expressions are possible at this stage
      rewriteFilter(node.content, context);
    }

  if (node.type === 1
  /* ELEMENT */
  ) {
      node.props.forEach(function (prop) {
        if (prop.type === 7
        /* DIRECTIVE */
        && prop.name !== 'for' && prop.exp) {
          rewriteFilter(prop.exp, context);
        }
      });
    }
};

function rewriteFilter(node, context) {
  if (node.type === 4
  /* SIMPLE_EXPRESSION */
  ) {
      parseFilter(node, context);
    } else {
    for (var i = 0; i < node.children.length; i++) {
      var child = node.children[i];
      if (_typeof(child) !== 'object') continue;

      if (child.type === 4
      /* SIMPLE_EXPRESSION */
      ) {
          parseFilter(child, context);
        } else if (child.type === 8
      /* COMPOUND_EXPRESSION */
      ) {
          rewriteFilter(node, context);
        } else if (child.type === 5
      /* INTERPOLATION */
      ) {
          rewriteFilter(child.content, context);
        }
    }
  }
}

function parseFilter(node, context) {
  var exp = node.content;
  var inSingle = false;
  var inDouble = false;
  var inTemplateString = false;
  var inRegex = false;
  var curly = 0;
  var square = 0;
  var paren = 0;
  var lastFilterIndex = 0;
  var c,
      prev,
      i,
      expression,
      filters = [];

  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);

    if (inSingle) {
      if (c === 0x27 && prev !== 0x5c) inSingle = false;
    } else if (inDouble) {
      if (c === 0x22 && prev !== 0x5c) inDouble = false;
    } else if (inTemplateString) {
      if (c === 0x60 && prev !== 0x5c) inTemplateString = false;
    } else if (inRegex) {
      if (c === 0x2f && prev !== 0x5c) inRegex = false;
    } else if (c === 0x7c && // pipe
    exp.charCodeAt(i + 1) !== 0x7c && exp.charCodeAt(i - 1) !== 0x7c && !curly && !square && !paren) {
      if (expression === undefined) {
        // first filter, end of expression
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 0x22:
          inDouble = true;
          break;
        // "

        case 0x27:
          inSingle = true;
          break;
        // '

        case 0x60:
          inTemplateString = true;
          break;
        // `

        case 0x28:
          paren++;
          break;
        // (

        case 0x29:
          paren--;
          break;
        // )

        case 0x5b:
          square++;
          break;
        // [

        case 0x5d:
          square--;
          break;
        // ]

        case 0x7b:
          curly++;
          break;
        // {

        case 0x7d:
          curly--;
          break;
        // }
      }

      if (c === 0x2f) {
        // /
        var j = i - 1;
        var p = void 0; // find first non-whitespace prev char

        for (; j >= 0; j--) {
          p = exp.charAt(j);
          if (p !== ' ') break;
        }

        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }

  if (expression === undefined) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }

  function pushFilter() {
    filters.push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }

  if (filters.length) {
     true && warnDeprecation("COMPILER_FILTER"
    /* COMPILER_FILTERS */
    , context, node.loc);

    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i], context);
    }

    node.content = expression;
  }
}

function wrapFilter(exp, filter, context) {
  context.helper(RESOLVE_FILTER);
  var i = filter.indexOf('(');

  if (i < 0) {
    context.filters.add(filter);
    return "".concat(toValidAssetId(filter, 'filter'), "(").concat(exp, ")");
  } else {
    var name = filter.slice(0, i);
    var args = filter.slice(i + 1);
    context.filters.add(name);
    return "".concat(toValidAssetId(name, 'filter'), "(").concat(exp).concat(args !== ')' ? ',' + args : args);
  }
}

function getBaseTransformPreset(prefixIdentifiers) {
  return [[transformOnce, transformIf, transformFor].concat([transformFilter], _toConsumableArray( true ? [transformExpression] : 0), [transformSlotOutlet, transformElement, trackSlotScopes, transformText]), {
    on: transformOn,
    bind: transformBind,
    model: transformModel
  }];
} // we name it `baseCompile` so that higher order compilers like
// @vue/compiler-dom can export `compile` while re-exporting everything else.


function baseCompile(template) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var onError = options.onError || defaultOnError;
  var isModuleMode = options.mode === 'module';
  /* istanbul ignore if */

  {
    if (options.prefixIdentifiers === true) {
      onError(createCompilerError(45
      /* X_PREFIX_ID_NOT_SUPPORTED */
      ));
    } else if (isModuleMode) {
      onError(createCompilerError(46
      /* X_MODULE_MODE_NOT_SUPPORTED */
      ));
    }
  }
  var prefixIdentifiers = !true;

  if (options.cacheHandlers) {
    onError(createCompilerError(47
    /* X_CACHE_HANDLER_NOT_SUPPORTED */
    ));
  }

  if (options.scopeId && !isModuleMode) {
    onError(createCompilerError(48
    /* X_SCOPE_ID_NOT_SUPPORTED */
    ));
  }

  var ast = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(template) ? baseParse(template, options) : template;

  var _getBaseTransformPres = getBaseTransformPreset(),
      _getBaseTransformPres2 = _slicedToArray(_getBaseTransformPres, 2),
      nodeTransforms = _getBaseTransformPres2[0],
      directiveTransforms = _getBaseTransformPres2[1];

  transform(ast, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, options, {
    prefixIdentifiers: prefixIdentifiers,
    nodeTransforms: [].concat(_toConsumableArray(nodeTransforms), _toConsumableArray(options.nodeTransforms || [])),
    directiveTransforms: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, directiveTransforms, options.directiveTransforms || {} // user transforms
    )
  }));
  return generate(ast, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, options, {
    prefixIdentifiers: prefixIdentifiers
  }));
}

var noopDirectiveTransform = function noopDirectiveTransform() {
  return {
    props: []
  };
};



/***/ }),

/***/ "./node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BASE_TRANSITION": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.BASE_TRANSITION),
/* harmony export */   "CAMELIZE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CAMELIZE),
/* harmony export */   "CAPITALIZE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CAPITALIZE),
/* harmony export */   "CREATE_BLOCK": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_BLOCK),
/* harmony export */   "CREATE_COMMENT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_COMMENT),
/* harmony export */   "CREATE_SLOTS": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_SLOTS),
/* harmony export */   "CREATE_STATIC": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_STATIC),
/* harmony export */   "CREATE_TEXT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_TEXT),
/* harmony export */   "CREATE_VNODE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_VNODE),
/* harmony export */   "FRAGMENT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.FRAGMENT),
/* harmony export */   "IS_REF": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.IS_REF),
/* harmony export */   "KEEP_ALIVE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.KEEP_ALIVE),
/* harmony export */   "MERGE_PROPS": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.MERGE_PROPS),
/* harmony export */   "OPEN_BLOCK": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.OPEN_BLOCK),
/* harmony export */   "POP_SCOPE_ID": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.POP_SCOPE_ID),
/* harmony export */   "PUSH_SCOPE_ID": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.PUSH_SCOPE_ID),
/* harmony export */   "RENDER_LIST": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RENDER_LIST),
/* harmony export */   "RENDER_SLOT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RENDER_SLOT),
/* harmony export */   "RESOLVE_COMPONENT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_COMPONENT),
/* harmony export */   "RESOLVE_DIRECTIVE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_DIRECTIVE),
/* harmony export */   "RESOLVE_DYNAMIC_COMPONENT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_DYNAMIC_COMPONENT),
/* harmony export */   "RESOLVE_FILTER": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_FILTER),
/* harmony export */   "SET_BLOCK_TRACKING": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.SET_BLOCK_TRACKING),
/* harmony export */   "SUSPENSE": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.SUSPENSE),
/* harmony export */   "TELEPORT": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TELEPORT),
/* harmony export */   "TO_DISPLAY_STRING": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_DISPLAY_STRING),
/* harmony export */   "TO_HANDLERS": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_HANDLERS),
/* harmony export */   "TO_HANDLER_KEY": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_HANDLER_KEY),
/* harmony export */   "UNREF": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.UNREF),
/* harmony export */   "WITH_CTX": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.WITH_CTX),
/* harmony export */   "WITH_DIRECTIVES": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.WITH_DIRECTIVES),
/* harmony export */   "WITH_SCOPE_ID": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.WITH_SCOPE_ID),
/* harmony export */   "advancePositionWithClone": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.advancePositionWithClone),
/* harmony export */   "advancePositionWithMutation": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.advancePositionWithMutation),
/* harmony export */   "assert": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.assert),
/* harmony export */   "baseCompile": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseCompile),
/* harmony export */   "baseParse": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseParse),
/* harmony export */   "buildProps": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.buildProps),
/* harmony export */   "buildSlots": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.buildSlots),
/* harmony export */   "checkCompatEnabled": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.checkCompatEnabled),
/* harmony export */   "createArrayExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createArrayExpression),
/* harmony export */   "createAssignmentExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createAssignmentExpression),
/* harmony export */   "createBlockStatement": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createBlockStatement),
/* harmony export */   "createCacheExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCacheExpression),
/* harmony export */   "createCallExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression),
/* harmony export */   "createCompilerError": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompilerError),
/* harmony export */   "createCompoundExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompoundExpression),
/* harmony export */   "createConditionalExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createConditionalExpression),
/* harmony export */   "createForLoopParams": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createForLoopParams),
/* harmony export */   "createFunctionExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createFunctionExpression),
/* harmony export */   "createIfStatement": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createIfStatement),
/* harmony export */   "createInterpolation": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createInterpolation),
/* harmony export */   "createObjectExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectExpression),
/* harmony export */   "createObjectProperty": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty),
/* harmony export */   "createReturnStatement": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createReturnStatement),
/* harmony export */   "createRoot": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createRoot),
/* harmony export */   "createSequenceExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSequenceExpression),
/* harmony export */   "createSimpleExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression),
/* harmony export */   "createStructuralDirectiveTransform": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createStructuralDirectiveTransform),
/* harmony export */   "createTemplateLiteral": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createTemplateLiteral),
/* harmony export */   "createTransformContext": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createTransformContext),
/* harmony export */   "createVNodeCall": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createVNodeCall),
/* harmony export */   "findDir": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findDir),
/* harmony export */   "findProp": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findProp),
/* harmony export */   "generate": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.generate),
/* harmony export */   "generateCodeFrame": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.generateCodeFrame),
/* harmony export */   "getBaseTransformPreset": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getBaseTransformPreset),
/* harmony export */   "getInnerRange": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getInnerRange),
/* harmony export */   "hasDynamicKeyVBind": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.hasDynamicKeyVBind),
/* harmony export */   "hasScopeRef": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.hasScopeRef),
/* harmony export */   "helperNameMap": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.helperNameMap),
/* harmony export */   "injectProp": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.injectProp),
/* harmony export */   "isBindKey": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isBindKey),
/* harmony export */   "isBuiltInType": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isBuiltInType),
/* harmony export */   "isCoreComponent": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isCoreComponent),
/* harmony export */   "isMemberExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isMemberExpression),
/* harmony export */   "isSimpleIdentifier": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isSimpleIdentifier),
/* harmony export */   "isSlotOutlet": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isSlotOutlet),
/* harmony export */   "isStaticExp": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp),
/* harmony export */   "isTemplateNode": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isTemplateNode),
/* harmony export */   "isText": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isText),
/* harmony export */   "isVSlot": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isVSlot),
/* harmony export */   "locStub": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.locStub),
/* harmony export */   "noopDirectiveTransform": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.noopDirectiveTransform),
/* harmony export */   "processExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processExpression),
/* harmony export */   "processFor": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processFor),
/* harmony export */   "processIf": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processIf),
/* harmony export */   "processSlotOutlet": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processSlotOutlet),
/* harmony export */   "registerRuntimeHelpers": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeHelpers),
/* harmony export */   "resolveComponentType": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.resolveComponentType),
/* harmony export */   "toValidAssetId": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.toValidAssetId),
/* harmony export */   "trackSlotScopes": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.trackSlotScopes),
/* harmony export */   "trackVForSlotScopes": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.trackVForSlotScopes),
/* harmony export */   "transform": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transform),
/* harmony export */   "transformBind": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformBind),
/* harmony export */   "transformElement": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformElement),
/* harmony export */   "transformExpression": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformExpression),
/* harmony export */   "transformModel": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformModel),
/* harmony export */   "transformOn": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformOn),
/* harmony export */   "traverseNode": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.traverseNode),
/* harmony export */   "warnDeprecation": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.warnDeprecation),
/* harmony export */   "DOMDirectiveTransforms": () => (/* binding */ DOMDirectiveTransforms),
/* harmony export */   "DOMNodeTransforms": () => (/* binding */ DOMNodeTransforms),
/* harmony export */   "TRANSITION": () => (/* binding */ TRANSITION),
/* harmony export */   "TRANSITION_GROUP": () => (/* binding */ TRANSITION_GROUP),
/* harmony export */   "V_MODEL_CHECKBOX": () => (/* binding */ V_MODEL_CHECKBOX),
/* harmony export */   "V_MODEL_DYNAMIC": () => (/* binding */ V_MODEL_DYNAMIC),
/* harmony export */   "V_MODEL_RADIO": () => (/* binding */ V_MODEL_RADIO),
/* harmony export */   "V_MODEL_SELECT": () => (/* binding */ V_MODEL_SELECT),
/* harmony export */   "V_MODEL_TEXT": () => (/* binding */ V_MODEL_TEXT),
/* harmony export */   "V_ON_WITH_KEYS": () => (/* binding */ V_ON_WITH_KEYS),
/* harmony export */   "V_ON_WITH_MODIFIERS": () => (/* binding */ V_ON_WITH_MODIFIERS),
/* harmony export */   "V_SHOW": () => (/* binding */ V_SHOW),
/* harmony export */   "compile": () => (/* binding */ compile),
/* harmony export */   "createDOMCompilerError": () => (/* binding */ createDOMCompilerError),
/* harmony export */   "parse": () => (/* binding */ parse),
/* harmony export */   "parserOptions": () => (/* binding */ parserOptions),
/* harmony export */   "transformStyle": () => (/* binding */ transformStyle)
/* harmony export */ });
/* harmony import */ var _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/compiler-core */ "./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js");
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");
var _registerRuntimeHelpe, _DOMErrorMessages;

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




var V_MODEL_RADIO = Symbol( true ? "vModelRadio" : 0);
var V_MODEL_CHECKBOX = Symbol( true ? "vModelCheckbox" : 0);
var V_MODEL_TEXT = Symbol( true ? "vModelText" : 0);
var V_MODEL_SELECT = Symbol( true ? "vModelSelect" : 0);
var V_MODEL_DYNAMIC = Symbol( true ? "vModelDynamic" : 0);
var V_ON_WITH_MODIFIERS = Symbol( true ? "vOnModifiersGuard" : 0);
var V_ON_WITH_KEYS = Symbol( true ? "vOnKeysGuard" : 0);
var V_SHOW = Symbol( true ? "vShow" : 0);
var TRANSITION = Symbol( true ? "Transition" : 0);
var TRANSITION_GROUP = Symbol( true ? "TransitionGroup" : 0);
(0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeHelpers)((_registerRuntimeHelpe = {}, _defineProperty(_registerRuntimeHelpe, V_MODEL_RADIO, "vModelRadio"), _defineProperty(_registerRuntimeHelpe, V_MODEL_CHECKBOX, "vModelCheckbox"), _defineProperty(_registerRuntimeHelpe, V_MODEL_TEXT, "vModelText"), _defineProperty(_registerRuntimeHelpe, V_MODEL_SELECT, "vModelSelect"), _defineProperty(_registerRuntimeHelpe, V_MODEL_DYNAMIC, "vModelDynamic"), _defineProperty(_registerRuntimeHelpe, V_ON_WITH_MODIFIERS, "withModifiers"), _defineProperty(_registerRuntimeHelpe, V_ON_WITH_KEYS, "withKeys"), _defineProperty(_registerRuntimeHelpe, V_SHOW, "vShow"), _defineProperty(_registerRuntimeHelpe, TRANSITION, "Transition"), _defineProperty(_registerRuntimeHelpe, TRANSITION_GROUP, "TransitionGroup"), _registerRuntimeHelpe));
/* eslint-disable no-restricted-globals */

var decoder;

function decodeHtmlBrowser(raw) {
  var asAttr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (!decoder) {
    decoder = document.createElement('div');
  }

  if (asAttr) {
    decoder.innerHTML = "<div foo=\"".concat(raw.replace(/"/g, '&quot;'), "\">");
    return decoder.children[0].getAttribute('foo');
  } else {
    decoder.innerHTML = raw;
    return decoder.textContent;
  }
}

var isRawTextContainer = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('style,iframe,script,noscript', true);
var parserOptions = {
  isVoidTag: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isVoidTag,
  isNativeTag: function isNativeTag(tag) {
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isHTMLTag)(tag) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSVGTag)(tag);
  },
  isPreTag: function isPreTag(tag) {
    return tag === 'pre';
  },
  decodeEntities: decodeHtmlBrowser,
  isBuiltInComponent: function isBuiltInComponent(tag) {
    if ((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isBuiltInType)(tag, "Transition")) {
      return TRANSITION;
    } else if ((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isBuiltInType)(tag, "TransitionGroup")) {
      return TRANSITION_GROUP;
    }
  },
  // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
  getNamespace: function getNamespace(tag, parent) {
    var ns = parent ? parent.ns : 0
    /* HTML */
    ;

    if (parent && ns === 2
    /* MATH_ML */
    ) {
        if (parent.tag === 'annotation-xml') {
          if (tag === 'svg') {
            return 1
            /* SVG */
            ;
          }

          if (parent.props.some(function (a) {
            return a.type === 6
            /* ATTRIBUTE */
            && a.name === 'encoding' && a.value != null && (a.value.content === 'text/html' || a.value.content === 'application/xhtml+xml');
          })) {
            ns = 0
            /* HTML */
            ;
          }
        } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== 'mglyph' && tag !== 'malignmark') {
          ns = 0
          /* HTML */
          ;
        }
      } else if (parent && ns === 1
    /* SVG */
    ) {
        if (parent.tag === 'foreignObject' || parent.tag === 'desc' || parent.tag === 'title') {
          ns = 0
          /* HTML */
          ;
        }
      }

    if (ns === 0
    /* HTML */
    ) {
        if (tag === 'svg') {
          return 1
          /* SVG */
          ;
        }

        if (tag === 'math') {
          return 2
          /* MATH_ML */
          ;
        }
      }

    return ns;
  },
  // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
  getTextMode: function getTextMode(_ref) {
    var tag = _ref.tag,
        ns = _ref.ns;

    if (ns === 0
    /* HTML */
    ) {
        if (tag === 'textarea' || tag === 'title') {
          return 1
          /* RCDATA */
          ;
        }

        if (isRawTextContainer(tag)) {
          return 2
          /* RAWTEXT */
          ;
        }
      }

    return 0
    /* DATA */
    ;
  }
}; // Parse inline CSS strings for static style attributes into an object.
// This is a NodeTransform since it works on the static `style` attribute and
// converts it into a dynamic equivalent:
// style="color: red" -> :style='{ "color": "red" }'
// It is then processed by `transformElement` and included in the generated
// props.

var transformStyle = function transformStyle(node) {
  if (node.type === 1
  /* ELEMENT */
  ) {
      node.props.forEach(function (p, i) {
        if (p.type === 6
        /* ATTRIBUTE */
        && p.name === 'style' && p.value) {
          // replace p with an expression node
          node.props[i] = {
            type: 7
            /* DIRECTIVE */
            ,
            name: "bind",
            arg: (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)("style", true, p.loc),
            exp: parseInlineCSS(p.value.content, p.loc),
            modifiers: [],
            loc: p.loc
          };
        }
      });
    }
};

var parseInlineCSS = function parseInlineCSS(cssText, loc) {
  var normalized = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.parseStringStyle)(cssText);
  return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(JSON.stringify(normalized), false, loc, 3
  /* CAN_STRINGIFY */
  );
};

function createDOMCompilerError(code, loc) {
  return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompilerError)(code, loc,  true ? DOMErrorMessages : 0);
}

var DOMErrorMessages = (_DOMErrorMessages = {}, _defineProperty(_DOMErrorMessages, 49
/* X_V_HTML_NO_EXPRESSION */
, "v-html is missing expression."), _defineProperty(_DOMErrorMessages, 50
/* X_V_HTML_WITH_CHILDREN */
, "v-html will override element children."), _defineProperty(_DOMErrorMessages, 51
/* X_V_TEXT_NO_EXPRESSION */
, "v-text is missing expression."), _defineProperty(_DOMErrorMessages, 52
/* X_V_TEXT_WITH_CHILDREN */
, "v-text will override element children."), _defineProperty(_DOMErrorMessages, 53
/* X_V_MODEL_ON_INVALID_ELEMENT */
, "v-model can only be used on <input>, <textarea> and <select> elements."), _defineProperty(_DOMErrorMessages, 54
/* X_V_MODEL_ARG_ON_ELEMENT */
, "v-model argument is not supported on plain elements."), _defineProperty(_DOMErrorMessages, 55
/* X_V_MODEL_ON_FILE_INPUT_ELEMENT */
, "v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead."), _defineProperty(_DOMErrorMessages, 56
/* X_V_MODEL_UNNECESSARY_VALUE */
, "Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior."), _defineProperty(_DOMErrorMessages, 57
/* X_V_SHOW_NO_EXPRESSION */
, "v-show is missing expression."), _defineProperty(_DOMErrorMessages, 58
/* X_TRANSITION_INVALID_CHILDREN */
, "<Transition> expects exactly one child element or component."), _defineProperty(_DOMErrorMessages, 59
/* X_IGNORED_SIDE_EFFECT_TAG */
, "Tags with side effect (<script> and <style>) are ignored in client component templates."), _DOMErrorMessages);

var transformVHtml = function transformVHtml(dir, node, context) {
  var exp = dir.exp,
      loc = dir.loc;

  if (!exp) {
    context.onError(createDOMCompilerError(49
    /* X_V_HTML_NO_EXPRESSION */
    , loc));
  }

  if (node.children.length) {
    context.onError(createDOMCompilerError(50
    /* X_V_HTML_WITH_CHILDREN */
    , loc));
    node.children.length = 0;
  }

  return {
    props: [(0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty)((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)("innerHTML", true, loc), exp || (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)('', true))]
  };
};

var transformVText = function transformVText(dir, node, context) {
  var exp = dir.exp,
      loc = dir.loc;

  if (!exp) {
    context.onError(createDOMCompilerError(51
    /* X_V_TEXT_NO_EXPRESSION */
    , loc));
  }

  if (node.children.length) {
    context.onError(createDOMCompilerError(52
    /* X_V_TEXT_WITH_CHILDREN */
    , loc));
    node.children.length = 0;
  }

  return {
    props: [(0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty)((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)("textContent", true), exp ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression)(context.helperString(_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_DISPLAY_STRING), [exp], loc) : (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)('', true))]
  };
};

var transformModel = function transformModel(dir, node, context) {
  var baseResult = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformModel)(dir, node, context); // base transform has errors OR component v-model (only need props)

  if (!baseResult.props.length || node.tagType === 1
  /* COMPONENT */
  ) {
      return baseResult;
    }

  if (dir.arg) {
    context.onError(createDOMCompilerError(54
    /* X_V_MODEL_ARG_ON_ELEMENT */
    , dir.arg.loc));
  }

  function checkDuplicatedValue() {
    var value = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findProp)(node, 'value');

    if (value) {
      context.onError(createDOMCompilerError(56
      /* X_V_MODEL_UNNECESSARY_VALUE */
      , value.loc));
    }
  }

  var tag = node.tag;
  var isCustomElement = context.isCustomElement(tag);

  if (tag === 'input' || tag === 'textarea' || tag === 'select' || isCustomElement) {
    var directiveToUse = V_MODEL_TEXT;
    var isInvalidType = false;

    if (tag === 'input' || isCustomElement) {
      var type = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findProp)(node, "type");

      if (type) {
        if (type.type === 7
        /* DIRECTIVE */
        ) {
            // :type="foo"
            directiveToUse = V_MODEL_DYNAMIC;
          } else if (type.value) {
          switch (type.value.content) {
            case 'radio':
              directiveToUse = V_MODEL_RADIO;
              break;

            case 'checkbox':
              directiveToUse = V_MODEL_CHECKBOX;
              break;

            case 'file':
              isInvalidType = true;
              context.onError(createDOMCompilerError(55
              /* X_V_MODEL_ON_FILE_INPUT_ELEMENT */
              , dir.loc));
              break;

            default:
              // text type
               true && checkDuplicatedValue();
              break;
          }
        }
      } else if ((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.hasDynamicKeyVBind)(node)) {
        // element has bindings with dynamic keys, which can possibly contain
        // "type".
        directiveToUse = V_MODEL_DYNAMIC;
      } else {
        // text type
         true && checkDuplicatedValue();
      }
    } else if (tag === 'select') {
      directiveToUse = V_MODEL_SELECT;
    } else {
      // textarea
       true && checkDuplicatedValue();
    } // inject runtime directive
    // by returning the helper symbol via needRuntime
    // the import will replaced a resolveDirective call.


    if (!isInvalidType) {
      baseResult.needRuntime = context.helper(directiveToUse);
    }
  } else {
    context.onError(createDOMCompilerError(53
    /* X_V_MODEL_ON_INVALID_ELEMENT */
    , dir.loc));
  } // native vmodel doesn't need the `modelValue` props since they are also
  // passed to the runtime as `binding.value`. removing it reduces code size.


  baseResult.props = baseResult.props.filter(function (p) {
    return !(p.key.type === 4
    /* SIMPLE_EXPRESSION */
    && p.key.content === 'modelValue');
  });
  return baseResult;
};

var isEventOptionModifier = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)("passive,once,capture");
var isNonKeyModifier = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)( // event propagation management
"stop,prevent,self," + // system modifiers + exact
"ctrl,shift,alt,meta,exact," + // mouse
"middle"); // left & right could be mouse or key modifiers based on event type

var maybeKeyModifier = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('left,right');
var isKeyboardEvent = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)("onkeyup,onkeydown,onkeypress", true);

var resolveModifiers = function resolveModifiers(key, modifiers, context, loc) {
  var keyModifiers = [];
  var nonKeyModifiers = [];
  var eventOptionModifiers = [];

  for (var i = 0; i < modifiers.length; i++) {
    var modifier = modifiers[i];

    if (modifier === 'native' && (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.checkCompatEnabled)("COMPILER_V_ON_NATIVE"
    /* COMPILER_V_ON_NATIVE */
    , context, loc)) {
      eventOptionModifiers.push(modifier);
    } else if (isEventOptionModifier(modifier)) {
      // eventOptionModifiers: modifiers for addEventListener() options,
      // e.g. .passive & .capture
      eventOptionModifiers.push(modifier);
    } else {
      // runtimeModifiers: modifiers that needs runtime guards
      if (maybeKeyModifier(modifier)) {
        if ((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key)) {
          if (isKeyboardEvent(key.content)) {
            keyModifiers.push(modifier);
          } else {
            nonKeyModifiers.push(modifier);
          }
        } else {
          keyModifiers.push(modifier);
          nonKeyModifiers.push(modifier);
        }
      } else {
        if (isNonKeyModifier(modifier)) {
          nonKeyModifiers.push(modifier);
        } else {
          keyModifiers.push(modifier);
        }
      }
    }
  }

  return {
    keyModifiers: keyModifiers,
    nonKeyModifiers: nonKeyModifiers,
    eventOptionModifiers: eventOptionModifiers
  };
};

var transformClick = function transformClick(key, event) {
  var isStaticClick = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key) && key.content.toLowerCase() === 'onclick';
  return isStaticClick ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(event, true) : key.type !== 4
  /* SIMPLE_EXPRESSION */
  ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompoundExpression)(["(", key, ") === \"onClick\" ? \"".concat(event, "\" : ("), key, ")"]) : key;
};

var transformOn = function transformOn(dir, node, context) {
  return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformOn)(dir, node, context, function (baseResult) {
    var modifiers = dir.modifiers;
    if (!modifiers.length) return baseResult;
    var _baseResult$props$ = baseResult.props[0],
        key = _baseResult$props$.key,
        handlerExp = _baseResult$props$.value;

    var _resolveModifiers = resolveModifiers(key, modifiers, context, dir.loc),
        keyModifiers = _resolveModifiers.keyModifiers,
        nonKeyModifiers = _resolveModifiers.nonKeyModifiers,
        eventOptionModifiers = _resolveModifiers.eventOptionModifiers; // normalize click.right and click.middle since they don't actually fire


    if (nonKeyModifiers.includes('right')) {
      key = transformClick(key, "onContextmenu");
    }

    if (nonKeyModifiers.includes('middle')) {
      key = transformClick(key, "onMouseup");
    }

    if (nonKeyModifiers.length) {
      handlerExp = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression)(context.helper(V_ON_WITH_MODIFIERS), [handlerExp, JSON.stringify(nonKeyModifiers)]);
    }

    if (keyModifiers.length && ( // if event name is dynamic, always wrap with keys guard
    !(0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key) || isKeyboardEvent(key.content))) {
      handlerExp = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression)(context.helper(V_ON_WITH_KEYS), [handlerExp, JSON.stringify(keyModifiers)]);
    }

    if (eventOptionModifiers.length) {
      var modifierPostfix = eventOptionModifiers.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize).join('');
      key = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key) ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)("".concat(key.content).concat(modifierPostfix), true) : (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompoundExpression)(["(", key, ") + \"".concat(modifierPostfix, "\"")]);
    }

    return {
      props: [(0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty)(key, handlerExp)]
    };
  });
};

var transformShow = function transformShow(dir, node, context) {
  var exp = dir.exp,
      loc = dir.loc;

  if (!exp) {
    context.onError(createDOMCompilerError(57
    /* X_V_SHOW_NO_EXPRESSION */
    , loc));
  }

  return {
    props: [],
    needRuntime: context.helper(V_SHOW)
  };
};

var warnTransitionChildren = function warnTransitionChildren(node, context) {
  if (node.type === 1
  /* ELEMENT */
  && node.tagType === 1
  /* COMPONENT */
  ) {
      var component = context.isBuiltInComponent(node.tag);

      if (component === TRANSITION) {
        return function () {
          if (node.children.length && hasMultipleChildren(node)) {
            context.onError(createDOMCompilerError(58
            /* X_TRANSITION_INVALID_CHILDREN */
            , {
              start: node.children[0].loc.start,
              end: node.children[node.children.length - 1].loc.end,
              source: ''
            }));
          }
        };
      }
    }
};

function hasMultipleChildren(node) {
  // #1352 filter out potential comment nodes.
  var children = node.children = node.children.filter(function (c) {
    return c.type !== 3;
  }
  /* COMMENT */
  );
  var child = children[0];
  return children.length !== 1 || child.type === 11
  /* FOR */
  || child.type === 9
  /* IF */
  && child.branches.some(hasMultipleChildren);
}

var ignoreSideEffectTags = function ignoreSideEffectTags(node, context) {
  if (node.type === 1
  /* ELEMENT */
  && node.tagType === 0
  /* ELEMENT */
  && (node.tag === 'script' || node.tag === 'style')) {
    context.onError(createDOMCompilerError(59
    /* X_IGNORED_SIDE_EFFECT_TAG */
    , node.loc));
    context.removeNode();
  }
};

var DOMNodeTransforms = [transformStyle].concat(_toConsumableArray( true ? [warnTransitionChildren] : 0));
var DOMDirectiveTransforms = {
  cloak: _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.noopDirectiveTransform,
  html: transformVHtml,
  text: transformVText,
  model: transformModel,
  on: transformOn,
  show: transformShow
};

function compile(template) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseCompile)(template, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, parserOptions, options, {
    nodeTransforms: [// ignore <script> and <tag>
    // this is not put inside DOMNodeTransforms because that list is used
    // by compiler-ssr to generate vnode fallback branches
    ignoreSideEffectTags].concat(_toConsumableArray(DOMNodeTransforms), _toConsumableArray(options.nodeTransforms || [])),
    directiveTransforms: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, DOMDirectiveTransforms, options.directiveTransforms || {}),
    transformHoist: null
  }));
}

function parse(template) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseParse)(template, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, parserOptions, options));
}



/***/ }),

/***/ "./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ITERATE_KEY": () => (/* binding */ ITERATE_KEY),
/* harmony export */   "computed": () => (/* binding */ computed),
/* harmony export */   "customRef": () => (/* binding */ customRef),
/* harmony export */   "effect": () => (/* binding */ effect),
/* harmony export */   "enableTracking": () => (/* binding */ enableTracking),
/* harmony export */   "isProxy": () => (/* binding */ isProxy),
/* harmony export */   "isReactive": () => (/* binding */ isReactive),
/* harmony export */   "isReadonly": () => (/* binding */ isReadonly),
/* harmony export */   "isRef": () => (/* binding */ isRef),
/* harmony export */   "markRaw": () => (/* binding */ markRaw),
/* harmony export */   "pauseTracking": () => (/* binding */ pauseTracking),
/* harmony export */   "proxyRefs": () => (/* binding */ proxyRefs),
/* harmony export */   "reactive": () => (/* binding */ reactive),
/* harmony export */   "readonly": () => (/* binding */ readonly),
/* harmony export */   "ref": () => (/* binding */ ref),
/* harmony export */   "resetTracking": () => (/* binding */ resetTracking),
/* harmony export */   "shallowReactive": () => (/* binding */ shallowReactive),
/* harmony export */   "shallowReadonly": () => (/* binding */ shallowReadonly),
/* harmony export */   "shallowRef": () => (/* binding */ shallowRef),
/* harmony export */   "stop": () => (/* binding */ stop),
/* harmony export */   "toRaw": () => (/* binding */ toRaw),
/* harmony export */   "toRef": () => (/* binding */ toRef),
/* harmony export */   "toRefs": () => (/* binding */ toRefs),
/* harmony export */   "track": () => (/* binding */ track),
/* harmony export */   "trigger": () => (/* binding */ trigger),
/* harmony export */   "triggerRef": () => (/* binding */ triggerRef),
/* harmony export */   "unref": () => (/* binding */ unref)
/* harmony export */ });
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


var targetMap = new WeakMap();
var effectStack = [];
var activeEffect;
var ITERATE_KEY = Symbol( true ? 'iterate' : 0);
var MAP_KEY_ITERATE_KEY = Symbol( true ? 'Map key iterate' : 0);

function isEffect(fn) {
  return fn && fn._isEffect === true;
}

function effect(fn) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _vue_shared__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJ;

  if (isEffect(fn)) {
    fn = fn.raw;
  }

  var effect = createReactiveEffect(fn, options);

  if (!options.lazy) {
    effect();
  }

  return effect;
}

function stop(effect) {
  if (effect.active) {
    cleanup(effect);

    if (effect.options.onStop) {
      effect.options.onStop();
    }

    effect.active = false;
  }
}

var uid = 0;

function createReactiveEffect(fn, options) {
  var effect = function reactiveEffect() {
    if (!effect.active) {
      return fn();
    }

    if (!effectStack.includes(effect)) {
      cleanup(effect);

      try {
        enableTracking();
        effectStack.push(effect);
        activeEffect = effect;
        return fn();
      } finally {
        effectStack.pop();
        resetTracking();
        activeEffect = effectStack[effectStack.length - 1];
      }
    }
  };

  effect.id = uid++;
  effect.allowRecurse = !!options.allowRecurse;
  effect._isEffect = true;
  effect.active = true;
  effect.raw = fn;
  effect.deps = [];
  effect.options = options;
  return effect;
}

function cleanup(effect) {
  var deps = effect.deps;

  if (deps.length) {
    for (var i = 0; i < deps.length; i++) {
      deps[i].delete(effect);
    }

    deps.length = 0;
  }
}

var shouldTrack = true;
var trackStack = [];

function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}

function enableTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = true;
}

function resetTracking() {
  var last = trackStack.pop();
  shouldTrack = last === undefined ? true : last;
}

function track(target, type, key) {
  if (!shouldTrack || activeEffect === undefined) {
    return;
  }

  var depsMap = targetMap.get(target);

  if (!depsMap) {
    targetMap.set(target, depsMap = new Map());
  }

  var dep = depsMap.get(key);

  if (!dep) {
    depsMap.set(key, dep = new Set());
  }

  if (!dep.has(activeEffect)) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);

    if ( true && activeEffect.options.onTrack) {
      activeEffect.options.onTrack({
        effect: activeEffect,
        target: target,
        type: type,
        key: key
      });
    }
  }
}

function trigger(target, type, key, newValue, oldValue, oldTarget) {
  var depsMap = targetMap.get(target);

  if (!depsMap) {
    // never been tracked
    return;
  }

  var effects = new Set();

  var add = function add(effectsToAdd) {
    if (effectsToAdd) {
      effectsToAdd.forEach(function (effect) {
        if (effect !== activeEffect || effect.allowRecurse) {
          effects.add(effect);
        }
      });
    }
  };

  if (type === "clear"
  /* CLEAR */
  ) {
      // collection being cleared
      // trigger all effects for target
      depsMap.forEach(add);
    } else if (key === 'length' && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {
    depsMap.forEach(function (dep, key) {
      if (key === 'length' || key >= newValue) {
        add(dep);
      }
    });
  } else {
    // schedule runs for SET | ADD | DELETE
    if (key !== void 0) {
      add(depsMap.get(key));
    } // also run for iteration key on ADD | DELETE | Map.SET


    switch (type) {
      case "add"
      /* ADD */
      :
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {
          add(depsMap.get(ITERATE_KEY));

          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {
            add(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key)) {
          // new index added to array -> length changes
          add(depsMap.get('length'));
        }

        break;

      case "delete"
      /* DELETE */
      :
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {
          add(depsMap.get(ITERATE_KEY));

          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {
            add(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }

        break;

      case "set"
      /* SET */
      :
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {
          add(depsMap.get(ITERATE_KEY));
        }

        break;
    }
  }

  var run = function run(effect) {
    if ( true && effect.options.onTrigger) {
      effect.options.onTrigger({
        effect: effect,
        target: target,
        key: key,
        type: type,
        newValue: newValue,
        oldValue: oldValue,
        oldTarget: oldTarget
      });
    }

    if (effect.options.scheduler) {
      effect.options.scheduler(effect);
    } else {
      effect();
    }
  };

  effects.forEach(run);
}

var isNonTrackableKeys = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.makeMap)("__proto__,__v_isRef,__isVue");
var builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map(function (key) {
  return Symbol[key];
}).filter(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol));
var get = /*#__PURE__*/createGetter();
var shallowGet = /*#__PURE__*/createGetter(false, true);
var readonlyGet = /*#__PURE__*/createGetter(true);
var shallowReadonlyGet = /*#__PURE__*/createGetter(true, true);
var arrayInstrumentations = {};
['includes', 'indexOf', 'lastIndexOf'].forEach(function (key) {
  var method = Array.prototype[key];

  arrayInstrumentations[key] = function () {
    var arr = toRaw(this);

    for (var i = 0, l = this.length; i < l; i++) {
      track(arr, "get"
      /* GET */
      , i + '');
    } // we run the method using the original args first (which may be reactive)


    for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
      args[_key2] = arguments[_key2];
    }

    var res = method.apply(arr, args);

    if (res === -1 || res === false) {
      // if that didn't work, run it again using raw values.
      return method.apply(arr, args.map(toRaw));
    } else {
      return res;
    }
  };
});
['push', 'pop', 'shift', 'unshift', 'splice'].forEach(function (key) {
  var method = Array.prototype[key];

  arrayInstrumentations[key] = function () {
    pauseTracking();

    for (var _len2 = arguments.length, args = new Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {
      args[_key3] = arguments[_key3];
    }

    var res = method.apply(this, args);
    resetTracking();
    return res;
  };
});

function createGetter() {
  var isReadonly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  var shallow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return function get(target, key, receiver) {
    if (key === "__v_isReactive"
    /* IS_REACTIVE */
    ) {
        return !isReadonly;
      } else if (key === "__v_isReadonly"
    /* IS_READONLY */
    ) {
        return isReadonly;
      } else if (key === "__v_raw"
    /* RAW */
    && receiver === (isReadonly ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }

    var targetIsArray = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target);

    if (!isReadonly && targetIsArray && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(arrayInstrumentations, key)) {
      return Reflect.get(arrayInstrumentations, key, receiver);
    }

    var res = Reflect.get(target, key, receiver);

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }

    if (!isReadonly) {
      track(target, "get"
      /* GET */
      , key);
    }

    if (shallow) {
      return res;
    }

    if (isRef(res)) {
      // ref unwrapping - does not apply for Array + integer key.
      var shouldUnwrap = !targetIsArray || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key);
      return shouldUnwrap ? res.value : res;
    }

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(res)) {
      // Convert returned value into a proxy as well. we do the isObject check
      // here to avoid invalid value warning. Also need to lazy access readonly
      // and reactive here to avoid circular dependency.
      return isReadonly ? readonly(res) : reactive(res);
    }

    return res;
  };
}

var set = /*#__PURE__*/createSetter();
var shallowSet = /*#__PURE__*/createSetter(true);

function createSetter() {
  var shallow = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  return function set(target, key, value, receiver) {
    var oldValue = target[key];

    if (!shallow) {
      value = toRaw(value);
      oldValue = toRaw(oldValue);

      if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }

    var hadKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key) ? Number(key) < target.length : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(target, key);
    var result = Reflect.set(target, key, value, receiver); // don't trigger if target is something up in the prototype chain of original

    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add"
        /* ADD */
        , key, value);
      } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(value, oldValue)) {
        trigger(target, "set"
        /* SET */
        , key, value, oldValue);
      }
    }

    return result;
  };
}

function deleteProperty(target, key) {
  var hadKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(target, key);
  var oldValue = target[key];
  var result = Reflect.deleteProperty(target, key);

  if (result && hadKey) {
    trigger(target, "delete"
    /* DELETE */
    , key, undefined, oldValue);
  }

  return result;
}

function has(target, key) {
  var result = Reflect.has(target, key);

  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key) || !builtInSymbols.has(key)) {
    track(target, "has"
    /* HAS */
    , key);
  }

  return result;
}

function ownKeys(target) {
  track(target, "iterate"
  /* ITERATE */
  , (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) ? 'length' : ITERATE_KEY);
  return Reflect.ownKeys(target);
}

var mutableHandlers = {
  get: get,
  set: set,
  deleteProperty: deleteProperty,
  has: has,
  ownKeys: ownKeys
};
var readonlyHandlers = {
  get: readonlyGet,
  set: function set(target, key) {
    if (true) {
      console.warn("Set operation on key \"".concat(String(key), "\" failed: target is readonly."), target);
    }

    return true;
  },
  deleteProperty: function deleteProperty(target, key) {
    if (true) {
      console.warn("Delete operation on key \"".concat(String(key), "\" failed: target is readonly."), target);
    }

    return true;
  }
};
var shallowReactiveHandlers = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, mutableHandlers, {
  get: shallowGet,
  set: shallowSet
}); // Props handlers are special in the sense that it should not unwrap top-level
// refs (in order to allow refs to be explicitly passed down), but should
// retain the reactivity of the normal readonly object.

var shallowReadonlyHandlers = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, readonlyHandlers, {
  get: shallowReadonlyGet
});

var toReactive = function toReactive(value) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? reactive(value) : value;
};

var toReadonly = function toReadonly(value) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? readonly(value) : value;
};

var toShallow = function toShallow(value) {
  return value;
};

var getProto = function getProto(v) {
  return Reflect.getPrototypeOf(v);
};

function get$1(target, key) {
  var isReadonly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var isShallow = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  // #1772: readonly(reactive(Map)) should return readonly + reactive version
  // of the value
  target = target["__v_raw"
  /* RAW */
  ];
  var rawTarget = toRaw(target);
  var rawKey = toRaw(key);

  if (key !== rawKey) {
    !isReadonly && track(rawTarget, "get"
    /* GET */
    , key);
  }

  !isReadonly && track(rawTarget, "get"
  /* GET */
  , rawKey);

  var _getProto = getProto(rawTarget),
      has = _getProto.has;

  var wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;

  if (has.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    // #3602 readonly(reactive(Map))
    // ensure that the nested reactive `Map` can do tracking for itself
    target.get(key);
  }
}

function has$1(key) {
  var isReadonly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var target = this["__v_raw"
  /* RAW */
  ];
  var rawTarget = toRaw(target);
  var rawKey = toRaw(key);

  if (key !== rawKey) {
    !isReadonly && track(rawTarget, "has"
    /* HAS */
    , key);
  }

  !isReadonly && track(rawTarget, "has"
  /* HAS */
  , rawKey);
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}

function size(target) {
  var isReadonly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  target = target["__v_raw"
  /* RAW */
  ];
  !isReadonly && track(toRaw(target), "iterate"
  /* ITERATE */
  , ITERATE_KEY);
  return Reflect.get(target, 'size', target);
}

function add(value) {
  value = toRaw(value);
  var target = toRaw(this);
  var proto = getProto(target);
  var hadKey = proto.has.call(target, value);

  if (!hadKey) {
    target.add(value);
    trigger(target, "add"
    /* ADD */
    , value, value);
  }

  return this;
}

function set$1(key, value) {
  value = toRaw(value);
  var target = toRaw(this);

  var _getProto2 = getProto(target),
      has = _getProto2.has,
      get = _getProto2.get;

  var hadKey = has.call(target, key);

  if (!hadKey) {
    key = toRaw(key);
    hadKey = has.call(target, key);
  } else if (true) {
    checkIdentityKeys(target, has, key);
  }

  var oldValue = get.call(target, key);
  target.set(key, value);

  if (!hadKey) {
    trigger(target, "add"
    /* ADD */
    , key, value);
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(value, oldValue)) {
    trigger(target, "set"
    /* SET */
    , key, value, oldValue);
  }

  return this;
}

function deleteEntry(key) {
  var target = toRaw(this);

  var _getProto3 = getProto(target),
      has = _getProto3.has,
      get = _getProto3.get;

  var hadKey = has.call(target, key);

  if (!hadKey) {
    key = toRaw(key);
    hadKey = has.call(target, key);
  } else if (true) {
    checkIdentityKeys(target, has, key);
  }

  var oldValue = get ? get.call(target, key) : undefined; // forward the operation before queueing reactions

  var result = target.delete(key);

  if (hadKey) {
    trigger(target, "delete"
    /* DELETE */
    , key, undefined, oldValue);
  }

  return result;
}

function clear() {
  var target = toRaw(this);
  var hadItems = target.size !== 0;
  var oldTarget =  true ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target) ? new Map(target) : new Set(target) : 0; // forward the operation before queueing reactions

  var result = target.clear();

  if (hadItems) {
    trigger(target, "clear"
    /* CLEAR */
    , undefined, undefined, oldTarget);
  }

  return result;
}

function createForEach(isReadonly, isShallow) {
  return function forEach(callback, thisArg) {
    var observed = this;
    var target = observed["__v_raw"
    /* RAW */
    ];
    var rawTarget = toRaw(target);
    var wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    !isReadonly && track(rawTarget, "iterate"
    /* ITERATE */
    , ITERATE_KEY);
    return target.forEach(function (value, key) {
      // important: make sure the callback is
      // 1. invoked with the reactive map as `this` and 3rd arg
      // 2. the value received should be a corresponding reactive/readonly.
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}

function createIterableMethod(method, isReadonly, isShallow) {
  return function () {
    var target = this["__v_raw"
    /* RAW */
    ];
    var rawTarget = toRaw(target);
    var targetIsMap = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(rawTarget);
    var isPair = method === 'entries' || method === Symbol.iterator && targetIsMap;
    var isKeyOnly = method === 'keys' && targetIsMap;
    var innerIterator = target[method].apply(target, arguments);
    var wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    !isReadonly && track(rawTarget, "iterate"
    /* ITERATE */
    , isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY); // return a wrapped iterator which returns observed versions of the
    // values emitted from the real iterator

    return _defineProperty({
      // iterator protocol
      next: function next() {
        var _innerIterator$next = innerIterator.next(),
            value = _innerIterator$next.value,
            done = _innerIterator$next.done;

        return done ? {
          value: value,
          done: done
        } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done: done
        };
      }
    }, Symbol.iterator, function () {
      return this;
    });
  };
}

function createReadonlyMethod(type) {
  return function () {
    if (true) {
      var key = (arguments.length <= 0 ? undefined : arguments[0]) ? "on key \"".concat(arguments.length <= 0 ? undefined : arguments[0], "\" ") : "";
      console.warn("".concat((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.capitalize)(type), " operation ").concat(key, "failed: target is readonly."), toRaw(this));
    }

    return type === "delete"
    /* DELETE */
    ? false : this;
  };
}

var mutableInstrumentations = {
  get: function get(key) {
    return get$1(this, key);
  },

  get size() {
    return size(this);
  },

  has: has$1,
  add: add,
  set: set$1,
  delete: deleteEntry,
  clear: clear,
  forEach: createForEach(false, false)
};
var shallowInstrumentations = {
  get: function get(key) {
    return get$1(this, key, false, true);
  },

  get size() {
    return size(this);
  },

  has: has$1,
  add: add,
  set: set$1,
  delete: deleteEntry,
  clear: clear,
  forEach: createForEach(false, true)
};
var readonlyInstrumentations = {
  get: function get(key) {
    return get$1(this, key, true);
  },

  get size() {
    return size(this, true);
  },

  has: function has(key) {
    return has$1.call(this, key, true);
  },
  add: createReadonlyMethod("add"
  /* ADD */
  ),
  set: createReadonlyMethod("set"
  /* SET */
  ),
  delete: createReadonlyMethod("delete"
  /* DELETE */
  ),
  clear: createReadonlyMethod("clear"
  /* CLEAR */
  ),
  forEach: createForEach(true, false)
};
var shallowReadonlyInstrumentations = {
  get: function get(key) {
    return get$1(this, key, true, true);
  },

  get size() {
    return size(this, true);
  },

  has: function has(key) {
    return has$1.call(this, key, true);
  },
  add: createReadonlyMethod("add"
  /* ADD */
  ),
  set: createReadonlyMethod("set"
  /* SET */
  ),
  delete: createReadonlyMethod("delete"
  /* DELETE */
  ),
  clear: createReadonlyMethod("clear"
  /* CLEAR */
  ),
  forEach: createForEach(true, true)
};
var iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];
iteratorMethods.forEach(function (method) {
  mutableInstrumentations[method] = createIterableMethod(method, false, false);
  readonlyInstrumentations[method] = createIterableMethod(method, true, false);
  shallowInstrumentations[method] = createIterableMethod(method, false, true);
  shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);
});

function createInstrumentationGetter(isReadonly, shallow) {
  var instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;
  return function (target, key, receiver) {
    if (key === "__v_isReactive"
    /* IS_REACTIVE */
    ) {
        return !isReadonly;
      } else if (key === "__v_isReadonly"
    /* IS_READONLY */
    ) {
        return isReadonly;
      } else if (key === "__v_raw"
    /* RAW */
    ) {
        return target;
      }

    return Reflect.get((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
  };
}

var mutableCollectionHandlers = {
  get: createInstrumentationGetter(false, false)
};
var shallowCollectionHandlers = {
  get: createInstrumentationGetter(false, true)
};
var readonlyCollectionHandlers = {
  get: createInstrumentationGetter(true, false)
};
var shallowReadonlyCollectionHandlers = {
  get: createInstrumentationGetter(true, true)
};

function checkIdentityKeys(target, has, key) {
  var rawKey = toRaw(key);

  if (rawKey !== key && has.call(target, rawKey)) {
    var type = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toRawType)(target);
    console.warn("Reactive ".concat(type, " contains both the raw and reactive ") + "versions of the same object".concat(type === "Map" ? " as keys" : "", ", ") + "which can lead to inconsistencies. " + "Avoid differentiating between the raw and reactive versions " + "of an object and only use the reactive version if possible.");
  }
}

var reactiveMap = new WeakMap();
var shallowReactiveMap = new WeakMap();
var readonlyMap = new WeakMap();
var shallowReadonlyMap = new WeakMap();

function targetTypeMap(rawType) {
  switch (rawType) {
    case 'Object':
    case 'Array':
      return 1
      /* COMMON */
      ;

    case 'Map':
    case 'Set':
    case 'WeakMap':
    case 'WeakSet':
      return 2
      /* COLLECTION */
      ;

    default:
      return 0
      /* INVALID */
      ;
  }
}

function getTargetType(value) {
  return value["__v_skip"
  /* SKIP */
  ] || !Object.isExtensible(value) ? 0
  /* INVALID */
  : targetTypeMap((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toRawType)(value));
}

function reactive(target) {
  // if trying to observe a readonly proxy, return the readonly version.
  if (target && target["__v_isReadonly"
  /* IS_READONLY */
  ]) {
    return target;
  }

  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
/**
 * Return a shallowly-reactive copy of the original object, where only the root
 * level properties are reactive. It also does not auto-unwrap refs (even at the
 * root level).
 */


function shallowReactive(target) {
  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
/**
 * Creates a readonly copy of the original object. Note the returned copy is not
 * made reactive, but `readonly` can be called on an already reactive object.
 */


function readonly(target) {
  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
/**
 * Returns a reactive-copy of the original object, where only the root level
 * properties are readonly, and does NOT unwrap refs nor recursively convert
 * returned properties.
 * This is used for creating the props proxy object for stateful components.
 */


function shallowReadonly(target) {
  return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
}

function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {
  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(target)) {
    if (true) {
      console.warn("value cannot be made reactive: ".concat(String(target)));
    }

    return target;
  } // target is already a Proxy, return it.
  // exception: calling readonly() on a reactive object


  if (target["__v_raw"
  /* RAW */
  ] && !(isReadonly && target["__v_isReactive"
  /* IS_REACTIVE */
  ])) {
    return target;
  } // target already has corresponding Proxy


  var existingProxy = proxyMap.get(target);

  if (existingProxy) {
    return existingProxy;
  } // only a whitelist of value types can be observed.


  var targetType = getTargetType(target);

  if (targetType === 0
  /* INVALID */
  ) {
      return target;
    }

  var proxy = new Proxy(target, targetType === 2
  /* COLLECTION */
  ? collectionHandlers : baseHandlers);
  proxyMap.set(target, proxy);
  return proxy;
}

function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"
    /* RAW */
    ]);
  }

  return !!(value && value["__v_isReactive"
  /* IS_REACTIVE */
  ]);
}

function isReadonly(value) {
  return !!(value && value["__v_isReadonly"
  /* IS_READONLY */
  ]);
}

function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}

function toRaw(observed) {
  return observed && toRaw(observed["__v_raw"
  /* RAW */
  ]) || observed;
}

function markRaw(value) {
  (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.def)(value, "__v_skip"
  /* SKIP */
  , true);
  return value;
}

var convert = function convert(val) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(val) ? reactive(val) : val;
};

function isRef(r) {
  return Boolean(r && r.__v_isRef === true);
}

function ref(value) {
  return createRef(value);
}

function shallowRef(value) {
  return createRef(value, true);
}

var RefImpl = /*#__PURE__*/function () {
  function RefImpl(_rawValue) {
    var _shallow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    _classCallCheck(this, RefImpl);

    this._rawValue = _rawValue;
    this._shallow = _shallow;
    this.__v_isRef = true;
    this._value = _shallow ? _rawValue : convert(_rawValue);
  }

  _createClass(RefImpl, [{
    key: "value",
    get: function get() {
      track(toRaw(this), "get"
      /* GET */
      , 'value');
      return this._value;
    },
    set: function set(newVal) {
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(toRaw(newVal), this._rawValue)) {
        this._rawValue = newVal;
        this._value = this._shallow ? newVal : convert(newVal);
        trigger(toRaw(this), "set"
        /* SET */
        , 'value', newVal);
      }
    }
  }]);

  return RefImpl;
}();

function createRef(rawValue) {
  var shallow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (isRef(rawValue)) {
    return rawValue;
  }

  return new RefImpl(rawValue, shallow);
}

function triggerRef(ref) {
  trigger(toRaw(ref), "set"
  /* SET */
  , 'value',  true ? ref.value : 0);
}

function unref(ref) {
  return isRef(ref) ? ref.value : ref;
}

var shallowUnwrapHandlers = {
  get: function get(target, key, receiver) {
    return unref(Reflect.get(target, key, receiver));
  },
  set: function set(target, key, value, receiver) {
    var oldValue = target[key];

    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};

function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}

var CustomRefImpl = /*#__PURE__*/function () {
  function CustomRefImpl(factory) {
    var _this = this;

    _classCallCheck(this, CustomRefImpl);

    this.__v_isRef = true;

    var _factory = factory(function () {
      return track(_this, "get"
      /* GET */
      ,
      /* GET */
      'value');
    }, function () {
      return trigger(_this, "set"
      /* SET */
      ,
      /* SET */
      'value');
    }),
        get = _factory.get,
        set = _factory.set;

    this._get = get;
    this._set = set;
  }

  _createClass(CustomRefImpl, [{
    key: "value",
    get: function get() {
      return this._get();
    },
    set: function set(newVal) {
      this._set(newVal);
    }
  }]);

  return CustomRefImpl;
}();

function customRef(factory) {
  return new CustomRefImpl(factory);
}

function toRefs(object) {
  if ( true && !isProxy(object)) {
    console.warn("toRefs() expects a reactive object but received a plain one.");
  }

  var ret = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(object) ? new Array(object.length) : {};

  for (var key in object) {
    ret[key] = toRef(object, key);
  }

  return ret;
}

var ObjectRefImpl = /*#__PURE__*/function () {
  function ObjectRefImpl(_object, _key) {
    _classCallCheck(this, ObjectRefImpl);

    this._object = _object;
    this._key = _key;
    this.__v_isRef = true;
  }

  _createClass(ObjectRefImpl, [{
    key: "value",
    get: function get() {
      return this._object[this._key];
    },
    set: function set(newVal) {
      this._object[this._key] = newVal;
    }
  }]);

  return ObjectRefImpl;
}();

function toRef(object, key) {
  return isRef(object[key]) ? object[key] : new ObjectRefImpl(object, key);
}

var ComputedRefImpl = /*#__PURE__*/function () {
  function ComputedRefImpl(getter, _setter, isReadonly) {
    var _this2 = this;

    _classCallCheck(this, ComputedRefImpl);

    this._setter = _setter;
    this._dirty = true;
    this.__v_isRef = true;
    this.effect = effect(getter, {
      lazy: true,
      scheduler: function scheduler() {
        if (!_this2._dirty) {
          _this2._dirty = true;
          trigger(toRaw(_this2), "set"
          /* SET */
          , 'value');
        }
      }
    });
    this["__v_isReadonly"
    /* IS_READONLY */
    ] = isReadonly;
  }

  _createClass(ComputedRefImpl, [{
    key: "value",
    get: function get() {
      // the computed ref may get wrapped by other proxies e.g. readonly() #3376
      var self = toRaw(this);

      if (self._dirty) {
        self._value = this.effect();
        self._dirty = false;
      }

      track(self, "get"
      /* GET */
      , 'value');
      return self._value;
    },
    set: function set(newValue) {
      this._setter(newValue);
    }
  }]);

  return ComputedRefImpl;
}();

function computed(getterOrOptions) {
  var getter;
  var setter;

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isFunction)(getterOrOptions)) {
    getter = getterOrOptions;
    setter =  true ? function () {
      console.warn('Write operation failed: computed value is readonly');
    } : 0;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }

  return new ComputedRefImpl(getter, setter, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isFunction)(getterOrOptions) || !getterOrOptions.set);
}



/***/ }),

/***/ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "customRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.customRef),
/* harmony export */   "isProxy": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy),
/* harmony export */   "isReactive": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive),
/* harmony export */   "isReadonly": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly),
/* harmony export */   "isRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef),
/* harmony export */   "markRaw": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.markRaw),
/* harmony export */   "proxyRefs": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs),
/* harmony export */   "reactive": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.reactive),
/* harmony export */   "readonly": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.readonly),
/* harmony export */   "ref": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref),
/* harmony export */   "shallowReactive": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReactive),
/* harmony export */   "shallowReadonly": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly),
/* harmony export */   "shallowRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowRef),
/* harmony export */   "toRaw": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw),
/* harmony export */   "toRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRef),
/* harmony export */   "toRefs": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRefs),
/* harmony export */   "triggerRef": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.triggerRef),
/* harmony export */   "unref": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.unref),
/* harmony export */   "camelize": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize),
/* harmony export */   "capitalize": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize),
/* harmony export */   "toDisplayString": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey),
/* harmony export */   "BaseTransition": () => (/* binding */ BaseTransition),
/* harmony export */   "Comment": () => (/* binding */ Comment$1),
/* harmony export */   "Fragment": () => (/* binding */ Fragment),
/* harmony export */   "KeepAlive": () => (/* binding */ KeepAlive),
/* harmony export */   "Static": () => (/* binding */ Static),
/* harmony export */   "Suspense": () => (/* binding */ Suspense),
/* harmony export */   "Teleport": () => (/* binding */ Teleport),
/* harmony export */   "Text": () => (/* binding */ Text),
/* harmony export */   "callWithAsyncErrorHandling": () => (/* binding */ callWithAsyncErrorHandling),
/* harmony export */   "callWithErrorHandling": () => (/* binding */ callWithErrorHandling),
/* harmony export */   "cloneVNode": () => (/* binding */ cloneVNode),
/* harmony export */   "compatUtils": () => (/* binding */ compatUtils),
/* harmony export */   "computed": () => (/* binding */ computed),
/* harmony export */   "createBlock": () => (/* binding */ createBlock),
/* harmony export */   "createCommentVNode": () => (/* binding */ createCommentVNode),
/* harmony export */   "createHydrationRenderer": () => (/* binding */ createHydrationRenderer),
/* harmony export */   "createRenderer": () => (/* binding */ createRenderer),
/* harmony export */   "createSlots": () => (/* binding */ createSlots),
/* harmony export */   "createStaticVNode": () => (/* binding */ createStaticVNode),
/* harmony export */   "createTextVNode": () => (/* binding */ createTextVNode),
/* harmony export */   "createVNode": () => (/* binding */ createVNode),
/* harmony export */   "defineAsyncComponent": () => (/* binding */ defineAsyncComponent),
/* harmony export */   "defineComponent": () => (/* binding */ defineComponent),
/* harmony export */   "defineEmit": () => (/* binding */ defineEmit),
/* harmony export */   "defineProps": () => (/* binding */ defineProps),
/* harmony export */   "devtools": () => (/* binding */ devtools),
/* harmony export */   "getCurrentInstance": () => (/* binding */ getCurrentInstance),
/* harmony export */   "getTransitionRawChildren": () => (/* binding */ getTransitionRawChildren),
/* harmony export */   "h": () => (/* binding */ h),
/* harmony export */   "handleError": () => (/* binding */ handleError),
/* harmony export */   "initCustomFormatter": () => (/* binding */ initCustomFormatter),
/* harmony export */   "inject": () => (/* binding */ inject),
/* harmony export */   "isRuntimeOnly": () => (/* binding */ isRuntimeOnly),
/* harmony export */   "isVNode": () => (/* binding */ isVNode),
/* harmony export */   "mergeProps": () => (/* binding */ mergeProps),
/* harmony export */   "nextTick": () => (/* binding */ nextTick),
/* harmony export */   "onActivated": () => (/* binding */ onActivated),
/* harmony export */   "onBeforeMount": () => (/* binding */ onBeforeMount),
/* harmony export */   "onBeforeUnmount": () => (/* binding */ onBeforeUnmount),
/* harmony export */   "onBeforeUpdate": () => (/* binding */ onBeforeUpdate),
/* harmony export */   "onDeactivated": () => (/* binding */ onDeactivated),
/* harmony export */   "onErrorCaptured": () => (/* binding */ onErrorCaptured),
/* harmony export */   "onMounted": () => (/* binding */ onMounted),
/* harmony export */   "onRenderTracked": () => (/* binding */ onRenderTracked),
/* harmony export */   "onRenderTriggered": () => (/* binding */ onRenderTriggered),
/* harmony export */   "onServerPrefetch": () => (/* binding */ onServerPrefetch),
/* harmony export */   "onUnmounted": () => (/* binding */ onUnmounted),
/* harmony export */   "onUpdated": () => (/* binding */ onUpdated),
/* harmony export */   "openBlock": () => (/* binding */ openBlock),
/* harmony export */   "popScopeId": () => (/* binding */ popScopeId),
/* harmony export */   "provide": () => (/* binding */ provide),
/* harmony export */   "pushScopeId": () => (/* binding */ pushScopeId),
/* harmony export */   "queuePostFlushCb": () => (/* binding */ queuePostFlushCb),
/* harmony export */   "registerRuntimeCompiler": () => (/* binding */ registerRuntimeCompiler),
/* harmony export */   "renderList": () => (/* binding */ renderList),
/* harmony export */   "renderSlot": () => (/* binding */ renderSlot),
/* harmony export */   "resolveComponent": () => (/* binding */ resolveComponent),
/* harmony export */   "resolveDirective": () => (/* binding */ resolveDirective),
/* harmony export */   "resolveDynamicComponent": () => (/* binding */ resolveDynamicComponent),
/* harmony export */   "resolveFilter": () => (/* binding */ resolveFilter),
/* harmony export */   "resolveTransitionHooks": () => (/* binding */ resolveTransitionHooks),
/* harmony export */   "setBlockTracking": () => (/* binding */ setBlockTracking),
/* harmony export */   "setDevtoolsHook": () => (/* binding */ setDevtoolsHook),
/* harmony export */   "setTransitionHooks": () => (/* binding */ setTransitionHooks),
/* harmony export */   "ssrContextKey": () => (/* binding */ ssrContextKey),
/* harmony export */   "ssrUtils": () => (/* binding */ ssrUtils),
/* harmony export */   "toHandlers": () => (/* binding */ toHandlers),
/* harmony export */   "transformVNodeArgs": () => (/* binding */ transformVNodeArgs),
/* harmony export */   "useContext": () => (/* binding */ useContext),
/* harmony export */   "useSSRContext": () => (/* binding */ useSSRContext),
/* harmony export */   "useTransitionState": () => (/* binding */ useTransitionState),
/* harmony export */   "version": () => (/* binding */ version),
/* harmony export */   "warn": () => (/* binding */ warn),
/* harmony export */   "watch": () => (/* binding */ watch),
/* harmony export */   "watchEffect": () => (/* binding */ watchEffect),
/* harmony export */   "withCtx": () => (/* binding */ withCtx),
/* harmony export */   "withDirectives": () => (/* binding */ withDirectives),
/* harmony export */   "withScopeId": () => (/* binding */ withScopeId)
/* harmony export */ });
/* harmony import */ var _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/reactivity */ "./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js");
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");
var _ErrorTypeStrings, _deprecationData;

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }





var stack = [];

function pushWarningContext(vnode) {
  stack.push(vnode);
}

function popWarningContext() {
  stack.pop();
}

function warn(msg) {
  // avoid props formatting or warn handler tracking deps that might be mutated
  // during patch, leading to infinite recursion.
  (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
  var instance = stack.length ? stack[stack.length - 1].component : null;
  var appWarnHandler = instance && instance.appContext.config.warnHandler;
  var trace = getComponentTrace();

  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  if (appWarnHandler) {
    callWithErrorHandling(appWarnHandler, instance, 11
    /* APP_WARN_HANDLER */
    , [msg + args.join(''), instance && instance.proxy, trace.map(function (_ref) {
      var vnode = _ref.vnode;
      return "at <".concat(formatComponentName(instance, vnode.type), ">");
    }).join('\n'), trace]);
  } else {
    var _console;

    var warnArgs = ["[Vue warn]: ".concat(msg)].concat(args);
    /* istanbul ignore if */

    if (trace.length && // avoid spamming console during tests
    !false) {
      warnArgs.push.apply(warnArgs, ["\n"].concat(_toConsumableArray(formatTrace(trace))));
    }

    (_console = console).warn.apply(_console, _toConsumableArray(warnArgs));
  }

  (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
}

function getComponentTrace() {
  var currentVNode = stack[stack.length - 1];

  if (!currentVNode) {
    return [];
  } // we can't just use the stack because it will be incomplete during updates
  // that did not start from the root. Re-construct the parent chain using
  // instance parent pointers.


  var normalizedStack = [];

  while (currentVNode) {
    var last = normalizedStack[0];

    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }

    var parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }

  return normalizedStack;
}
/* istanbul ignore next */


function formatTrace(trace) {
  var logs = [];
  trace.forEach(function (entry, i) {
    logs.push.apply(logs, _toConsumableArray(i === 0 ? [] : ["\n"]).concat(_toConsumableArray(formatTraceEntry(entry))));
  });
  return logs;
}

function formatTraceEntry(_ref2) {
  var vnode = _ref2.vnode,
      recurseCount = _ref2.recurseCount;
  var postfix = recurseCount > 0 ? "... (".concat(recurseCount, " recursive calls)") : "";
  var isRoot = vnode.component ? vnode.component.parent == null : false;
  var open = " at <".concat(formatComponentName(vnode.component, vnode.type, isRoot));
  var close = ">" + postfix;
  return vnode.props ? [open].concat(_toConsumableArray(formatProps(vnode.props)), [close]) : [open + close];
}
/* istanbul ignore next */


function formatProps(props) {
  var res = [];
  var keys = Object.keys(props);
  keys.slice(0, 3).forEach(function (key) {
    res.push.apply(res, _toConsumableArray(formatProp(key, props[key])));
  });

  if (keys.length > 3) {
    res.push(" ...");
  }

  return res;
}
/* istanbul ignore next */


function formatProp(key, value, raw) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(value)) {
    value = JSON.stringify(value);
    return raw ? value : ["".concat(key, "=").concat(value)];
  } else if (typeof value === 'number' || typeof value === 'boolean' || value == null) {
    return raw ? value : ["".concat(key, "=").concat(value)];
  } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(value)) {
    value = formatProp(key, (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(value.value), true);
    return raw ? value : ["".concat(key, "=Ref<"), value, ">"];
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
    return ["".concat(key, "=fn").concat(value.name ? "<".concat(value.name, ">") : "")];
  } else {
    value = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(value);
    return raw ? value : ["".concat(key, "="), value];
  }
}

var ErrorTypeStrings = (_ErrorTypeStrings = {}, _defineProperty(_ErrorTypeStrings, "bc"
/* BEFORE_CREATE */
, 'beforeCreate hook'), _defineProperty(_ErrorTypeStrings, "c"
/* CREATED */
, 'created hook'), _defineProperty(_ErrorTypeStrings, "bm"
/* BEFORE_MOUNT */
, 'beforeMount hook'), _defineProperty(_ErrorTypeStrings, "m"
/* MOUNTED */
, 'mounted hook'), _defineProperty(_ErrorTypeStrings, "bu"
/* BEFORE_UPDATE */
, 'beforeUpdate hook'), _defineProperty(_ErrorTypeStrings, "u"
/* UPDATED */
, 'updated'), _defineProperty(_ErrorTypeStrings, "bum"
/* BEFORE_UNMOUNT */
, 'beforeUnmount hook'), _defineProperty(_ErrorTypeStrings, "um"
/* UNMOUNTED */
, 'unmounted hook'), _defineProperty(_ErrorTypeStrings, "a"
/* ACTIVATED */
, 'activated hook'), _defineProperty(_ErrorTypeStrings, "da"
/* DEACTIVATED */
, 'deactivated hook'), _defineProperty(_ErrorTypeStrings, "ec"
/* ERROR_CAPTURED */
, 'errorCaptured hook'), _defineProperty(_ErrorTypeStrings, "rtc"
/* RENDER_TRACKED */
, 'renderTracked hook'), _defineProperty(_ErrorTypeStrings, "rtg"
/* RENDER_TRIGGERED */
, 'renderTriggered hook'), _defineProperty(_ErrorTypeStrings, 0
/* SETUP_FUNCTION */
, 'setup function'), _defineProperty(_ErrorTypeStrings, 1
/* RENDER_FUNCTION */
, 'render function'), _defineProperty(_ErrorTypeStrings, 2
/* WATCH_GETTER */
, 'watcher getter'), _defineProperty(_ErrorTypeStrings, 3
/* WATCH_CALLBACK */
, 'watcher callback'), _defineProperty(_ErrorTypeStrings, 4
/* WATCH_CLEANUP */
, 'watcher cleanup function'), _defineProperty(_ErrorTypeStrings, 5
/* NATIVE_EVENT_HANDLER */
, 'native event handler'), _defineProperty(_ErrorTypeStrings, 6
/* COMPONENT_EVENT_HANDLER */
, 'component event handler'), _defineProperty(_ErrorTypeStrings, 7
/* VNODE_HOOK */
, 'vnode hook'), _defineProperty(_ErrorTypeStrings, 8
/* DIRECTIVE_HOOK */
, 'directive hook'), _defineProperty(_ErrorTypeStrings, 9
/* TRANSITION_HOOK */
, 'transition hook'), _defineProperty(_ErrorTypeStrings, 10
/* APP_ERROR_HANDLER */
, 'app errorHandler'), _defineProperty(_ErrorTypeStrings, 11
/* APP_WARN_HANDLER */
, 'app warnHandler'), _defineProperty(_ErrorTypeStrings, 12
/* FUNCTION_REF */
, 'ref function'), _defineProperty(_ErrorTypeStrings, 13
/* ASYNC_COMPONENT_LOADER */
, 'async component loader'), _defineProperty(_ErrorTypeStrings, 14
/* SCHEDULER */
, 'scheduler flush. This is likely a Vue internals bug. ' + 'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/vue-next'), _ErrorTypeStrings);

function callWithErrorHandling(fn, instance, type, args) {
  var res;

  try {
    res = args ? fn.apply(void 0, _toConsumableArray(args)) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }

  return res;
}

function callWithAsyncErrorHandling(fn, instance, type, args) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(fn)) {
    var res = callWithErrorHandling(fn, instance, type, args);

    if (res && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(res)) {
      res.catch(function (err) {
        handleError(err, instance, type);
      });
    }

    return res;
  }

  var values = [];

  for (var i = 0; i < fn.length; i++) {
    values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
  }

  return values;
}

function handleError(err, instance, type) {
  var throwInDev = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var contextVNode = instance ? instance.vnode : null;

  if (instance) {
    var cur = instance.parent; // the exposed instance is the render proxy to keep it consistent with 2.x

    var exposedInstance = instance.proxy; // in production the hook receives only the error code

    var errorInfo =  true ? ErrorTypeStrings[type] : 0;

    while (cur) {
      var errorCapturedHooks = cur.ec;

      if (errorCapturedHooks) {
        for (var i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }

      cur = cur.parent;
    } // app-level handling


    var appErrorHandler = instance.appContext.config.errorHandler;

    if (appErrorHandler) {
      callWithErrorHandling(appErrorHandler, null, 10
      /* APP_ERROR_HANDLER */
      , [err, exposedInstance, errorInfo]);
      return;
    }
  }

  logError(err, type, contextVNode, throwInDev);
}

function logError(err, type, contextVNode) {
  var throwInDev = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

  if (true) {
    var info = ErrorTypeStrings[type];

    if (contextVNode) {
      pushWarningContext(contextVNode);
    }

    warn("Unhandled error".concat(info ? " during execution of ".concat(info) : ""));

    if (contextVNode) {
      popWarningContext();
    } // crash in dev by default so it's more noticeable


    if (throwInDev) {
      throw err;
    } else {
      console.error(err);
    }
  } else {}
}

var isFlushing = false;
var isFlushPending = false;
var queue = [];
var flushIndex = 0;
var pendingPreFlushCbs = [];
var activePreFlushCbs = null;
var preFlushIndex = 0;
var pendingPostFlushCbs = [];
var activePostFlushCbs = null;
var postFlushIndex = 0;
var resolvedPromise = Promise.resolve();
var currentFlushPromise = null;
var currentPreFlushParentJob = null;
var RECURSION_LIMIT = 100;

function nextTick(fn) {
  var p = currentFlushPromise || resolvedPromise;
  return fn ? p.then(this ? fn.bind(this) : fn) : p;
} // #2768
// Use binary-search to find a suitable position in the queue,
// so that the queue maintains the increasing order of job's id,
// which can prevent the job from being skipped and also can avoid repeated patching.


function findInsertionIndex(job) {
  // the start index should be `flushIndex + 1`
  var start = flushIndex + 1;
  var end = queue.length;
  var jobId = getId(job);

  while (start < end) {
    var middle = start + end >>> 1;
    var middleJobId = getId(queue[middle]);
    middleJobId < jobId ? start = middle + 1 : end = middle;
  }

  return start;
}

function queueJob(job) {
  // the dedupe search uses the startIndex argument of Array.includes()
  // by default the search index includes the current job that is being run
  // so it cannot recursively trigger itself again.
  // if the job is a watch() callback, the search will start with a +1 index to
  // allow it recursively trigger itself - it is the user's responsibility to
  // ensure it doesn't end up in an infinite loop.
  if ((!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) && job !== currentPreFlushParentJob) {
    var pos = findInsertionIndex(job);

    if (pos > -1) {
      queue.splice(pos, 0, job);
    } else {
      queue.push(job);
    }

    queueFlush();
  }
}

function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}

function invalidateJob(job) {
  var i = queue.indexOf(job);

  if (i > flushIndex) {
    queue.splice(i, 1);
  }
}

function queueCb(cb, activeQueue, pendingQueue, index) {
  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(cb)) {
    if (!activeQueue || !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)) {
      pendingQueue.push(cb);
    }
  } else {
    // if cb is an array, it is a component lifecycle hook which can only be
    // triggered by a job, which is already deduped in the main queue, so
    // we can skip duplicate check here to improve perf
    pendingQueue.push.apply(pendingQueue, _toConsumableArray(cb));
  }

  queueFlush();
}

function queuePreFlushCb(cb) {
  queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);
}

function queuePostFlushCb(cb) {
  queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);
}

function flushPreFlushCbs(seen) {
  var parentJob = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  if (pendingPreFlushCbs.length) {
    currentPreFlushParentJob = parentJob;
    activePreFlushCbs = _toConsumableArray(new Set(pendingPreFlushCbs));
    pendingPreFlushCbs.length = 0;

    if (true) {
      seen = seen || new Map();
    }

    for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {
      if ( true && checkRecursiveUpdates(seen, activePreFlushCbs[preFlushIndex])) {
        continue;
      }

      activePreFlushCbs[preFlushIndex]();
    }

    activePreFlushCbs = null;
    preFlushIndex = 0;
    currentPreFlushParentJob = null; // recursively flush until it drains

    flushPreFlushCbs(seen, parentJob);
  }
}

function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    var deduped = _toConsumableArray(new Set(pendingPostFlushCbs));

    pendingPostFlushCbs.length = 0; // #1947 already has active queue, nested flushPostFlushCbs call

    if (activePostFlushCbs) {
      var _activePostFlushCbs;

      (_activePostFlushCbs = activePostFlushCbs).push.apply(_activePostFlushCbs, _toConsumableArray(deduped));

      return;
    }

    activePostFlushCbs = deduped;

    if (true) {
      seen = seen || new Map();
    }

    activePostFlushCbs.sort(function (a, b) {
      return getId(a) - getId(b);
    });

    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      if ( true && checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) {
        continue;
      }

      activePostFlushCbs[postFlushIndex]();
    }

    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}

var getId = function getId(job) {
  return job.id == null ? Infinity : job.id;
};

function flushJobs(seen) {
  isFlushPending = false;
  isFlushing = true;

  if (true) {
    seen = seen || new Map();
  }

  flushPreFlushCbs(seen); // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child so its render effect will have smaller
  //    priority number)
  // 2. If a component is unmounted during a parent component's update,
  //    its update can be skipped.

  queue.sort(function (a, b) {
    return getId(a) - getId(b);
  });

  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      var job = queue[flushIndex];

      if (job && job.active !== false) {
        if ( true && checkRecursiveUpdates(seen, job)) {
          continue;
        }

        callWithErrorHandling(job, null, 14
        /* SCHEDULER */
        );
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs(seen);
    isFlushing = false;
    currentFlushPromise = null; // some postFlushCb queued jobs!
    // keep flushing until it drains.

    if (queue.length || pendingPreFlushCbs.length || pendingPostFlushCbs.length) {
      flushJobs(seen);
    }
  }
}

function checkRecursiveUpdates(seen, fn) {
  if (!seen.has(fn)) {
    seen.set(fn, 1);
  } else {
    var count = seen.get(fn);

    if (count > RECURSION_LIMIT) {
      var instance = fn.ownerInstance;
      var componentName = instance && getComponentName(instance.type);
      warn("Maximum recursive updates exceeded".concat(componentName ? " in component <".concat(componentName, ">") : "", ". ") + "This means you have a reactive effect that is mutating its own " + "dependencies and thus recursively triggering itself. Possible sources " + "include component template, render function, updated hook or " + "watcher source function.");
      return true;
    } else {
      seen.set(fn, count + 1);
    }
  }
}
/* eslint-disable no-restricted-globals */


var isHmrUpdating = false;
var hmrDirtyComponents = new Set(); // Expose the HMR runtime on the global object
// This makes it entirely tree-shakable without polluting the exports and makes
// it easier to be used in toolings like vue-loader
// Note: for a component to be eligible for HMR it also needs the __hmrId option
// to be set so that its instances can be registered / removed.

if (true) {
  var globalObject = typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {};
  globalObject.__VUE_HMR_RUNTIME__ = {
    createRecord: tryWrap(createRecord),
    rerender: tryWrap(rerender),
    reload: tryWrap(reload)
  };
}

var map = new Map();

function registerHMR(instance) {
  var id = instance.type.__hmrId;
  var record = map.get(id);

  if (!record) {
    createRecord(id, instance.type);
    record = map.get(id);
  }

  record.instances.add(instance);
}

function unregisterHMR(instance) {
  map.get(instance.type.__hmrId).instances.delete(instance);
}

function createRecord(id, component) {
  if (!component) {
    warn("HMR API usage is out of date.\n" + "Please upgrade vue-loader/vite/rollup-plugin-vue or other relevant " + "dependency that handles Vue SFC compilation.");
    component = {};
  }

  if (map.has(id)) {
    return false;
  }

  map.set(id, {
    component: isClassComponent(component) ? component.__vccOpts : component,
    instances: new Set()
  });
  return true;
}

function rerender(id, newRender) {
  var record = map.get(id);
  if (!record) return;
  if (newRender) record.component.render = newRender; // Array.from creates a snapshot which avoids the set being mutated during
  // updates

  Array.from(record.instances).forEach(function (instance) {
    if (newRender) {
      instance.render = newRender;
    }

    instance.renderCache = []; // this flag forces child components with slot content to update

    isHmrUpdating = true;
    instance.update();
    isHmrUpdating = false;
  });
}

function reload(id, newComp) {
  var record = map.get(id);
  if (!record) return; // Array.from creates a snapshot which avoids the set being mutated during
  // updates

  var component = record.component,
      instances = record.instances;

  if (!hmrDirtyComponents.has(component)) {
    // 1. Update existing comp definition to match new one
    newComp = isClassComponent(newComp) ? newComp.__vccOpts : newComp;
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(component, newComp);

    for (var key in component) {
      if (key !== '__file' && !(key in newComp)) {
        delete component[key];
      }
    } // 2. Mark component dirty. This forces the renderer to replace the component
    // on patch.


    hmrDirtyComponents.add(component); // 3. Make sure to unmark the component after the reload.

    queuePostFlushCb(function () {
      hmrDirtyComponents.delete(component);
    });
  }

  Array.from(instances).forEach(function (instance) {
    if (instance.parent) {
      // 4. Force the parent instance to re-render. This will cause all updated
      // components to be unmounted and re-mounted. Queue the update so that we
      // don't end up forcing the same parent to re-render multiple times.
      queueJob(instance.parent.update);
    } else if (instance.appContext.reload) {
      // root instance mounted via createApp() has a reload method
      instance.appContext.reload();
    } else if (typeof window !== 'undefined') {
      // root instance inside tree created via raw render(). Force reload.
      window.location.reload();
    } else {
      console.warn('[HMR] Root or manually mounted instance modified. Full reload required.');
    }
  });
}

function tryWrap(fn) {
  return function (id, arg) {
    try {
      return fn(id, arg);
    } catch (e) {
      console.error(e);
      console.warn("[HMR] Something went wrong during Vue component hot-reload. " + "Full reload required.");
    }
  };
}

var devtools;

function setDevtoolsHook(hook) {
  devtools = hook;
}

function devtoolsInitApp(app, version) {
  // TODO queue if devtools is undefined
  if (!devtools) return;
  devtools.emit("app:init"
  /* APP_INIT */
  , app, version, {
    Fragment: Fragment,
    Text: Text,
    Comment: Comment$1,
    Static: Static
  });
}

function devtoolsUnmountApp(app) {
  if (!devtools) return;
  devtools.emit("app:unmount"
  /* APP_UNMOUNT */
  , app);
}

var devtoolsComponentAdded = /*#__PURE__*/createDevtoolsComponentHook("component:added"
/* COMPONENT_ADDED */
);
var devtoolsComponentUpdated = /*#__PURE__*/createDevtoolsComponentHook("component:updated"
/* COMPONENT_UPDATED */
);
var devtoolsComponentRemoved = /*#__PURE__*/createDevtoolsComponentHook("component:removed"
/* COMPONENT_REMOVED */
);

function createDevtoolsComponentHook(hook) {
  return function (component) {
    if (!devtools) return;
    devtools.emit(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : undefined, component);
  };
}

var devtoolsPerfStart = /*#__PURE__*/createDevtoolsPerformanceHook("perf:start"
/* PERFORMANCE_START */
);
var devtoolsPerfEnd = /*#__PURE__*/createDevtoolsPerformanceHook("perf:end"
/* PERFORMANCE_END */
);

function createDevtoolsPerformanceHook(hook) {
  return function (component, type, time) {
    if (!devtools) return;
    devtools.emit(hook, component.appContext.app, component.uid, component, type, time);
  };
}

function devtoolsComponentEmit(component, event, params) {
  if (!devtools) return;
  devtools.emit("component:emit"
  /* COMPONENT_EMIT */
  , component.appContext.app, component, event, params);
}

var deprecationData = (_deprecationData = {}, _defineProperty(_deprecationData, "GLOBAL_MOUNT"
/* GLOBAL_MOUNT */
, {
  message: "The global app bootstrapping API has changed: vm.$mount() and the \"el\" " + "option have been removed. Use createApp(RootComponent).mount() instead.",
  link: "https://v3.vuejs.org/guide/migration/global-api.html#mounting-app-instance"
}), _defineProperty(_deprecationData, "GLOBAL_MOUNT_CONTAINER"
/* GLOBAL_MOUNT_CONTAINER */
, {
  message: "Vue detected directives on the mount container. " + "In Vue 3, the container is no longer considered part of the template " + "and will not be processed/replaced.",
  link: "https://v3.vuejs.org/guide/migration/mount-changes.html"
}), _defineProperty(_deprecationData, "GLOBAL_EXTEND"
/* GLOBAL_EXTEND */
, {
  message: "Vue.extend() has been removed in Vue 3. " + "Use defineComponent() instead.",
  link: "https://v3.vuejs.org/api/global-api.html#definecomponent"
}), _defineProperty(_deprecationData, "GLOBAL_PROTOTYPE"
/* GLOBAL_PROTOTYPE */
, {
  message: "Vue.prototype is no longer available in Vue 3. " + "Use app.config.globalProperties instead.",
  link: "https://v3.vuejs.org/guide/migration/global-api.html#vue-prototype-replaced-by-config-globalproperties"
}), _defineProperty(_deprecationData, "GLOBAL_SET"
/* GLOBAL_SET */
, {
  message: "Vue.set() has been removed as it is no longer needed in Vue 3. " + "Simply use native JavaScript mutations."
}), _defineProperty(_deprecationData, "GLOBAL_DELETE"
/* GLOBAL_DELETE */
, {
  message: "Vue.delete() has been removed as it is no longer needed in Vue 3. " + "Simply use native JavaScript mutations."
}), _defineProperty(_deprecationData, "GLOBAL_OBSERVABLE"
/* GLOBAL_OBSERVABLE */
, {
  message: "Vue.observable() has been removed. " + "Use `import { reactive } from \"vue\"` from Composition API instead.",
  link: "https://v3.vuejs.org/api/basic-reactivity.html"
}), _defineProperty(_deprecationData, "GLOBAL_PRIVATE_UTIL"
/* GLOBAL_PRIVATE_UTIL */
, {
  message: "Vue.util has been removed. Please refactor to avoid its usage " + "since it was an internal API even in Vue 2."
}), _defineProperty(_deprecationData, "CONFIG_SILENT"
/* CONFIG_SILENT */
, {
  message: "config.silent has been removed because it is not good practice to " + "intentionally suppress warnings. You can use your browser console's " + "filter features to focus on relevant messages."
}), _defineProperty(_deprecationData, "CONFIG_DEVTOOLS"
/* CONFIG_DEVTOOLS */
, {
  message: "config.devtools has been removed. To enable devtools for " + "production, configure the __VUE_PROD_DEVTOOLS__ compile-time flag.",
  link: "https://github.com/vuejs/vue-next/tree/master/packages/vue#bundler-build-feature-flags"
}), _defineProperty(_deprecationData, "CONFIG_KEY_CODES"
/* CONFIG_KEY_CODES */
, {
  message: "config.keyCodes has been removed. " + "In Vue 3, you can directly use the kebab-case key names as v-on modifiers.",
  link: "https://v3.vuejs.org/guide/migration/keycode-modifiers.html"
}), _defineProperty(_deprecationData, "CONFIG_PRODUCTION_TIP"
/* CONFIG_PRODUCTION_TIP */
, {
  message: "config.productionTip has been removed.",
  link: "https://v3.vuejs.org/guide/migration/global-api.html#config-productiontip-removed"
}), _defineProperty(_deprecationData, "CONFIG_IGNORED_ELEMENTS"
/* CONFIG_IGNORED_ELEMENTS */
, {
  message: function message() {
    var msg = "config.ignoredElements has been removed.";

    if (isRuntimeOnly()) {
      msg += " Pass the \"isCustomElement\" option to @vue/compiler-dom instead.";
    } else {
      msg += " Use config.isCustomElement instead.";
    }

    return msg;
  },
  link: "https://v3.vuejs.org/guide/migration/global-api.html#config-ignoredelements-is-now-config-iscustomelement"
}), _defineProperty(_deprecationData, "CONFIG_WHITESPACE"
/* CONFIG_WHITESPACE */
, {
  // this warning is only relevant in the full build when using runtime
  // compilation, so it's put in the runtime compatConfig list.
  message: "Vue 3 compiler's whitespace option will default to \"condense\" instead of " + "\"preserve\". To suppress this warning, provide an explicit value for " + "`config.compilerOptions.whitespace`."
}), _defineProperty(_deprecationData, "CONFIG_OPTION_MERGE_STRATS"
/* CONFIG_OPTION_MERGE_STRATS */
, {
  message: "config.optionMergeStrategies no longer exposes internal strategies. " + "Use custom merge functions instead."
}), _defineProperty(_deprecationData, "INSTANCE_SET"
/* INSTANCE_SET */
, {
  message: "vm.$set() has been removed as it is no longer needed in Vue 3. " + "Simply use native JavaScript mutations."
}), _defineProperty(_deprecationData, "INSTANCE_DELETE"
/* INSTANCE_DELETE */
, {
  message: "vm.$delete() has been removed as it is no longer needed in Vue 3. " + "Simply use native JavaScript mutations."
}), _defineProperty(_deprecationData, "INSTANCE_DESTROY"
/* INSTANCE_DESTROY */
, {
  message: "vm.$destroy() has been removed. Use app.unmount() instead.",
  link: "https://v3.vuejs.org/api/application-api.html#unmount"
}), _defineProperty(_deprecationData, "INSTANCE_EVENT_EMITTER"
/* INSTANCE_EVENT_EMITTER */
, {
  message: "vm.$on/$once/$off() have been removed. " + "Use an external event emitter library instead.",
  link: "https://v3.vuejs.org/guide/migration/events-api.html"
}), _defineProperty(_deprecationData, "INSTANCE_EVENT_HOOKS"
/* INSTANCE_EVENT_HOOKS */
, {
  message: function message(event) {
    return "\"".concat(event, "\" lifecycle events are no longer supported. From templates, ") + "use the \"vnode\" prefix instead of \"hook:\". For example, @".concat(event, " ") + "should be changed to @vnode-".concat(event.slice(5), ". ") + "From JavaScript, use Composition API to dynamically register lifecycle " + "hooks.";
  },
  link: "https://v3.vuejs.org/guide/migration/vnode-lifecycle-events.html"
}), _defineProperty(_deprecationData, "INSTANCE_CHILDREN"
/* INSTANCE_CHILDREN */
, {
  message: "vm.$children has been removed. Consider refactoring your logic " + "to avoid relying on direct access to child components.",
  link: "https://v3.vuejs.org/guide/migration/children.html"
}), _defineProperty(_deprecationData, "INSTANCE_LISTENERS"
/* INSTANCE_LISTENERS */
, {
  message: "vm.$listeners has been removed. In Vue 3, parent v-on listeners are " + "included in vm.$attrs and it is no longer necessary to separately use " + "v-on=\"$listeners\" if you are already using v-bind=\"$attrs\". " + "(Note: the Vue 3 behavior only applies if this compat config is disabled)",
  link: "https://v3.vuejs.org/guide/migration/listeners-removed.html"
}), _defineProperty(_deprecationData, "INSTANCE_SCOPED_SLOTS"
/* INSTANCE_SCOPED_SLOTS */
, {
  message: "vm.$scopedSlots has been removed. Use vm.$slots instead.",
  link: "https://v3.vuejs.org/guide/migration/slots-unification.html"
}), _defineProperty(_deprecationData, "INSTANCE_ATTRS_CLASS_STYLE"
/* INSTANCE_ATTRS_CLASS_STYLE */
, {
  message: function message(componentName) {
    return "Component <".concat(componentName || 'Anonymous', "> has `inheritAttrs: false` but is ") + "relying on class/style fallthrough from parent. In Vue 3, class/style " + "are now included in $attrs and will no longer fallthrough when " + "inheritAttrs is false. If you are already using v-bind=\"$attrs\" on " + "component root it should render the same end result. " + "If you are binding $attrs to a non-root element and expecting " + "class/style to fallthrough on root, you will need to now manually bind " + "them on root via :class=\"$attrs.class\".";
  },
  link: "https://v3.vuejs.org/guide/migration/attrs-includes-class-style.html"
}), _defineProperty(_deprecationData, "OPTIONS_DATA_FN"
/* OPTIONS_DATA_FN */
, {
  message: "The \"data\" option can no longer be a plain object. " + "Always use a function.",
  link: "https://v3.vuejs.org/guide/migration/data-option.html"
}), _defineProperty(_deprecationData, "OPTIONS_DATA_MERGE"
/* OPTIONS_DATA_MERGE */
, {
  message: function message(key) {
    return "Detected conflicting key \"".concat(key, "\" when merging data option values. ") + "In Vue 3, data keys are merged shallowly and will override one another.";
  },
  link: "https://v3.vuejs.org/guide/migration/data-option.html#mixin-merge-behavior-change"
}), _defineProperty(_deprecationData, "OPTIONS_BEFORE_DESTROY"
/* OPTIONS_BEFORE_DESTROY */
, {
  message: "`beforeDestroy` has been renamed to `beforeUnmount`."
}), _defineProperty(_deprecationData, "OPTIONS_DESTROYED"
/* OPTIONS_DESTROYED */
, {
  message: "`destroyed` has been renamed to `unmounted`."
}), _defineProperty(_deprecationData, "WATCH_ARRAY"
/* WATCH_ARRAY */
, {
  message: "\"watch\" option or vm.$watch on an array value will no longer " + "trigger on array mutation unless the \"deep\" option is specified. " + "If current usage is intended, you can disable the compat behavior and " + "suppress this warning with:" + "\n\n  configureCompat({ ".concat("WATCH_ARRAY"
  /* WATCH_ARRAY */
  , ": false })\n"),
  link: "https://v3.vuejs.org/guide/migration/watch.html"
}), _defineProperty(_deprecationData, "PROPS_DEFAULT_THIS"
/* PROPS_DEFAULT_THIS */
, {
  message: function message(key) {
    return "props default value function no longer has access to \"this\". The compat " + "build only offers access to this.$options." + "(found in prop \"".concat(key, "\")");
  },
  link: "https://v3.vuejs.org/guide/migration/props-default-this.html"
}), _defineProperty(_deprecationData, "CUSTOM_DIR"
/* CUSTOM_DIR */
, {
  message: function message(legacyHook, newHook) {
    return "Custom directive hook \"".concat(legacyHook, "\" has been removed. ") + "Use \"".concat(newHook, "\" instead.");
  },
  link: "https://v3.vuejs.org/guide/migration/custom-directives.html"
}), _defineProperty(_deprecationData, "V_FOR_REF"
/* V_FOR_REF */
, {
  message: "Ref usage on v-for no longer creates array ref values in Vue 3. " + "Consider using function refs or refactor to avoid ref usage altogether.",
  link: "https://v3.vuejs.org/guide/migration/array-refs.html"
}), _defineProperty(_deprecationData, "V_ON_KEYCODE_MODIFIER"
/* V_ON_KEYCODE_MODIFIER */
, {
  message: "Using keyCode as v-on modifier is no longer supported. " + "Use kebab-case key name modifiers instead.",
  link: "https://v3.vuejs.org/guide/migration/keycode-modifiers.html"
}), _defineProperty(_deprecationData, "ATTR_FALSE_VALUE"
/* ATTR_FALSE_VALUE */
, {
  message: function message(name) {
    return "Attribute \"".concat(name, "\" with v-bind value `false` will render ") + "".concat(name, "=\"false\" instead of removing it in Vue 3. To remove the attribute, ") + "use `null` or `undefined` instead. If the usage is intended, " + "you can disable the compat behavior and suppress this warning with:" + "\n\n  configureCompat({ ".concat("ATTR_FALSE_VALUE"
    /* ATTR_FALSE_VALUE */
    , ": false })\n");
  },
  link: "https://v3.vuejs.org/guide/migration/attribute-coercion.html"
}), _defineProperty(_deprecationData, "ATTR_ENUMERATED_COERCION"
/* ATTR_ENUMERATED_COERCION */
, {
  message: function message(name, value, coerced) {
    return "Enumerated attribute \"".concat(name, "\" with v-bind value `").concat(value, "` will ") + "".concat(value === null ? "be removed" : "render the value as-is", " instead of coercing the value to \"").concat(coerced, "\" in Vue 3. ") + "Always use explicit \"true\" or \"false\" values for enumerated attributes. " + "If the usage is intended, " + "you can disable the compat behavior and suppress this warning with:" + "\n\n  configureCompat({ ".concat("ATTR_ENUMERATED_COERCION"
    /* ATTR_ENUMERATED_COERCION */
    , ": false })\n");
  },
  link: "https://v3.vuejs.org/guide/migration/attribute-coercion.html"
}), _defineProperty(_deprecationData, "TRANSITION_CLASSES"
/* TRANSITION_CLASSES */
, {
  message: "" // this feature cannot be runtime-detected

}), _defineProperty(_deprecationData, "TRANSITION_GROUP_ROOT"
/* TRANSITION_GROUP_ROOT */
, {
  message: "<TransitionGroup> no longer renders a root <span> element by " + "default if no \"tag\" prop is specified. If you do not rely on the span " + "for styling, you can disable the compat behavior and suppress this " + "warning with:" + "\n\n  configureCompat({ ".concat("TRANSITION_GROUP_ROOT"
  /* TRANSITION_GROUP_ROOT */
  , ": false })\n"),
  link: "https://v3.vuejs.org/guide/migration/transition-group.html"
}), _defineProperty(_deprecationData, "COMPONENT_ASYNC"
/* COMPONENT_ASYNC */
, {
  message: function message(comp) {
    var name = getComponentName(comp);
    return "Async component".concat(name ? " <".concat(name, ">") : "s", " should be explicitly created via `defineAsyncComponent()` ") + "in Vue 3. Plain functions will be treated as functional components in " + "non-compat build. If you have already migrated all async component " + "usage and intend to use plain functions for functional components, " + "you can disable the compat behavior and suppress this " + "warning with:" + "\n\n  configureCompat({ ".concat("COMPONENT_ASYNC"
    /* COMPONENT_ASYNC */
    , ": false })\n");
  },
  link: "https://v3.vuejs.org/guide/migration/async-components.html"
}), _defineProperty(_deprecationData, "COMPONENT_FUNCTIONAL"
/* COMPONENT_FUNCTIONAL */
, {
  message: function message(comp) {
    var name = getComponentName(comp);
    return "Functional component".concat(name ? " <".concat(name, ">") : "s", " should be defined as a plain function in Vue 3. The \"functional\" ") + "option has been removed. NOTE: Before migrating to use plain " + "functions for functional components, first make sure that all async " + "components usage have been migrated and its compat behavior has " + "been disabled.";
  },
  link: "https://v3.vuejs.org/guide/migration/functional-components.html"
}), _defineProperty(_deprecationData, "COMPONENT_V_MODEL"
/* COMPONENT_V_MODEL */
, {
  message: function message(comp) {
    var configMsg = "opt-in to " + "Vue 3 behavior on a per-component basis with `compatConfig: { ".concat("COMPONENT_V_MODEL"
    /* COMPONENT_V_MODEL */
    , ": false }`.");

    if (comp.props && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(comp.props) ? comp.props.includes('modelValue') : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(comp.props, 'modelValue')) {
      return "Component delcares \"modelValue\" prop, which is Vue 3 usage, but " + "is running under Vue 2 compat v-model behavior. You can ".concat(configMsg);
    }

    return "v-model usage on component has changed in Vue 3. Component that expects " + "to work with v-model should now use the \"modelValue\" prop and emit the " + "\"update:modelValue\" event. You can update the usage and then ".concat(configMsg);
  },
  link: "https://v3.vuejs.org/guide/migration/v-model.html"
}), _defineProperty(_deprecationData, "RENDER_FUNCTION"
/* RENDER_FUNCTION */
, {
  message: "Vue 3's render function API has changed. " + "You can opt-in to the new API with:" + "\n\n  configureCompat({ ".concat("RENDER_FUNCTION"
  /* RENDER_FUNCTION */
  , ": false })\n") + "\n  (This can also be done per-component via the \"compatConfig\" option.)",
  link: "https://v3.vuejs.org/guide/migration/render-function-api.html"
}), _defineProperty(_deprecationData, "FILTERS"
/* FILTERS */
, {
  message: "filters have been removed in Vue 3. " + "The \"|\" symbol will be treated as native JavaScript bitwise OR operator. " + "Use method calls or computed properties instead.",
  link: "https://v3.vuejs.org/guide/migration/filters.html"
}), _defineProperty(_deprecationData, "PRIVATE_APIS"
/* PRIVATE_APIS */
, {
  message: function message(name) {
    return "\"".concat(name, "\" is a Vue 2 private API that no longer exists in Vue 3. ") + "If you are seeing this warning only due to a dependency, you can " + "suppress this warning via { PRIVATE_APIS: 'supress-warning' }.";
  }
}), _deprecationData);
var instanceWarned = Object.create(null);
var warnCount = Object.create(null);

function warnDeprecation(key, instance) {
  if (false) {}

  instance = instance || getCurrentInstance(); // check user config

  var config = getCompatConfigForKey(key, instance);

  if (config === 'suppress-warning') {
    return;
  }

  for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
    args[_key2 - 2] = arguments[_key2];
  }

  var dupKey = key + args.join('');
  var compId = instance && formatComponentName(instance, instance.type);

  if (compId === 'Anonymous' && instance) {
    compId = instance.uid;
  } // skip if the same warning is emitted for the same component type


  var componentDupKey = dupKey + compId;

  if (componentDupKey in instanceWarned) {
    return;
  }

  instanceWarned[componentDupKey] = true; // same warning, but different component. skip the long message and just
  // log the key and count.

  if (dupKey in warnCount) {
    warn("(deprecation ".concat(key, ") (").concat(++warnCount[dupKey] + 1, ")"));
    return;
  }

  warnCount[dupKey] = 0;
  var _deprecationData$key = deprecationData[key],
      message = _deprecationData$key.message,
      link = _deprecationData$key.link;
  warn("(deprecation ".concat(key, ") ").concat(typeof message === 'function' ? message.apply(void 0, args) : message).concat(link ? "\n  Details: ".concat(link) : ""));

  if (!isCompatEnabled(key, instance, true)) {
    console.error("^ The above deprecation's compat behavior is disabled and will likely " + "lead to runtime errors.");
  }
}

var globalCompatConfig = {
  MODE: 2
};

function getCompatConfigForKey(key, instance) {
  var instanceConfig = instance && instance.type.compatConfig;

  if (instanceConfig && key in instanceConfig) {
    return instanceConfig[key];
  }

  return globalCompatConfig[key];
}

function isCompatEnabled(key, instance) {
  var enableForBuiltIn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  // skip compat for built-in components
  if (!enableForBuiltIn && instance && instance.type.__isBuiltIn) {
    return false;
  }

  var rawMode = getCompatConfigForKey('MODE', instance) || 2;
  var val = getCompatConfigForKey(key, instance);
  var mode = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(rawMode) ? rawMode(instance && instance.type) : rawMode;

  if (mode === 2) {
    return val !== false;
  } else {
    return val === true || val === 'suppress-warning';
  }
}

function emit(instance, event) {
  var props = instance.vnode.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;

  for (var _len3 = arguments.length, rawArgs = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
    rawArgs[_key3 - 2] = arguments[_key3];
  }

  if (true) {
    var emitsOptions = instance.emitsOptions,
        _instance$propsOption = _slicedToArray(instance.propsOptions, 1),
        propsOptions = _instance$propsOption[0];

    if (emitsOptions) {
      if (!(event in emitsOptions) && !false) {
        if (!propsOptions || !((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(event) in propsOptions)) {
          warn("Component emitted event \"".concat(event, "\" but it is neither declared in ") + "the emits option nor as an \"".concat((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(event), "\" prop."));
        }
      } else {
        var validator = emitsOptions[event];

        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(validator)) {
          var isValid = validator.apply(void 0, rawArgs);

          if (!isValid) {
            warn("Invalid event arguments: event validation failed for event \"".concat(event, "\"."));
          }
        }
      }
    }
  }

  var args = rawArgs;
  var isModelListener = event.startsWith('update:'); // for v-model update:xxx events, apply modifiers on args

  var modelArg = isModelListener && event.slice(7);

  if (modelArg && modelArg in props) {
    var modifiersKey = "".concat(modelArg === 'modelValue' ? 'model' : modelArg, "Modifiers");

    var _ref3 = props[modifiersKey] || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
        number = _ref3.number,
        trim = _ref3.trim;

    if (trim) {
      args = rawArgs.map(function (a) {
        return a.trim();
      });
    } else if (number) {
      args = rawArgs.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber);
    }
  }

  if (true) {
    devtoolsComponentEmit(instance, event, args);
  }

  if (true) {
    var lowerCaseEvent = event.toLowerCase();

    if (lowerCaseEvent !== event && props[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(lowerCaseEvent)]) {
      warn("Event \"".concat(lowerCaseEvent, "\" is emitted in component ") + "".concat(formatComponentName(instance, instance.type), " but the handler is registered for \"").concat(event, "\". ") + "Note that HTML attributes are case-insensitive and you cannot use " + "v-on to listen to camelCase events when using in-DOM templates. " + "You should probably use \"".concat((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event), "\" instead of \"").concat(event, "\"."));
    }
  }

  var handlerName;
  var handler = props[handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(event)] || // also try camelCase event handler (#2249)
  props[handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(event))]; // for v-model update:xxx events, also trigger kebab-case equivalent
  // for props passed via kebab-case

  if (!handler && isModelListener) {
    handler = props[handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event))];
  }

  if (handler) {
    callWithAsyncErrorHandling(handler, instance, 6
    /* COMPONENT_EVENT_HANDLER */
    , args);
  }

  var onceHandler = props[handlerName + "Once"];

  if (onceHandler) {
    if (!instance.emitted) {
      (instance.emitted = {})[handlerName] = true;
    } else if (instance.emitted[handlerName]) {
      return;
    }

    callWithAsyncErrorHandling(onceHandler, instance, 6
    /* COMPONENT_EVENT_HANDLER */
    , args);
  }
}

function normalizeEmitsOptions(comp, appContext) {
  var asMixin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var cache = appContext.emitsCache;
  var cached = cache.get(comp);

  if (cached !== undefined) {
    return cached;
  }

  var raw = comp.emits;
  var normalized = {}; // apply mixin/extends props

  var hasExtends = false;

  if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {
    var extendEmits = function extendEmits(raw) {
      var normalizedFromExtend = normalizeEmitsOptions(raw, appContext, true);

      if (normalizedFromExtend) {
        hasExtends = true;
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, normalizedFromExtend);
      }
    };

    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }

    if (comp.extends) {
      extendEmits(comp.extends);
    }

    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }

  if (!raw && !hasExtends) {
    cache.set(comp, null);
    return null;
  }

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
    raw.forEach(function (key) {
      return normalized[key] = null;
    });
  } else {
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, raw);
  }

  cache.set(comp, normalized);
  return normalized;
} // Check if an incoming prop key is a declared emit event listener.
// e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are
// both considered matched listeners.


function isEmitListener(options, key) {
  if (!options || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
    return false;
  }

  key = key.slice(2).replace(/Once$/, '');
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, key[0].toLowerCase() + key.slice(1)) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, key);
}
/**
 * mark the current rendering instance for asset resolution (e.g.
 * resolveComponent, resolveDirective) during render
 */


var currentRenderingInstance = null;
var currentScopeId = null;
/**
 * Note: rendering calls maybe nested. The function returns the parent rendering
 * instance if present, which should be restored after the render is done:
 *
 * ```js
 * const prev = setCurrentRenderingInstance(i)
 * // ...render
 * setCurrentRenderingInstance(prev)
 * ```
 */

function setCurrentRenderingInstance(instance) {
  var prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
/**
 * Set scope id when creating hoisted vnodes.
 * @private compiler helper
 */


function pushScopeId(id) {
  currentScopeId = id;
}
/**
 * Technically we no longer need this after 3.0.8 but we need to keep the same
 * API for backwards compat w/ code generated by compilers.
 * @private
 */


function popScopeId() {
  currentScopeId = null;
}
/**
 * Only for backwards compat
 * @private
 */


var withScopeId = function withScopeId(_id) {
  return withCtx;
};
/**
 * Wrap a slot function to memoize current rendering instance
 * @private compiler helper
 */


function withCtx(fn) // false only
{
  var ctx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : currentRenderingInstance;
  var isNonScopedSlot = arguments.length > 2 ? arguments[2] : undefined;
  if (!ctx) return fn; // already normalized

  if (fn._n) {
    return fn;
  }

  var renderFnWithContext = function renderFnWithContext() {
    // If a user calls a compiled slot inside a template expression (#1745), it
    // can mess up block tracking, so by default we disable block tracking and
    // force bail out when invoking a compiled slot (indicated by the ._d flag).
    // This isn't necessary if rendering a compiled `<slot>`, so we flip the
    // ._d flag off when invoking the wrapped fn inside `renderSlot`.
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }

    var prevInstance = setCurrentRenderingInstance(ctx);
    var res = fn.apply(void 0, arguments);
    setCurrentRenderingInstance(prevInstance);

    if (renderFnWithContext._d) {
      setBlockTracking(1);
    }

    if (true) {
      devtoolsComponentUpdated(ctx);
    }

    return res;
  }; // mark normalized to avoid duplicated wrapping


  renderFnWithContext._n = true; // mark this as compiled by default
  // this is used in vnode.ts -> normalizeChildren() to set the slot
  // rendering flag.

  renderFnWithContext._c = true; // disable block tracking by default

  renderFnWithContext._d = true;
  return renderFnWithContext;
}
/**
 * dev only flag to track whether $attrs was used during render.
 * If $attrs was used during render then the warning for failed attrs
 * fallthrough can be suppressed.
 */


var accessedAttrs = false;

function markAttrsAccessed() {
  accessedAttrs = true;
}

function renderComponentRoot(instance) {
  var Component = instance.type,
      vnode = instance.vnode,
      proxy = instance.proxy,
      withProxy = instance.withProxy,
      props = instance.props,
      _instance$propsOption2 = _slicedToArray(instance.propsOptions, 1),
      propsOptions = _instance$propsOption2[0],
      slots = instance.slots,
      attrs = instance.attrs,
      emit = instance.emit,
      render = instance.render,
      renderCache = instance.renderCache,
      data = instance.data,
      setupState = instance.setupState,
      ctx = instance.ctx,
      inheritAttrs = instance.inheritAttrs;

  var result;
  var prev = setCurrentRenderingInstance(instance);

  if (true) {
    accessedAttrs = false;
  }

  try {
    var fallthroughAttrs;

    if (vnode.shapeFlag & 4
    /* STATEFUL_COMPONENT */
    ) {
        // withProxy is a proxy with a different `has` trap only for
        // runtime-compiled render functions using `with` block.
        var proxyToUse = withProxy || proxy;
        result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));
        fallthroughAttrs = attrs;
      } else {
      // functional
      var _render = Component; // in dev, mark attrs accessed if optional props (attrs === props)

      if ( true && attrs === props) {
        markAttrsAccessed();
      }

      result = normalizeVNode(_render.length > 1 ? _render(props,  true ? {
        get attrs() {
          markAttrsAccessed();
          return attrs;
        },

        slots: slots,
        emit: emit
      } : 0) : _render(props, null
      /* we know it doesn't need it */
      ));
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    } // attr merging
    // in dev mode, comments are preserved, and it's possible for a template
    // to have comments along side the root element which makes it a fragment


    var root = result;
    var setRoot = undefined;

    if ( true && result.patchFlag > 0 && result.patchFlag & 2048
    /* DEV_ROOT_FRAGMENT */
    ) {
        ;

        var _getChildRoot = getChildRoot(result);

        var _getChildRoot2 = _slicedToArray(_getChildRoot, 2);

        root = _getChildRoot2[0];
        setRoot = _getChildRoot2[1];
      }

    if (fallthroughAttrs && inheritAttrs !== false) {
      var keys = Object.keys(fallthroughAttrs);
      var _root = root,
          shapeFlag = _root.shapeFlag;

      if (keys.length) {
        if (shapeFlag & 1
        /* ELEMENT */
        || shapeFlag & 6
        /* COMPONENT */
        ) {
            if (propsOptions && keys.some(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)) {
              // If a v-model listener (onUpdate:xxx) has a corresponding declared
              // prop, it indicates this component expects to handle v-model and
              // it should not fallthrough.
              // related: #1543, #1643, #1989
              fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
            }

            root = cloneVNode(root, fallthroughAttrs);
          } else if ( true && !accessedAttrs && root.type !== Comment$1) {
          var allAttrs = Object.keys(attrs);
          var eventAttrs = [];
          var extraAttrs = [];

          for (var i = 0, l = allAttrs.length; i < l; i++) {
            var key = allAttrs[i];

            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
              // ignore v-model handlers when they fail to fallthrough
              if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key)) {
                // remove `on`, lowercase first letter to reflect event casing
                // accurately
                eventAttrs.push(key[2].toLowerCase() + key.slice(3));
              }
            } else {
              extraAttrs.push(key);
            }
          }

          if (extraAttrs.length) {
            warn("Extraneous non-props attributes (" + "".concat(extraAttrs.join(', '), ") ") + "were passed to component but could not be automatically inherited " + "because component renders fragment or text root nodes.");
          }

          if (eventAttrs.length) {
            warn("Extraneous non-emits event listeners (" + "".concat(eventAttrs.join(', '), ") ") + "were passed to component but could not be automatically inherited " + "because component renders fragment or text root nodes. " + "If the listener is intended to be a component custom event listener only, " + "declare it using the \"emits\" option.");
          }
        }
      }
    }

    if (false) {} // inherit directives

    if (vnode.dirs) {
      if ( true && !isElementRoot(root)) {
        warn("Runtime directive used on component with non-element root node. " + "The directives will not function as intended.");
      }

      root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
    } // inherit transition data


    if (vnode.transition) {
      if ( true && !isElementRoot(root)) {
        warn("Component inside <Transition> renders non-element root node " + "that cannot be animated.");
      }

      root.transition = vnode.transition;
    }

    if ( true && setRoot) {
      setRoot(root);
    } else {
      result = root;
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1
    /* RENDER_FUNCTION */
    );
    result = createVNode(Comment$1);
  }

  setCurrentRenderingInstance(prev);
  return result;
}
/**
 * dev only
 * In dev mode, template root level comments are rendered, which turns the
 * template into a fragment root, but we need to locate the single element
 * root for attrs and scope id processing.
 */


var getChildRoot = function getChildRoot(vnode) {
  var rawChildren = vnode.children;
  var dynamicChildren = vnode.dynamicChildren;
  var childRoot = filterSingleRoot(rawChildren);

  if (!childRoot) {
    return [vnode, undefined];
  }

  var index = rawChildren.indexOf(childRoot);
  var dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;

  var setRoot = function setRoot(updatedRoot) {
    rawChildren[index] = updatedRoot;

    if (dynamicChildren) {
      if (dynamicIndex > -1) {
        dynamicChildren[dynamicIndex] = updatedRoot;
      } else if (updatedRoot.patchFlag > 0) {
        vnode.dynamicChildren = [].concat(_toConsumableArray(dynamicChildren), [updatedRoot]);
      }
    }
  };

  return [normalizeVNode(childRoot), setRoot];
};

function filterSingleRoot(children) {
  var singleRoot;

  for (var i = 0; i < children.length; i++) {
    var child = children[i];

    if (isVNode(child)) {
      // ignore user comment
      if (child.type !== Comment$1 || child.children === 'v-if') {
        if (singleRoot) {
          // has more than 1 non-comment child, return now
          return;
        } else {
          singleRoot = child;
        }
      }
    } else {
      return;
    }
  }

  return singleRoot;
}

var getFunctionalFallthrough = function getFunctionalFallthrough(attrs) {
  var res;

  for (var key in attrs) {
    if (key === 'class' || key === 'style' || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }

  return res;
};

var filterModelListeners = function filterModelListeners(attrs, props) {
  var res = {};

  for (var key in attrs) {
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }

  return res;
};

var isElementRoot = function isElementRoot(vnode) {
  return vnode.shapeFlag & 6
  /* COMPONENT */
  || vnode.shapeFlag & 1
  /* ELEMENT */
  || vnode.type === Comment$1 // potential v-if branch switch
  ;
};

function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  var prevProps = prevVNode.props,
      prevChildren = prevVNode.children,
      component = prevVNode.component;
  var nextProps = nextVNode.props,
      nextChildren = nextVNode.children,
      patchFlag = nextVNode.patchFlag;
  var emits = component.emitsOptions; // Parent component's render function was hot-updated. Since this may have
  // caused the child component's slots content to have changed, we need to
  // force the child to update as well.

  if ( true && (prevChildren || nextChildren) && isHmrUpdating) {
    return true;
  } // force child update for runtime directive or transition on component vnode.


  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }

  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024
    /* DYNAMIC_SLOTS */
    ) {
        // slot content that references values that might have changed,
        // e.g. in a v-for
        return true;
      }

    if (patchFlag & 16
    /* FULL_PROPS */
    ) {
        if (!prevProps) {
          return !!nextProps;
        } // presence of this flag indicates props are always non-null


        return hasPropsChanged(prevProps, nextProps, emits);
      } else if (patchFlag & 8
    /* PROPS */
    ) {
        var dynamicProps = nextVNode.dynamicProps;

        for (var i = 0; i < dynamicProps.length; i++) {
          var key = dynamicProps[i];

          if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
            return true;
          }
        }
      }
  } else {
    // this path is only taken by manually written render functions
    // so presence of any children leads to a forced update
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }

    if (prevProps === nextProps) {
      return false;
    }

    if (!prevProps) {
      return !!nextProps;
    }

    if (!nextProps) {
      return true;
    }

    return hasPropsChanged(prevProps, nextProps, emits);
  }

  return false;
}

function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  var nextKeys = Object.keys(nextProps);

  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }

  for (var i = 0; i < nextKeys.length; i++) {
    var key = nextKeys[i];

    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }

  return false;
}

function updateHOCHostEl(_ref4, el // HostNode
) {
  var vnode = _ref4.vnode,
      parent = _ref4.parent;

  while (parent && parent.subTree === vnode) {
    (vnode = parent.vnode).el = el;
    parent = parent.parent;
  }
}

var isSuspense = function isSuspense(type) {
  return type.__isSuspense;
}; // Suspense exposes a component-like API, and is treated like a component
// in the compiler, but internally it's a special built-in type that hooks
// directly into the renderer.


var SuspenseImpl = {
  name: 'Suspense',
  // In order to make Suspense tree-shakable, we need to avoid importing it
  // directly in the renderer. The renderer checks for the __isSuspense flag
  // on a vnode's type and calls the `process` method, passing in renderer
  // internals.
  __isSuspense: true,
  process: function process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, // platform-specific impl passed from renderer
  rendererInternals) {
    if (n1 == null) {
      mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals);
    } else {
      patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, rendererInternals);
    }
  },
  hydrate: hydrateSuspense,
  create: createSuspenseBoundary,
  normalize: normalizeSuspenseChildren
}; // Force-casted public typing for h and TSX props inference

var Suspense = SuspenseImpl;

function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
  var patch = rendererInternals.p,
      createElement = rendererInternals.o.createElement;
  var hiddenContainer = createElement('div');
  var suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals); // start mounting the content subtree in an off-dom container

  patch(null, suspense.pendingBranch = vnode.ssContent, hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds); // now check if we have encountered any async deps

  if (suspense.deps > 0) {
    // has async
    // mount the fallback tree
    patch(null, vnode.ssFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
    isSVG, slotScopeIds);
    setActiveBranch(suspense, vnode.ssFallback);
  } else {
    // Suspense has no async deps. Just resolve.
    suspense.resolve();
  }
}

function patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, _ref5) {
  var patch = _ref5.p,
      unmount = _ref5.um,
      createElement = _ref5.o.createElement;
  var suspense = n2.suspense = n1.suspense;
  suspense.vnode = n2;
  n2.el = n1.el;
  var newBranch = n2.ssContent;
  var newFallback = n2.ssFallback;
  var activeBranch = suspense.activeBranch,
      pendingBranch = suspense.pendingBranch,
      isInFallback = suspense.isInFallback,
      isHydrating = suspense.isHydrating;

  if (pendingBranch) {
    suspense.pendingBranch = newBranch;

    if (isSameVNodeType(newBranch, pendingBranch)) {
      // same root type but content may have changed.
      patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);

      if (suspense.deps <= 0) {
        suspense.resolve();
      } else if (isInFallback) {
        patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
        isSVG, slotScopeIds, optimized);
        setActiveBranch(suspense, newFallback);
      }
    } else {
      // toggled before pending tree is resolved
      suspense.pendingId++;

      if (isHydrating) {
        // if toggled before hydration is finished, the current DOM tree is
        // no longer valid. set it as the active branch so it will be unmounted
        // when resolved
        suspense.isHydrating = false;
        suspense.activeBranch = pendingBranch;
      } else {
        unmount(pendingBranch, parentComponent, suspense);
      } // increment pending ID. this is used to invalidate async callbacks
      // reset suspense state


      suspense.deps = 0; // discard effects from pending branch

      suspense.effects.length = 0; // discard previous container

      suspense.hiddenContainer = createElement('div');

      if (isInFallback) {
        // already in fallback state
        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);

        if (suspense.deps <= 0) {
          suspense.resolve();
        } else {
          patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
          isSVG, slotScopeIds, optimized);
          setActiveBranch(suspense, newFallback);
        }
      } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
        // toggled "back" to current active branch
        patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized); // force resolve

        suspense.resolve(true);
      } else {
        // switched to a 3rd branch
        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);

        if (suspense.deps <= 0) {
          suspense.resolve();
        }
      }
    }
  } else {
    if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
      // root did not change, just normal patch
      patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
      setActiveBranch(suspense, newBranch);
    } else {
      // root node toggled
      // invoke @pending event
      var onPending = n2.props && n2.props.onPending;

      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(onPending)) {
        onPending();
      } // mount pending branch in off-dom container


      suspense.pendingBranch = newBranch;
      suspense.pendingId++;
      patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);

      if (suspense.deps <= 0) {
        // incoming branch has no async deps, resolve now.
        suspense.resolve();
      } else {
        var timeout = suspense.timeout,
            pendingId = suspense.pendingId;

        if (timeout > 0) {
          setTimeout(function () {
            if (suspense.pendingId === pendingId) {
              suspense.fallback(newFallback);
            }
          }, timeout);
        } else if (timeout === 0) {
          suspense.fallback(newFallback);
        }
      }
    }
  }
}

var hasWarned = false;

function createSuspenseBoundary(vnode, parent, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals) {
  var isHydrating = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : false;

  /* istanbul ignore if */
  if ( true && !hasWarned) {
    hasWarned = true; // @ts-ignore `console.info` cannot be null error

    console[console.info ? 'info' : 'log']("<Suspense> is an experimental feature and its API will likely change.");
  }

  var patch = rendererInternals.p,
      _move = rendererInternals.m,
      _unmount2 = rendererInternals.um,
      _next = rendererInternals.n,
      _rendererInternals$o = rendererInternals.o,
      parentNode = _rendererInternals$o.parentNode,
      remove = _rendererInternals$o.remove;
  var timeout = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(vnode.props && vnode.props.timeout);
  var suspense = {
    vnode: vnode,
    parent: parent,
    parentComponent: parentComponent,
    isSVG: isSVG,
    container: container,
    hiddenContainer: hiddenContainer,
    anchor: anchor,
    deps: 0,
    pendingId: 0,
    timeout: typeof timeout === 'number' ? timeout : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: true,
    isHydrating: isHydrating,
    isUnmounted: false,
    effects: [],
    resolve: function resolve() {
      var resume = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (true) {
        if (!resume && !suspense.pendingBranch) {
          throw new Error("suspense.resolve() is called without a pending branch.");
        }

        if (suspense.isUnmounted) {
          throw new Error("suspense.resolve() is called on an already unmounted suspense boundary.");
        }
      }

      var vnode = suspense.vnode,
          activeBranch = suspense.activeBranch,
          pendingBranch = suspense.pendingBranch,
          pendingId = suspense.pendingId,
          effects = suspense.effects,
          parentComponent = suspense.parentComponent,
          container = suspense.container;

      if (suspense.isHydrating) {
        suspense.isHydrating = false;
      } else if (!resume) {
        var delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === 'out-in';

        if (delayEnter) {
          activeBranch.transition.afterLeave = function () {
            if (pendingId === suspense.pendingId) {
              _move(pendingBranch, container, _anchor, 0
              /* ENTER */
              );
            }
          };
        } // this is initial anchor on mount


        var _anchor = suspense.anchor; // unmount current active tree

        if (activeBranch) {
          // if the fallback tree was mounted, it may have been moved
          // as part of a parent suspense. get the latest anchor for insertion
          _anchor = _next(activeBranch);

          _unmount2(activeBranch, parentComponent, suspense, true);
        }

        if (!delayEnter) {
          // move content from off-dom container to actual container
          _move(pendingBranch, container, _anchor, 0
          /* ENTER */
          );
        }
      }

      setActiveBranch(suspense, pendingBranch);
      suspense.pendingBranch = null;
      suspense.isInFallback = false; // flush buffered effects
      // check if there is a pending parent suspense

      var parent = suspense.parent;
      var hasUnresolvedAncestor = false;

      while (parent) {
        if (parent.pendingBranch) {
          var _parent$effects;

          // found a pending parent suspense, merge buffered post jobs
          // into that parent
          (_parent$effects = parent.effects).push.apply(_parent$effects, _toConsumableArray(effects));

          hasUnresolvedAncestor = true;
          break;
        }

        parent = parent.parent;
      } // no pending parent suspense, flush all jobs


      if (!hasUnresolvedAncestor) {
        queuePostFlushCb(effects);
      }

      suspense.effects = []; // invoke @resolve event

      var onResolve = vnode.props && vnode.props.onResolve;

      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(onResolve)) {
        onResolve();
      }
    },
    fallback: function fallback(fallbackVNode) {
      if (!suspense.pendingBranch) {
        return;
      }

      var vnode = suspense.vnode,
          activeBranch = suspense.activeBranch,
          parentComponent = suspense.parentComponent,
          container = suspense.container,
          isSVG = suspense.isSVG; // invoke @fallback event

      var onFallback = vnode.props && vnode.props.onFallback;

      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(onFallback)) {
        onFallback();
      }

      var anchor = _next(activeBranch);

      var mountFallback = function mountFallback() {
        if (!suspense.isInFallback) {
          return;
        } // mount the fallback tree


        patch(null, fallbackVNode, container, anchor, parentComponent, null, // fallback tree will not have suspense context
        isSVG, slotScopeIds, optimized);
        setActiveBranch(suspense, fallbackVNode);
      };

      var delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === 'out-in';

      if (delayEnter) {
        activeBranch.transition.afterLeave = mountFallback;
      } // unmount current active branch


      _unmount2(activeBranch, parentComponent, null, // no suspense so unmount hooks fire now
      true // shouldRemove
      );

      suspense.isInFallback = true;

      if (!delayEnter) {
        mountFallback();
      }
    },
    move: function move(container, anchor, type) {
      suspense.activeBranch && _move(suspense.activeBranch, container, anchor, type);
      suspense.container = container;
    },
    next: function next() {
      return suspense.activeBranch && _next(suspense.activeBranch);
    },
    registerDep: function registerDep(instance, setupRenderEffect) {
      var isInPendingSuspense = !!suspense.pendingBranch;

      if (isInPendingSuspense) {
        suspense.deps++;
      }

      var hydratedEl = instance.vnode.el;
      instance.asyncDep.catch(function (err) {
        handleError(err, instance, 0
        /* SETUP_FUNCTION */
        );
      }).then(function (asyncSetupResult) {
        // retry when the setup() promise resolves.
        // component may have been unmounted before resolve.
        if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
          return;
        } // retry from this component


        instance.asyncResolved = true;
        var vnode = instance.vnode;

        if (true) {
          pushWarningContext(vnode);
        }

        handleSetupResult(instance, asyncSetupResult, false);

        if (hydratedEl) {
          // vnode may have been replaced if an update happened before the
          // async dep is resolved.
          vnode.el = hydratedEl;
        }

        var placeholder = !hydratedEl && instance.subTree.el;
        setupRenderEffect(instance, vnode, // component may have been moved before resolve.
        // if this is not a hydration, instance.subTree will be the comment
        // placeholder.
        parentNode(hydratedEl || instance.subTree.el), // anchor will not be used if this is hydration, so only need to
        // consider the comment placeholder case.
        hydratedEl ? null : _next(instance.subTree), suspense, isSVG, optimized);

        if (placeholder) {
          remove(placeholder);
        }

        updateHOCHostEl(instance, vnode.el);

        if (true) {
          popWarningContext();
        } // only decrease deps count if suspense is not already resolved


        if (isInPendingSuspense && --suspense.deps === 0) {
          suspense.resolve();
        }
      });
    },
    unmount: function unmount(parentSuspense, doRemove) {
      suspense.isUnmounted = true;

      if (suspense.activeBranch) {
        _unmount2(suspense.activeBranch, parentComponent, parentSuspense, doRemove);
      }

      if (suspense.pendingBranch) {
        _unmount2(suspense.pendingBranch, parentComponent, parentSuspense, doRemove);
      }
    }
  };
  return suspense;
}

function hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {
  /* eslint-disable no-restricted-globals */
  var suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement('div'), null, isSVG, slotScopeIds, optimized, rendererInternals, true
  /* hydrating */
  ); // there are two possible scenarios for server-rendered suspense:
  // - success: ssr content should be fully resolved
  // - failure: ssr content should be the fallback branch.
  // however, on the client we don't really know if it has failed or not
  // attempt to hydrate the DOM assuming it has succeeded, but we still
  // need to construct a suspense boundary first

  var result = hydrateNode(node, suspense.pendingBranch = vnode.ssContent, parentComponent, suspense, slotScopeIds, optimized);

  if (suspense.deps === 0) {
    suspense.resolve();
  }

  return result;
  /* eslint-enable no-restricted-globals */
}

function normalizeSuspenseChildren(vnode) {
  var shapeFlag = vnode.shapeFlag,
      children = vnode.children;
  var isSlotChildren = shapeFlag & 32
  /* SLOTS_CHILDREN */
  ;
  vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);
  vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
}

function normalizeSuspenseSlot(s) {
  var block;

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(s)) {
    var isCompiledSlot = s._c;

    if (isCompiledSlot) {
      // disableTracking: false
      // allow block tracking for compiled slots
      // (see ./componentRenderContext.ts)
      s._d = false;
      openBlock();
    }

    s = s();

    if (isCompiledSlot) {
      s._d = true;
      block = currentBlock;
      closeBlock();
    }
  }

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(s)) {
    var singleChild = filterSingleRoot(s);

    if ( true && !singleChild) {
      warn("<Suspense> slots expect a single root node.");
    }

    s = singleChild;
  }

  s = normalizeVNode(s);

  if (block) {
    s.dynamicChildren = block.filter(function (c) {
      return c !== s;
    });
  }

  return s;
}

function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(fn)) {
      var _suspense$effects;

      (_suspense$effects = suspense.effects).push.apply(_suspense$effects, _toConsumableArray(fn));
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}

function setActiveBranch(suspense, branch) {
  suspense.activeBranch = branch;
  var vnode = suspense.vnode,
      parentComponent = suspense.parentComponent;
  var el = vnode.el = branch.el; // in case suspense is the root node of a component,
  // recursively update the HOC el

  if (parentComponent && parentComponent.subTree === vnode) {
    parentComponent.vnode.el = el;
    updateHOCHostEl(parentComponent, el);
  }
}

function provide(key, value) {
  if (!currentInstance) {
    if (true) {
      warn("provide() can only be used inside setup().");
    }
  } else {
    var provides = currentInstance.provides; // by default an instance inherits its parent's provides object
    // but when it needs to provide values of its own, it creates its
    // own provides object using parent provides object as prototype.
    // this way in `inject` we can simply look up injections from direct
    // parent and let the prototype chain do the work.

    var parentProvides = currentInstance.parent && currentInstance.parent.provides;

    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    } // TS doesn't allow symbol as index type


    provides[key] = value;
  }
}

function inject(key, defaultValue) {
  var treatDefaultAsFactory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  // fallback to `currentRenderingInstance` so that this can be called in
  // a functional component
  var instance = currentInstance || currentRenderingInstance;

  if (instance) {
    // #2400
    // to support `app.use` plugins,
    // fallback to appContext's `provides` if the intance is at root
    var provides = instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides;

    if (provides && key in provides) {
      // TS doesn't allow symbol as index type
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(defaultValue) ? defaultValue() : defaultValue;
    } else if (true) {
      warn("injection \"".concat(String(key), "\" not found."));
    }
  } else if (true) {
    warn("inject() can only be used inside setup() or functional components.");
  }
} // Simple effect.


function watchEffect(effect, options) {
  return doWatch(effect, null, options);
} // initial value for watchers to trigger on undefined initial values


var INITIAL_WATCHER_VALUE = {}; // implementation

function watch(source, cb, options) {
  if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(cb)) {
    warn("`watch(fn, options?)` signature has been moved to a separate API. " + "Use `watchEffect(fn, options?)` instead. `watch` now only " + "supports `watch(source, cb, options?) signature.");
  }

  return doWatch(source, cb, options);
}

function doWatch(source, cb) {
  var _ref6 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
      immediate = _ref6.immediate,
      deep = _ref6.deep,
      flush = _ref6.flush,
      onTrack = _ref6.onTrack,
      onTrigger = _ref6.onTrigger;

  var instance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : currentInstance;

  if ( true && !cb) {
    if (immediate !== undefined) {
      warn("watch() \"immediate\" option is only respected when using the " + "watch(source, callback, options?) signature.");
    }

    if (deep !== undefined) {
      warn("watch() \"deep\" option is only respected when using the " + "watch(source, callback, options?) signature.");
    }
  }

  var warnInvalidSource = function warnInvalidSource(s) {
    warn("Invalid watch source: ", s, "A watch source can only be a getter/effect function, a ref, " + "a reactive object, or an array of these types.");
  };

  var getter;
  var forceTrigger = false;
  var isMultiSource = false;

  if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(source)) {
    getter = function getter() {
      return source.value;
    };

    forceTrigger = !!source._shallow;
  } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(source)) {
    getter = function getter() {
      return source;
    };

    deep = true;
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(source)) {
    isMultiSource = true;
    forceTrigger = source.some(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive);

    getter = function getter() {
      return source.map(function (s) {
        if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(s)) {
          return s.value;
        } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(s)) {
          return traverse(s);
        } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(s)) {
          return callWithErrorHandling(s, instance, 2
          /* WATCH_GETTER */
          );
        } else {
           true && warnInvalidSource(s);
        }
      });
    };
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(source)) {
    if (cb) {
      // getter with cb
      getter = function getter() {
        return callWithErrorHandling(source, instance, 2
        /* WATCH_GETTER */
        );
      };
    } else {
      // no cb -> simple effect
      getter = function getter() {
        if (instance && instance.isUnmounted) {
          return;
        }

        if (cleanup) {
          cleanup();
        }

        return callWithAsyncErrorHandling(source, instance, 3
        /* WATCH_CALLBACK */
        , [onInvalidate]);
      };
    }
  } else {
    getter = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
     true && warnInvalidSource(source);
  }

  if (cb && deep) {
    var baseGetter = getter;

    getter = function getter() {
      return traverse(baseGetter());
    };
  }

  var cleanup;

  var onInvalidate = function onInvalidate(fn) {
    cleanup = runner.options.onStop = function () {
      callWithErrorHandling(fn, instance, 4
      /* WATCH_CLEANUP */
      );
    };
  };

  var oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;

  var job = function job() {
    if (!runner.active) {
      return;
    }

    if (cb) {
      // watch(source, cb)
      var newValue = runner();

      if (deep || forceTrigger || (isMultiSource ? newValue.some(function (v, i) {
        return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(v, oldValue[i]);
      }) : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(newValue, oldValue)) || false) {
        // cleanup before running cb again
        if (cleanup) {
          cleanup();
        }

        callWithAsyncErrorHandling(cb, instance, 3
        /* WATCH_CALLBACK */
        , [newValue, // pass undefined as the old value when it's changed for the first time
        oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue, onInvalidate]);
        oldValue = newValue;
      }
    } else {
      // watchEffect
      runner();
    }
  }; // important: mark the job as a watcher callback so that scheduler knows
  // it is allowed to self-trigger (#1727)


  job.allowRecurse = !!cb;
  var scheduler;

  if (flush === 'sync') {
    scheduler = job; // the scheduler function gets called directly
  } else if (flush === 'post') {
    scheduler = function scheduler() {
      return queuePostRenderEffect(job, instance && instance.suspense);
    };
  } else {
    // default: 'pre'
    scheduler = function scheduler() {
      if (!instance || instance.isMounted) {
        queuePreFlushCb(job);
      } else {
        // with 'pre' option, the first call must happen before
        // the component is mounted so it is called synchronously.
        job();
      }
    };
  }

  var runner = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.effect)(getter, {
    lazy: true,
    onTrack: onTrack,
    onTrigger: onTrigger,
    scheduler: scheduler
  });
  recordInstanceBoundEffect(runner, instance); // initial run

  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = runner();
    }
  } else if (flush === 'post') {
    queuePostRenderEffect(runner, instance && instance.suspense);
  } else {
    runner();
  }

  return function () {
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.stop)(runner);

    if (instance) {
      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(instance.effects, runner);
    }
  };
} // this.$watch


function instanceWatch(source, value, options) {
  var publicThis = this.proxy;
  var getter = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(source) ? source.includes('.') ? createPathGetter(publicThis, source) : function () {
    return publicThis[source];
  } : source.bind(publicThis, publicThis);
  var cb;

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }

  return doWatch(getter, cb.bind(publicThis), options, this);
}

function createPathGetter(ctx, path) {
  var segments = path.split('.');
  return function () {
    var cur = ctx;

    for (var i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }

    return cur;
  };
}

function traverse(value) {
  var seen = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();

  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(value) || seen.has(value) || value["__v_skip"
  /* SKIP */
  ]) {
    return value;
  }

  seen.add(value);

  if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(value)) {
    traverse(value.value, seen);
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
    for (var i = 0; i < value.length; i++) {
      traverse(value[i], seen);
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isMap)(value)) {
    value.forEach(function (v) {
      traverse(v, seen);
    });
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(value)) {
    for (var key in value) {
      traverse(value[key], seen);
    }
  }

  return value;
}

function useTransitionState() {
  var state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: new Map()
  };
  onMounted(function () {
    state.isMounted = true;
  });
  onBeforeUnmount(function () {
    state.isUnmounting = true;
  });
  return state;
}

var TransitionHookValidator = [Function, Array];
var BaseTransitionImpl = {
  name: "BaseTransition",
  props: {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    // enter
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    // leave
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    // appear
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
  },
  setup: function setup(props, _ref7) {
    var slots = _ref7.slots;
    var instance = getCurrentInstance();
    var state = useTransitionState();
    var prevTransitionKey;
    return function () {
      var children = slots.default && getTransitionRawChildren(slots.default(), true);

      if (!children || !children.length) {
        return;
      } // warn multiple elements


      if ( true && children.length > 1) {
        warn('<transition> can only be used on a single element or component. Use ' + '<transition-group> for lists.');
      } // there's no need to track reactivity for these props so use the raw
      // props for a bit better perf


      var rawProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
      var mode = rawProps.mode; // check mode

      if ( true && mode && !['in-out', 'out-in', 'default'].includes(mode)) {
        warn("invalid <transition> mode: ".concat(mode));
      } // at this point children has a guaranteed length of 1.


      var child = children[0];

      if (state.isLeaving) {
        return emptyPlaceholder(child);
      } // in the case of <transition><keep-alive/></transition>, we need to
      // compare the type of the kept-alive children.


      var innerChild = getKeepAliveChild(child);

      if (!innerChild) {
        return emptyPlaceholder(child);
      }

      var enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
      setTransitionHooks(innerChild, enterHooks);
      var oldChild = instance.subTree;
      var oldInnerChild = oldChild && getKeepAliveChild(oldChild);
      var transitionKeyChanged = false;
      var getTransitionKey = innerChild.type.getTransitionKey;

      if (getTransitionKey) {
        var key = getTransitionKey();

        if (prevTransitionKey === undefined) {
          prevTransitionKey = key;
        } else if (key !== prevTransitionKey) {
          prevTransitionKey = key;
          transitionKeyChanged = true;
        }
      } // handle mode


      if (oldInnerChild && oldInnerChild.type !== Comment$1 && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
        var leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance); // update old tree's hooks in case of dynamic transition

        setTransitionHooks(oldInnerChild, leavingHooks); // switching between different views

        if (mode === 'out-in') {
          state.isLeaving = true; // return placeholder node and queue update when leave finishes

          leavingHooks.afterLeave = function () {
            state.isLeaving = false;
            instance.update();
          };

          return emptyPlaceholder(child);
        } else if (mode === 'in-out' && innerChild.type !== Comment$1) {
          leavingHooks.delayLeave = function (el, earlyRemove, delayedLeave) {
            var leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild; // early removal callback

            el._leaveCb = function () {
              earlyRemove();
              el._leaveCb = undefined;
              delete enterHooks.delayedLeave;
            };

            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }

      return child;
    };
  }
}; // export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files

var BaseTransition = BaseTransitionImpl;

function getLeavingNodesForType(state, vnode) {
  var leavingVNodes = state.leavingVNodes;
  var leavingVNodesCache = leavingVNodes.get(vnode.type);

  if (!leavingVNodesCache) {
    leavingVNodesCache = Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }

  return leavingVNodesCache;
} // The transition hooks are attached to the vnode as vnode.transition
// and will be called at appropriate timing in the renderer.


function resolveTransitionHooks(vnode, props, state, instance) {
  var appear = props.appear,
      mode = props.mode,
      _props$persisted = props.persisted,
      persisted = _props$persisted === void 0 ? false : _props$persisted,
      onBeforeEnter = props.onBeforeEnter,
      onEnter = props.onEnter,
      onAfterEnter = props.onAfterEnter,
      onEnterCancelled = props.onEnterCancelled,
      onBeforeLeave = props.onBeforeLeave,
      onLeave = props.onLeave,
      onAfterLeave = props.onAfterLeave,
      onLeaveCancelled = props.onLeaveCancelled,
      onBeforeAppear = props.onBeforeAppear,
      onAppear = props.onAppear,
      onAfterAppear = props.onAfterAppear,
      onAppearCancelled = props.onAppearCancelled;
  var key = String(vnode.key);
  var leavingVNodesCache = getLeavingNodesForType(state, vnode);

  var callHook = function callHook(hook, args) {
    hook && callWithAsyncErrorHandling(hook, instance, 9
    /* TRANSITION_HOOK */
    , args);
  };

  var hooks = {
    mode: mode,
    persisted: persisted,
    beforeEnter: function beforeEnter(el) {
      var hook = onBeforeEnter;

      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      } // for same element (v-show)


      if (el._leaveCb) {
        el._leaveCb(true
        /* cancelled */
        );
      } // for toggled element with same key (v-if)


      var leavingVNode = leavingVNodesCache[key];

      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
        // force early removal (not cancelled)
        leavingVNode.el._leaveCb();
      }

      callHook(hook, [el]);
    },
    enter: function enter(el) {
      var hook = onEnter;
      var afterHook = onAfterEnter;
      var cancelHook = onEnterCancelled;

      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }

      var called = false;

      var done = el._enterCb = function (cancelled) {
        if (called) return;
        called = true;

        if (cancelled) {
          callHook(cancelHook, [el]);
        } else {
          callHook(afterHook, [el]);
        }

        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }

        el._enterCb = undefined;
      };

      if (hook) {
        hook(el, done);

        if (hook.length <= 1) {
          done();
        }
      } else {
        done();
      }
    },
    leave: function leave(el, remove) {
      var key = String(vnode.key);

      if (el._enterCb) {
        el._enterCb(true
        /* cancelled */
        );
      }

      if (state.isUnmounting) {
        return remove();
      }

      callHook(onBeforeLeave, [el]);
      var called = false;

      var done = el._leaveCb = function (cancelled) {
        if (called) return;
        called = true;
        remove();

        if (cancelled) {
          callHook(onLeaveCancelled, [el]);
        } else {
          callHook(onAfterLeave, [el]);
        }

        el._leaveCb = undefined;

        if (leavingVNodesCache[key] === vnode) {
          delete leavingVNodesCache[key];
        }
      };

      leavingVNodesCache[key] = vnode;

      if (onLeave) {
        onLeave(el, done);

        if (onLeave.length <= 1) {
          done();
        }
      } else {
        done();
      }
    },
    clone: function clone(vnode) {
      return resolveTransitionHooks(vnode, props, state, instance);
    }
  };
  return hooks;
} // the placeholder really only handles one special case: KeepAlive
// in the case of a KeepAlive in a leave phase we need to return a KeepAlive
// placeholder with empty content to avoid the KeepAlive instance from being
// unmounted.


function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}

function getKeepAliveChild(vnode) {
  return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : undefined : vnode;
}

function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6
  /* COMPONENT */
  && vnode.component) {
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128
  /* SUSPENSE */
  ) {
      vnode.ssContent.transition = hooks.clone(vnode.ssContent);
      vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    } else {
    vnode.transition = hooks;
  }
}

function getTransitionRawChildren(children) {
  var keepComment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var ret = [];
  var keyedFragmentCount = 0;

  for (var i = 0; i < children.length; i++) {
    var child = children[i]; // handle fragment children case, e.g. v-for

    if (child.type === Fragment) {
      if (child.patchFlag & 128
      /* KEYED_FRAGMENT */
      ) keyedFragmentCount++;
      ret = ret.concat(getTransitionRawChildren(child.children, keepComment));
    } // comment placeholders should be skipped, e.g. v-if
    else if (keepComment || child.type !== Comment$1) {
        ret.push(child);
      }
  } // #1126 if a transition children list contains multiple sub fragments, these
  // fragments will be merged into a flat children array. Since each v-for
  // fragment may contain different static bindings inside, we need to de-op
  // these children to force full diffs to ensure correct behavior.


  if (keyedFragmentCount > 1) {
    for (var _i2 = 0; _i2 < ret.length; _i2++) {
      ret[_i2].patchFlag = -2
      /* BAIL */
      ;
    }
  }

  return ret;
} // implementation, close to no-op


function defineComponent(options) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(options) ? {
    setup: options,
    name: options.name
  } : options;
}

var isAsyncWrapper = function isAsyncWrapper(i) {
  return !!i.type.__asyncLoader;
};

function defineAsyncComponent(source) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(source)) {
    source = {
      loader: source
    };
  }

  var _source = source,
      loader = _source.loader,
      loadingComponent = _source.loadingComponent,
      errorComponent = _source.errorComponent,
      _source$delay = _source.delay,
      delay = _source$delay === void 0 ? 200 : _source$delay,
      timeout = _source.timeout,
      _source$suspensible = _source.suspensible,
      suspensible = _source$suspensible === void 0 ? true : _source$suspensible,
      userOnError = _source.onError;
  var pendingRequest = null;
  var resolvedComp;
  var retries = 0;

  var retry = function retry() {
    retries++;
    pendingRequest = null;
    return load();
  };

  var load = function load() {
    var thisRequest;
    return pendingRequest || (thisRequest = pendingRequest = loader().catch(function (err) {
      err = err instanceof Error ? err : new Error(String(err));

      if (userOnError) {
        return new Promise(function (resolve, reject) {
          var userRetry = function userRetry() {
            return resolve(retry());
          };

          var userFail = function userFail() {
            return reject(err);
          };

          userOnError(err, userRetry, userFail, retries + 1);
        });
      } else {
        throw err;
      }
    }).then(function (comp) {
      if (thisRequest !== pendingRequest && pendingRequest) {
        return pendingRequest;
      }

      if ( true && !comp) {
        warn("Async component loader resolved to undefined. " + "If you are using retry(), make sure to return its return value.");
      } // interop module default


      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === 'Module')) {
        comp = comp.default;
      }

      if ( true && comp && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(comp) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {
        throw new Error("Invalid async component load result: ".concat(comp));
      }

      resolvedComp = comp;
      return comp;
    }));
  };

  return defineComponent({
    name: 'AsyncComponentWrapper',
    __asyncLoader: load,

    get __asyncResolved() {
      return resolvedComp;
    },

    setup: function setup() {
      var instance = currentInstance; // already resolved

      if (resolvedComp) {
        return function () {
          return createInnerComp(resolvedComp, instance);
        };
      }

      var onError = function onError(err) {
        pendingRequest = null;
        handleError(err, instance, 13
        /* ASYNC_COMPONENT_LOADER */
        , !errorComponent
        /* do not throw in dev if user provided error component */
        );
      }; // suspense-controlled or SSR.


      if (suspensible && instance.suspense || false) {
        return load().then(function (comp) {
          return function () {
            return createInnerComp(comp, instance);
          };
        }).catch(function (err) {
          onError(err);
          return function () {
            return errorComponent ? createVNode(errorComponent, {
              error: err
            }) : null;
          };
        });
      }

      var loaded = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)(false);
      var error = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)();
      var delayed = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)(!!delay);

      if (delay) {
        setTimeout(function () {
          delayed.value = false;
        }, delay);
      }

      if (timeout != null) {
        setTimeout(function () {
          if (!loaded.value && !error.value) {
            var err = new Error("Async component timed out after ".concat(timeout, "ms."));
            onError(err);
            error.value = err;
          }
        }, timeout);
      }

      load().then(function () {
        loaded.value = true;

        if (instance.parent && isKeepAlive(instance.parent.vnode)) {
          // parent is keep-alive, force update so the loaded component's
          // name is taken into account
          queueJob(instance.parent.update);
        }
      }).catch(function (err) {
        onError(err);
        error.value = err;
      });
      return function () {
        if (loaded.value && resolvedComp) {
          return createInnerComp(resolvedComp, instance);
        } else if (error.value && errorComponent) {
          return createVNode(errorComponent, {
            error: error.value
          });
        } else if (loadingComponent && !delayed.value) {
          return createVNode(loadingComponent);
        }
      };
    }
  });
}

function createInnerComp(comp, _ref8) {
  var _ref8$vnode = _ref8.vnode,
      ref = _ref8$vnode.ref,
      props = _ref8$vnode.props,
      children = _ref8$vnode.children;
  var vnode = createVNode(comp, props, children); // ensure inner component inherits the async wrapper's ref owner

  vnode.ref = ref;
  return vnode;
}

var isKeepAlive = function isKeepAlive(vnode) {
  return vnode.type.__isKeepAlive;
};

var KeepAliveImpl = {
  name: "KeepAlive",
  // Marker for special handling inside the renderer. We are not using a ===
  // check directly on KeepAlive in the renderer, because importing it directly
  // would prevent it from being tree-shaken.
  __isKeepAlive: true,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup: function setup(props, _ref9) {
    var slots = _ref9.slots;
    var instance = getCurrentInstance(); // KeepAlive communicates with the instantiated renderer via the
    // ctx where the renderer passes in its internals,
    // and the KeepAlive instance exposes activate/deactivate implementations.
    // The whole point of this is to avoid importing KeepAlive directly in the
    // renderer to facilitate tree-shaking.

    var sharedContext = instance.ctx; // if the internal renderer is not registered, it indicates that this is server-side rendering,
    // for KeepAlive, we just need to render its children

    if (!sharedContext.renderer) {
      return slots.default;
    }

    var cache = new Map();
    var keys = new Set();
    var current = null;

    if (true) {
      instance.__v_cache = cache;
    }

    var parentSuspense = instance.suspense;
    var _sharedContext$render = sharedContext.renderer,
        patch = _sharedContext$render.p,
        move = _sharedContext$render.m,
        _unmount = _sharedContext$render.um,
        createElement = _sharedContext$render.o.createElement;
    var storageContainer = createElement('div');

    sharedContext.activate = function (vnode, container, anchor, isSVG, optimized) {
      var instance = vnode.component;
      move(vnode, container, anchor, 0
      /* ENTER */
      , parentSuspense); // in case props have changed

      patch(instance.vnode, vnode, container, anchor, instance, parentSuspense, isSVG, vnode.slotScopeIds, optimized);
      queuePostRenderEffect(function () {
        instance.isDeactivated = false;

        if (instance.a) {
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.a);
        }

        var vnodeHook = vnode.props && vnode.props.onVnodeMounted;

        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance.parent, vnode);
        }
      }, parentSuspense);

      if (true) {
        // Update components tree
        devtoolsComponentAdded(instance);
      }
    };

    sharedContext.deactivate = function (vnode) {
      var instance = vnode.component;
      move(vnode, storageContainer, null, 1
      /* LEAVE */
      , parentSuspense);
      queuePostRenderEffect(function () {
        if (instance.da) {
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.da);
        }

        var vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;

        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance.parent, vnode);
        }

        instance.isDeactivated = true;
      }, parentSuspense);

      if (true) {
        // Update components tree
        devtoolsComponentAdded(instance);
      }
    };

    function unmount(vnode) {
      // reset the shapeFlag so it can be properly unmounted
      resetShapeFlag(vnode);

      _unmount(vnode, instance, parentSuspense);
    }

    function pruneCache(filter) {
      cache.forEach(function (vnode, key) {
        var name = getComponentName(vnode.type);

        if (name && (!filter || !filter(name))) {
          pruneCacheEntry(key);
        }
      });
    }

    function pruneCacheEntry(key) {
      var cached = cache.get(key);

      if (!current || cached.type !== current.type) {
        unmount(cached);
      } else if (current) {
        // current active instance should no longer be kept-alive.
        // we can't unmount it now but it might be later, so reset its flag now.
        resetShapeFlag(current);
      }

      cache.delete(key);
      keys.delete(key);
    } // prune cache on include/exclude prop change


    watch(function () {
      return [props.include, props.exclude];
    }, function (_ref10) {
      var _ref11 = _slicedToArray(_ref10, 2),
          include = _ref11[0],
          exclude = _ref11[1];

      include && pruneCache(function (name) {
        return matches(include, name);
      });
      exclude && pruneCache(function (name) {
        return !matches(exclude, name);
      });
    }, // prune post-render after `current` has been updated
    {
      flush: 'post',
      deep: true
    }); // cache sub tree after render

    var pendingCacheKey = null;

    var cacheSubtree = function cacheSubtree() {
      // fix #1621, the pendingCacheKey could be 0
      if (pendingCacheKey != null) {
        cache.set(pendingCacheKey, getInnerChild(instance.subTree));
      }
    };

    onMounted(cacheSubtree);
    onUpdated(cacheSubtree);
    onBeforeUnmount(function () {
      cache.forEach(function (cached) {
        var subTree = instance.subTree,
            suspense = instance.suspense;
        var vnode = getInnerChild(subTree);

        if (cached.type === vnode.type) {
          // current instance will be unmounted as part of keep-alive's unmount
          resetShapeFlag(vnode); // but invoke its deactivated hook here

          var da = vnode.component.da;
          da && queuePostRenderEffect(da, suspense);
          return;
        }

        unmount(cached);
      });
    });
    return function () {
      pendingCacheKey = null;

      if (!slots.default) {
        return null;
      }

      var children = slots.default();
      var rawVNode = children[0];

      if (children.length > 1) {
        if (true) {
          warn("KeepAlive should contain exactly one component child.");
        }

        current = null;
        return children;
      } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4
      /* STATEFUL_COMPONENT */
      ) && !(rawVNode.shapeFlag & 128
      /* SUSPENSE */
      )) {
        current = null;
        return rawVNode;
      }

      var vnode = getInnerChild(rawVNode);
      var comp = vnode.type; // for async components, name check should be based in its loaded
      // inner component if available

      var name = getComponentName(isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp);
      var include = props.include,
          exclude = props.exclude,
          max = props.max;

      if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
        current = vnode;
        return rawVNode;
      }

      var key = vnode.key == null ? comp : vnode.key;
      var cachedVNode = cache.get(key); // clone vnode if it's reused because we are going to mutate it

      if (vnode.el) {
        vnode = cloneVNode(vnode);

        if (rawVNode.shapeFlag & 128
        /* SUSPENSE */
        ) {
            rawVNode.ssContent = vnode;
          }
      } // #1513 it's possible for the returned vnode to be cloned due to attr
      // fallthrough or scopeId, so the vnode here may not be the final vnode
      // that is mounted. Instead of caching it directly, we store the pending
      // key and cache `instance.subTree` (the normalized vnode) in
      // beforeMount/beforeUpdate hooks.


      pendingCacheKey = key;

      if (cachedVNode) {
        // copy over mounted state
        vnode.el = cachedVNode.el;
        vnode.component = cachedVNode.component;

        if (vnode.transition) {
          // recursively update transition hooks on subTree
          setTransitionHooks(vnode, vnode.transition);
        } // avoid vnode being mounted as fresh


        vnode.shapeFlag |= 512
        /* COMPONENT_KEPT_ALIVE */
        ; // make this key the freshest

        keys.delete(key);
        keys.add(key);
      } else {
        keys.add(key); // prune oldest entry

        if (max && keys.size > parseInt(max, 10)) {
          pruneCacheEntry(keys.values().next().value);
        }
      } // avoid vnode being unmounted


      vnode.shapeFlag |= 256
      /* COMPONENT_SHOULD_KEEP_ALIVE */
      ;
      current = vnode;
      return rawVNode;
    };
  }
}; // export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files

var KeepAlive = KeepAliveImpl;

function matches(pattern, name) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(pattern)) {
    return pattern.some(function (p) {
      return matches(p, name);
    });
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(pattern)) {
    return pattern.split(',').indexOf(name) > -1;
  } else if (pattern.test) {
    return pattern.test(name);
  }
  /* istanbul ignore next */


  return false;
}

function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a"
  /* ACTIVATED */
  , target);
}

function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da"
  /* DEACTIVATED */
  , target);
}

function registerKeepAliveHook(hook, type) {
  var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : currentInstance;

  // cache the deactivate branch check wrapper for injected hooks so the same
  // hook can be properly deduped by the scheduler. "__wdc" stands for "with
  // deactivation check".
  var wrappedHook = hook.__wdc || (hook.__wdc = function () {
    // only fire the hook if the target instance is NOT in a deactivated branch.
    var current = target;

    while (current) {
      if (current.isDeactivated) {
        return;
      }

      current = current.parent;
    }

    hook();
  });

  injectHook(type, wrappedHook, target); // In addition to registering it on the target instance, we walk up the parent
  // chain and register it on all ancestor instances that are keep-alive roots.
  // This avoids the need to walk the entire component tree when invoking these
  // hooks, and more importantly, avoids the need to track child components in
  // arrays.

  if (target) {
    var current = target.parent;

    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }

      current = current.parent;
    }
  }
}

function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  // injectHook wraps the original for error handling, so make sure to remove
  // the wrapped version.
  var injected = injectHook(type, hook, keepAliveRoot, true
  /* prepend */
  );
  onUnmounted(function () {
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(keepAliveRoot[type], injected);
  }, target);
}

function resetShapeFlag(vnode) {
  var shapeFlag = vnode.shapeFlag;

  if (shapeFlag & 256
  /* COMPONENT_SHOULD_KEEP_ALIVE */
  ) {
      shapeFlag -= 256
      /* COMPONENT_SHOULD_KEEP_ALIVE */
      ;
    }

  if (shapeFlag & 512
  /* COMPONENT_KEPT_ALIVE */
  ) {
      shapeFlag -= 512
      /* COMPONENT_KEPT_ALIVE */
      ;
    }

  vnode.shapeFlag = shapeFlag;
}

function getInnerChild(vnode) {
  return vnode.shapeFlag & 128
  /* SUSPENSE */
  ? vnode.ssContent : vnode;
}

function injectHook(type, hook) {
  var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : currentInstance;
  var prepend = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  if (target) {
    var hooks = target[type] || (target[type] = []); // cache the error handling wrapper for injected hooks so the same hook
    // can be properly deduped by the scheduler. "__weh" stands for "with error
    // handling".

    var wrappedHook = hook.__weh || (hook.__weh = function () {
      if (target.isUnmounted) {
        return;
      } // disable tracking inside all lifecycle hooks
      // since they can potentially be called inside effects.


      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)(); // Set currentInstance during hook invocation.
      // This assumes the hook does not synchronously trigger other hooks, which
      // can only be false when the user does something really funky.

      setCurrentInstance(target);

      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      var res = callWithAsyncErrorHandling(hook, target, type, args);
      setCurrentInstance(null);
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
      return res;
    });

    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }

    return wrappedHook;
  } else if (true) {
    var apiName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(ErrorTypeStrings[type].replace(/ hook$/, ''));
    warn("".concat(apiName, " is called when there is no active component instance to be ") + "associated with. " + "Lifecycle injection APIs can only be used during execution of setup()." + (" If you are using async setup(), make sure to register lifecycle " + "hooks before the first await statement."));
  }
}

var createHook = function createHook(lifecycle) {
  return function (hook) {
    var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : currentInstance;
    return (// post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
      (!isInSSRComponentSetup || lifecycle === "sp"
      /* SERVER_PREFETCH */
      ) && injectHook(lifecycle, hook, target)
    );
  };
};

var onBeforeMount = createHook("bm"
/* BEFORE_MOUNT */
);
var onMounted = createHook("m"
/* MOUNTED */
);
var onBeforeUpdate = createHook("bu"
/* BEFORE_UPDATE */
);
var onUpdated = createHook("u"
/* UPDATED */
);
var onBeforeUnmount = createHook("bum"
/* BEFORE_UNMOUNT */
);
var onUnmounted = createHook("um"
/* UNMOUNTED */
);
var onServerPrefetch = createHook("sp"
/* SERVER_PREFETCH */
);
var onRenderTriggered = createHook("rtg"
/* RENDER_TRIGGERED */
);
var onRenderTracked = createHook("rtc"
/* RENDER_TRACKED */
);

function onErrorCaptured(hook) {
  var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : currentInstance;
  injectHook("ec"
  /* ERROR_CAPTURED */
  , hook, target);
}

function createDuplicateChecker() {
  var cache = Object.create(null);
  return function (type, key) {
    if (cache[key]) {
      warn("".concat(type, " property \"").concat(key, "\" is already defined in ").concat(cache[key], "."));
    } else {
      cache[key] = type;
    }
  };
}

var shouldCacheAccess = true;

function applyOptions(instance) {
  var options = resolveMergedOptions(instance);
  var publicThis = instance.proxy;
  var ctx = instance.ctx; // do not cache property access on public proxy during state initialization

  shouldCacheAccess = false; // call beforeCreate first before accessing other options since
  // the hook may mutate resolved options (#2791)

  if (options.beforeCreate) {
    callHook(options.beforeCreate, instance, "bc"
    /* BEFORE_CREATE */
    );
  }

  var dataOptions = options.data,
      computedOptions = options.computed,
      methods = options.methods,
      watchOptions = options.watch,
      provideOptions = options.provide,
      injectOptions = options.inject,
      created = options.created,
      beforeMount = options.beforeMount,
      mounted = options.mounted,
      beforeUpdate = options.beforeUpdate,
      updated = options.updated,
      activated = options.activated,
      deactivated = options.deactivated,
      beforeDestroy = options.beforeDestroy,
      beforeUnmount = options.beforeUnmount,
      destroyed = options.destroyed,
      unmounted = options.unmounted,
      render = options.render,
      renderTracked = options.renderTracked,
      renderTriggered = options.renderTriggered,
      errorCaptured = options.errorCaptured,
      serverPrefetch = options.serverPrefetch,
      expose = options.expose,
      inheritAttrs = options.inheritAttrs,
      components = options.components,
      directives = options.directives,
      filters = options.filters;
  var checkDuplicateProperties =  true ? createDuplicateChecker() : 0;

  if (true) {
    var _instance$propsOption3 = _slicedToArray(instance.propsOptions, 1),
        propsOptions = _instance$propsOption3[0];

    if (propsOptions) {
      for (var key in propsOptions) {
        checkDuplicateProperties("Props"
        /* PROPS */
        , key);
      }
    }
  } // options initialization order (to be consistent with Vue 2):
  // - props (already done outside of this function)
  // - inject
  // - methods
  // - data (deferred since it relies on `this` access)
  // - computed
  // - watch (deferred since it relies on `this` access)


  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }

  if (methods) {
    for (var _key5 in methods) {
      var methodHandler = methods[_key5];

      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(methodHandler)) {
        // In dev mode, we use the `createRenderContext` function to define methods to the proxy target,
        // and those are read-only but reconfigurable, so it needs to be redefined here
        if (true) {
          Object.defineProperty(ctx, _key5, {
            value: methodHandler.bind(publicThis),
            configurable: true,
            enumerable: true,
            writable: true
          });
        } else {}

        if (true) {
          checkDuplicateProperties("Methods"
          /* METHODS */
          , _key5);
        }
      } else if (true) {
        warn("Method \"".concat(_key5, "\" has type \"").concat(_typeof(methodHandler), "\" in the component definition. ") + "Did you reference the function correctly?");
      }
    }
  }

  if (dataOptions) {
    (function () {
      if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(dataOptions)) {
        warn("The data option must be a function. " + "Plain object usage is no longer supported.");
      }

      var data = dataOptions.call(publicThis, publicThis);

      if ( true && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(data)) {
        warn("data() returned a Promise - note data() cannot be async; If you " + "intend to perform data fetching before component renders, use " + "async setup() + <Suspense>.");
      }

      if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(data)) {
         true && warn("data() should return an object.");
      } else {
        instance.data = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.reactive)(data);

        if (true) {
          var _loop = function _loop(_key6) {
            checkDuplicateProperties("Data"
            /* DATA */
            , _key6); // expose data on ctx during dev

            if (_key6[0] !== '$' && _key6[0] !== '_') {
              Object.defineProperty(ctx, _key6, {
                configurable: true,
                enumerable: true,
                get: function get() {
                  return data[_key6];
                },
                set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
              });
            }
          };

          for (var _key6 in data) {
            _loop(_key6);
          }
        }
      }
    })();
  } // state initialization complete at this point - start caching access


  shouldCacheAccess = true;

  if (computedOptions) {
    var _loop2 = function _loop2(_key7) {
      var opt = computedOptions[_key7];
      var get = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt) ? opt.bind(publicThis, publicThis) : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt.get) ? opt.get.bind(publicThis, publicThis) : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;

      if ( true && get === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP) {
        warn("Computed property \"".concat(_key7, "\" has no getter."));
      }

      var set = !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt.set) ? opt.set.bind(publicThis) :  true ? function () {
        warn("Write operation failed: computed property \"".concat(_key7, "\" is readonly."));
      } : 0;
      var c = computed({
        get: get,
        set: set
      });
      Object.defineProperty(ctx, _key7, {
        enumerable: true,
        configurable: true,
        get: function get() {
          return c.value;
        },
        set: function set(v) {
          return c.value = v;
        }
      });

      if (true) {
        checkDuplicateProperties("Computed"
        /* COMPUTED */
        , _key7);
      }
    };

    for (var _key7 in computedOptions) {
      _loop2(_key7);
    }
  }

  if (watchOptions) {
    for (var _key8 in watchOptions) {
      createWatcher(watchOptions[_key8], ctx, publicThis, _key8);
    }
  }

  if (provideOptions) {
    var provides = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach(function (key) {
      provide(key, provides[key]);
    });
  }

  if (created) {
    callHook(created, instance, "c"
    /* CREATED */
    );
  }

  function registerLifecycleHook(register, hook) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)) {
      hook.forEach(function (_hook) {
        return register(_hook.bind(publicThis));
      });
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }

  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(expose)) {
    if (expose.length) {
      var exposed = instance.exposed || (instance.exposed = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs)({}));
      expose.forEach(function (key) {
        exposed[key] = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRef)(publicThis, key);
      });
    } else if (!instance.exposed) {
      instance.exposed = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    }
  } // options that are handled when creating the instance but also need to be
  // applied from mixins


  if (render && instance.render === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP) {
    instance.render = render;
  }

  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  } // asset options.


  if (components) instance.components = components;
  if (directives) instance.directives = directives;
}

function resolveInjections(injectOptions, ctx) {
  var checkDuplicateProperties = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }

  for (var key in injectOptions) {
    var opt = injectOptions[key];

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(opt)) {
      if ('default' in opt) {
        ctx[key] = inject(opt.from || key, opt.default, true
        /* treat default function as factory */
        );
      } else {
        ctx[key] = inject(opt.from || key);
      }
    } else {
      ctx[key] = inject(opt);
    }

    if (true) {
      checkDuplicateProperties("Inject"
      /* INJECT */
      , key);
    }
  }
}

function callHook(hook, instance, type) {
  callWithAsyncErrorHandling((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook) ? hook.map(function (h) {
    return h.bind(instance.proxy);
  }) : hook.bind(instance.proxy), instance, type);
}

function createWatcher(raw, ctx, publicThis, key) {
  var getter = key.includes('.') ? createPathGetter(publicThis, key) : function () {
    return publicThis[key];
  };

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(raw)) {
    var handler = ctx[raw];

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(handler)) {
      watch(getter, handler);
    } else if (true) {
      warn("Invalid watch handler specified by key \"".concat(raw, "\""), handler);
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(raw)) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
      raw.forEach(function (r) {
        return createWatcher(r, ctx, publicThis, key);
      });
    } else {
      var _handler = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];

      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(_handler)) {
        watch(getter, _handler, raw);
      } else if (true) {
        warn("Invalid watch handler specified by key \"".concat(raw.handler, "\""), _handler);
      }
    }
  } else if (true) {
    warn("Invalid watch option: \"".concat(key, "\""), raw);
  }
}
/**
 * Resolve merged options and cache it on the component.
 * This is done only once per-component since the merging does not involve
 * instances.
 */


function resolveMergedOptions(instance) {
  var base = instance.type;
  var mixins = base.mixins,
      extendsOptions = base.extends;
  var _instance$appContext = instance.appContext,
      globalMixins = _instance$appContext.mixins,
      cache = _instance$appContext.optionsCache,
      optionMergeStrategies = _instance$appContext.config.optionMergeStrategies;
  var cached = cache.get(base);
  var resolved;

  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};

    if (globalMixins.length) {
      globalMixins.forEach(function (m) {
        return mergeOptions(resolved, m, optionMergeStrategies, true);
      });
    }

    mergeOptions(resolved, base, optionMergeStrategies);
  }

  cache.set(base, resolved);
  return resolved;
}

function mergeOptions(to, from, strats) {
  var asMixin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var mixins = from.mixins,
      extendsOptions = from.extends;

  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }

  if (mixins) {
    mixins.forEach(function (m) {
      return mergeOptions(to, m, strats, true);
    });
  }

  for (var key in from) {
    if (asMixin && key === 'expose') {
       true && warn("\"expose\" option is ignored when declared in mixins or extends. " + "It should only be declared in the base component itself.");
    } else {
      var strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }

  return to;
}

var internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeObjectOptions,
  emits: mergeObjectOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeHook,
  created: mergeHook,
  beforeMount: mergeHook,
  mounted: mergeHook,
  beforeUpdate: mergeHook,
  updated: mergeHook,
  beforeDestroy: mergeHook,
  destroyed: mergeHook,
  activated: mergeHook,
  deactivated: mergeHook,
  errorCaptured: mergeHook,
  serverPrefetch: mergeHook,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch has special merge behavior in v2, but isn't actually needed in v3.
  // since we are only exposing these for compat and nobody should be relying
  // on the watch-specific behavior, just expose the object merge strat.
  watch: mergeObjectOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};

function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }

  if (!to) {
    return from;
  }

  return function mergedDataFn() {
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(to) ? to.call(this, this) : to, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(from) ? from.call(this, this) : from);
  };
}

function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}

function normalizeInject(raw) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
    var res = {};

    for (var i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }

    return res;
  }

  return raw;
}

function mergeHook(to, from) {
  return to ? _toConsumableArray(new Set([].concat(to, from))) : from;
}

function mergeObjectOptions(to, from) {
  return to ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(Object.create(null), to), from) : from;
}

function initProps(instance, rawProps, isStateful) {
  var isSSR = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var props = {};
  var attrs = {};
  (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(attrs, InternalObjectKey, 1);
  instance.propsDefaults = Object.create(null);
  setFullProps(instance, rawProps, props, attrs); // ensure all declared prop keys are present

  for (var key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = undefined;
    }
  } // validation


  if (true) {
    validateProps(rawProps || {}, props, instance);
  }

  if (isStateful) {
    // stateful
    instance.props = isSSR ? props : (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReactive)(props);
  } else {
    if (!instance.type.props) {
      // functional w/ optional props, props === attrs
      instance.props = attrs;
    } else {
      // functional w/ declared props
      instance.props = props;
    }
  }

  instance.attrs = attrs;
}

function updateProps(instance, rawProps, rawPrevProps, optimized) {
  var props = instance.props,
      attrs = instance.attrs,
      patchFlag = instance.vnode.patchFlag;
  var rawCurrentProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);

  var _instance$propsOption4 = _slicedToArray(instance.propsOptions, 1),
      options = _instance$propsOption4[0];

  var hasAttrsChanged = false;

  if ( // always force full diff in dev
  // - #1942 if hmr is enabled with sfc component
  // - vite#872 non-sfc component used by sfc component
  !( true && (instance.type.__hmrId || instance.parent && instance.parent.type.__hmrId)) && (optimized || patchFlag > 0) && !(patchFlag & 16
  /* FULL_PROPS */
  )) {
    if (patchFlag & 8
    /* PROPS */
    ) {
        // Compiler-generated props & no keys change, just set the updated
        // the props.
        var propsToUpdate = instance.vnode.dynamicProps;

        for (var i = 0; i < propsToUpdate.length; i++) {
          var key = propsToUpdate[i]; // PROPS flag guarantees rawProps to be non-null

          var value = rawProps[key];

          if (options) {
            // attr / props separation was done on init and will be consistent
            // in this code path, so just check if attrs have it.
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(attrs, key)) {
              if (value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            } else {
              var camelizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key);
              props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false
              /* isAbsent */
              );
            }
          } else {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
  } else {
    // full props update.
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    } // in case of dynamic props, check if we need to delete keys from
    // the props object


    var kebabKey;

    for (var _key9 in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, _key9) && ( // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      (kebabKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(_key9)) === _key9 || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && ( // for camelCase
          rawPrevProps[_key9] !== undefined || // for kebab-case
          rawPrevProps[kebabKey] !== undefined)) {
            props[_key9] = resolvePropValue(options, rawCurrentProps, _key9, undefined, instance, true
            /* isAbsent */
            );
          }
        } else {
          delete props[_key9];
        }
      }
    } // in the case of functional component w/o props declaration, props and
    // attrs point to the same object so it should already have been updated.


    if (attrs !== rawCurrentProps) {
      for (var _key10 in attrs) {
        if (!rawProps || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, _key10)) {
          delete attrs[_key10];
          hasAttrsChanged = true;
        }
      }
    }
  } // trigger updates for $attrs in case it's used in component slots


  if (hasAttrsChanged) {
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.trigger)(instance, "set"
    /* SET */
    , '$attrs');
  }

  if (true) {
    validateProps(rawProps || {}, props, instance);
  }
}

function setFullProps(instance, rawProps, props, attrs) {
  var _instance$propsOption5 = _slicedToArray(instance.propsOptions, 2),
      options = _instance$propsOption5[0],
      needCastKeys = _instance$propsOption5[1];

  var hasAttrsChanged = false;
  var rawCastValues;

  if (rawProps) {
    for (var key in rawProps) {
      // key, ref are reserved and never passed down
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) {
        continue;
      }

      var value = rawProps[key]; // prop option names are camelized during normalization, so to support
      // kebab -> camel conversion here we need to camelize the key.

      var camelKey = void 0;

      if (options && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, camelKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }

  if (needCastKeys) {
    var rawCurrentProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
    var castValues = rawCastValues || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;

    for (var i = 0; i < needCastKeys.length; i++) {
      var _key11 = needCastKeys[i];
      props[_key11] = resolvePropValue(options, rawCurrentProps, _key11, castValues[_key11], instance, !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(castValues, _key11));
    }
  }

  return hasAttrsChanged;
}

function resolvePropValue(options, props, key, value, instance, isAbsent) {
  var opt = options[key];

  if (opt != null) {
    var hasDefault = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(opt, 'default'); // default values

    if (hasDefault && value === undefined) {
      var defaultValue = opt.default;

      if (opt.type !== Function && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(defaultValue)) {
        var propsDefaults = instance.propsDefaults;

        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(null, props);
          setCurrentInstance(null);
        }
      } else {
        value = defaultValue;
      }
    } // boolean casting


    if (opt[0
    /* shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[1
      /* shouldCastTrue */
      ] && (value === '' || value === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key))) {
        value = true;
      }
    }
  }

  return value;
}

function normalizePropsOptions(comp, appContext) {
  var asMixin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var cache = appContext.propsCache;
  var cached = cache.get(comp);

  if (cached) {
    return cached;
  }

  var raw = comp.props;
  var normalized = {};
  var needCastKeys = []; // apply mixin/extends props

  var hasExtends = false;

  if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {
    var extendProps = function extendProps(raw) {
      hasExtends = true;

      var _normalizePropsOption = normalizePropsOptions(raw, appContext, true),
          _normalizePropsOption2 = _slicedToArray(_normalizePropsOption, 2),
          props = _normalizePropsOption2[0],
          keys = _normalizePropsOption2[1];

      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, props);
      if (keys) needCastKeys.push.apply(needCastKeys, _toConsumableArray(keys));
    };

    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }

    if (comp.extends) {
      extendProps(comp.extends);
    }

    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }

  if (!raw && !hasExtends) {
    cache.set(comp, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR);
    return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
  }

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {
    for (var i = 0; i < raw.length; i++) {
      if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(raw[i])) {
        warn("props must be strings when using array syntax.", raw[i]);
      }

      var normalizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(raw[i]);

      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
      }
    }
  } else if (raw) {
    if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(raw)) {
      warn("invalid props options", raw);
    }

    for (var key in raw) {
      var _normalizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key);

      if (validatePropName(_normalizedKey)) {
        var opt = raw[key];
        var prop = normalized[_normalizedKey] = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opt) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt) ? {
          type: opt
        } : opt;

        if (prop) {
          var booleanIndex = getTypeIndex(Boolean, prop.type);
          var stringIndex = getTypeIndex(String, prop.type);
          prop[0
          /* shouldCast */
          ] = booleanIndex > -1;
          prop[1
          /* shouldCastTrue */
          ] = stringIndex < 0 || booleanIndex < stringIndex; // if the prop needs boolean casting or default value

          if (booleanIndex > -1 || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(prop, 'default')) {
            needCastKeys.push(_normalizedKey);
          }
        }
      }
    }
  }

  var res = [normalized, needCastKeys];
  cache.set(comp, res);
  return res;
}

function validatePropName(key) {
  if (key[0] !== '$') {
    return true;
  } else if (true) {
    warn("Invalid prop name: \"".concat(key, "\" is a reserved property."));
  }

  return false;
} // use function string name to check type constructors
// so that it works across vms / iframes.


function getType(ctor) {
  var match = ctor && ctor.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : '';
}

function isSameType(a, b) {
  return getType(a) === getType(b);
}

function getTypeIndex(type, expectedTypes) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(expectedTypes)) {
    return expectedTypes.findIndex(function (t) {
      return isSameType(t, type);
    });
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }

  return -1;
}
/**
 * dev only
 */


function validateProps(rawProps, props, instance) {
  var resolvedValues = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);
  var options = instance.propsOptions[0];

  for (var key in options) {
    var opt = options[key];
    if (opt == null) continue;
    validateProp(key, resolvedValues[key], opt, !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, key) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)));
  }
}
/**
 * dev only
 */


function validateProp(name, value, prop, isAbsent) {
  var type = prop.type,
      required = prop.required,
      validator = prop.validator; // required!

  if (required && isAbsent) {
    warn('Missing required prop: "' + name + '"');
    return;
  } // missing but optional


  if (value == null && !prop.required) {
    return;
  } // type check


  if (type != null && type !== true) {
    var isValid = false;
    var types = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(type) ? type : [type];
    var expectedTypes = []; // value is valid as long as one of the specified types match

    for (var i = 0; i < types.length && !isValid; i++) {
      var _assertType = assertType(value, types[i]),
          valid = _assertType.valid,
          expectedType = _assertType.expectedType;

      expectedTypes.push(expectedType || '');
      isValid = valid;
    }

    if (!isValid) {
      warn(getInvalidTypeMessage(name, value, expectedTypes));
      return;
    }
  } // custom validator


  if (validator && !validator(value)) {
    warn('Invalid prop: custom validator check failed for prop "' + name + '".');
  }
}

var isSimpleType = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('String,Number,Boolean,Function,Symbol,BigInt');
/**
 * dev only
 */

function assertType(value, type) {
  var valid;
  var expectedType = getType(type);

  if (isSimpleType(expectedType)) {
    var t = _typeof(value);

    valid = t === expectedType.toLowerCase(); // for primitive wrapper objects

    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(value);
  } else if (expectedType === 'Array') {
    valid = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value);
  } else {
    valid = value instanceof type;
  }

  return {
    valid: valid,
    expectedType: expectedType
  };
}
/**
 * dev only
 */


function getInvalidTypeMessage(name, value, expectedTypes) {
  var message = "Invalid prop: type check failed for prop \"".concat(name, "\".") + " Expected ".concat(expectedTypes.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize).join(', '));
  var expectedType = expectedTypes[0];
  var receivedType = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toRawType)(value);
  var expectedValue = styleValue(value, expectedType);
  var receivedValue = styleValue(value, receivedType); // check if we need to specify expected value

  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
    message += " with value ".concat(expectedValue);
  }

  message += ", got ".concat(receivedType, " "); // check if we need to specify received value

  if (isExplicable(receivedType)) {
    message += "with value ".concat(receivedValue, ".");
  }

  return message;
}
/**
 * dev only
 */


function styleValue(value, type) {
  if (type === 'String') {
    return "\"".concat(value, "\"");
  } else if (type === 'Number') {
    return "".concat(Number(value));
  } else {
    return "".concat(value);
  }
}
/**
 * dev only
 */


function isExplicable(type) {
  var explicitTypes = ['string', 'number', 'boolean'];
  return explicitTypes.some(function (elem) {
    return type.toLowerCase() === elem;
  });
}
/**
 * dev only
 */


function isBoolean() {
  for (var _len5 = arguments.length, args = new Array(_len5), _key12 = 0; _key12 < _len5; _key12++) {
    args[_key12] = arguments[_key12];
  }

  return args.some(function (elem) {
    return elem.toLowerCase() === 'boolean';
  });
}

var isInternalKey = function isInternalKey(key) {
  return key[0] === '_' || key === '$stable';
};

var normalizeSlotValue = function normalizeSlotValue(value) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
};

var normalizeSlot = function normalizeSlot(key, rawSlot, ctx) {
  var normalized = withCtx(function (props) {
    if ( true && currentInstance) {
      warn("Slot \"".concat(key, "\" invoked outside of the render function: ") + "this will not track dependencies used in the slot. " + "Invoke the slot function inside the render function instead.");
    }

    return normalizeSlotValue(rawSlot(props));
  }, ctx);
  normalized._c = false;
  return normalized;
};

var normalizeObjectSlots = function normalizeObjectSlots(rawSlots, slots, instance) {
  var ctx = rawSlots._ctx;

  for (var key in rawSlots) {
    if (isInternalKey(key)) continue;
    var value = rawSlots[key];

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
      slots[key] = normalizeSlot(key, value, ctx);
    } else if (value != null) {
      (function () {
        if (true) {
          warn("Non-function value encountered for slot \"".concat(key, "\". ") + "Prefer function slots for better performance.");
        }

        var normalized = normalizeSlotValue(value);

        slots[key] = function () {
          return normalized;
        };
      })();
    }
  }
};

var normalizeVNodeSlots = function normalizeVNodeSlots(instance, children) {
  if ( true && !isKeepAlive(instance.vnode) && !false) {
    warn("Non-function value encountered for default slot. " + "Prefer function slots for better performance.");
  }

  var normalized = normalizeSlotValue(children);

  instance.slots.default = function () {
    return normalized;
  };
};

var initSlots = function initSlots(instance, children) {
  if (instance.vnode.shapeFlag & 32
  /* SLOTS_CHILDREN */
  ) {
      var type = children._;

      if (type) {
        // users can get the shallow readonly version of the slots object through `this.$slots`,
        // we should avoid the proxy object polluting the slots of the internal instance
        instance.slots = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(children); // make compiler marker non-enumerable

        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(children, '_', type);
      } else {
        normalizeObjectSlots(children, instance.slots = {});
      }
    } else {
    instance.slots = {};

    if (children) {
      normalizeVNodeSlots(instance, children);
    }
  }

  (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(instance.slots, InternalObjectKey, 1);
};

var updateSlots = function updateSlots(instance, children, optimized) {
  var vnode = instance.vnode,
      slots = instance.slots;
  var needDeletionCheck = true;
  var deletionComparisonTarget = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;

  if (vnode.shapeFlag & 32
  /* SLOTS_CHILDREN */
  ) {
      var type = children._;

      if (type) {
        // compiled slots.
        if ( true && isHmrUpdating) {
          // Parent was HMR updated so slot content may have changed.
          // force update slots and mark instance for hmr as well
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(slots, children);
        } else if (optimized && type === 1
        /* STABLE */
        ) {
            // compiled AND stable.
            // no need to update, and skip stale slots removal.
            needDeletionCheck = false;
          } else {
          // compiled but dynamic (v-if/v-for on slots) - update slots, but skip
          // normalization.
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(slots, children); // #2893
          // when rendering the optimized slots by manually written render function,
          // we need to delete the `slots._` flag if necessary to make subsequent updates reliable,
          // i.e. let the `renderSlot` create the bailed Fragment

          if (!optimized && type === 1
          /* STABLE */
          ) {
              delete slots._;
            }
        }
      } else {
        needDeletionCheck = !children.$stable;
        normalizeObjectSlots(children, slots);
      }

      deletionComparisonTarget = children;
    } else if (children) {
    // non slot object children (direct value) passed to a component
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = {
      default: 1
    };
  } // delete stale slots


  if (needDeletionCheck) {
    for (var key in slots) {
      if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
        delete slots[key];
      }
    }
  }
};
/**
Runtime helper for applying directives to a vnode. Example usage:

const comp = resolveComponent('comp')
const foo = resolveDirective('foo')
const bar = resolveDirective('bar')

return withDirectives(h(comp), [
  [foo, this.x],
  [bar, this.y]
])
*/


var isBuiltInDirective = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text');

function validateDirectiveName(name) {
  if (isBuiltInDirective(name)) {
    warn('Do not use built-in directive ids as custom directive id: ' + name);
  }
}
/**
 * Adds directives to a VNode.
 */


function withDirectives(vnode, directives) {
  var internalInstance = currentRenderingInstance;

  if (internalInstance === null) {
     true && warn("withDirectives can only be used inside render functions.");
    return vnode;
  }

  var instance = internalInstance.proxy;
  var bindings = vnode.dirs || (vnode.dirs = []);

  for (var i = 0; i < directives.length; i++) {
    var _directives$i = _slicedToArray(directives[i], 4),
        dir = _directives$i[0],
        value = _directives$i[1],
        arg = _directives$i[2],
        _directives$i$ = _directives$i[3],
        modifiers = _directives$i$ === void 0 ? _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ : _directives$i$;

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(dir)) {
      dir = {
        mounted: dir,
        updated: dir
      };
    }

    bindings.push({
      dir: dir,
      instance: instance,
      value: value,
      oldValue: void 0,
      arg: arg,
      modifiers: modifiers
    });
  }

  return vnode;
}

function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  var bindings = vnode.dirs;
  var oldBindings = prevVNode && prevVNode.dirs;

  for (var i = 0; i < bindings.length; i++) {
    var binding = bindings[i];

    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }

    var hook = binding.dir[name];

    if (hook) {
      // disable tracking inside all lifecycle hooks
      // since they can potentially be called inside effects.
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
      callWithAsyncErrorHandling(hook, instance, 8
      /* DIRECTIVE_HOOK */
      , [vnode.el, binding, vnode, prevVNode]);
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
    }
  }
}

function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: undefined,
      warnHandler: undefined,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: Object.create(null),
    optionsCache: new WeakMap(),
    propsCache: new WeakMap(),
    emitsCache: new WeakMap()
  };
}

var uid = 0;

function createAppAPI(render, hydrate) {
  return function createApp(rootComponent) {
    var rootProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    if (rootProps != null && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(rootProps)) {
       true && warn("root props passed to app.mount() must be an object.");
      rootProps = null;
    }

    var context = createAppContext();
    var installedPlugins = new Set();
    var isMounted = false;
    var app = context.app = {
      _uid: uid++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      version: version,

      get config() {
        return context.config;
      },

      set config(v) {
        if (true) {
          warn("app.config cannot be replaced. Modify individual options instead.");
        }
      },

      use: function use(plugin) {
        for (var _len6 = arguments.length, options = new Array(_len6 > 1 ? _len6 - 1 : 0), _key13 = 1; _key13 < _len6; _key13++) {
          options[_key13 - 1] = arguments[_key13];
        }

        if (installedPlugins.has(plugin)) {
           true && warn("Plugin has already been applied to target app.");
        } else if (plugin && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install.apply(plugin, [app].concat(options));
        } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(plugin)) {
          installedPlugins.add(plugin);
          plugin.apply(void 0, [app].concat(options));
        } else if (true) {
          warn("A plugin must either be a function or an object with an \"install\" " + "function.");
        }

        return app;
      },
      mixin: function mixin(_mixin) {
        if (true) {
          if (!context.mixins.includes(_mixin)) {
            context.mixins.push(_mixin);
          } else if (true) {
            warn('Mixin has already been applied to target app' + (_mixin.name ? ": ".concat(_mixin.name) : ''));
          }
        } else {}

        return app;
      },
      component: function component(name, _component) {
        if (true) {
          validateComponentName(name, context.config);
        }

        if (!_component) {
          return context.components[name];
        }

        if ( true && context.components[name]) {
          warn("Component \"".concat(name, "\" has already been registered in target app."));
        }

        context.components[name] = _component;
        return app;
      },
      directive: function directive(name, _directive) {
        if (true) {
          validateDirectiveName(name);
        }

        if (!_directive) {
          return context.directives[name];
        }

        if ( true && context.directives[name]) {
          warn("Directive \"".concat(name, "\" has already been registered in target app."));
        }

        context.directives[name] = _directive;
        return app;
      },
      mount: function mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          var vnode = createVNode(rootComponent, rootProps); // store app context on the root VNode.
          // this will be set on the root instance on initial mount.

          vnode.appContext = context; // HMR root reload

          if (true) {
            context.reload = function () {
              render(cloneVNode(vnode), rootContainer, isSVG);
            };
          }

          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render(vnode, rootContainer, isSVG);
          }

          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;

          if (true) {
            devtoolsInitApp(app, version);
          }

          return vnode.component.proxy;
        } else if (true) {
          warn("App has already been mounted.\n" + "If you want to remount the same app, move your app creation logic " + "into a factory function and create fresh app instances for each " + "mount - e.g. `const createMyApp = () => createApp(App)`");
        }
      },
      unmount: function unmount() {
        if (isMounted) {
          render(null, app._container);

          if (true) {
            devtoolsUnmountApp(app);
          }

          delete app._container.__vue_app__;
        } else if (true) {
          warn("Cannot unmount an app that is not mounted.");
        }
      },
      provide: function provide(key, value) {
        if ( true && key in context.provides) {
          warn("App already provides property with key \"".concat(String(key), "\". ") + "It will be overwritten with the new value.");
        } // TypeScript doesn't allow symbols as index type
        // https://github.com/Microsoft/TypeScript/issues/24587


        context.provides[key] = value;
        return app;
      }
    };
    return app;
  };
}

var hasMismatch = false;

var isSVGContainer = function isSVGContainer(container) {
  return /svg/.test(container.namespaceURI) && container.tagName !== 'foreignObject';
};

var isComment = function isComment(node) {
  return node.nodeType === 8;
}
/* COMMENT */
; // Note: hydration is DOM-specific
// But we have to place it in core due to tight coupling with core - splitting
// it out creates a ton of unnecessary complexity.
// Hydration also depends on some renderer internal logic which needs to be
// passed in via arguments.


function createHydrationFunctions(rendererInternals) {
  var mountComponent = rendererInternals.mt,
      patch = rendererInternals.p,
      _rendererInternals$o2 = rendererInternals.o,
      patchProp = _rendererInternals$o2.patchProp,
      nextSibling = _rendererInternals$o2.nextSibling,
      parentNode = _rendererInternals$o2.parentNode,
      remove = _rendererInternals$o2.remove,
      insert = _rendererInternals$o2.insert,
      createComment = _rendererInternals$o2.createComment;

  var hydrate = function hydrate(vnode, container) {
    if ( true && !container.hasChildNodes()) {
      warn("Attempting to hydrate existing markup but container is empty. " + "Performing full mount instead.");
      patch(null, vnode, container);
      return;
    }

    hasMismatch = false;
    hydrateNode(container.firstChild, vnode, null, null, null);
    flushPostFlushCbs();

    if (hasMismatch && !false) {
      // this error should show up in production
      console.error("Hydration completed but contains mismatches.");
    }
  };

  var hydrateNode = function hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds) {
    var optimized = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
    var isFragmentStart = isComment(node) && node.data === '[';

    var onMismatch = function onMismatch() {
      return handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);
    };

    var type = vnode.type,
        ref = vnode.ref,
        shapeFlag = vnode.shapeFlag;
    var domType = node.nodeType;
    vnode.el = node;
    var nextNode = null;

    switch (type) {
      case Text:
        if (domType !== 3
        /* TEXT */
        ) {
            nextNode = onMismatch();
          } else {
          if (node.data !== vnode.children) {
            hasMismatch = true;
             true && warn("Hydration text mismatch:" + "\n- Client: ".concat(JSON.stringify(node.data)) + "\n- Server: ".concat(JSON.stringify(vnode.children)));
            node.data = vnode.children;
          }

          nextNode = nextSibling(node);
        }

        break;

      case Comment$1:
        if (domType !== 8
        /* COMMENT */
        || isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = nextSibling(node);
        }

        break;

      case Static:
        if (domType !== 1
        /* ELEMENT */
        ) {
            nextNode = onMismatch();
          } else {
          // determine anchor, adopt content
          nextNode = node; // if the static vnode has its content stripped during build,
          // adopt it from the server-rendered HTML.

          var needToAdoptContent = !vnode.children.length;

          for (var i = 0; i < vnode.staticCount; i++) {
            if (needToAdoptContent) vnode.children += nextNode.outerHTML;

            if (i === vnode.staticCount - 1) {
              vnode.anchor = nextNode;
            }

            nextNode = nextSibling(nextNode);
          }

          return nextNode;
        }

        break;

      case Fragment:
        if (!isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
        }

        break;

      default:
        if (shapeFlag & 1
        /* ELEMENT */
        ) {
            if (domType !== 1
            /* ELEMENT */
            || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) {
              nextNode = onMismatch();
            } else {
              nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
            }
          } else if (shapeFlag & 6
        /* COMPONENT */
        ) {
            // when setting up the render effect, if the initial vnode already
            // has .el set, the component will perform hydration instead of mount
            // on its sub-tree.
            vnode.slotScopeIds = slotScopeIds;
            var container = parentNode(node);
            mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized); // component may be async, so in the case of fragments we cannot rely
            // on component's rendered output to determine the end of the fragment
            // instead, we do a lookahead to find the end anchor node.

            nextNode = isFragmentStart ? locateClosingAsyncAnchor(node) : nextSibling(node); // #3787
            // if component is async, it may get moved / unmounted before its
            // inner component is loaded, so we need to give it a placeholder
            // vnode that matches its adopted DOM.

            if (isAsyncWrapper(vnode)) {
              var subTree;

              if (isFragmentStart) {
                subTree = createVNode(Fragment);
                subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
              } else {
                subTree = node.nodeType === 3 ? createTextVNode('') : createVNode('div');
              }

              subTree.el = node;
              vnode.component.subTree = subTree;
            }
          } else if (shapeFlag & 64
        /* TELEPORT */
        ) {
            if (domType !== 8
            /* COMMENT */
            ) {
                nextNode = onMismatch();
              } else {
              nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);
            }
          } else if (shapeFlag & 128
        /* SUSPENSE */
        ) {
            nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);
          } else if (true) {
          warn('Invalid HostVNode type:', type, "(".concat(_typeof(type), ")"));
        }

    }

    if (ref != null) {
      setRef(ref, null, parentSuspense, vnode);
    }

    return nextNode;
  };

  var hydrateElement = function hydrateElement(el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) {
    optimized = optimized || !!vnode.dynamicChildren;
    var props = vnode.props,
        patchFlag = vnode.patchFlag,
        shapeFlag = vnode.shapeFlag,
        dirs = vnode.dirs; // skip props & children if this is hoisted static nodes

    if (patchFlag !== -1
    /* HOISTED */
    ) {
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, 'created');
        } // props


        if (props) {
          if (!optimized || patchFlag & 16
          /* FULL_PROPS */
          || patchFlag & 32
          /* HYDRATE_EVENTS */
          ) {
            for (var key in props) {
              if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
                patchProp(el, key, null, props[key]);
              }
            }
          } else if (props.onClick) {
            // Fast path for click listeners (which is most often) to avoid
            // iterating through props.
            patchProp(el, 'onClick', null, props.onClick);
          }
        } // vnode / directive hooks


        var vnodeHooks;

        if (vnodeHooks = props && props.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHooks, parentComponent, vnode);
        }

        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');
        }

        if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {
          queueEffectWithSuspense(function () {
            vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
            dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');
          }, parentSuspense);
        } // children


        if (shapeFlag & 16
        /* ARRAY_CHILDREN */
        && // skip if element has innerHTML / textContent
        !(props && (props.innerHTML || props.textContent))) {
          var next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);
          var _hasWarned = false;

          while (next) {
            hasMismatch = true;

            if ( true && !_hasWarned) {
              warn("Hydration children mismatch in <".concat(vnode.type, ">: ") + "server rendered element contains more child nodes than client vdom.");
              _hasWarned = true;
            } // The SSRed DOM contains more nodes than it should. Remove them.


            var cur = next;
            next = next.nextSibling;
            remove(cur);
          }
        } else if (shapeFlag & 8
        /* TEXT_CHILDREN */
        ) {
            if (el.textContent !== vnode.children) {
              hasMismatch = true;
               true && warn("Hydration text content mismatch in <".concat(vnode.type, ">:\n") + "- Client: ".concat(el.textContent, "\n") + "- Server: ".concat(vnode.children));
              el.textContent = vnode.children;
            }
          }
      }

    return el.nextSibling;
  };

  var hydrateChildren = function hydrateChildren(node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) {
    optimized = optimized || !!parentVNode.dynamicChildren;
    var children = parentVNode.children;
    var l = children.length;
    var hasWarned = false;

    for (var i = 0; i < l; i++) {
      var vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i]);

      if (node) {
        node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
      } else if (vnode.type === Text && !vnode.children) {
        continue;
      } else {
        hasMismatch = true;

        if ( true && !hasWarned) {
          warn("Hydration children mismatch in <".concat(container.tagName.toLowerCase(), ">: ") + "server rendered element contains fewer child nodes than client vdom.");
          hasWarned = true;
        } // the SSRed DOM didn't contain enough nodes. Mount the missing ones.


        patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
      }
    }

    return node;
  };

  var hydrateFragment = function hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) {
    var fragmentSlotScopeIds = vnode.slotScopeIds;

    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }

    var container = parentNode(node);
    var next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);

    if (next && isComment(next) && next.data === ']') {
      return nextSibling(vnode.anchor = next);
    } else {
      // fragment didn't hydrate successfully, since we didn't get a end anchor
      // back. This should have led to node/children mismatch warnings.
      hasMismatch = true; // since the anchor is missing, we need to create one and insert it

      insert(vnode.anchor = createComment("]"), container, next);
      return next;
    }
  };

  var handleMismatch = function handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) {
    hasMismatch = true;
     true && warn("Hydration node mismatch:\n- Client vnode:", vnode.type, "\n- Server rendered DOM:", node, node.nodeType === 3
    /* TEXT */
    ? "(text)" : isComment(node) && node.data === '[' ? "(start of fragment)" : "");
    vnode.el = null;

    if (isFragment) {
      // remove excessive fragment nodes
      var end = locateClosingAsyncAnchor(node);

      while (true) {
        var _next2 = nextSibling(node);

        if (_next2 && _next2 !== end) {
          remove(_next2);
        } else {
          break;
        }
      }
    }

    var next = nextSibling(node);
    var container = parentNode(node);
    remove(node);
    patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
    return next;
  };

  var locateClosingAsyncAnchor = function locateClosingAsyncAnchor(node) {
    var match = 0;

    while (node) {
      node = nextSibling(node);

      if (node && isComment(node)) {
        if (node.data === '[') match++;

        if (node.data === ']') {
          if (match === 0) {
            return nextSibling(node);
          } else {
            match--;
          }
        }
      }
    }

    return node;
  };

  return [hydrate, hydrateNode];
}

var supported;
var perf;

function startMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    perf.mark("vue-".concat(type, "-").concat(instance.uid));
  }

  if (true) {
    devtoolsPerfStart(instance, type, supported ? perf.now() : Date.now());
  }
}

function endMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    var startTag = "vue-".concat(type, "-").concat(instance.uid);
    var endTag = startTag + ":end";
    perf.mark(endTag);
    perf.measure("<".concat(formatComponentName(instance, instance.type), "> ").concat(type), startTag, endTag);
    perf.clearMarks(startTag);
    perf.clearMarks(endTag);
  }

  if (true) {
    devtoolsPerfEnd(instance, type, supported ? perf.now() : Date.now());
  }
}

function isSupported() {
  if (supported !== undefined) {
    return supported;
  }
  /* eslint-disable no-restricted-globals */


  if (typeof window !== 'undefined' && window.performance) {
    supported = true;
    perf = window.performance;
  } else {
    supported = false;
  }
  /* eslint-enable no-restricted-globals */


  return supported;
}
/**
 * This is only called in esm-bundler builds.
 * It is called when a renderer is created, in `baseCreateRenderer` so that
 * importing runtime-core is side-effects free.
 *
 * istanbul-ignore-next
 */


function initFeatureFlags() {
  var needWarn = false;

  if (false) {}

  if (false) {}

  if ( true && needWarn) {
    console.warn("You are running the esm-bundler build of Vue. It is recommended to " + "configure your bundler to explicitly replace feature flag globals " + "with boolean literals to get proper tree-shaking in the final bundle. " + "See http://link.vuejs.org/feature-flags for more details.");
  }
}

var prodEffectOptions = {
  scheduler: queueJob,
  // #1801, #2043 component render effects should allow recursive updates
  allowRecurse: true
};

function createDevEffectOptions(instance) {
  return {
    scheduler: queueJob,
    allowRecurse: true,
    onTrack: instance.rtc ? function (e) {
      return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.rtc, e);
    } : void 0,
    onTrigger: instance.rtg ? function (e) {
      return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.rtg, e);
    } : void 0
  };
}

var queuePostRenderEffect = queueEffectWithSuspense;

var setRef = function setRef(rawRef, oldRawRef, parentSuspense, vnode) {
  var isUnmount = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(rawRef)) {
    rawRef.forEach(function (r, i) {
      return setRef(r, oldRawRef && ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount);
    });
    return;
  }

  if (isAsyncWrapper(vnode) && !isUnmount) {
    // when mounting async components, nothing needs to be done,
    // because the template ref is forwarded to inner component
    return;
  }

  var refValue = vnode.shapeFlag & 4
  /* STATEFUL_COMPONENT */
  ? vnode.component.exposed || vnode.component.proxy : vnode.el;
  var value = isUnmount ? null : refValue;
  var owner = rawRef.i,
      ref = rawRef.r;

  if ( true && !owner) {
    warn("Missing ref owner context. ref cannot be used on hoisted vnodes. " + "A vnode with ref must be created inside the render function.");
    return;
  }

  var oldRef = oldRawRef && oldRawRef.r;
  var refs = owner.refs === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ ? owner.refs = {} : owner.refs;
  var setupState = owner.setupState; // dynamic ref changed. unset old ref

  if (oldRef != null && oldRef !== ref) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(oldRef)) {
      refs[oldRef] = null;

      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(oldRef)) {
      oldRef.value = null;
    }
  }

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(ref)) {
    var doSet = function doSet() {
      {
        refs[ref] = value;
      }

      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, ref)) {
        setupState[ref] = value;
      }
    }; // #1789: for non-null values, set them after render
    // null values means this is unmount and it should not overwrite another
    // ref with the same key


    if (value) {
      doSet.id = -1;
      queuePostRenderEffect(doSet, parentSuspense);
    } else {
      doSet();
    }
  } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(ref)) {
    var _doSet = function _doSet() {
      ref.value = value;
    };

    if (value) {
      _doSet.id = -1;
      queuePostRenderEffect(_doSet, parentSuspense);
    } else {
      _doSet();
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(ref)) {
    callWithErrorHandling(ref, owner, 12
    /* FUNCTION_REF */
    , [value, refs]);
  } else if (true) {
    warn('Invalid template ref type:', value, "(".concat(_typeof(value), ")"));
  }
};
/**
 * The createRenderer function accepts two generic arguments:
 * HostNode and HostElement, corresponding to Node and Element types in the
 * host environment. For example, for runtime-dom, HostNode would be the DOM
 * `Node` interface and HostElement would be the DOM `Element` interface.
 *
 * Custom renderers can pass in the platform specific types like this:
 *
 * ``` js
 * const { render, createApp } = createRenderer<Node, Element>({
 *   patchProp,
 *   ...nodeOps
 * })
 * ```
 */


function createRenderer(options) {
  return baseCreateRenderer(options);
} // Separate API for creating hydration-enabled renderer.
// Hydration logic is only used when calling this function, making it
// tree-shakable.


function createHydrationRenderer(options) {
  return baseCreateRenderer(options, createHydrationFunctions);
} // implementation


function baseCreateRenderer(options, createHydrationFns) {
  // compile-time feature flags check
  {
    initFeatureFlags();
  }

  if (true) {
    var target = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)();
    target.__VUE__ = true;
    setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__);
  }

  var hostInsert = options.insert,
      hostRemove = options.remove,
      hostPatchProp = options.patchProp,
      hostForcePatchProp = options.forcePatchProp,
      hostCreateElement = options.createElement,
      hostCreateText = options.createText,
      hostCreateComment = options.createComment,
      hostSetText = options.setText,
      hostSetElementText = options.setElementText,
      hostParentNode = options.parentNode,
      hostNextSibling = options.nextSibling,
      _options$setScopeId = options.setScopeId,
      hostSetScopeId = _options$setScopeId === void 0 ? _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP : _options$setScopeId,
      hostCloneNode = options.cloneNode,
      hostInsertStaticContent = options.insertStaticContent; // Note: functions inside this closure should use `const xxx = () => {}`
  // style in order to prevent being inlined by minifiers.

  var patch = function patch(n1, n2, container) {
    var anchor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var parentComponent = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    var parentSuspense = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
    var isSVG = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
    var slotScopeIds = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;
    var optimized = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;

    // patching & not same type, unmount old tree
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }

    if (n2.patchFlag === -2
    /* BAIL */
    ) {
        optimized = false;
        n2.dynamicChildren = null;
      }

    var type = n2.type,
        ref = n2.ref,
        shapeFlag = n2.shapeFlag;

    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;

      case Comment$1:
        processCommentNode(n1, n2, container, anchor);
        break;

      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, isSVG);
        } else if (true) {
          patchStaticNode(n1, n2, container, isSVG);
        }

        break;

      case Fragment:
        processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        break;

      default:
        if (shapeFlag & 1
        /* ELEMENT */
        ) {
            processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          } else if (shapeFlag & 6
        /* COMPONENT */
        ) {
            processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          } else if (shapeFlag & 64
        /* TELEPORT */
        ) {
            type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
          } else if (shapeFlag & 128
        /* SUSPENSE */
        ) {
            type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
          } else if (true) {
          warn('Invalid VNode type:', type, "(".concat(_typeof(type), ")"));
        }

    } // set ref


    if (ref != null && parentComponent) {
      setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };

  var processText = function processText(n1, n2, container, anchor) {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
    } else {
      var el = n2.el = n1.el;

      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };

  var processCommentNode = function processCommentNode(n1, n2, container, anchor) {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateComment(n2.children || ''), container, anchor);
    } else {
      // there's no support for dynamic comments
      n2.el = n1.el;
    }
  };

  var mountStaticNode = function mountStaticNode(n2, container, anchor, isSVG) {
    var _hostInsertStaticCont = hostInsertStaticContent(n2.children, container, anchor, isSVG);

    var _hostInsertStaticCont2 = _slicedToArray(_hostInsertStaticCont, 2);

    n2.el = _hostInsertStaticCont2[0];
    n2.anchor = _hostInsertStaticCont2[1];
  };
  /**
   * Dev / HMR only
   */


  var patchStaticNode = function patchStaticNode(n1, n2, container, isSVG) {
    // static nodes are only patched during dev for HMR
    if (n2.children !== n1.children) {
      var anchor = hostNextSibling(n1.anchor); // remove existing

      removeStaticNode(n1);

      var _hostInsertStaticCont3 = hostInsertStaticContent(n2.children, container, anchor, isSVG);

      var _hostInsertStaticCont4 = _slicedToArray(_hostInsertStaticCont3, 2);

      n2.el = _hostInsertStaticCont4[0];
      n2.anchor = _hostInsertStaticCont4[1];
    } else {
      n2.el = n1.el;
      n2.anchor = n1.anchor;
    }
  };

  var moveStaticNode = function moveStaticNode(_ref12, container, nextSibling) {
    var el = _ref12.el,
        anchor = _ref12.anchor;
    var next;

    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }

    hostInsert(anchor, container, nextSibling);
  };

  var removeStaticNode = function removeStaticNode(_ref13) {
    var el = _ref13.el,
        anchor = _ref13.anchor;
    var next;

    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }

    hostRemove(anchor);
  };

  var processElement = function processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) {
    isSVG = isSVG || n2.type === 'svg';

    if (n1 == null) {
      mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };

  var mountElement = function mountElement(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) {
    var el;
    var vnodeHook;
    var type = vnode.type,
        props = vnode.props,
        shapeFlag = vnode.shapeFlag,
        transition = vnode.transition,
        patchFlag = vnode.patchFlag,
        dirs = vnode.dirs;

    if (false
    /* HOISTED */
    ) {} else {
      el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props); // mount children first, since some props may rely on child content
      // being already rendered, e.g. `<select value>`

      if (shapeFlag & 8
      /* TEXT_CHILDREN */
      ) {
          hostSetElementText(el, vnode.children);
        } else if (shapeFlag & 16
      /* ARRAY_CHILDREN */
      ) {
          mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== 'foreignObject', slotScopeIds, optimized || !!vnode.dynamicChildren);
        }

      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, 'created');
      } // props


      if (props) {
        for (var key in props) {
          if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) {
            hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }

        if (vnodeHook = props.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
      } // scopeId


      setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    }

    if (true) {
      Object.defineProperty(el, '__vnode', {
        value: vnode,
        enumerable: false
      });
      Object.defineProperty(el, '__vueParentComponent', {
        value: parentComponent,
        enumerable: false
      });
    }

    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');
    } // #1583 For inside suspense + suspense not resolved case, enter hook should call when suspense resolved
    // #1689 For inside suspense + suspense resolved case, just call it


    var needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;

    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }

    hostInsert(el, container, anchor);

    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(function () {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');
      }, parentSuspense);
    }
  };

  var setScopeId = function setScopeId(el, vnode, scopeId, slotScopeIds, parentComponent) {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }

    if (slotScopeIds) {
      for (var i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }

    if (parentComponent) {
      var subTree = parentComponent.subTree;

      if ( true && subTree.patchFlag > 0 && subTree.patchFlag & 2048
      /* DEV_ROOT_FRAGMENT */
      ) {
          subTree = filterSingleRoot(subTree.children) || subTree;
        }

      if (vnode === subTree) {
        var parentVNode = parentComponent.vnode;
        setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
      }
    }
  };

  var mountChildren = function mountChildren(children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) {
    var start = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;

    for (var i = start; i < children.length; i++) {
      var child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };

  var patchElement = function patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) {
    var el = n2.el = n1.el;
    var patchFlag = n2.patchFlag,
        dynamicChildren = n2.dynamicChildren,
        dirs = n2.dirs; // #1426 take the old vnode's patch flag into account since user may clone a
    // compiler-generated vnode, which de-opts to FULL_PROPS

    patchFlag |= n1.patchFlag & 16
    /* FULL_PROPS */
    ;
    var oldProps = n1.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    var newProps = n2.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    var vnodeHook;

    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }

    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, 'beforeUpdate');
    }

    if ( true && isHmrUpdating) {
      // HMR updated, force full diff
      patchFlag = 0;
      optimized = false;
      dynamicChildren = null;
    }

    if (patchFlag > 0) {
      // the presence of a patchFlag means this element's render code was
      // generated by the compiler and can take the fast path.
      // in this path old node and new node are guaranteed to have the same shape
      // (i.e. at the exact same position in the source template)
      if (patchFlag & 16
      /* FULL_PROPS */
      ) {
          // element props contain dynamic keys, full diff needed
          patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
        } else {
        // class
        // this flag is matched when the element has dynamic class bindings.
        if (patchFlag & 2
        /* CLASS */
        ) {
            if (oldProps.class !== newProps.class) {
              hostPatchProp(el, 'class', null, newProps.class, isSVG);
            }
          } // style
        // this flag is matched when the element has dynamic style bindings


        if (patchFlag & 4
        /* STYLE */
        ) {
            hostPatchProp(el, 'style', oldProps.style, newProps.style, isSVG);
          } // props
        // This flag is matched when the element has dynamic prop/attr bindings
        // other than class and style. The keys of dynamic prop/attrs are saved for
        // faster iteration.
        // Note dynamic keys like :[foo]="bar" will cause this optimization to
        // bail out and go through a full diff because we need to unset the old key


        if (patchFlag & 8
        /* PROPS */
        ) {
            // if the flag is present then dynamicProps must be non-null
            var propsToUpdate = n2.dynamicProps;

            for (var i = 0; i < propsToUpdate.length; i++) {
              var key = propsToUpdate[i];
              var prev = oldProps[key];
              var next = newProps[key];

              if (next !== prev || hostForcePatchProp && hostForcePatchProp(el, key)) {
                hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
              }
            }
          }
      } // text
      // This flag is matched when the element has only dynamic text children.


      if (patchFlag & 1
      /* TEXT */
      ) {
          if (n1.children !== n2.children) {
            hostSetElementText(el, n2.children);
          }
        }
    } else if (!optimized && dynamicChildren == null) {
      // unoptimized, full diff
      patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
    }

    var areChildrenSVG = isSVG && n2.type !== 'foreignObject';

    if (dynamicChildren) {
      patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);

      if ( true && parentComponent && parentComponent.type.__hmrId) {
        traverseStaticChildren(n1, n2);
      }
    } else if (!optimized) {
      // full diff
      patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
    }

    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(function () {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, 'updated');
      }, parentSuspense);
    }
  }; // The fast path for blocks.


  var patchBlockChildren = function patchBlockChildren(oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) {
    for (var i = 0; i < newChildren.length; i++) {
      var oldVNode = oldChildren[i];
      var newVNode = newChildren[i]; // Determine the container (parent element) for the patch.

      var container = // oldVNode may be an errored async setup() component inside Suspense
      // which will not have a mounted element
      oldVNode.el && ( // - In the case of a Fragment, we need to provide the actual parent
      // of the Fragment itself so it can move its children.
      oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
      // which also requires the correct parent container
      !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
      oldVNode.shapeFlag & 6
      /* COMPONENT */
      || oldVNode.shapeFlag & 64
      /* TELEPORT */
      ) ? hostParentNode(oldVNode.el) : // In other cases, the parent container is not actually used so we
      // just pass the block element here to avoid a DOM parentNode call.
      fallbackContainer;
      patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
    }
  };

  var patchProps = function patchProps(el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) {
    if (oldProps !== newProps) {
      for (var key in newProps) {
        // empty string is not valid prop
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) continue;
        var next = newProps[key];
        var prev = oldProps[key];

        if (next !== prev || hostForcePatchProp && hostForcePatchProp(el, key)) {
          hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
        }
      }

      if (oldProps !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
        for (var _key14 in oldProps) {
          if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(_key14) && !(_key14 in newProps)) {
            hostPatchProp(el, _key14, oldProps[_key14], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
      }
    }
  };

  var processFragment = function processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) {
    var fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText('');
    var fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText('');
    var patchFlag = n2.patchFlag,
        dynamicChildren = n2.dynamicChildren,
        fragmentSlotScopeIds = n2.slotScopeIds;

    if (dynamicChildren) {
      optimized = true;
    } // check if this is a slot fragment with :slotted scope ids


    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }

    if ( true && isHmrUpdating) {
      // HMR updated, force full diff
      patchFlag = 0;
      optimized = false;
      dynamicChildren = null;
    }

    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor); // a fragment can only have array children
      // since they are either generated by the compiler, or implicitly created
      // from arrays.

      mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      if (patchFlag > 0 && patchFlag & 64
      /* STABLE_FRAGMENT */
      && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        // a stable fragment (template root or <template v-for>) doesn't need to
        // patch children order, but it may contain dynamicChildren.
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);

        if ( true && parentComponent && parentComponent.type.__hmrId) {
          traverseStaticChildren(n1, n2);
        } else if ( // #2080 if the stable fragment has a key, it's a <template v-for> that may
        //  get moved around. Make sure all root level vnodes inherit el.
        // #2134 or if it's a component root, it may also get moved around
        // as the component is being moved.
        n2.key != null || parentComponent && n2 === parentComponent.subTree) {
          traverseStaticChildren(n1, n2, true
          /* shallow */
          );
        }
      } else {
        // keyed / unkeyed, or manual fragments.
        // for keyed & unkeyed, since they are compiler generated from v-for,
        // each child is guaranteed to be a block so the fragment will never
        // have dynamicChildren.
        patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
    }
  };

  var processComponent = function processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) {
    n2.slotScopeIds = slotScopeIds;

    if (n1 == null) {
      if (n2.shapeFlag & 512
      /* COMPONENT_KEPT_ALIVE */
      ) {
          parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
        } else {
        mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };

  var mountComponent = function mountComponent(initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) {
    var instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);

    if ( true && instance.type.__hmrId) {
      registerHMR(instance);
    }

    if (true) {
      pushWarningContext(initialVNode);
      startMeasure(instance, "mount");
    } // inject renderer internals for keepAlive


    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    } // resolve props and slots for setup context


    {
      if (true) {
        startMeasure(instance, "init");
      }

      setupComponent(instance);

      if (true) {
        endMeasure(instance, "init");
      }
    } // setup() is async. This component relies on async logic to be resolved
    // before proceeding

    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect); // Give it a placeholder if this is not hydration
      // TODO handle self-defined fallback

      if (!initialVNode.el) {
        var placeholder = instance.subTree = createVNode(Comment$1);
        processCommentNode(null, placeholder, container, anchor);
      }

      return;
    }

    setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);

    if (true) {
      popWarningContext();
      endMeasure(instance, "mount");
    }
  };

  var updateComponent = function updateComponent(n1, n2, optimized) {
    var instance = n2.component = n1.component;

    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        // async & still pending - just update props and slots
        // since the component's reactive effect for render isn't set-up yet
        if (true) {
          pushWarningContext(n2);
        }

        updateComponentPreRender(instance, n2, optimized);

        if (true) {
          popWarningContext();
        }

        return;
      } else {
        // normal update
        instance.next = n2; // in case the child component is also queued, remove it to avoid
        // double updating the same child component in the same flush.

        invalidateJob(instance.update); // instance.update is the reactive effect runner.

        instance.update();
      }
    } else {
      // no update needed. just copy over properties
      n2.component = n1.component;
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };

  var setupRenderEffect = function setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) {
    // create reactive effect for rendering
    instance.update = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.effect)(function componentEffect() {
      if (!instance.isMounted) {
        var vnodeHook;
        var _initialVNode = initialVNode,
            el = _initialVNode.el,
            props = _initialVNode.props;
        var bm = instance.bm,
            m = instance.m,
            parent = instance.parent; // beforeMount hook

        if (bm) {
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bm);
        } // onVnodeBeforeMount


        if (vnodeHook = props && props.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }

        if (el && hydrateNode) {
          // vnode has adopted host node - perform hydration instead of mount.
          var hydrateSubTree = function hydrateSubTree() {
            if (true) {
              startMeasure(instance, "render");
            }

            instance.subTree = renderComponentRoot(instance);

            if (true) {
              endMeasure(instance, "render");
            }

            if (true) {
              startMeasure(instance, "hydrate");
            }

            hydrateNode(el, instance.subTree, instance, parentSuspense, null);

            if (true) {
              endMeasure(instance, "hydrate");
            }
          };

          if (isAsyncWrapper(initialVNode)) {
            initialVNode.type.__asyncLoader().then( // note: we are moving the render call into an async callback,
            // which means it won't track dependencies - but it's ok because
            // a server-rendered async wrapper is already in resolved state
            // and it will never need to change.
            function () {
              return !instance.isUnmounted && hydrateSubTree();
            });
          } else {
            hydrateSubTree();
          }
        } else {
          if (true) {
            startMeasure(instance, "render");
          }

          var subTree = instance.subTree = renderComponentRoot(instance);

          if (true) {
            endMeasure(instance, "render");
          }

          if (true) {
            startMeasure(instance, "patch");
          }

          patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);

          if (true) {
            endMeasure(instance, "patch");
          }

          initialVNode.el = subTree.el;
        } // mounted hook


        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        } // onVnodeMounted


        if (vnodeHook = props && props.onVnodeMounted) {
          var scopedInitialVNode = initialVNode;
          queuePostRenderEffect(function () {
            return invokeVNodeHook(vnodeHook, parent, scopedInitialVNode);
          }, parentSuspense);
        } // activated hook for keep-alive roots.
        // #1742 activated hook must be accessed after first render
        // since the hook may be injected by a child keep-alive


        if (initialVNode.shapeFlag & 256
        /* COMPONENT_SHOULD_KEEP_ALIVE */
        ) {
            instance.a && queuePostRenderEffect(instance.a, parentSuspense);
          }

        instance.isMounted = true;

        if (true) {
          devtoolsComponentAdded(instance);
        } // #2458: deference mount-only object parameters to prevent memleaks


        initialVNode = container = anchor = null;
      } else {
        // updateComponent
        // This is triggered by mutation of component's own state (next: null)
        // OR parent calling processComponent (next: VNode)
        var next = instance.next,
            bu = instance.bu,
            u = instance.u,
            _parent = instance.parent,
            vnode = instance.vnode;
        var originNext = next;

        var _vnodeHook;

        if (true) {
          pushWarningContext(next || instance.vnode);
        }

        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        } // beforeUpdate hook


        if (bu) {
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bu);
        } // onVnodeBeforeUpdate


        if (_vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(_vnodeHook, _parent, next, vnode);
        } // render


        if (true) {
          startMeasure(instance, "render");
        }

        var nextTree = renderComponentRoot(instance);

        if (true) {
          endMeasure(instance, "render");
        }

        var prevTree = instance.subTree;
        instance.subTree = nextTree;

        if (true) {
          startMeasure(instance, "patch");
        }

        patch(prevTree, nextTree, // parent may have changed if it's in a teleport
        hostParentNode(prevTree.el), // anchor may have changed if it's in a fragment
        getNextHostNode(prevTree), instance, parentSuspense, isSVG);

        if (true) {
          endMeasure(instance, "patch");
        }

        next.el = nextTree.el;

        if (originNext === null) {
          // self-triggered update. In case of HOC, update parent component
          // vnode el. HOC is indicated by parent instance's subTree pointing
          // to child component's vnode
          updateHOCHostEl(instance, nextTree.el);
        } // updated hook


        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        } // onVnodeUpdated


        if (_vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(function () {
            return invokeVNodeHook(_vnodeHook, _parent, next, vnode);
          }, parentSuspense);
        }

        if (true) {
          devtoolsComponentUpdated(instance);
        }

        if (true) {
          popWarningContext();
        }
      }
    },  true ? createDevEffectOptions(instance) : 0);

    if (true) {
      // @ts-ignore
      instance.update.ownerInstance = instance;
    }
  };

  var updateComponentPreRender = function updateComponentPreRender(instance, nextVNode, optimized) {
    nextVNode.component = instance;
    var prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)(); // props update may have triggered pre-flush watchers.
    // flush them before the render update.

    flushPreFlushCbs(undefined, instance.update);
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
  };

  var patchChildren = function patchChildren(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds) {
    var optimized = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;
    var c1 = n1 && n1.children;
    var prevShapeFlag = n1 ? n1.shapeFlag : 0;
    var c2 = n2.children;
    var patchFlag = n2.patchFlag,
        shapeFlag = n2.shapeFlag; // fast path

    if (patchFlag > 0) {
      if (patchFlag & 128
      /* KEYED_FRAGMENT */
      ) {
          // this could be either fully-keyed or mixed (some keyed some not)
          // presence of patchFlag means children are guaranteed to be arrays
          patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          return;
        } else if (patchFlag & 256
      /* UNKEYED_FRAGMENT */
      ) {
          // unkeyed
          patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          return;
        }
    } // children has 3 possibilities: text, array or no children.


    if (shapeFlag & 8
    /* TEXT_CHILDREN */
    ) {
        // text children fast path
        if (prevShapeFlag & 16
        /* ARRAY_CHILDREN */
        ) {
            unmountChildren(c1, parentComponent, parentSuspense);
          }

        if (c2 !== c1) {
          hostSetElementText(container, c2);
        }
      } else {
      if (prevShapeFlag & 16
      /* ARRAY_CHILDREN */
      ) {
          // prev children was array
          if (shapeFlag & 16
          /* ARRAY_CHILDREN */
          ) {
              // two arrays, cannot assume anything, do full diff
              patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            } else {
            // no new children, just unmount old
            unmountChildren(c1, parentComponent, parentSuspense, true);
          }
        } else {
        // prev children was text OR null
        // new children is array OR null
        if (prevShapeFlag & 8
        /* TEXT_CHILDREN */
        ) {
            hostSetElementText(container, '');
          } // mount new if array


        if (shapeFlag & 16
        /* ARRAY_CHILDREN */
        ) {
            mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          }
      }
    }
  };

  var patchUnkeyedChildren = function patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) {
    c1 = c1 || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
    c2 = c2 || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
    var oldLength = c1.length;
    var newLength = c2.length;
    var commonLength = Math.min(oldLength, newLength);
    var i;

    for (i = 0; i < commonLength; i++) {
      var nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }

    if (oldLength > newLength) {
      // remove old
      unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
    } else {
      // mount new
      mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
    }
  }; // can be all-keyed or mixed


  var patchKeyedChildren = function patchKeyedChildren(c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) {
    var i = 0;
    var l2 = c2.length;
    var e1 = c1.length - 1; // prev ending index

    var e2 = l2 - 1; // next ending index
    // 1. sync from start
    // (a b) c
    // (a b) d e

    while (i <= e1 && i <= e2) {
      var n1 = c1[i];
      var n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);

      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }

      i++;
    } // 2. sync from end
    // a (b c)
    // d e (b c)


    while (i <= e1 && i <= e2) {
      var _n2 = c1[e1];

      var _n3 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);

      if (isSameVNodeType(_n2, _n3)) {
        patch(_n2, _n3, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }

      e1--;
      e2--;
    } // 3. common sequence + mount
    // (a b)
    // (a b) c
    // i = 2, e1 = 1, e2 = 2
    // (a b)
    // c (a b)
    // i = 0, e1 = -1, e2 = 0


    if (i > e1) {
      if (i <= e2) {
        var nextPos = e2 + 1;
        var anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;

        while (i <= e2) {
          patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          i++;
        }
      }
    } // 4. common sequence + unmount
    // (a b) c
    // (a b)
    // i = 2, e1 = 2, e2 = 1
    // a (b c)
    // (b c)
    // i = 0, e1 = 0, e2 = -1
    else if (i > e2) {
        while (i <= e1) {
          unmount(c1[i], parentComponent, parentSuspense, true);
          i++;
        }
      } // 5. unknown sequence
      // [i ... e1 + 1]: a b [c d e] f g
      // [i ... e2 + 1]: a b [e d c h] f g
      // i = 2, e1 = 4, e2 = 5
      else {
          var s1 = i; // prev starting index

          var s2 = i; // next starting index
          // 5.1 build key:index map for newChildren

          var keyToNewIndexMap = new Map();

          for (i = s2; i <= e2; i++) {
            var nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);

            if (nextChild.key != null) {
              if ( true && keyToNewIndexMap.has(nextChild.key)) {
                warn("Duplicate keys found during update:", JSON.stringify(nextChild.key), "Make sure keys are unique.");
              }

              keyToNewIndexMap.set(nextChild.key, i);
            }
          } // 5.2 loop through old children left to be patched and try to patch
          // matching nodes & remove nodes that are no longer present


          var j;
          var patched = 0;
          var toBePatched = e2 - s2 + 1;
          var moved = false; // used to track whether any node has moved

          var maxNewIndexSoFar = 0; // works as Map<newIndex, oldIndex>
          // Note that oldIndex is offset by +1
          // and oldIndex = 0 is a special value indicating the new node has
          // no corresponding old node.
          // used for determining longest stable subsequence

          var newIndexToOldIndexMap = new Array(toBePatched);

          for (i = 0; i < toBePatched; i++) {
            newIndexToOldIndexMap[i] = 0;
          }

          for (i = s1; i <= e1; i++) {
            var prevChild = c1[i];

            if (patched >= toBePatched) {
              // all new children have been patched so this can only be a removal
              unmount(prevChild, parentComponent, parentSuspense, true);
              continue;
            }

            var newIndex = void 0;

            if (prevChild.key != null) {
              newIndex = keyToNewIndexMap.get(prevChild.key);
            } else {
              // key-less node, try to locate a key-less node of the same type
              for (j = s2; j <= e2; j++) {
                if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                  newIndex = j;
                  break;
                }
              }
            }

            if (newIndex === undefined) {
              unmount(prevChild, parentComponent, parentSuspense, true);
            } else {
              newIndexToOldIndexMap[newIndex - s2] = i + 1;

              if (newIndex >= maxNewIndexSoFar) {
                maxNewIndexSoFar = newIndex;
              } else {
                moved = true;
              }

              patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
              patched++;
            }
          } // 5.3 move and mount
          // generate longest stable subsequence only when nodes have moved


          var increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;
          j = increasingNewIndexSequence.length - 1; // looping backwards so that we can use last patched node as anchor

          for (i = toBePatched - 1; i >= 0; i--) {
            var nextIndex = s2 + i;
            var _nextChild = c2[nextIndex];

            var _anchor2 = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;

            if (newIndexToOldIndexMap[i] === 0) {
              // mount new
              patch(null, _nextChild, container, _anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            } else if (moved) {
              // move if:
              // There is no stable subsequence (e.g. a reverse)
              // OR current node is not among the stable sequence
              if (j < 0 || i !== increasingNewIndexSequence[j]) {
                move(_nextChild, container, _anchor2, 2
                /* REORDER */
                );
              } else {
                j--;
              }
            }
          }
        }
  };

  var move = function move(vnode, container, anchor, moveType) {
    var parentSuspense = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    var el = vnode.el,
        type = vnode.type,
        transition = vnode.transition,
        children = vnode.children,
        shapeFlag = vnode.shapeFlag;

    if (shapeFlag & 6
    /* COMPONENT */
    ) {
        move(vnode.component.subTree, container, anchor, moveType);
        return;
      }

    if (shapeFlag & 128
    /* SUSPENSE */
    ) {
        vnode.suspense.move(container, anchor, moveType);
        return;
      }

    if (shapeFlag & 64
    /* TELEPORT */
    ) {
        type.move(vnode, container, anchor, internals);
        return;
      }

    if (type === Fragment) {
      hostInsert(el, container, anchor);

      for (var i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }

      hostInsert(vnode.anchor, container, anchor);
      return;
    }

    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    } // single nodes


    var needTransition = moveType !== 2
    /* REORDER */
    && shapeFlag & 1
    /* ELEMENT */
    && transition;

    if (needTransition) {
      if (moveType === 0
      /* ENTER */
      ) {
          transition.beforeEnter(el);
          hostInsert(el, container, anchor);
          queuePostRenderEffect(function () {
            return transition.enter(el);
          }, parentSuspense);
        } else {
        var leave = transition.leave,
            delayLeave = transition.delayLeave,
            afterLeave = transition.afterLeave;

        var _remove = function _remove() {
          return hostInsert(el, container, anchor);
        };

        var performLeave = function performLeave() {
          leave(el, function () {
            _remove();

            afterLeave && afterLeave();
          });
        };

        if (delayLeave) {
          delayLeave(el, _remove, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };

  var unmount = function unmount(vnode, parentComponent, parentSuspense) {
    var doRemove = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var optimized = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    var type = vnode.type,
        props = vnode.props,
        ref = vnode.ref,
        children = vnode.children,
        dynamicChildren = vnode.dynamicChildren,
        shapeFlag = vnode.shapeFlag,
        patchFlag = vnode.patchFlag,
        dirs = vnode.dirs; // unset ref

    if (ref != null) {
      setRef(ref, null, parentSuspense, vnode, true);
    }

    if (shapeFlag & 256
    /* COMPONENT_SHOULD_KEEP_ALIVE */
    ) {
        parentComponent.ctx.deactivate(vnode);
        return;
      }

    var shouldInvokeDirs = shapeFlag & 1
    /* ELEMENT */
    && dirs;
    var vnodeHook;

    if (vnodeHook = props && props.onVnodeBeforeUnmount) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }

    if (shapeFlag & 6
    /* COMPONENT */
    ) {
        unmountComponent(vnode.component, parentSuspense, doRemove);
      } else {
      if (shapeFlag & 128
      /* SUSPENSE */
      ) {
          vnode.suspense.unmount(parentSuspense, doRemove);
          return;
        }

      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, 'beforeUnmount');
      }

      if (shapeFlag & 64
      /* TELEPORT */
      ) {
          vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
        } else if (dynamicChildren && ( // #1153: fast path should not be taken for non-stable (v-for) fragments
      type !== Fragment || patchFlag > 0 && patchFlag & 64
      /* STABLE_FRAGMENT */
      )) {
        // fast path for block nodes: only need to unmount dynamic children.
        unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
      } else if (type === Fragment && (patchFlag & 128
      /* KEYED_FRAGMENT */
      || patchFlag & 256
      /* UNKEYED_FRAGMENT */
      ) || !optimized && shapeFlag & 16
      /* ARRAY_CHILDREN */
      ) {
        unmountChildren(children, parentComponent, parentSuspense);
      }

      if (doRemove) {
        remove(vnode);
      }
    }

    if ((vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(function () {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, 'unmounted');
      }, parentSuspense);
    }
  };

  var remove = function remove(vnode) {
    var type = vnode.type,
        el = vnode.el,
        anchor = vnode.anchor,
        transition = vnode.transition;

    if (type === Fragment) {
      removeFragment(el, anchor);
      return;
    }

    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }

    var performRemove = function performRemove() {
      hostRemove(el);

      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };

    if (vnode.shapeFlag & 1
    /* ELEMENT */
    && transition && !transition.persisted) {
      var leave = transition.leave,
          delayLeave = transition.delayLeave;

      var performLeave = function performLeave() {
        return leave(el, performRemove);
      };

      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };

  var removeFragment = function removeFragment(cur, end) {
    // For fragments, directly remove all contained DOM nodes.
    // (fragment child nodes cannot have transition)
    var next;

    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }

    hostRemove(end);
  };

  var unmountComponent = function unmountComponent(instance, parentSuspense, doRemove) {
    if ( true && instance.type.__hmrId) {
      unregisterHMR(instance);
    }

    var bum = instance.bum,
        effects = instance.effects,
        update = instance.update,
        subTree = instance.subTree,
        um = instance.um; // beforeUnmount hook

    if (bum) {
      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bum);
    }

    if (effects) {
      for (var i = 0; i < effects.length; i++) {
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.stop)(effects[i]);
      }
    } // update may be null if a component is unmounted before its async
    // setup has resolved.


    if (update) {
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.stop)(update);
      unmount(subTree, instance, parentSuspense, doRemove);
    } // unmounted hook


    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }

    queuePostRenderEffect(function () {
      instance.isUnmounted = true;
    }, parentSuspense); // A component with async dep inside a pending suspense is unmounted before
    // its async dep resolves. This should remove the dep from the suspense, and
    // cause the suspense to resolve immediately if that was the last dep.

    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;

      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }

    if (true) {
      devtoolsComponentRemoved(instance);
    }
  };

  var unmountChildren = function unmountChildren(children, parentComponent, parentSuspense) {
    var doRemove = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var optimized = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    var start = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

    for (var i = start; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };

  var getNextHostNode = function getNextHostNode(vnode) {
    if (vnode.shapeFlag & 6
    /* COMPONENT */
    ) {
        return getNextHostNode(vnode.component.subTree);
      }

    if (vnode.shapeFlag & 128
    /* SUSPENSE */
    ) {
        return vnode.suspense.next();
      }

    return hostNextSibling(vnode.anchor || vnode.el);
  };

  var render = function render(vnode, container, isSVG) {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(container._vnode || null, vnode, container, null, null, null, isSVG);
    }

    flushPostFlushCbs();
    container._vnode = vnode;
  };

  var internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  var hydrate;
  var hydrateNode;

  if (createHydrationFns) {
    var _createHydrationFns = createHydrationFns(internals);

    var _createHydrationFns2 = _slicedToArray(_createHydrationFns, 2);

    hydrate = _createHydrationFns2[0];
    hydrateNode = _createHydrationFns2[1];
  }

  return {
    render: render,
    hydrate: hydrate,
    createApp: createAppAPI(render, hydrate)
  };
}

function invokeVNodeHook(hook, instance, vnode) {
  var prevVNode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  callWithAsyncErrorHandling(hook, instance, 7
  /* VNODE_HOOK */
  , [vnode, prevVNode]);
}
/**
 * #1156
 * When a component is HMR-enabled, we need to make sure that all static nodes
 * inside a block also inherit the DOM element from the previous tree so that
 * HMR updates (which are full updates) can retrieve the element for patching.
 *
 * #2080
 * Inside keyed `template` fragment static children, if a fragment is moved,
 * the children will always moved so that need inherit el form previous nodes
 * to ensure correct moved position.
 */


function traverseStaticChildren(n1, n2) {
  var shallow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var ch1 = n1.children;
  var ch2 = n2.children;

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ch1) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ch2)) {
    for (var i = 0; i < ch1.length; i++) {
      // this is only called in the optimized path so array children are
      // guaranteed to be vnodes
      var c1 = ch1[i];
      var c2 = ch2[i];

      if (c2.shapeFlag & 1
      /* ELEMENT */
      && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32
        /* HYDRATE_EVENTS */
        ) {
            c2 = ch2[i] = cloneIfMounted(ch2[i]);
            c2.el = c1.el;
          }

        if (!shallow) traverseStaticChildren(c1, c2);
      } // also inherit for comment nodes, but not placeholders (e.g. v-if which
      // would have received .el during block patch)


      if ( true && c2.type === Comment$1 && !c2.el) {
        c2.el = c1.el;
      }
    }
  }
} // https://en.wikipedia.org/wiki/Longest_increasing_subsequence


function getSequence(arr) {
  var p = arr.slice();
  var result = [0];
  var i, j, u, v, c;
  var len = arr.length;

  for (i = 0; i < len; i++) {
    var arrI = arr[i];

    if (arrI !== 0) {
      j = result[result.length - 1];

      if (arr[j] < arrI) {
        p[i] = j;
        result.push(i);
        continue;
      }

      u = 0;
      v = result.length - 1;

      while (u < v) {
        c = (u + v) / 2 | 0;

        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }

      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p[i] = result[u - 1];
        }

        result[u] = i;
      }
    }
  }

  u = result.length;
  v = result[u - 1];

  while (u-- > 0) {
    result[u] = v;
    v = p[v];
  }

  return result;
}

var isTeleport = function isTeleport(type) {
  return type.__isTeleport;
};

var isTeleportDisabled = function isTeleportDisabled(props) {
  return props && (props.disabled || props.disabled === '');
};

var isTargetSVG = function isTargetSVG(target) {
  return typeof SVGElement !== 'undefined' && target instanceof SVGElement;
};

var resolveTarget = function resolveTarget(props, select) {
  var targetSelector = props && props.to;

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(targetSelector)) {
    if (!select) {
       true && warn("Current renderer does not support string target for Teleports. " + "(missing querySelector renderer option)");
      return null;
    } else {
      var target = select(targetSelector);

      if (!target) {
         true && warn("Failed to locate Teleport target with selector \"".concat(targetSelector, "\". ") + "Note the target element must exist before the component is mounted - " + "i.e. the target cannot be rendered by the component itself, and " + "ideally should be outside of the entire Vue component tree.");
      }

      return target;
    }
  } else {
    if ( true && !targetSelector && !isTeleportDisabled(props)) {
      warn("Invalid Teleport target: ".concat(targetSelector));
    }

    return targetSelector;
  }
};

var TeleportImpl = {
  __isTeleport: true,
  process: function (_process) {
    function process(_x, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9, _x10) {
      return _process.apply(this, arguments);
    }

    process.toString = function () {
      return _process.toString();
    };

    return process;
  }(function (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
    var mountChildren = internals.mc,
        patchChildren = internals.pc,
        patchBlockChildren = internals.pbc,
        _internals$o = internals.o,
        insert = _internals$o.insert,
        querySelector = _internals$o.querySelector,
        createText = _internals$o.createText,
        createComment = _internals$o.createComment;
    var disabled = isTeleportDisabled(n2.props);
    var shapeFlag = n2.shapeFlag,
        children = n2.children,
        dynamicChildren = n2.dynamicChildren; // #3302
    // HMR updated, force full diff

    if ( true && isHmrUpdating) {
      optimized = false;
      dynamicChildren = null;
    }

    if (n1 == null) {
      // insert anchors in the main view
      var placeholder = n2.el =  true ? createComment('teleport start') : 0;
      var mainAnchor = n2.anchor =  true ? createComment('teleport end') : 0;
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      var target = n2.target = resolveTarget(n2.props, querySelector);
      var targetAnchor = n2.targetAnchor = createText('');

      if (target) {
        insert(targetAnchor, target); // #2652 we could be teleporting from a non-SVG tree into an SVG tree

        isSVG = isSVG || isTargetSVG(target);
      } else if ( true && !disabled) {
        warn('Invalid Teleport target on mount:', target, "(".concat(_typeof(target), ")"));
      }

      var mount = function mount(container, anchor) {
        // Teleport *always* has Array children. This is enforced in both the
        // compiler and vnode children normalization.
        if (shapeFlag & 16
        /* ARRAY_CHILDREN */
        ) {
            mountChildren(children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          }
      };

      if (disabled) {
        mount(container, mainAnchor);
      } else if (target) {
        mount(target, targetAnchor);
      }
    } else {
      // update content
      n2.el = n1.el;

      var _mainAnchor = n2.anchor = n1.anchor;

      var _target = n2.target = n1.target;

      var _targetAnchor = n2.targetAnchor = n1.targetAnchor;

      var wasDisabled = isTeleportDisabled(n1.props);
      var currentContainer = wasDisabled ? container : _target;
      var currentAnchor = wasDisabled ? _mainAnchor : _targetAnchor;
      isSVG = isSVG || isTargetSVG(_target);

      if (dynamicChildren) {
        // fast path when the teleport happens to be a block root
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds); // even in block tree mode we need to make sure all root-level nodes
        // in the teleport inherit previous DOM references so that they can
        // be moved in future patches.

        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);
      }

      if (disabled) {
        if (!wasDisabled) {
          // enabled -> disabled
          // move into main container
          moveTeleport(n2, container, _mainAnchor, internals, 1
          /* TOGGLE */
          );
        }
      } else {
        // target changed
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          var nextTarget = n2.target = resolveTarget(n2.props, querySelector);

          if (nextTarget) {
            moveTeleport(n2, nextTarget, null, internals, 0
            /* TARGET_CHANGE */
            );
          } else if (true) {
            warn('Invalid Teleport target on update:', _target, "(".concat(_typeof(_target), ")"));
          }
        } else if (wasDisabled) {
          // disabled -> enabled
          // move into teleport target
          moveTeleport(n2, _target, _targetAnchor, internals, 1
          /* TOGGLE */
          );
        }
      }
    }
  }),
  remove: function remove(vnode, parentComponent, parentSuspense, optimized, _ref14, doRemove) {
    var unmount = _ref14.um,
        hostRemove = _ref14.o.remove;
    var shapeFlag = vnode.shapeFlag,
        children = vnode.children,
        anchor = vnode.anchor,
        targetAnchor = vnode.targetAnchor,
        target = vnode.target,
        props = vnode.props;

    if (target) {
      hostRemove(targetAnchor);
    } // an unmounted teleport should always remove its children if not disabled


    if (doRemove || !isTeleportDisabled(props)) {
      hostRemove(anchor);

      if (shapeFlag & 16
      /* ARRAY_CHILDREN */
      ) {
          for (var i = 0; i < children.length; i++) {
            var child = children[i];
            unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);
          }
        }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};

function moveTeleport(vnode, container, parentAnchor, _ref15)
/* REORDER */
{
  var insert = _ref15.o.insert,
      move = _ref15.m;
  var moveType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 2;

  // move target anchor if this is a target change.
  if (moveType === 0
  /* TARGET_CHANGE */
  ) {
      insert(vnode.targetAnchor, container, parentAnchor);
    }

  var el = vnode.el,
      anchor = vnode.anchor,
      shapeFlag = vnode.shapeFlag,
      children = vnode.children,
      props = vnode.props;
  var isReorder = moveType === 2
  /* REORDER */
  ; // move main view anchor if this is a re-order.

  if (isReorder) {
    insert(el, container, parentAnchor);
  } // if this is a re-order and teleport is enabled (content is in target)
  // do not move children. So the opposite is: only move children if this
  // is not a reorder, or the teleport is disabled


  if (!isReorder || isTeleportDisabled(props)) {
    // Teleport has either Array children or no children.
    if (shapeFlag & 16
    /* ARRAY_CHILDREN */
    ) {
        for (var i = 0; i < children.length; i++) {
          move(children[i], container, parentAnchor, 2
          /* REORDER */
          );
        }
      }
  } // move main view anchor if this is a re-order.


  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}

function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, _ref16, hydrateChildren) {
  var _ref16$o = _ref16.o,
      nextSibling = _ref16$o.nextSibling,
      parentNode = _ref16$o.parentNode,
      querySelector = _ref16$o.querySelector;
  var target = vnode.target = resolveTarget(vnode.props, querySelector);

  if (target) {
    // if multiple teleports rendered to the same target element, we need to
    // pick up from where the last teleport finished instead of the first node
    var targetNode = target._lpa || target.firstChild;

    if (vnode.shapeFlag & 16
    /* ARRAY_CHILDREN */
    ) {
        if (isTeleportDisabled(vnode.props)) {
          vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
          vnode.targetAnchor = targetNode;
        } else {
          vnode.anchor = nextSibling(node);
          vnode.targetAnchor = hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
        }

        target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
      }
  }

  return vnode.anchor && nextSibling(vnode.anchor);
} // Force-casted public typing for h and TSX props inference


var Teleport = TeleportImpl;
var COMPONENTS = 'components';
var DIRECTIVES = 'directives';
/**
 * @private
 */

function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}

var NULL_DYNAMIC_COMPONENT = Symbol();
/**
 * @private
 */

function resolveDynamicComponent(component) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    // invalid types will fallthrough to createVNode and raise warning
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
/**
 * @private
 */


function resolveDirective(name) {
  return resolveAsset(DIRECTIVES, name);
} // implementation


function resolveAsset(type, name) {
  var warnMissing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var maybeSelfReference = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var instance = currentRenderingInstance || currentInstance;

  if (instance) {
    var Component = instance.type; // explicit self name has highest priority

    if (type === COMPONENTS) {
      var selfName = getComponentName(Component);

      if (selfName && (selfName === name || selfName === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name) || selfName === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name)))) {
        return Component;
      }
    }

    var res = // local registration
    // check instance[type] first which is resolved for options API
    resolve(instance[type] || Component[type], name) || // global registration
    resolve(instance.appContext[type], name);

    if (!res && maybeSelfReference) {
      // fallback to implicit self-reference
      return Component;
    }

    if ( true && warnMissing && !res) {
      warn("Failed to resolve ".concat(type.slice(0, -1), ": ").concat(name));
    }

    return res;
  } else if (true) {
    warn("resolve".concat((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)(type.slice(0, -1)), " ") + "can only be used in render() or setup().");
  }
}

function resolve(registry, name) {
  return registry && (registry[name] || registry[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name)] || registry[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name))]);
}

var Fragment = Symbol( true ? 'Fragment' : 0);
var Text = Symbol( true ? 'Text' : 0);
var Comment$1 = Symbol( true ? 'Comment' : 0);
var Static = Symbol( true ? 'Static' : 0); // Since v-if and v-for are the two possible ways node structure can dynamically
// change, once we consider v-if branches and each v-for fragment a block, we
// can divide a template into nested blocks, and within each block the node
// structure would be stable. This allows us to skip most children diffing
// and only worry about the dynamic nodes (indicated by patch flags).

var blockStack = [];
var currentBlock = null;
/**
 * Open a block.
 * This must be called before `createBlock`. It cannot be part of `createBlock`
 * because the children of the block are evaluated before `createBlock` itself
 * is called. The generated code typically looks like this:
 *
 * ```js
 * function render() {
 *   return (openBlock(),createBlock('div', null, [...]))
 * }
 * ```
 * disableTracking is true when creating a v-for fragment block, since a v-for
 * fragment always diffs its children.
 *
 * @private
 */

function openBlock() {
  var disableTracking = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  blockStack.push(currentBlock = disableTracking ? null : []);
}

function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
} // Whether we should be tracking dynamic child nodes inside a block.
// Only tracks when this value is > 0
// We are not using a simple boolean because this value may need to be
// incremented/decremented by nested usage of v-once (see below)


var isBlockTreeEnabled = 1;
/**
 * Block tracking sometimes needs to be disabled, for example during the
 * creation of a tree that needs to be cached by v-once. The compiler generates
 * code like this:
 *
 * ``` js
 * _cache[1] || (
 *   setBlockTracking(-1),
 *   _cache[1] = createVNode(...),
 *   setBlockTracking(1),
 *   _cache[1]
 * )
 * ```
 *
 * @private
 */

function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}
/**
 * Create a block root vnode. Takes the same exact arguments as `createVNode`.
 * A block root keeps track of dynamic nodes within the block in the
 * `dynamicChildren` array.
 *
 * @private
 */


function createBlock(type, props, children, patchFlag, dynamicProps) {
  var vnode = createVNode(type, props, children, patchFlag, dynamicProps, true
  /* isBlock: prevent a block from tracking itself */
  ); // save current block children on the block vnode

  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR : null; // close block

  closeBlock(); // a block is always going to be patched, so track it as a child of its
  // parent block

  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }

  return vnode;
}

function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}

function isSameVNodeType(n1, n2) {
  if ( true && n2.shapeFlag & 6
  /* COMPONENT */
  && hmrDirtyComponents.has(n2.type)) {
    // HMR only: if the component has been hot-updated, force a reload.
    return false;
  }

  return n1.type === n2.type && n1.key === n2.key;
}

var vnodeArgsTransformer;
/**
 * Internal API for registering an arguments transform for createVNode
 * used for creating stubs in the test-utils
 * It is *internal* but needs to be exposed for test-utils to pick up proper
 * typings
 */

function transformVNodeArgs(transformer) {
  vnodeArgsTransformer = transformer;
}

var createVNodeWithArgsTransform = function createVNodeWithArgsTransform() {
  for (var _len7 = arguments.length, args = new Array(_len7), _key15 = 0; _key15 < _len7; _key15++) {
    args[_key15] = arguments[_key15];
  }

  return _createVNode.apply(void 0, _toConsumableArray(vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args));
};

var InternalObjectKey = "__vInternal";

var normalizeKey = function normalizeKey(_ref17) {
  var key = _ref17.key;
  return key != null ? key : null;
};

var normalizeRef = function normalizeRef(_ref18) {
  var ref = _ref18.ref;
  return ref != null ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(ref) || (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(ref) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(ref) ? {
    i: currentRenderingInstance,
    r: ref
  } : ref : null;
};

var createVNode =  true ? createVNodeWithArgsTransform : 0;

function _createVNode(type) {
  var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var patchFlag = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var dynamicProps = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
  var isBlockNode = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    if ( true && !type) {
      warn("Invalid vnode type when creating vnode: ".concat(type, "."));
    }

    type = Comment$1;
  }

  if (isVNode(type)) {
    // createVNode receiving an existing vnode. This happens in cases like
    // <component :is="vnode"/>
    // #2078 make sure to merge refs during the clone instead of overwriting it
    var cloned = cloneVNode(type, props, true
    /* mergeRef: true */
    );

    if (children) {
      normalizeChildren(cloned, children);
    }

    return cloned;
  } // class component normalization.


  if (isClassComponent(type)) {
    type = type.__vccOpts;
  } // class & style normalization.


  if (props) {
    // for reactive or proxy objects, we need to clone it to enable mutation.
    if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(props) || InternalObjectKey in props) {
      props = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, props);
    }

    var _props = props,
        klass = _props.class,
        style = _props.style;

    if (klass && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(klass)) {
      props.class = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(klass);
    }

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(style)) {
      // reactive state objects need to be cloned since they are likely to be
      // mutated
      if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(style) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(style)) {
        style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, style);
      }

      props.style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle)(style);
    }
  } // encode the vnode type information into a bitmap


  var shapeFlag = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(type) ? 1
  /* ELEMENT */
  : isSuspense(type) ? 128
  /* SUSPENSE */
  : isTeleport(type) ? 64
  /* TELEPORT */
  : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(type) ? 4
  /* STATEFUL_COMPONENT */
  : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(type) ? 2
  /* FUNCTIONAL_COMPONENT */
  : 0;

  if ( true && shapeFlag & 4
  /* STATEFUL_COMPONENT */
  && (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(type)) {
    type = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(type);
    warn("Vue received a Component which was made a reactive object. This can " + "lead to unnecessary performance overhead, and should be avoided by " + "marking the component with `markRaw` or using `shallowRef` " + "instead of `ref`.", "\nComponent that was made reactive: ", type);
  }

  var vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type: type,
    props: props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children: null,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: shapeFlag,
    patchFlag: patchFlag,
    dynamicProps: dynamicProps,
    dynamicChildren: null,
    appContext: null
  }; // validate key

  if ( true && vnode.key !== vnode.key) {
    warn("VNode created with invalid key (NaN). VNode type:", vnode.type);
  }

  normalizeChildren(vnode, children); // normalize suspense children

  if (shapeFlag & 128
  /* SUSPENSE */
  ) {
      type.normalize(vnode);
    }

  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && ( // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  patchFlag > 0 || shapeFlag & 6
  /* COMPONENT */
  ) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  patchFlag !== 32
  /* HYDRATE_EVENTS */
  ) {
      currentBlock.push(vnode);
    }

  return vnode;
}

function cloneVNode(vnode, extraProps) {
  var mergeRef = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  // This is intentionally NOT using spread or extend to avoid the runtime
  // key enumeration cost.
  var props = vnode.props,
      ref = vnode.ref,
      patchFlag = vnode.patchFlag,
      children = vnode.children;
  var mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  var cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? // #2078 in the case of <component :is="vnode" ref="extra"/>
    // if the vnode itself already has a ref, cloneVNode will need to merge
    // the refs so the single vnode can be set on multiple refs
    mergeRef && ref ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ref) ? ref.concat(normalizeRef(extraProps)) : [ref, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children:  true && patchFlag === -1
    /* HOISTED */
    && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(children) ? children.map(deepCloneVNode) : children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: perserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 // hoisted node
    ? 16
    /* FULL_PROPS */
    : patchFlag | 16
    /* FULL_PROPS */
    : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor
  };
  return cloned;
}
/**
 * Dev only, for HMR of hoisted vnodes reused in v-for
 * https://github.com/vitejs/vite/issues/2022
 */


function deepCloneVNode(vnode) {
  var cloned = cloneVNode(vnode);

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(vnode.children)) {
    cloned.children = vnode.children.map(deepCloneVNode);
  }

  return cloned;
}
/**
 * @private
 */


function createTextVNode() {
  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ' ';
  var flag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return createVNode(Text, null, text, flag);
}
/**
 * @private
 */


function createStaticVNode(content, numberOfNodes) {
  // A static vnode can contain multiple stringified elements, and the number
  // of elements is necessary for hydration.
  var vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
/**
 * @private
 */


function createCommentVNode() {
  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var asBlock = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return asBlock ? (openBlock(), createBlock(Comment$1, null, text)) : createVNode(Comment$1, null, text);
}

function normalizeVNode(child) {
  if (child == null || typeof child === 'boolean') {
    // empty placeholder
    return createVNode(Comment$1);
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(child)) {
    // fragment
    return createVNode(Fragment, null, // #3666, avoid reference pollution when reusing vnode
    child.slice());
  } else if (_typeof(child) === 'object') {
    // already vnode, this should be the most common since compiled templates
    // always produce all-vnode children arrays
    return cloneIfMounted(child);
  } else {
    // strings and numbers
    return createVNode(Text, null, String(child));
  }
} // optimized normalization for template-compiled render fns


function cloneIfMounted(child) {
  return child.el === null ? child : cloneVNode(child);
}

function normalizeChildren(vnode, children) {
  var type = 0;
  var shapeFlag = vnode.shapeFlag;

  if (children == null) {
    children = null;
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(children)) {
    type = 16
    /* ARRAY_CHILDREN */
    ;
  } else if (_typeof(children) === 'object') {
    if (shapeFlag & 1
    /* ELEMENT */
    || shapeFlag & 64
    /* TELEPORT */
    ) {
        // Normalize slot to plain children for plain element and Teleport
        var slot = children.default;

        if (slot) {
          // _c marker is added by withCtx() indicating this is a compiled slot
          slot._c && (slot._d = false);
          normalizeChildren(vnode, slot());
          slot._c && (slot._d = true);
        }

        return;
      } else {
      type = 32
      /* SLOTS_CHILDREN */
      ;
      var slotFlag = children._;

      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3
      /* FORWARDED */
      && currentRenderingInstance) {
        // a child component receives forwarded slots from the parent.
        // its slot type is determined by its parent's slot type.
        if (currentRenderingInstance.slots._ === 1
        /* STABLE */
        ) {
            children._ = 1
            /* STABLE */
            ;
          } else {
          children._ = 2
          /* DYNAMIC */
          ;
          vnode.patchFlag |= 1024
          /* DYNAMIC_SLOTS */
          ;
        }
      }
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(children)) {
    children = {
      default: children,
      _ctx: currentRenderingInstance
    };
    type = 32
    /* SLOTS_CHILDREN */
    ;
  } else {
    children = String(children); // force teleport children to array so it can be moved around

    if (shapeFlag & 64
    /* TELEPORT */
    ) {
        type = 16
        /* ARRAY_CHILDREN */
        ;
        children = [createTextVNode(children)];
      } else {
      type = 8
      /* TEXT_CHILDREN */
      ;
    }
  }

  vnode.children = children;
  vnode.shapeFlag |= type;
}

function mergeProps() {
  var ret = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, arguments.length <= 0 ? undefined : arguments[0]);

  for (var i = 1; i < arguments.length; i++) {
    var toMerge = i < 0 || arguments.length <= i ? undefined : arguments[i];

    for (var key in toMerge) {
      if (key === 'class') {
        if (ret.class !== toMerge.class) {
          ret.class = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)([ret.class, toMerge.class]);
        }
      } else if (key === 'style') {
        ret.style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle)([ret.style, toMerge.style]);
      } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
        var existing = ret[key];
        var incoming = toMerge[key];

        if (existing !== incoming) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== '') {
        ret[key] = toMerge[key];
      }
    }
  }

  return ret;
}
/**
 * Actual implementation
 */


function renderList(source, renderItem) {
  var ret;

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(source) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(source)) {
    ret = new Array(source.length);

    for (var i = 0, l = source.length; i < l; i++) {
      ret[i] = renderItem(source[i], i);
    }
  } else if (typeof source === 'number') {
    if ( true && !Number.isInteger(source)) {
      warn("The v-for range expect an integer value but got ".concat(source, "."));
      return [];
    }

    ret = new Array(source);

    for (var _i3 = 0; _i3 < source; _i3++) {
      ret[_i3] = renderItem(_i3 + 1, _i3);
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(source, renderItem);
    } else {
      var keys = Object.keys(source);
      ret = new Array(keys.length);

      for (var _i4 = 0, _l = keys.length; _i4 < _l; _i4++) {
        var key = keys[_i4];
        ret[_i4] = renderItem(source[key], key, _i4);
      }
    }
  } else {
    ret = [];
  }

  return ret;
}
/**
 * Compiler runtime helper for creating dynamic slots object
 * @private
 */


function createSlots(slots, dynamicSlots) {
  for (var i = 0; i < dynamicSlots.length; i++) {
    var slot = dynamicSlots[i]; // array of dynamic slot generated by <template v-for="..." #[...]>

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(slot)) {
      for (var j = 0; j < slot.length; j++) {
        slots[slot[j].name] = slot[j].fn;
      }
    } else if (slot) {
      // conditional single slot generated by <template v-if="..." #foo>
      slots[slot.name] = slot.fn;
    }
  }

  return slots;
}
/**
 * Compiler runtime helper for rendering `<slot/>`
 * @private
 */


function renderSlot(slots, name) {
  var props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var // this is not a user-facing function, so the fallback is always generated by
  // the compiler and guaranteed to be a function returning an array
  fallback = arguments.length > 3 ? arguments[3] : undefined;
  var noSlotted = arguments.length > 4 ? arguments[4] : undefined;
  var slot = slots[name];

  if ( true && slot && slot.length > 1) {
    warn("SSR-optimized slot function detected in a non-SSR-optimized render " + "function. You need to mark this component with $dynamic-slots in the " + "parent template.");

    slot = function slot() {
      return [];
    };
  } // a compiled slot disables block tracking by default to avoid manual
  // invocation interfering with template-based block tracking, but in
  // `renderSlot` we can be sure that it's template-based so we can force
  // enable it.


  if (slot && slot._c) {
    slot._d = false;
  }

  openBlock();
  var validSlotContent = slot && ensureValidVNode(slot(props));
  var rendered = createBlock(Fragment, {
    key: props.key || "_".concat(name)
  }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1
  /* STABLE */
  ? 64
  /* STABLE_FRAGMENT */
  : -2
  /* BAIL */
  );

  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + '-s'];
  }

  if (slot && slot._c) {
    slot._d = true;
  }

  return rendered;
}

function ensureValidVNode(vnodes) {
  return vnodes.some(function (child) {
    if (!isVNode(child)) return true;
    if (child.type === Comment$1) return false;
    if (child.type === Fragment && !ensureValidVNode(child.children)) return false;
    return true;
  }) ? vnodes : null;
}
/**
 * For prefixing keys in v-on="obj" with "on"
 * @private
 */


function toHandlers(obj) {
  var ret = {};

  if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(obj)) {
    warn("v-on with no argument expects an object value.");
    return ret;
  }

  for (var key in obj) {
    ret[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(key)] = obj[key];
  }

  return ret;
}
/**
 * #2437 In Vue 3, functional components do not have a public instance proxy but
 * they exist in the internal parent chain. For code that relies on traversing
 * public $parent chains, skip functional ones and go to the parent instead.
 */


var getPublicInstance = function getPublicInstance(i) {
  if (!i) return null;
  if (isStatefulComponent(i)) return i.exposed ? i.exposed : i.proxy;
  return getPublicInstance(i.parent);
};

var publicPropertiesMap = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(Object.create(null), {
  $: function $(i) {
    return i;
  },
  $el: function $el(i) {
    return i.vnode.el;
  },
  $data: function $data(i) {
    return i.data;
  },
  $props: function $props(i) {
    return  true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.props) : 0;
  },
  $attrs: function $attrs(i) {
    return  true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.attrs) : 0;
  },
  $slots: function $slots(i) {
    return  true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.slots) : 0;
  },
  $refs: function $refs(i) {
    return  true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.refs) : 0;
  },
  $parent: function $parent(i) {
    return getPublicInstance(i.parent);
  },
  $root: function $root(i) {
    return getPublicInstance(i.root);
  },
  $emit: function $emit(i) {
    return i.emit;
  },
  $options: function $options(i) {
    return  true ? resolveMergedOptions(i) : 0;
  },
  $forceUpdate: function $forceUpdate(i) {
    return function () {
      return queueJob(i.update);
    };
  },
  $nextTick: function $nextTick(i) {
    return nextTick.bind(i.proxy);
  },
  $watch: function $watch(i) {
    return  true ? instanceWatch.bind(i) : 0;
  }
});
var PublicInstanceProxyHandlers = {
  get: function get(_ref19, key) {
    var instance = _ref19._;
    var ctx = instance.ctx,
        setupState = instance.setupState,
        data = instance.data,
        props = instance.props,
        accessCache = instance.accessCache,
        type = instance.type,
        appContext = instance.appContext; // let @vue/reactivity know it should never observe Vue public instances.

    if (key === "__v_skip"
    /* SKIP */
    ) {
        return true;
      } // for internal formatters to know that this is a Vue instance


    if ( true && key === '__isVue') {
      return true;
    } // data / props / ctx
    // This getter gets called for every property access on the render context
    // during render and is a major hotspot. The most expensive part of this
    // is the multiple hasOwn() calls. It's much faster to do a simple property
    // access on a plain object, so we use an accessCache object (with null
    // prototype) to memoize what access type a key corresponds to.


    var normalizedProps;

    if (key[0] !== '$') {
      var n = accessCache[key];

      if (n !== undefined) {
        switch (n) {
          case 0
          /* SETUP */
          :
            return setupState[key];

          case 1
          /* DATA */
          :
            return data[key];

          case 3
          /* CONTEXT */
          :
            return ctx[key];

          case 2
          /* PROPS */
          :
            return props[key];
          // default: just fallthrough
        }
      } else if (setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key)) {
        accessCache[key] = 0
        /* SETUP */
        ;
        return setupState[key];
      } else if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {
        accessCache[key] = 1
        /* DATA */
        ;
        return data[key];
      } else if ( // only cache other properties when instance has declared (thus stable)
      // props
      (normalizedProps = instance.propsOptions[0]) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(normalizedProps, key)) {
        accessCache[key] = 2
        /* PROPS */
        ;
        return props[key];
      } else if (ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key)) {
        accessCache[key] = 3
        /* CONTEXT */
        ;
        return ctx[key];
      } else if ( false || shouldCacheAccess) {
        accessCache[key] = 4
        /* OTHER */
        ;
      }
    }

    var publicGetter = publicPropertiesMap[key];
    var cssModule, globalProperties; // public $xxx properties

    if (publicGetter) {
      if (key === '$attrs') {
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.track)(instance, "get"
        /* GET */
        , key);
         true && markAttrsAccessed();
      }

      return publicGetter(instance);
    } else if ( // css module (injected by vue-loader)
    (cssModule = type.__cssModules) && (cssModule = cssModule[key])) {
      return cssModule;
    } else if (ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key)) {
      // user may set custom properties to `this` that start with `$`
      accessCache[key] = 3
      /* CONTEXT */
      ;
      return ctx[key];
    } else if ( // global properties
    globalProperties = appContext.config.globalProperties, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(globalProperties, key)) {
      {
        return globalProperties[key];
      }
    } else if ( true && currentRenderingInstance && (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(key) || // #1091 avoid internal isRef/isVNode checks on component instance leading
    // to infinite warning loop
    key.indexOf('__v') !== 0)) {
      if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (key[0] === '$' || key[0] === '_') && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {
        warn("Property ".concat(JSON.stringify(key), " must be accessed via $data because it starts with a reserved ") + "character (\"$\" or \"_\") and is not proxied on the render context.");
      } else if (instance === currentRenderingInstance) {
        warn("Property ".concat(JSON.stringify(key), " was accessed during render ") + "but is not defined on instance.");
      }
    }
  },
  set: function set(_ref20, key, value) {
    var instance = _ref20._;
    var data = instance.data,
        setupState = instance.setupState,
        ctx = instance.ctx;

    if (setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key)) {
      setupState[key] = value;
    } else if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {
      data[key] = value;
    } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(instance.props, key)) {
       true && warn("Attempting to mutate prop \"".concat(key, "\". Props are readonly."), instance);
      return false;
    }

    if (key[0] === '$' && key.slice(1) in instance) {
       true && warn("Attempting to mutate public property \"".concat(key, "\". ") + "Properties starting with $ are reserved and readonly.", instance);
      return false;
    } else {
      if ( true && key in instance.appContext.config.globalProperties) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          value: value
        });
      } else {
        ctx[key] = value;
      }
    }

    return true;
  },
  has: function has(_ref21, key) {
    var _ref21$_ = _ref21._,
        data = _ref21$_.data,
        setupState = _ref21$_.setupState,
        accessCache = _ref21$_.accessCache,
        ctx = _ref21$_.ctx,
        appContext = _ref21$_.appContext,
        propsOptions = _ref21$_.propsOptions;
    var normalizedProps;
    return accessCache[key] !== undefined || data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key) || setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key) || (normalizedProps = propsOptions[0]) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(normalizedProps, key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(publicPropertiesMap, key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(appContext.config.globalProperties, key);
  }
};

if (true) {
  PublicInstanceProxyHandlers.ownKeys = function (target) {
    warn("Avoid app logic that relies on enumerating keys on a component instance. " + "The keys will be empty in production mode to avoid performance overhead.");
    return Reflect.ownKeys(target);
  };
}

var RuntimeCompiledPublicInstanceProxyHandlers = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, PublicInstanceProxyHandlers, {
  get: function get(target, key) {
    // fast path for unscopables when using `with` block
    if (key === Symbol.unscopables) {
      return;
    }

    return PublicInstanceProxyHandlers.get(target, key, target);
  },
  has: function has(_, key) {
    var has = key[0] !== '_' && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isGloballyWhitelisted)(key);

    if ( true && !has && PublicInstanceProxyHandlers.has(_, key)) {
      warn("Property ".concat(JSON.stringify(key), " should not start with _ which is a reserved prefix for Vue internals."));
    }

    return has;
  }
}); // In dev mode, the proxy target exposes the same properties as seen on `this`
// for easier console inspection. In prod mode it will be an empty object so
// these properties definitions can be skipped.

function createRenderContext(instance) {
  var target = {}; // expose internal instance for proxy handlers

  Object.defineProperty(target, "_", {
    configurable: true,
    enumerable: false,
    get: function get() {
      return instance;
    }
  }); // expose public properties

  Object.keys(publicPropertiesMap).forEach(function (key) {
    Object.defineProperty(target, key, {
      configurable: true,
      enumerable: false,
      get: function get() {
        return publicPropertiesMap[key](instance);
      },
      // intercepted by the proxy so no need for implementation,
      // but needed to prevent set errors
      set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
    });
  });
  return target;
} // dev only


function exposePropsOnRenderContext(instance) {
  var ctx = instance.ctx,
      _instance$propsOption6 = _slicedToArray(instance.propsOptions, 1),
      propsOptions = _instance$propsOption6[0];

  if (propsOptions) {
    Object.keys(propsOptions).forEach(function (key) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: function get() {
          return instance.props[key];
        },
        set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
      });
    });
  }
} // dev only


function exposeSetupStateOnRenderContext(instance) {
  var ctx = instance.ctx,
      setupState = instance.setupState;
  Object.keys((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(setupState)).forEach(function (key) {
    if (key[0] === '$' || key[0] === '_') {
      warn("setup() return property ".concat(JSON.stringify(key), " should not start with \"$\" or \"_\" ") + "which are reserved prefixes for Vue internals.");
      return;
    }

    Object.defineProperty(ctx, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return setupState[key];
      },
      set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP
    });
  });
}

var emptyAppContext = createAppContext();
var uid$1 = 0;

function createComponentInstance(vnode, parent, suspense) {
  var type = vnode.type; // inherit parent app context - or - if root, adopt from root vnode

  var appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  var instance = {
    uid: uid$1++,
    vnode: vnode,
    type: type,
    parent: parent,
    appContext: appContext,
    root: null,
    next: null,
    subTree: null,
    update: null,
    render: null,
    proxy: null,
    exposed: null,
    withProxy: null,
    effects: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    // local resovled assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    emitted: null,
    // props default value
    propsDefaults: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    data: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    props: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    attrs: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    slots: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    refs: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    setupState: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,
    setupContext: null,
    // suspense related
    suspense: suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };

  if (true) {
    instance.ctx = createRenderContext(instance);
  } else {}

  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  return instance;
}

var currentInstance = null;

var getCurrentInstance = function getCurrentInstance() {
  return currentInstance || currentRenderingInstance;
};

var setCurrentInstance = function setCurrentInstance(instance) {
  currentInstance = instance;
};

var isBuiltInTag = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('slot,component');

function validateComponentName(name, config) {
  var appIsNativeTag = config.isNativeTag || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NO;

  if (isBuiltInTag(name) || appIsNativeTag(name)) {
    warn('Do not use built-in or reserved HTML elements as component id: ' + name);
  }
}

function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4
  /* STATEFUL_COMPONENT */
  ;
}

var isInSSRComponentSetup = false;

function setupComponent(instance) {
  var isSSR = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  isInSSRComponentSetup = isSSR;
  var _instance$vnode = instance.vnode,
      props = _instance$vnode.props,
      children = _instance$vnode.children;
  var isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children);
  var setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : undefined;
  isInSSRComponentSetup = false;
  return setupResult;
}

function setupStatefulComponent(instance, isSSR) {
  var Component = instance.type;

  if (true) {
    if (Component.name) {
      validateComponentName(Component.name, instance.appContext.config);
    }

    if (Component.components) {
      var names = Object.keys(Component.components);

      for (var i = 0; i < names.length; i++) {
        validateComponentName(names[i], instance.appContext.config);
      }
    }

    if (Component.directives) {
      var _names = Object.keys(Component.directives);

      for (var _i5 = 0; _i5 < _names.length; _i5++) {
        validateDirectiveName(_names[_i5]);
      }
    }

    if (Component.compilerOptions && isRuntimeOnly()) {
      warn("\"compilerOptions\" is only supported when using a build of Vue that " + "includes the runtime compiler. Since you are using a runtime-only " + "build, the options should be passed via your build tool config instead.");
    }
  } // 0. create render proxy property access cache


  instance.accessCache = Object.create(null); // 1. create public instance / render proxy
  // also mark it raw so it's never observed

  instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);

  if (true) {
    exposePropsOnRenderContext(instance);
  } // 2. call setup()


  var setup = Component.setup;

  if (setup) {
    var setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    currentInstance = instance;
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
    var setupResult = callWithErrorHandling(setup, instance, 0
    /* SETUP_FUNCTION */
    , [ true ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(instance.props) : 0, setupContext]);
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
    currentInstance = null;

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(setupResult)) {
      if (isSSR) {
        // return the promise so server-renderer can wait on it
        return setupResult.then(function (resolvedResult) {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch(function (e) {
          handleError(e, instance, 0
          /* SETUP_FUNCTION */
          );
        });
      } else {
        // async setup returned Promise.
        // bail here and wait for re-entry.
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}

function handleSetupResult(instance, setupResult, isSSR) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(setupResult)) {
    // setup returned an inline render function
    {
      instance.render = setupResult;
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(setupResult)) {
    if ( true && isVNode(setupResult)) {
      warn("setup() should not return VNodes directly - " + "return a render function instead.");
    } // setup returned bindings.
    // assuming a render function compiled from template is present.


    if (true) {
      instance.devtoolsRawSetupState = setupResult;
    }

    instance.setupState = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs)(setupResult);

    if (true) {
      exposeSetupStateOnRenderContext(instance);
    }
  } else if ( true && setupResult !== undefined) {
    warn("setup() should return an object. Received: ".concat(setupResult === null ? 'null' : _typeof(setupResult)));
  }

  finishComponentSetup(instance, isSSR);
}

var compile; // dev only

var isRuntimeOnly = function isRuntimeOnly() {
  return !compile;
};
/**
 * For runtime-dom to register the compiler.
 * Note the exported method uses any to avoid d.ts relying on the compiler types.
 */


function registerRuntimeCompiler(_compile) {
  compile = _compile;
}

function finishComponentSetup(instance, isSSR, skipOptions) {
  var Component = instance.type; // template / render function normalization

  if (!instance.render) {
    // could be set from setup()
    if (compile && !Component.render) {
      var template = Component.template;

      if (template) {
        if (true) {
          startMeasure(instance, "compile");
        }

        var _instance$appContext$ = instance.appContext.config,
            isCustomElement = _instance$appContext$.isCustomElement,
            compilerOptions = _instance$appContext$.compilerOptions;
        var delimiters = Component.delimiters,
            componentCompilerOptions = Component.compilerOptions;
        var finalCompilerOptions = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({
          isCustomElement: isCustomElement,
          delimiters: delimiters
        }, compilerOptions), componentCompilerOptions);
        Component.render = compile(template, finalCompilerOptions);

        if (true) {
          endMeasure(instance, "compile");
        }
      }
    }

    instance.render = Component.render || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP; // for runtime-compiled render functions using `with` blocks, the render
    // proxy used needs a different `has` handler which is more performant and
    // also only allows a whitelist of globals to fallthrough.

    if (instance.render._rc) {
      instance.withProxy = new Proxy(instance.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
    }
  } // support for 2.x options


  if (true) {
    currentInstance = instance;
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();
    applyOptions(instance);
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();
    currentInstance = null;
  } // warn missing template/render
  // the runtime compilation of template in SSR is done by server-render


  if ( true && !Component.render && instance.render === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP && !isSSR) {
    /* istanbul ignore if */
    if (!compile && Component.template) {
      warn("Component provided template option but " + "runtime compilation is not supported in this build of Vue." + " Configure your bundler to alias \"vue\" to \"vue/dist/vue.esm-bundler.js\"."
      /* should not happen */
      );
    } else {
      warn("Component is missing template or render function.");
    }
  }
}

var attrHandlers = {
  get: function get(target, key) {
    if (true) {
      markAttrsAccessed();
    }

    return target[key];
  },
  set: function set() {
    warn("setupContext.attrs is readonly.");
    return false;
  },
  deleteProperty: function deleteProperty() {
    warn("setupContext.attrs is readonly.");
    return false;
  }
};

function createSetupContext(instance) {
  var expose = function expose(exposed) {
    if ( true && instance.exposed) {
      warn("expose() should be called only once per setup().");
    }

    instance.exposed = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs)(exposed);
  };

  if (true) {
    // We use getters in dev in case libs like test-utils overwrite instance
    // properties (overwrites should not be done in prod)
    return Object.freeze({
      get attrs() {
        return new Proxy(instance.attrs, attrHandlers);
      },

      get slots() {
        return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(instance.slots);
      },

      get emit() {
        return function (event) {
          for (var _len8 = arguments.length, args = new Array(_len8 > 1 ? _len8 - 1 : 0), _key16 = 1; _key16 < _len8; _key16++) {
            args[_key16 - 1] = arguments[_key16];
          }

          return instance.emit.apply(instance, [event].concat(args));
        };
      },

      expose: expose
    });
  } else {}
} // record effects created during a component's setup() so that they can be
// stopped when the component unmounts


function recordInstanceBoundEffect(effect) {
  var instance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : currentInstance;

  if (instance) {
    (instance.effects || (instance.effects = [])).push(effect);
  }
}

var classifyRE = /(?:^|[-_])(\w)/g;

var classify = function classify(str) {
  return str.replace(classifyRE, function (c) {
    return c.toUpperCase();
  }).replace(/[-_]/g, '');
};

function getComponentName(Component) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(Component) ? Component.displayName || Component.name : Component.name;
}
/* istanbul ignore next */


function formatComponentName(instance, Component) {
  var isRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var name = getComponentName(Component);

  if (!name && Component.__file) {
    var match = Component.__file.match(/([^/\\]+)\.\w+$/);

    if (match) {
      name = match[1];
    }
  }

  if (!name && instance && instance.parent) {
    // try to infer the name based on reverse resolution
    var inferFromRegistry = function inferFromRegistry(registry) {
      for (var key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };

    name = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
  }

  return name ? classify(name) : isRoot ? "App" : "Anonymous";
}

function isClassComponent(value) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value) && '__vccOpts' in value;
}

function computed(getterOrOptions) {
  var c = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.computed)(getterOrOptions);
  recordInstanceBoundEffect(c.effect);
  return c;
} // implementation


function defineProps() {
  if (true) {
    warn("defineProps() is a compiler-hint helper that is only usable inside " + "<script setup> of a single file component. Its arguments should be " + "compiled away and passing it at runtime has no effect.");
  }

  return null;
} // implementation


function defineEmit() {
  if (true) {
    warn("defineEmit() is a compiler-hint helper that is only usable inside " + "<script setup> of a single file component. Its arguments should be " + "compiled away and passing it at runtime has no effect.");
  }

  return null;
}

function useContext() {
  var i = getCurrentInstance();

  if ( true && !i) {
    warn("useContext() called without active instance.");
  }

  return i.setupContext || (i.setupContext = createSetupContext(i));
} // Actual implementation


function h(type, propsOrChildren, children) {
  var l = arguments.length;

  if (l === 2) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(propsOrChildren) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(propsOrChildren)) {
      // single vnode without props
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      } // props without children


      return createVNode(type, propsOrChildren);
    } else {
      // omit props
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode(children)) {
      children = [children];
    }

    return createVNode(type, propsOrChildren, children);
  }
}

var ssrContextKey = Symbol( true ? "ssrContext" : 0);

var useSSRContext = function useSSRContext() {
  {
    var ctx = inject(ssrContextKey);

    if (!ctx) {
      warn("Server rendering context not provided. Make sure to only call " + "useSSRContext() conditionally in the server build.");
    }

    return ctx;
  }
};

function initCustomFormatter() {
  /* eslint-disable no-restricted-globals */
  if ( false || typeof window === 'undefined') {
    return;
  }

  var vueStyle = {
    style: 'color:#3ba776'
  };
  var numberStyle = {
    style: 'color:#0b1bc9'
  };
  var stringStyle = {
    style: 'color:#b62e24'
  };
  var keywordStyle = {
    style: 'color:#9d288c'
  }; // custom formatter for Chrome
  // https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html

  var formatter = {
    header: function header(obj) {
      // TODO also format ComponentPublicInstance & ctx.slots/attrs in setup
      if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(obj)) {
        return null;
      }

      if (obj.__isVue) {
        return ['div', vueStyle, "VueInstance"];
      } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(obj)) {
        return ['div', {}, ['span', vueStyle, genRefFlag(obj)], '<', formatValue(obj.value), ">"];
      } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(obj)) {
        return ['div', {}, ['span', vueStyle, 'Reactive'], '<', formatValue(obj), ">".concat((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly)(obj) ? " (readonly)" : "")];
      } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly)(obj)) {
        return ['div', {}, ['span', vueStyle, 'Readonly'], '<', formatValue(obj), '>'];
      }

      return null;
    },
    hasBody: function hasBody(obj) {
      return obj && obj.__isVue;
    },
    body: function body(obj) {
      if (obj && obj.__isVue) {
        return ['div', {}].concat(_toConsumableArray(formatInstance(obj.$)));
      }
    }
  };

  function formatInstance(instance) {
    var blocks = [];

    if (instance.type.props && instance.props) {
      blocks.push(createInstanceBlock('props', (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(instance.props)));
    }

    if (instance.setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
      blocks.push(createInstanceBlock('setup', instance.setupState));
    }

    if (instance.data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
      blocks.push(createInstanceBlock('data', (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(instance.data)));
    }

    var computed = extractKeys(instance, 'computed');

    if (computed) {
      blocks.push(createInstanceBlock('computed', computed));
    }

    var injected = extractKeys(instance, 'inject');

    if (injected) {
      blocks.push(createInstanceBlock('injected', injected));
    }

    blocks.push(['div', {}, ['span', {
      style: keywordStyle.style + ';opacity:0.66'
    }, '$ (internal): '], ['object', {
      object: instance
    }]]);
    return blocks;
  }

  function createInstanceBlock(type, target) {
    target = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, target);

    if (!Object.keys(target).length) {
      return ['span', {}];
    }

    return ['div', {
      style: 'line-height:1.25em;margin-bottom:0.6em'
    }, ['div', {
      style: 'color:#476582'
    }, type], ['div', {
      style: 'padding-left:1.25em'
    }].concat(_toConsumableArray(Object.keys(target).map(function (key) {
      return ['div', {}, ['span', keywordStyle, key + ': '], formatValue(target[key], false)];
    })))];
  }

  function formatValue(v) {
    var asRaw = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    if (typeof v === 'number') {
      return ['span', numberStyle, v];
    } else if (typeof v === 'string') {
      return ['span', stringStyle, JSON.stringify(v)];
    } else if (typeof v === 'boolean') {
      return ['span', keywordStyle, v];
    } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(v)) {
      return ['object', {
        object: asRaw ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(v) : v
      }];
    } else {
      return ['span', stringStyle, String(v)];
    }
  }

  function extractKeys(instance, type) {
    var Comp = instance.type;

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(Comp)) {
      return;
    }

    var extracted = {};

    for (var key in instance.ctx) {
      if (isKeyOfType(Comp, key, type)) {
        extracted[key] = instance.ctx[key];
      }
    }

    return extracted;
  }

  function isKeyOfType(Comp, key, type) {
    var opts = Comp[type];

    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opts) && opts.includes(key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(opts) && key in opts) {
      return true;
    }

    if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
      return true;
    }

    if (Comp.mixins && Comp.mixins.some(function (m) {
      return isKeyOfType(m, key, type);
    })) {
      return true;
    }
  }

  function genRefFlag(v) {
    if (v._shallow) {
      return "ShallowRef";
    }

    if (v.effect) {
      return "ComputedRef";
    }

    return "Ref";
  }

  if (window.devtoolsFormatters) {
    window.devtoolsFormatters.push(formatter);
  } else {
    window.devtoolsFormatters = [formatter];
  }
} // Core API ------------------------------------------------------------------


var version = "3.1.1";
/**
 * SSR utils for \@vue/server-renderer. Only exposed in cjs builds.
 * @internal
 */

var ssrUtils = null;
/**
 * @internal only exposed in compat builds
 */

var resolveFilter = null;
/**
 * @internal only exposed in compat builds.
 */

var compatUtils = null;


/***/ }),

/***/ "./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseTransition": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition),
/* harmony export */   "Comment": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Comment),
/* harmony export */   "Fragment": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment),
/* harmony export */   "KeepAlive": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.KeepAlive),
/* harmony export */   "Static": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Static),
/* harmony export */   "Suspense": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Suspense),
/* harmony export */   "Teleport": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Teleport),
/* harmony export */   "Text": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Text),
/* harmony export */   "callWithAsyncErrorHandling": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling),
/* harmony export */   "callWithErrorHandling": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling),
/* harmony export */   "camelize": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.camelize),
/* harmony export */   "capitalize": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.capitalize),
/* harmony export */   "cloneVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.cloneVNode),
/* harmony export */   "compatUtils": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.compatUtils),
/* harmony export */   "computed": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.computed),
/* harmony export */   "createBlock": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createBlock),
/* harmony export */   "createCommentVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode),
/* harmony export */   "createHydrationRenderer": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer),
/* harmony export */   "createRenderer": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createRenderer),
/* harmony export */   "createSlots": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createSlots),
/* harmony export */   "createStaticVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createStaticVNode),
/* harmony export */   "createTextVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createTextVNode),
/* harmony export */   "createVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode),
/* harmony export */   "customRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.customRef),
/* harmony export */   "defineAsyncComponent": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineAsyncComponent),
/* harmony export */   "defineComponent": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineComponent),
/* harmony export */   "defineEmit": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineEmit),
/* harmony export */   "defineProps": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineProps),
/* harmony export */   "devtools": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.devtools),
/* harmony export */   "getCurrentInstance": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance),
/* harmony export */   "getTransitionRawChildren": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren),
/* harmony export */   "h": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.h),
/* harmony export */   "handleError": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.handleError),
/* harmony export */   "initCustomFormatter": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.initCustomFormatter),
/* harmony export */   "inject": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.inject),
/* harmony export */   "isProxy": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isProxy),
/* harmony export */   "isReactive": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isReactive),
/* harmony export */   "isReadonly": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isReadonly),
/* harmony export */   "isRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRef),
/* harmony export */   "isRuntimeOnly": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly),
/* harmony export */   "isVNode": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isVNode),
/* harmony export */   "markRaw": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.markRaw),
/* harmony export */   "mergeProps": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.mergeProps),
/* harmony export */   "nextTick": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.nextTick),
/* harmony export */   "onActivated": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onActivated),
/* harmony export */   "onBeforeMount": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeMount),
/* harmony export */   "onBeforeUnmount": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount),
/* harmony export */   "onBeforeUpdate": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeUpdate),
/* harmony export */   "onDeactivated": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onDeactivated),
/* harmony export */   "onErrorCaptured": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onErrorCaptured),
/* harmony export */   "onMounted": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onMounted),
/* harmony export */   "onRenderTracked": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onRenderTracked),
/* harmony export */   "onRenderTriggered": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onRenderTriggered),
/* harmony export */   "onServerPrefetch": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onServerPrefetch),
/* harmony export */   "onUnmounted": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUnmounted),
/* harmony export */   "onUpdated": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUpdated),
/* harmony export */   "openBlock": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.openBlock),
/* harmony export */   "popScopeId": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.popScopeId),
/* harmony export */   "provide": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.provide),
/* harmony export */   "proxyRefs": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.proxyRefs),
/* harmony export */   "pushScopeId": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.pushScopeId),
/* harmony export */   "queuePostFlushCb": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.queuePostFlushCb),
/* harmony export */   "reactive": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.reactive),
/* harmony export */   "readonly": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.readonly),
/* harmony export */   "ref": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ref),
/* harmony export */   "registerRuntimeCompiler": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeCompiler),
/* harmony export */   "renderList": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.renderList),
/* harmony export */   "renderSlot": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.renderSlot),
/* harmony export */   "resolveComponent": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveComponent),
/* harmony export */   "resolveDirective": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveDirective),
/* harmony export */   "resolveDynamicComponent": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent),
/* harmony export */   "resolveFilter": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveFilter),
/* harmony export */   "resolveTransitionHooks": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks),
/* harmony export */   "setBlockTracking": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setBlockTracking),
/* harmony export */   "setDevtoolsHook": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setDevtoolsHook),
/* harmony export */   "setTransitionHooks": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks),
/* harmony export */   "shallowReactive": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowReactive),
/* harmony export */   "shallowReadonly": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly),
/* harmony export */   "shallowRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowRef),
/* harmony export */   "ssrContextKey": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ssrContextKey),
/* harmony export */   "ssrUtils": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ssrUtils),
/* harmony export */   "toDisplayString": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey),
/* harmony export */   "toHandlers": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toHandlers),
/* harmony export */   "toRaw": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRaw),
/* harmony export */   "toRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRef),
/* harmony export */   "toRefs": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRefs),
/* harmony export */   "transformVNodeArgs": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.transformVNodeArgs),
/* harmony export */   "triggerRef": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.triggerRef),
/* harmony export */   "unref": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.unref),
/* harmony export */   "useContext": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useContext),
/* harmony export */   "useSSRContext": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useSSRContext),
/* harmony export */   "useTransitionState": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useTransitionState),
/* harmony export */   "version": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.version),
/* harmony export */   "warn": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn),
/* harmony export */   "watch": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watch),
/* harmony export */   "watchEffect": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchEffect),
/* harmony export */   "withCtx": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withCtx),
/* harmony export */   "withDirectives": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withDirectives),
/* harmony export */   "withScopeId": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withScopeId),
/* harmony export */   "Transition": () => (/* binding */ Transition),
/* harmony export */   "TransitionGroup": () => (/* binding */ TransitionGroup),
/* harmony export */   "createApp": () => (/* binding */ createApp),
/* harmony export */   "createSSRApp": () => (/* binding */ createSSRApp),
/* harmony export */   "hydrate": () => (/* binding */ hydrate),
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "useCssModule": () => (/* binding */ useCssModule),
/* harmony export */   "useCssVars": () => (/* binding */ useCssVars),
/* harmony export */   "vModelCheckbox": () => (/* binding */ vModelCheckbox),
/* harmony export */   "vModelDynamic": () => (/* binding */ vModelDynamic),
/* harmony export */   "vModelRadio": () => (/* binding */ vModelRadio),
/* harmony export */   "vModelSelect": () => (/* binding */ vModelSelect),
/* harmony export */   "vModelText": () => (/* binding */ vModelText),
/* harmony export */   "vShow": () => (/* binding */ vShow),
/* harmony export */   "withKeys": () => (/* binding */ withKeys),
/* harmony export */   "withModifiers": () => (/* binding */ withModifiers)
/* harmony export */ });
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");
/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/runtime-core */ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js");
/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vue/runtime-core */ "./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }




var svgNS = 'http://www.w3.org/2000/svg';
var doc = typeof document !== 'undefined' ? document : null;
var tempContainer;
var tempSVGContainer;
var nodeOps = {
  insert: function insert(child, parent, anchor) {
    parent.insertBefore(child, anchor || null);
  },
  remove: function remove(child) {
    var parent = child.parentNode;

    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: function createElement(tag, isSVG, is, props) {
    var el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? {
      is: is
    } : undefined);

    if (tag === 'select' && props && props.multiple != null) {
      el.setAttribute('multiple', props.multiple);
    }

    return el;
  },
  createText: function createText(text) {
    return doc.createTextNode(text);
  },
  createComment: function createComment(text) {
    return doc.createComment(text);
  },
  setText: function setText(node, text) {
    node.nodeValue = text;
  },
  setElementText: function setElementText(el, text) {
    el.textContent = text;
  },
  parentNode: function parentNode(node) {
    return node.parentNode;
  },
  nextSibling: function nextSibling(node) {
    return node.nextSibling;
  },
  querySelector: function querySelector(selector) {
    return doc.querySelector(selector);
  },
  setScopeId: function setScopeId(el, id) {
    el.setAttribute(id, '');
  },
  cloneNode: function cloneNode(el) {
    var cloned = el.cloneNode(true); // #3072
    // - in `patchDOMProp`, we store the actual value in the `el._value` property.
    // - normally, elements using `:value` bindings will not be hoisted, but if
    //   the bound value is a constant, e.g. `:value="true"` - they do get
    //   hoisted.
    // - in production, hoisted nodes are cloned when subsequent inserts, but
    //   cloneNode() does not copy the custom property we attached.
    // - This may need to account for other custom DOM properties we attach to
    //   elements in addition to `_value` in the future.

    if ("_value" in el) {
      cloned._value = el._value;
    }

    return cloned;
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent: function insertStaticContent(content, parent, anchor, isSVG) {
    var temp = isSVG ? tempSVGContainer || (tempSVGContainer = doc.createElementNS(svgNS, 'svg')) : tempContainer || (tempContainer = doc.createElement('div'));
    temp.innerHTML = content;
    var first = temp.firstChild;
    var node = first;
    var last = node;

    while (node) {
      last = node;
      nodeOps.insert(node, parent, anchor);
      node = temp.firstChild;
    }

    return [first, last];
  }
}; // compiler should normalize class + :class bindings on the same element
// into a single binding ['staticClass', dynamic]

function patchClass(el, value, isSVG) {
  if (value == null) {
    value = '';
  }

  if (isSVG) {
    el.setAttribute('class', value);
  } else {
    // directly setting className should be faster than setAttribute in theory
    // if this is an element during a transition, take the temporary transition
    // classes into account.
    var transitionClasses = el._vtc;

    if (transitionClasses) {
      value = (value ? [value].concat(_toConsumableArray(transitionClasses)) : _toConsumableArray(transitionClasses)).join(' ');
    }

    el.className = value;
  }
}

function patchStyle(el, prev, next) {
  var style = el.style;

  if (!next) {
    el.removeAttribute('style');
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(next)) {
    if (prev !== next) {
      var current = style.display;
      style.cssText = next; // indicates that the `display` of the element is controlled by `v-show`,
      // so we always keep the current `display` value regardless of the `style` value,
      // thus handing over control to `v-show`.

      if ('_vod' in el) {
        style.display = current;
      }
    }
  } else {
    for (var key in next) {
      setStyle(style, key, next[key]);
    }

    if (prev && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(prev)) {
      for (var _key in prev) {
        if (next[_key] == null) {
          setStyle(style, _key, '');
        }
      }
    }
  }
}

var importantRE = /\s*!important$/;

function setStyle(style, name, val) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(val)) {
    val.forEach(function (v) {
      return setStyle(style, name, v);
    });
  } else {
    if (name.startsWith('--')) {
      // custom property definition
      style.setProperty(name, val);
    } else {
      var prefixed = autoPrefix(style, name);

      if (importantRE.test(val)) {
        // !important
        style.setProperty((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(prefixed), val.replace(importantRE, ''), 'important');
      } else {
        style[prefixed] = val;
      }
    }
  }
}

var prefixes = ['Webkit', 'Moz', 'ms'];
var prefixCache = {};

function autoPrefix(style, rawName) {
  var cached = prefixCache[rawName];

  if (cached) {
    return cached;
  }

  var name = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(rawName);

  if (name !== 'filter' && name in style) {
    return prefixCache[rawName] = name;
  }

  name = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)(name);

  for (var i = 0; i < prefixes.length; i++) {
    var prefixed = prefixes[i] + name;

    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }

  return rawName;
}

var xlinkNS = 'http://www.w3.org/1999/xlink';

function patchAttr(el, key, value, isSVG, instance) {
  if (isSVG && key.startsWith('xlink:')) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    // note we are only checking boolean attributes that don't have a
    // corresponding dom prop of the same name here.
    var isBoolean = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSpecialBooleanAttr)(key);

    if (value == null || isBoolean && value === false) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, isBoolean ? '' : value);
    }
  }
} // __UNSAFE__
// functions. The user is responsible for using them with only trusted content.


function patchDOMProp(el, key, value, // the following args are passed only due to potential innerHTML/textContent
// overriding existing VNodes, in which case the old tree must be properly
// unmounted.
prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === 'innerHTML' || key === 'textContent') {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }

    el[key] = value == null ? '' : value;
    return;
  }

  if (key === 'value' && el.tagName !== 'PROGRESS') {
    // store value as _value as well since
    // non-string values will be stringified.
    el._value = value;
    var newValue = value == null ? '' : value;

    if (el.value !== newValue) {
      el.value = newValue;
    }

    if (value == null) {
      el.removeAttribute(key);
    }

    return;
  }

  if (value === '' || value == null) {
    var type = _typeof(el[key]);

    if (value === '' && type === 'boolean') {
      // e.g. <select multiple> compiles to { multiple: '' }
      el[key] = true;
      return;
    } else if (value == null && type === 'string') {
      // e.g. <div :id="null">
      el[key] = '';
      el.removeAttribute(key);
      return;
    } else if (type === 'number') {
      // e.g. <img :width="null">
      el[key] = 0;
      el.removeAttribute(key);
      return;
    }
  } // some properties perform value validation and throw


  try {
    el[key] = value;
  } catch (e) {
    if (true) {
      (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)("Failed setting prop \"".concat(key, "\" on <").concat(el.tagName.toLowerCase(), ">: ") + "value ".concat(value, " is invalid."), e);
    }
  }
} // Async edge case fix requires storing an event listener's attach timestamp.


var _getNow = Date.now;
var skipTimestampCheck = false;

if (typeof window !== 'undefined') {
  // Determine what event timestamp the browser is using. Annoyingly, the
  // timestamp can either be hi-res (relative to page load) or low-res
  // (relative to UNIX epoch), so in order to compare time we have to use the
  // same timestamp type when saving the flush timestamp.
  if (_getNow() > document.createEvent('Event').timeStamp) {
    // if the low-res timestamp which is bigger than the event timestamp
    // (which is evaluated AFTER) it means the event is using a hi-res timestamp,
    // and we need to use the hi-res version for event listeners as well.
    _getNow = function _getNow() {
      return performance.now();
    };
  } // #3485: Firefox <= 53 has incorrect Event.timeStamp implementation
  // and does not fire microtasks in between event propagation, so safe to exclude.


  var ffMatch = navigator.userAgent.match(/firefox\/(\d+)/i);
  skipTimestampCheck = !!(ffMatch && Number(ffMatch[1]) <= 53);
} // To avoid the overhead of repeatedly calling performance.now(), we cache
// and use the same timestamp for all event listeners attached in the same tick.


var cachedNow = 0;
var p = Promise.resolve();

var reset = function reset() {
  cachedNow = 0;
};

var getNow = function getNow() {
  return cachedNow || (p.then(reset), cachedNow = _getNow());
};

function addEventListener(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}

function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}

function patchEvent(el, rawName, prevValue, nextValue) {
  var instance = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
  // vei = vue event invokers
  var invokers = el._vei || (el._vei = {});
  var existingInvoker = invokers[rawName];

  if (nextValue && existingInvoker) {
    // patch
    existingInvoker.value = nextValue;
  } else {
    var _parseName = parseName(rawName),
        _parseName2 = _slicedToArray(_parseName, 2),
        name = _parseName2[0],
        options = _parseName2[1];

    if (nextValue) {
      // add
      var invoker = invokers[rawName] = createInvoker(nextValue, instance);
      addEventListener(el, name, invoker, options);
    } else if (existingInvoker) {
      // remove
      removeEventListener(el, name, existingInvoker, options);
      invokers[rawName] = undefined;
    }
  }
}

var optionsModifierRE = /(?:Once|Passive|Capture)$/;

function parseName(name) {
  var options;

  if (optionsModifierRE.test(name)) {
    options = {};
    var m;

    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }

  return [(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(name.slice(2)), options];
}

function createInvoker(initialValue, instance) {
  var invoker = function invoker(e) {
    // async edge case #6566: inner click event triggers patch, event handler
    // attached to outer element during patch, and triggered again. This
    // happens because browsers fire microtask ticks between event propagation.
    // the solution is simple: we save the timestamp when a handler is attached,
    // and the handler would only fire if the event passed to it was fired
    // AFTER it was attached.
    var timeStamp = e.timeStamp || _getNow();

    if (skipTimestampCheck || timeStamp >= invoker.attached - 1) {
      (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling)(patchStopImmediatePropagation(e, invoker.value), instance, 5
      /* NATIVE_EVENT_HANDLER */
      , [e]);
    }
  };

  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}

function patchStopImmediatePropagation(e, value) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
    var originalStop = e.stopImmediatePropagation;

    e.stopImmediatePropagation = function () {
      originalStop.call(e);
      e._stopped = true;
    };

    return value.map(function (fn) {
      return function (e) {
        return !e._stopped && fn(e);
      };
    });
  } else {
    return value;
  }
}

var nativeOnRE = /^on[a-z]/;

var forcePatchProp = function forcePatchProp(_, key) {
  return key === 'value';
};

var patchProp = function patchProp(el, key, prevValue, nextValue) {
  var isSVG = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var prevChildren = arguments.length > 5 ? arguments[5] : undefined;
  var parentComponent = arguments.length > 6 ? arguments[6] : undefined;
  var parentSuspense = arguments.length > 7 ? arguments[7] : undefined;
  var unmountChildren = arguments.length > 8 ? arguments[8] : undefined;

  switch (key) {
    // special
    case 'class':
      patchClass(el, nextValue, isSVG);
      break;

    case 'style':
      patchStyle(el, prevValue, nextValue);
      break;

    default:
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {
        // ignore v-model listeners
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key)) {
          patchEvent(el, key, prevValue, nextValue, parentComponent);
        }
      } else if (shouldSetAsProp(el, key, nextValue, isSVG)) {
        patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
      } else {
        // special case for <input v-model type="checkbox"> with
        // :true-value & :false-value
        // store value as dom properties since non-string values will be
        // stringified.
        if (key === 'true-value') {
          el._trueValue = nextValue;
        } else if (key === 'false-value') {
          el._falseValue = nextValue;
        }

        patchAttr(el, key, nextValue, isSVG);
      }

      break;
  }
};

function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    // most keys must be set as attribute on svg elements to work
    // ...except innerHTML
    if (key === 'innerHTML') {
      return true;
    } // or native onclick with function values


    if (key in el && nativeOnRE.test(key) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {
      return true;
    }

    return false;
  } // spellcheck and draggable are numerated attrs, however their
  // corresponding DOM properties are actually booleans - this leads to
  // setting it with a string "false" value leading it to be coerced to
  // `true`, so we need to always treat them as attributes.
  // Note that `contentEditable` doesn't have this problem: its DOM
  // property is also enumerated string values.


  if (key === 'spellcheck' || key === 'draggable') {
    return false;
  } // #1787, #2840 form property on form elements is readonly and must be set as
  // attribute.


  if (key === 'form') {
    return false;
  } // #1526 <input list> must be set as attribute


  if (key === 'list' && el.tagName === 'INPUT') {
    return false;
  } // #2766 <textarea type> must be set as attribute


  if (key === 'type' && el.tagName === 'TEXTAREA') {
    return false;
  } // native onclick with string value, must be set as attribute


  if (nativeOnRE.test(key) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(value)) {
    return false;
  }

  return key in el;
}

function useCssModule() {
  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '$style';

  /* istanbul ignore else */
  {
    var instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();

    if (!instance) {
       true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)("useCssModule must be called inside setup()");
      return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    }

    var modules = instance.type.__cssModules;

    if (!modules) {
       true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)("Current instance does not have CSS modules injected.");
      return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    }

    var mod = modules[name];

    if (!mod) {
       true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)("Current instance does not have CSS module named \"".concat(name, "\"."));
      return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;
    }

    return mod;
  }
}
/**
 * Runtime helper for SFC's CSS variable injection feature.
 * @private
 */


function useCssVars(getter) {
  var instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
  /* istanbul ignore next */

  if (!instance) {
     true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)("useCssVars is called without current active component instance.");
    return;
  }

  var setVars = function setVars() {
    return setVarsOnVNode(instance.subTree, getter(instance.proxy));
  };

  (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onMounted)(function () {
    return (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchEffect)(setVars, {
      flush: 'post'
    });
  });
  (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUpdated)(setVars);
}

function setVarsOnVNode(vnode, vars) {
  if (vnode.shapeFlag & 128
  /* SUSPENSE */
  ) {
      var suspense = vnode.suspense;
      vnode = suspense.activeBranch;

      if (suspense.pendingBranch && !suspense.isHydrating) {
        suspense.effects.push(function () {
          setVarsOnVNode(suspense.activeBranch, vars);
        });
      }
    } // drill down HOCs until it's a non-component vnode


  while (vnode.component) {
    vnode = vnode.component.subTree;
  }

  if (vnode.shapeFlag & 1
  /* ELEMENT */
  && vnode.el) {
    var style = vnode.el.style;

    for (var key in vars) {
      style.setProperty("--".concat(key), vars[key]);
    }
  } else if (vnode.type === _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment) {
    vnode.children.forEach(function (c) {
      return setVarsOnVNode(c, vars);
    });
  }
}

var TRANSITION = 'transition';
var ANIMATION = 'animation'; // DOM Transition is a higher-order-component based on the platform-agnostic
// base Transition component, with DOM-specific logic.

var Transition = function Transition(props, _ref) {
  var slots = _ref.slots;
  return (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.h)(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition, resolveTransitionProps(props), slots);
};

Transition.displayName = 'Transition';
var DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
var TransitionPropsValidators = Transition.props = /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition.props, DOMTransitionPropsValidators);
/**
 * #3227 Incoming hooks may be merged into arrays when wrapping Transition
 * with custom HOCs.
 */

var callHook = function callHook(hook) {
  var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)) {
    hook.forEach(function (h) {
      return h.apply(void 0, _toConsumableArray(args));
    });
  } else if (hook) {
    hook.apply(void 0, _toConsumableArray(args));
  }
};
/**
 * Check if a hook expects a callback (2nd arg), which means the user
 * intends to explicitly control the end of the transition.
 */


var hasExplicitCallback = function hasExplicitCallback(hook) {
  return hook ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook) ? hook.some(function (h) {
    return h.length > 1;
  }) : hook.length > 1 : false;
};

function resolveTransitionProps(rawProps) {
  var baseProps = {};

  for (var key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }

  if (rawProps.css === false) {
    return baseProps;
  }

  var _rawProps$name = rawProps.name,
      name = _rawProps$name === void 0 ? 'v' : _rawProps$name,
      type = rawProps.type,
      duration = rawProps.duration,
      _rawProps$enterFromCl = rawProps.enterFromClass,
      enterFromClass = _rawProps$enterFromCl === void 0 ? "".concat(name, "-enter-from") : _rawProps$enterFromCl,
      _rawProps$enterActive = rawProps.enterActiveClass,
      enterActiveClass = _rawProps$enterActive === void 0 ? "".concat(name, "-enter-active") : _rawProps$enterActive,
      _rawProps$enterToClas = rawProps.enterToClass,
      enterToClass = _rawProps$enterToClas === void 0 ? "".concat(name, "-enter-to") : _rawProps$enterToClas,
      _rawProps$appearFromC = rawProps.appearFromClass,
      appearFromClass = _rawProps$appearFromC === void 0 ? enterFromClass : _rawProps$appearFromC,
      _rawProps$appearActiv = rawProps.appearActiveClass,
      appearActiveClass = _rawProps$appearActiv === void 0 ? enterActiveClass : _rawProps$appearActiv,
      _rawProps$appearToCla = rawProps.appearToClass,
      appearToClass = _rawProps$appearToCla === void 0 ? enterToClass : _rawProps$appearToCla,
      _rawProps$leaveFromCl = rawProps.leaveFromClass,
      leaveFromClass = _rawProps$leaveFromCl === void 0 ? "".concat(name, "-leave-from") : _rawProps$leaveFromCl,
      _rawProps$leaveActive = rawProps.leaveActiveClass,
      leaveActiveClass = _rawProps$leaveActive === void 0 ? "".concat(name, "-leave-active") : _rawProps$leaveActive,
      _rawProps$leaveToClas = rawProps.leaveToClass,
      leaveToClass = _rawProps$leaveToClas === void 0 ? "".concat(name, "-leave-to") : _rawProps$leaveToClas;
  var durations = normalizeDuration(duration);
  var enterDuration = durations && durations[0];
  var leaveDuration = durations && durations[1];

  var _onBeforeEnter = baseProps.onBeforeEnter,
      onEnter = baseProps.onEnter,
      _onEnterCancelled = baseProps.onEnterCancelled,
      _onLeave = baseProps.onLeave,
      _onLeaveCancelled = baseProps.onLeaveCancelled,
      _baseProps$onBeforeAp = baseProps.onBeforeAppear,
      _onBeforeAppear = _baseProps$onBeforeAp === void 0 ? _onBeforeEnter : _baseProps$onBeforeAp,
      _baseProps$onAppear = baseProps.onAppear,
      onAppear = _baseProps$onAppear === void 0 ? onEnter : _baseProps$onAppear,
      _baseProps$onAppearCa = baseProps.onAppearCancelled,
      _onAppearCancelled = _baseProps$onAppearCa === void 0 ? _onEnterCancelled : _baseProps$onAppearCa;

  var finishEnter = function finishEnter(el, isAppear, done) {
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };

  var finishLeave = function finishLeave(el, done) {
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };

  var makeEnterHook = function makeEnterHook(isAppear) {
    return function (el, done) {
      var hook = isAppear ? onAppear : onEnter;

      var resolve = function resolve() {
        return finishEnter(el, isAppear, done);
      };

      callHook(hook, [el, resolve]);
      nextFrame(function () {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);

        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve);
        }
      });
    };
  };

  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(baseProps, {
    onBeforeEnter: function onBeforeEnter(el) {
      callHook(_onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear: function onBeforeAppear(el) {
      callHook(_onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave: function onLeave(el, done) {
      var resolve = function resolve() {
        return finishLeave(el, done);
      };

      addTransitionClass(el, leaveFromClass); // force reflow so *-leave-from classes immediately take effect (#2593)

      forceReflow();
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);

        if (!hasExplicitCallback(_onLeave)) {
          whenTransitionEnds(el, type, leaveDuration, resolve);
        }
      });
      callHook(_onLeave, [el, resolve]);
    },
    onEnterCancelled: function onEnterCancelled(el) {
      finishEnter(el, false);
      callHook(_onEnterCancelled, [el]);
    },
    onAppearCancelled: function onAppearCancelled(el) {
      finishEnter(el, true);
      callHook(_onAppearCancelled, [el]);
    },
    onLeaveCancelled: function onLeaveCancelled(el) {
      finishLeave(el);
      callHook(_onLeaveCancelled, [el]);
    }
  });
}

function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    var n = NumberOf(duration);
    return [n, n];
  }
}

function NumberOf(val) {
  var res = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(val);
  if (true) validateDuration(res);
  return res;
}

function validateDuration(val) {
  if (typeof val !== 'number') {
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)("<transition> explicit duration is not a valid number - " + "got ".concat(JSON.stringify(val), "."));
  } else if (isNaN(val)) {
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)("<transition> explicit duration is NaN - " + 'the duration expression might be incorrect.');
  }
}

function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach(function (c) {
    return c && el.classList.add(c);
  });
  (el._vtc || (el._vtc = new Set())).add(cls);
}

function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach(function (c) {
    return c && el.classList.remove(c);
  });
  var _vtc = el._vtc;

  if (_vtc) {
    _vtc.delete(cls);

    if (!_vtc.size) {
      el._vtc = undefined;
    }
  }
}

function nextFrame(cb) {
  requestAnimationFrame(function () {
    requestAnimationFrame(cb);
  });
}

var endId = 0;

function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
  var id = el._endId = ++endId;

  var resolveIfNotStale = function resolveIfNotStale() {
    if (id === el._endId) {
      resolve();
    }
  };

  if (explicitTimeout) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }

  var _getTransitionInfo = getTransitionInfo(el, expectedType),
      type = _getTransitionInfo.type,
      timeout = _getTransitionInfo.timeout,
      propCount = _getTransitionInfo.propCount;

  if (!type) {
    return resolve();
  }

  var endEvent = type + 'end';
  var ended = 0;

  var end = function end() {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };

  var onEnd = function onEnd(e) {
    if (e.target === el && ++ended >= propCount) {
      end();
    }
  };

  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}

function getTransitionInfo(el, expectedType) {
  var styles = window.getComputedStyle(el); // JSDOM may return undefined for transition properties

  var getStyleProperties = function getStyleProperties(key) {
    return (styles[key] || '').split(', ');
  };

  var transitionDelays = getStyleProperties(TRANSITION + 'Delay');
  var transitionDurations = getStyleProperties(TRANSITION + 'Duration');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = getStyleProperties(ANIMATION + 'Delay');
  var animationDurations = getStyleProperties(ANIMATION + 'Duration');
  var animationTimeout = getTimeout(animationDelays, animationDurations);
  var type = null;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */

  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }

  var hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(styles[TRANSITION + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  };
}

function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(Math, _toConsumableArray(durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i]);
  })));
} // Old versions of Chromium (below 61.0.3163.100) formats floating pointer
// numbers in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down
// (i.e. acting as a floor function) causing unexpected behaviors


function toMs(s) {
  return Number(s.slice(0, -1).replace(',', '.')) * 1000;
} // synchronously force layout to put elements into a certain state


function forceReflow() {
  return document.body.offsetHeight;
}

var positionMap = new WeakMap();
var newPositionMap = new WeakMap();
var TransitionGroupImpl = {
  name: 'TransitionGroup',
  props: /*#__PURE__*/(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup: function setup(props, _ref2) {
    var slots = _ref2.slots;
    var instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
    var state = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useTransitionState)();
    var prevChildren;
    var children;
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUpdated)(function () {
      // children is guaranteed to exist after initial render
      if (!prevChildren.length) {
        return;
      }

      var moveClass = props.moveClass || "".concat(props.name || 'v', "-move");

      if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {
        return;
      } // we divide the work into three loops to avoid mixing DOM reads and writes
      // in each iteration - which helps prevent layout thrashing.


      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      var movedChildren = prevChildren.filter(applyTranslation); // force reflow to put everything in position

      forceReflow();
      movedChildren.forEach(function (c) {
        var el = c.el;
        var style = el.style;
        addTransitionClass(el, moveClass);
        style.transform = style.webkitTransform = style.transitionDuration = '';

        var cb = el._moveCb = function (e) {
          if (e && e.target !== el) {
            return;
          }

          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener('transitionend', cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        };

        el.addEventListener('transitionend', cb);
      });
    });
    return function () {
      var rawProps = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.toRaw)(props);
      var cssTransitionProps = resolveTransitionProps(rawProps);
      var tag = rawProps.tag || _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment;
      prevChildren = children;
      children = slots.default ? (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren)(slots.default()) : [];

      for (var i = 0; i < children.length; i++) {
        var child = children[i];

        if (child.key != null) {
          (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks)(child, (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks)(child, cssTransitionProps, state, instance));
        } else if (true) {
          (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)("<TransitionGroup> children must be keyed.");
        }
      }

      if (prevChildren) {
        for (var _i2 = 0; _i2 < prevChildren.length; _i2++) {
          var _child = prevChildren[_i2];
          (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks)(_child, (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks)(_child, cssTransitionProps, state, instance));
          positionMap.set(_child, _child.el.getBoundingClientRect());
        }
      }

      return (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode)(tag, null, children);
    };
  }
};
var TransitionGroup = TransitionGroupImpl;

function callPendingCbs(c) {
  var el = c.el;

  if (el._moveCb) {
    el._moveCb();
  }

  if (el._enterCb) {
    el._enterCb();
  }
}

function recordPosition(c) {
  newPositionMap.set(c, c.el.getBoundingClientRect());
}

function applyTranslation(c) {
  var oldPos = positionMap.get(c);
  var newPos = newPositionMap.get(c);
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;

  if (dx || dy) {
    var s = c.el.style;
    s.transform = s.webkitTransform = "translate(".concat(dx, "px,").concat(dy, "px)");
    s.transitionDuration = '0s';
    return c;
  }
}

function hasCSSTransform(el, root, moveClass) {
  // Detect whether an element with the move class applied has
  // CSS transitions. Since the element may be inside an entering
  // transition at this very moment, we make a clone of it and remove
  // all other transition classes applied to ensure only the move class
  // is applied.
  var clone = el.cloneNode();

  if (el._vtc) {
    el._vtc.forEach(function (cls) {
      cls.split(/\s+/).forEach(function (c) {
        return c && clone.classList.remove(c);
      });
    });
  }

  moveClass.split(/\s+/).forEach(function (c) {
    return c && clone.classList.add(c);
  });
  clone.style.display = 'none';
  var container = root.nodeType === 1 ? root : root.parentNode;
  container.appendChild(clone);

  var _getTransitionInfo2 = getTransitionInfo(clone),
      hasTransform = _getTransitionInfo2.hasTransform;

  container.removeChild(clone);
  return hasTransform;
}

var getModelAssigner = function getModelAssigner(vnode) {
  var fn = vnode.props['onUpdate:modelValue'];
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(fn) ? function (value) {
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(fn, value);
  } : fn;
};

function onCompositionStart(e) {
  e.target.composing = true;
}

function onCompositionEnd(e) {
  var target = e.target;

  if (target.composing) {
    target.composing = false;
    trigger(target, 'input');
  }
}

function trigger(el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
} // We are exporting the v-model runtime directly as vnode hooks so that it can
// be tree-shaken in case v-model is never used.


var vModelText = {
  created: function created(el, _ref3, vnode) {
    var _ref3$modifiers = _ref3.modifiers,
        lazy = _ref3$modifiers.lazy,
        trim = _ref3$modifiers.trim,
        number = _ref3$modifiers.number;
    el._assign = getModelAssigner(vnode);
    var castToNumber = number || el.type === 'number';
    addEventListener(el, lazy ? 'change' : 'input', function (e) {
      if (e.target.composing) return;
      var domValue = el.value;

      if (trim) {
        domValue = domValue.trim();
      } else if (castToNumber) {
        domValue = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(domValue);
      }

      el._assign(domValue);
    });

    if (trim) {
      addEventListener(el, 'change', function () {
        el.value = el.value.trim();
      });
    }

    if (!lazy) {
      addEventListener(el, 'compositionstart', onCompositionStart);
      addEventListener(el, 'compositionend', onCompositionEnd); // Safari < 10.2 & UIWebView doesn't fire compositionend when
      // switching focus before confirming composition choice
      // this also fixes the issue where some browsers e.g. iOS Chrome
      // fires "change" instead of "input" on autocomplete.

      addEventListener(el, 'change', onCompositionEnd);
    }
  },
  // set value on mounted so it's after min/max for type="range"
  mounted: function mounted(el, _ref4) {
    var value = _ref4.value;
    el.value = value == null ? '' : value;
  },
  beforeUpdate: function beforeUpdate(el, _ref5, vnode) {
    var value = _ref5.value,
        _ref5$modifiers = _ref5.modifiers,
        trim = _ref5$modifiers.trim,
        number = _ref5$modifiers.number;
    el._assign = getModelAssigner(vnode); // avoid clearing unresolved text. #2302

    if (el.composing) return;

    if (document.activeElement === el) {
      if (trim && el.value.trim() === value) {
        return;
      }

      if ((number || el.type === 'number') && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(el.value) === value) {
        return;
      }
    }

    var newValue = value == null ? '' : value;

    if (el.value !== newValue) {
      el.value = newValue;
    }
  }
};
var vModelCheckbox = {
  created: function created(el, _, vnode) {
    el._assign = getModelAssigner(vnode);
    addEventListener(el, 'change', function () {
      var modelValue = el._modelValue;
      var elementValue = getValue(el);
      var checked = el.checked;
      var assign = el._assign;

      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(modelValue)) {
        var index = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(modelValue, elementValue);
        var found = index !== -1;

        if (checked && !found) {
          assign(modelValue.concat(elementValue));
        } else if (!checked && found) {
          var filtered = _toConsumableArray(modelValue);

          filtered.splice(index, 1);
          assign(filtered);
        }
      } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(modelValue)) {
        var cloned = new Set(modelValue);

        if (checked) {
          cloned.add(elementValue);
        } else {
          cloned.delete(elementValue);
        }

        assign(cloned);
      } else {
        assign(getCheckboxValue(el, checked));
      }
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: setChecked,
  beforeUpdate: function beforeUpdate(el, binding, vnode) {
    el._assign = getModelAssigner(vnode);
    setChecked(el, binding, vnode);
  }
};

function setChecked(el, _ref6, vnode) {
  var value = _ref6.value,
      oldValue = _ref6.oldValue;
  el._modelValue = value;

  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
    el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(value, vnode.props.value) > -1;
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)) {
    el.checked = value.has(vnode.props.value);
  } else if (value !== oldValue) {
    el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, getCheckboxValue(el, true));
  }
}

var vModelRadio = {
  created: function created(el, _ref7, vnode) {
    var value = _ref7.value;
    el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, vnode.props.value);
    el._assign = getModelAssigner(vnode);
    addEventListener(el, 'change', function () {
      el._assign(getValue(el));
    });
  },
  beforeUpdate: function beforeUpdate(el, _ref8, vnode) {
    var value = _ref8.value,
        oldValue = _ref8.oldValue;
    el._assign = getModelAssigner(vnode);

    if (value !== oldValue) {
      el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, vnode.props.value);
    }
  }
};
var vModelSelect = {
  created: function created(el, _ref9, vnode) {
    var value = _ref9.value,
        number = _ref9.modifiers.number;
    var isSetModel = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value);
    addEventListener(el, 'change', function () {
      var selectedVal = Array.prototype.filter.call(el.options, function (o) {
        return o.selected;
      }).map(function (o) {
        return number ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(getValue(o)) : getValue(o);
      });

      el._assign(el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]);
    });
    el._assign = getModelAssigner(vnode);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted: function mounted(el, _ref10) {
    var value = _ref10.value;
    setSelected(el, value);
  },
  beforeUpdate: function beforeUpdate(el, _binding, vnode) {
    el._assign = getModelAssigner(vnode);
  },
  updated: function updated(el, _ref11) {
    var value = _ref11.value;
    setSelected(el, value);
  }
};

function setSelected(el, value) {
  var isMultiple = el.multiple;

  if (isMultiple && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)) {
     true && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)("<select multiple v-model> expects an Array or Set value for its binding, " + "but got ".concat(Object.prototype.toString.call(value).slice(8, -1), "."));
    return;
  }

  for (var i = 0, l = el.options.length; i < l; i++) {
    var option = el.options[i];
    var optionValue = getValue(option);

    if (isMultiple) {
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {
        option.selected = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(value, optionValue) > -1;
      } else {
        option.selected = value.has(optionValue);
      }
    } else {
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(getValue(option), value)) {
        if (el.selectedIndex !== i) el.selectedIndex = i;
        return;
      }
    }
  }

  if (!isMultiple && el.selectedIndex !== -1) {
    el.selectedIndex = -1;
  }
} // retrieve raw value set via :value bindings


function getValue(el) {
  return '_value' in el ? el._value : el.value;
} // retrieve raw value for true-value and false-value set via :true-value or :false-value bindings


function getCheckboxValue(el, checked) {
  var key = checked ? '_trueValue' : '_falseValue';
  return key in el ? el[key] : checked;
}

var vModelDynamic = {
  created: function created(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, 'created');
  },
  mounted: function mounted(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, 'mounted');
  },
  beforeUpdate: function beforeUpdate(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, 'beforeUpdate');
  },
  updated: function updated(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, 'updated');
  }
};

function callModelHook(el, binding, vnode, prevVNode, hook) {
  var modelToUse;

  switch (el.tagName) {
    case 'SELECT':
      modelToUse = vModelSelect;
      break;

    case 'TEXTAREA':
      modelToUse = vModelText;
      break;

    default:
      switch (vnode.props && vnode.props.type) {
        case 'checkbox':
          modelToUse = vModelCheckbox;
          break;

        case 'radio':
          modelToUse = vModelRadio;
          break;

        default:
          modelToUse = vModelText;
      }

  }

  var fn = modelToUse[hook];
  fn && fn(el, binding, vnode, prevVNode);
}

var systemModifiers = ['ctrl', 'shift', 'alt', 'meta'];
var modifierGuards = {
  stop: function stop(e) {
    return e.stopPropagation();
  },
  prevent: function prevent(e) {
    return e.preventDefault();
  },
  self: function self(e) {
    return e.target !== e.currentTarget;
  },
  ctrl: function ctrl(e) {
    return !e.ctrlKey;
  },
  shift: function shift(e) {
    return !e.shiftKey;
  },
  alt: function alt(e) {
    return !e.altKey;
  },
  meta: function meta(e) {
    return !e.metaKey;
  },
  left: function left(e) {
    return 'button' in e && e.button !== 0;
  },
  middle: function middle(e) {
    return 'button' in e && e.button !== 1;
  },
  right: function right(e) {
    return 'button' in e && e.button !== 2;
  },
  exact: function exact(e, modifiers) {
    return systemModifiers.some(function (m) {
      return e["".concat(m, "Key")] && !modifiers.includes(m);
    });
  }
};
/**
 * @private
 */

var withModifiers = function withModifiers(fn, modifiers) {
  return function (event) {
    for (var i = 0; i < modifiers.length; i++) {
      var guard = modifierGuards[modifiers[i]];
      if (guard && guard(event, modifiers)) return;
    }

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key2 = 1; _key2 < _len; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    return fn.apply(void 0, [event].concat(args));
  };
}; // Kept for 2.x compat.
// Note: IE11 compat for `spacebar` and `del` is removed for now.


var keyNames = {
  esc: 'escape',
  space: ' ',
  up: 'arrow-up',
  left: 'arrow-left',
  right: 'arrow-right',
  down: 'arrow-down',
  delete: 'backspace'
};
/**
 * @private
 */

var withKeys = function withKeys(fn, modifiers) {
  return function (event) {
    if (!('key' in event)) {
      return;
    }

    var eventKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event.key);

    if (modifiers.some(function (k) {
      return k === eventKey || keyNames[k] === eventKey;
    })) {
      return fn(event);
    }
  };
};

var vShow = {
  beforeMount: function beforeMount(el, _ref12, _ref13) {
    var value = _ref12.value;
    var transition = _ref13.transition;
    el._vod = el.style.display === 'none' ? '' : el.style.display;

    if (transition && value) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value);
    }
  },
  mounted: function mounted(el, _ref14, _ref15) {
    var value = _ref14.value;
    var transition = _ref15.transition;

    if (transition && value) {
      transition.enter(el);
    }
  },
  updated: function updated(el, _ref16, _ref17) {
    var value = _ref16.value,
        oldValue = _ref16.oldValue;
    var transition = _ref17.transition;
    if (!value === !oldValue) return;

    if (transition) {
      if (value) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, function () {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value);
    }
  },
  beforeUnmount: function beforeUnmount(el, _ref18) {
    var value = _ref18.value;
    setDisplay(el, value);
  }
};

function setDisplay(el, value) {
  el.style.display = value ? el._vod : 'none';
}

var rendererOptions = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({
  patchProp: patchProp,
  forcePatchProp: forcePatchProp
}, nodeOps); // lazy create the renderer - this makes core renderer logic tree-shakable
// in case the user only imports reactivity utilities from Vue.

var renderer;
var enabledHydration = false;

function ensureRenderer() {
  return renderer || (renderer = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createRenderer)(rendererOptions));
}

function ensureHydrationRenderer() {
  renderer = enabledHydration ? renderer : (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer)(rendererOptions);
  enabledHydration = true;
  return renderer;
} // use explicit type casts here to avoid import() calls in rolled-up d.ts


var render = function render() {
  var _ensureRenderer;

  (_ensureRenderer = ensureRenderer()).render.apply(_ensureRenderer, arguments);
};

var hydrate = function hydrate() {
  var _ensureHydrationRende;

  (_ensureHydrationRende = ensureHydrationRenderer()).hydrate.apply(_ensureHydrationRende, arguments);
};

var createApp = function createApp() {
  var _ensureRenderer2;

  var app = (_ensureRenderer2 = ensureRenderer()).createApp.apply(_ensureRenderer2, arguments);

  if (true) {
    injectNativeTagCheck(app);
    injectCompilerOptionsCheck(app);
  }

  var mount = app.mount;

  app.mount = function (containerOrSelector) {
    var container = normalizeContainer(containerOrSelector);
    if (!container) return;
    var component = app._component;

    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(component) && !component.render && !component.template) {
      // __UNSAFE__
      // Reason: potential execution of JS expressions in in-DOM template.
      // The user must make sure the in-DOM template is trusted. If it's
      // rendered by the server, the template should not contain any user data.
      component.template = container.innerHTML;
    } // clear content before mounting


    container.innerHTML = '';
    var proxy = mount(container, false, container instanceof SVGElement);

    if (container instanceof Element) {
      container.removeAttribute('v-cloak');
      container.setAttribute('data-v-app', '');
    }

    return proxy;
  };

  return app;
};

var createSSRApp = function createSSRApp() {
  var _ensureHydrationRende2;

  var app = (_ensureHydrationRende2 = ensureHydrationRenderer()).createApp.apply(_ensureHydrationRende2, arguments);

  if (true) {
    injectNativeTagCheck(app);
    injectCompilerOptionsCheck(app);
  }

  var mount = app.mount;

  app.mount = function (containerOrSelector) {
    var container = normalizeContainer(containerOrSelector);

    if (container) {
      return mount(container, true, container instanceof SVGElement);
    }
  };

  return app;
};

function injectNativeTagCheck(app) {
  // Inject `isNativeTag`
  // this is used for component name validation (dev only)
  Object.defineProperty(app.config, 'isNativeTag', {
    value: function value(tag) {
      return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isHTMLTag)(tag) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSVGTag)(tag);
    },
    writable: false
  });
} // dev only


function injectCompilerOptionsCheck(app) {
  if ((0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly)()) {
    var isCustomElement = app.config.isCustomElement;
    Object.defineProperty(app.config, 'isCustomElement', {
      get: function get() {
        return isCustomElement;
      },
      set: function set() {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)("The `isCustomElement` config option is deprecated. Use " + "`compilerOptions.isCustomElement` instead.");
      }
    });
    var compilerOptions = app.config.compilerOptions;
    var msg = "The `compilerOptions` config option is only respected when using " + "a build of Vue.js that includes the runtime compiler (aka \"full build\"). " + "Since you are using the runtime-only build, `compilerOptions` " + "must be passed to `@vue/compiler-dom` in the build setup instead.\n" + "- For vue-loader: pass it via vue-loader's `compilerOptions` loader option.\n" + "- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n" + "- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom";
    Object.defineProperty(app.config, 'compilerOptions', {
      get: function get() {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(msg);
        return compilerOptions;
      },
      set: function set() {
        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(msg);
      }
    });
  }
}

function normalizeContainer(container) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(container)) {
    var res = document.querySelector(container);

    if ( true && !res) {
      (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)("Failed to mount app: mount target selector \"".concat(container, "\" returned null."));
    }

    return res;
  }

  if ( true && container instanceof window.ShadowRoot && container.mode === 'closed') {
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)("mounting on a ShadowRoot with `{mode: \"closed\"}` may lead to unpredictable bugs");
  }

  return container;
}



/***/ }),

/***/ "./node_modules/@vue/shared/dist/shared.esm-bundler.js":
/*!*************************************************************!*\
  !*** ./node_modules/@vue/shared/dist/shared.esm-bundler.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EMPTY_ARR": () => (/* binding */ EMPTY_ARR),
/* harmony export */   "EMPTY_OBJ": () => (/* binding */ EMPTY_OBJ),
/* harmony export */   "NO": () => (/* binding */ NO),
/* harmony export */   "NOOP": () => (/* binding */ NOOP),
/* harmony export */   "PatchFlagNames": () => (/* binding */ PatchFlagNames),
/* harmony export */   "babelParserDefaultPlugins": () => (/* binding */ babelParserDefaultPlugins),
/* harmony export */   "camelize": () => (/* binding */ camelize),
/* harmony export */   "capitalize": () => (/* binding */ capitalize),
/* harmony export */   "def": () => (/* binding */ def),
/* harmony export */   "escapeHtml": () => (/* binding */ escapeHtml),
/* harmony export */   "escapeHtmlComment": () => (/* binding */ escapeHtmlComment),
/* harmony export */   "extend": () => (/* binding */ extend),
/* harmony export */   "generateCodeFrame": () => (/* binding */ generateCodeFrame),
/* harmony export */   "getGlobalThis": () => (/* binding */ getGlobalThis),
/* harmony export */   "hasChanged": () => (/* binding */ hasChanged),
/* harmony export */   "hasOwn": () => (/* binding */ hasOwn),
/* harmony export */   "hyphenate": () => (/* binding */ hyphenate),
/* harmony export */   "invokeArrayFns": () => (/* binding */ invokeArrayFns),
/* harmony export */   "isArray": () => (/* binding */ isArray),
/* harmony export */   "isBooleanAttr": () => (/* binding */ isBooleanAttr),
/* harmony export */   "isDate": () => (/* binding */ isDate),
/* harmony export */   "isFunction": () => (/* binding */ isFunction),
/* harmony export */   "isGloballyWhitelisted": () => (/* binding */ isGloballyWhitelisted),
/* harmony export */   "isHTMLTag": () => (/* binding */ isHTMLTag),
/* harmony export */   "isIntegerKey": () => (/* binding */ isIntegerKey),
/* harmony export */   "isKnownAttr": () => (/* binding */ isKnownAttr),
/* harmony export */   "isMap": () => (/* binding */ isMap),
/* harmony export */   "isModelListener": () => (/* binding */ isModelListener),
/* harmony export */   "isNoUnitNumericStyleProp": () => (/* binding */ isNoUnitNumericStyleProp),
/* harmony export */   "isObject": () => (/* binding */ isObject),
/* harmony export */   "isOn": () => (/* binding */ isOn),
/* harmony export */   "isPlainObject": () => (/* binding */ isPlainObject),
/* harmony export */   "isPromise": () => (/* binding */ isPromise),
/* harmony export */   "isReservedProp": () => (/* binding */ isReservedProp),
/* harmony export */   "isSSRSafeAttrName": () => (/* binding */ isSSRSafeAttrName),
/* harmony export */   "isSVGTag": () => (/* binding */ isSVGTag),
/* harmony export */   "isSet": () => (/* binding */ isSet),
/* harmony export */   "isSpecialBooleanAttr": () => (/* binding */ isSpecialBooleanAttr),
/* harmony export */   "isString": () => (/* binding */ isString),
/* harmony export */   "isSymbol": () => (/* binding */ isSymbol),
/* harmony export */   "isVoidTag": () => (/* binding */ isVoidTag),
/* harmony export */   "looseEqual": () => (/* binding */ looseEqual),
/* harmony export */   "looseIndexOf": () => (/* binding */ looseIndexOf),
/* harmony export */   "makeMap": () => (/* binding */ makeMap),
/* harmony export */   "normalizeClass": () => (/* binding */ normalizeClass),
/* harmony export */   "normalizeStyle": () => (/* binding */ normalizeStyle),
/* harmony export */   "objectToString": () => (/* binding */ objectToString),
/* harmony export */   "parseStringStyle": () => (/* binding */ parseStringStyle),
/* harmony export */   "propsToAttrMap": () => (/* binding */ propsToAttrMap),
/* harmony export */   "remove": () => (/* binding */ remove),
/* harmony export */   "slotFlagsText": () => (/* binding */ slotFlagsText),
/* harmony export */   "stringifyStyle": () => (/* binding */ stringifyStyle),
/* harmony export */   "toDisplayString": () => (/* binding */ toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* binding */ toHandlerKey),
/* harmony export */   "toNumber": () => (/* binding */ toNumber),
/* harmony export */   "toRawType": () => (/* binding */ toRawType),
/* harmony export */   "toTypeString": () => (/* binding */ toTypeString)
/* harmony export */ });
var _PatchFlagNames, _slotFlagsText;

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 * IMPORTANT: all calls of this function must be prefixed with
 * \/\*#\_\_PURE\_\_\*\/
 * So that rollup can tree-shake them if necessary.
 */
function makeMap(str, expectsLowerCase) {
  var map = Object.create(null);
  var list = str.split(',');

  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }

  return expectsLowerCase ? function (val) {
    return !!map[val.toLowerCase()];
  } : function (val) {
    return !!map[val];
  };
}
/**
 * dev only flag -> name mapping
 */


var PatchFlagNames = (_PatchFlagNames = {}, _defineProperty(_PatchFlagNames, 1
/* TEXT */
, "TEXT"), _defineProperty(_PatchFlagNames, 2
/* CLASS */
, "CLASS"), _defineProperty(_PatchFlagNames, 4
/* STYLE */
, "STYLE"), _defineProperty(_PatchFlagNames, 8
/* PROPS */
, "PROPS"), _defineProperty(_PatchFlagNames, 16
/* FULL_PROPS */
, "FULL_PROPS"), _defineProperty(_PatchFlagNames, 32
/* HYDRATE_EVENTS */
, "HYDRATE_EVENTS"), _defineProperty(_PatchFlagNames, 64
/* STABLE_FRAGMENT */
, "STABLE_FRAGMENT"), _defineProperty(_PatchFlagNames, 128
/* KEYED_FRAGMENT */
, "KEYED_FRAGMENT"), _defineProperty(_PatchFlagNames, 256
/* UNKEYED_FRAGMENT */
, "UNKEYED_FRAGMENT"), _defineProperty(_PatchFlagNames, 512
/* NEED_PATCH */
, "NEED_PATCH"), _defineProperty(_PatchFlagNames, 1024
/* DYNAMIC_SLOTS */
, "DYNAMIC_SLOTS"), _defineProperty(_PatchFlagNames, 2048
/* DEV_ROOT_FRAGMENT */
, "DEV_ROOT_FRAGMENT"), _defineProperty(_PatchFlagNames, -1
/* HOISTED */
, "HOISTED"), _defineProperty(_PatchFlagNames, -2
/* BAIL */
, "BAIL"), _PatchFlagNames);
/**
 * Dev only
 */

var slotFlagsText = (_slotFlagsText = {}, _defineProperty(_slotFlagsText, 1
/* STABLE */
, 'STABLE'), _defineProperty(_slotFlagsText, 2
/* DYNAMIC */
, 'DYNAMIC'), _defineProperty(_slotFlagsText, 3
/* FORWARDED */
, 'FORWARDED'), _slotFlagsText);
var GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' + 'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' + 'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';
var isGloballyWhitelisted = /*#__PURE__*/makeMap(GLOBALS_WHITE_LISTED);
var range = 2;

function generateCodeFrame(source) {
  var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : source.length;
  var lines = source.split(/\r?\n/);
  var count = 0;
  var res = [];

  for (var i = 0; i < lines.length; i++) {
    count += lines[i].length + 1;

    if (count >= start) {
      for (var j = i - range; j <= i + range || end > count; j++) {
        if (j < 0 || j >= lines.length) continue;
        var line = j + 1;
        res.push("".concat(line).concat(' '.repeat(Math.max(3 - String(line).length, 0)), "|  ").concat(lines[j]));
        var lineLength = lines[j].length;

        if (j === i) {
          // push underline
          var pad = start - (count - lineLength) + 1;
          var length = Math.max(1, end > count ? lineLength - pad : end - start);
          res.push("   |  " + ' '.repeat(pad) + '^'.repeat(length));
        } else if (j > i) {
          if (end > count) {
            var _length = Math.max(Math.min(end - count, lineLength), 1);

            res.push("   |  " + '^'.repeat(_length));
          }

          count += lineLength + 1;
        }
      }

      break;
    }
  }

  return res.join('\n');
}
/**
 * On the client we only need to offer special cases for boolean attributes that
 * have different names from their corresponding dom properties:
 * - itemscope -> N/A
 * - allowfullscreen -> allowFullscreen
 * - formnovalidate -> formNoValidate
 * - ismap -> isMap
 * - nomodule -> noModule
 * - novalidate -> noValidate
 * - readonly -> readOnly
 */


var specialBooleanAttrs = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly";
var isSpecialBooleanAttr = /*#__PURE__*/makeMap(specialBooleanAttrs);
/**
 * The full list is needed during SSR to produce the correct initial markup.
 */

var isBooleanAttr = /*#__PURE__*/makeMap(specialBooleanAttrs + ",async,autofocus,autoplay,controls,default,defer,disabled,hidden," + "loop,open,required,reversed,scoped,seamless," + "checked,muted,multiple,selected");
var unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
var attrValidationCache = {};

function isSSRSafeAttrName(name) {
  if (attrValidationCache.hasOwnProperty(name)) {
    return attrValidationCache[name];
  }

  var isUnsafe = unsafeAttrCharRE.test(name);

  if (isUnsafe) {
    console.error("unsafe attribute name: ".concat(name));
  }

  return attrValidationCache[name] = !isUnsafe;
}

var propsToAttrMap = {
  acceptCharset: 'accept-charset',
  className: 'class',
  htmlFor: 'for',
  httpEquiv: 'http-equiv'
};
/**
 * CSS properties that accept plain numbers
 */

var isNoUnitNumericStyleProp = /*#__PURE__*/makeMap("animation-iteration-count,border-image-outset,border-image-slice," + "border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count," + "columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order," + "grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column," + "grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp," + "line-height,opacity,order,orphans,tab-size,widows,z-index,zoom," + // SVG
"fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset," + "stroke-miterlimit,stroke-opacity,stroke-width");
/**
 * Known attributes, this is used for stringification of runtime static nodes
 * so that we don't stringify bindings that cannot be set from HTML.
 * Don't also forget to allow `data-*` and `aria-*`!
 * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes
 */

var isKnownAttr = /*#__PURE__*/makeMap("accept,accept-charset,accesskey,action,align,allow,alt,async," + "autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor," + "border,buffered,capture,challenge,charset,checked,cite,class,code," + "codebase,color,cols,colspan,content,contenteditable,contextmenu,controls," + "coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname," + "disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form," + "formaction,formenctype,formmethod,formnovalidate,formtarget,headers," + "height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity," + "ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low," + "manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate," + "open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly," + "referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped," + "selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset," + "start,step,style,summary,tabindex,target,title,translate,type,usemap," + "value,width,wrap");

function normalizeStyle(value) {
  if (isArray(value)) {
    var res = {};

    for (var i = 0; i < value.length; i++) {
      var item = value[i];
      var normalized = normalizeStyle(isString(item) ? parseStringStyle(item) : item);

      if (normalized) {
        for (var key in normalized) {
          res[key] = normalized[key];
        }
      }
    }

    return res;
  } else if (isObject(value)) {
    return value;
  }
}

var listDelimiterRE = /;(?![^(]*\))/g;
var propertyDelimiterRE = /:(.+)/;

function parseStringStyle(cssText) {
  var ret = {};
  cssText.split(listDelimiterRE).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}

function stringifyStyle(styles) {
  var ret = '';

  if (!styles) {
    return ret;
  }

  for (var key in styles) {
    var value = styles[key];
    var normalizedKey = key.startsWith("--") ? key : hyphenate(key);

    if (isString(value) || typeof value === 'number' && isNoUnitNumericStyleProp(normalizedKey)) {
      // only render valid values
      ret += "".concat(normalizedKey, ":").concat(value, ";");
    }
  }

  return ret;
}

function normalizeClass(value) {
  var res = '';

  if (isString(value)) {
    res = value;
  } else if (isArray(value)) {
    for (var i = 0; i < value.length; i++) {
      var normalized = normalizeClass(value[i]);

      if (normalized) {
        res += normalized + ' ';
      }
    }
  } else if (isObject(value)) {
    for (var name in value) {
      if (value[name]) {
        res += name + ' ';
      }
    }
  }

  return res.trim();
} // These tag configs are shared between compiler-dom and runtime-dom, so they
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element


var HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' + 'header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,' + 'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' + 'data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,' + 'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' + 'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' + 'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' + 'option,output,progress,select,textarea,details,dialog,menu,' + 'summary,template,blockquote,iframe,tfoot'; // https://developer.mozilla.org/en-US/docs/Web/SVG/Element

var SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' + 'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' + 'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' + 'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' + 'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' + 'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' + 'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' + 'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' + 'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' + 'text,textPath,title,tspan,unknown,use,view';
var VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';
var isHTMLTag = /*#__PURE__*/makeMap(HTML_TAGS);
var isSVGTag = /*#__PURE__*/makeMap(SVG_TAGS);
var isVoidTag = /*#__PURE__*/makeMap(VOID_TAGS);
var escapeRE = /["'&<>]/;

function escapeHtml(string) {
  var str = '' + string;
  var match = escapeRE.exec(str);

  if (!match) {
    return str;
  }

  var html = '';
  var escaped;
  var index;
  var lastIndex = 0;

  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        // "
        escaped = '&quot;';
        break;

      case 38:
        // &
        escaped = '&amp;';
        break;

      case 39:
        // '
        escaped = '&#39;';
        break;

      case 60:
        // <
        escaped = '&lt;';
        break;

      case 62:
        // >
        escaped = '&gt;';
        break;

      default:
        continue;
    }

    if (lastIndex !== index) {
      html += str.substring(lastIndex, index);
    }

    lastIndex = index + 1;
    html += escaped;
  }

  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
} // https://www.w3.org/TR/html52/syntax.html#comments


var commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;

function escapeHtmlComment(src) {
  return src.replace(commentStripRE, '');
}

function looseCompareArrays(a, b) {
  if (a.length !== b.length) return false;
  var equal = true;

  for (var i = 0; equal && i < a.length; i++) {
    equal = looseEqual(a[i], b[i]);
  }

  return equal;
}

function looseEqual(a, b) {
  if (a === b) return true;
  var aValidType = isDate(a);
  var bValidType = isDate(b);

  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
  }

  aValidType = isArray(a);
  bValidType = isArray(b);

  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b) : false;
  }

  aValidType = isObject(a);
  bValidType = isObject(b);

  if (aValidType || bValidType) {
    /* istanbul ignore if: this if will probably never be called */
    if (!aValidType || !bValidType) {
      return false;
    }

    var aKeysCount = Object.keys(a).length;
    var bKeysCount = Object.keys(b).length;

    if (aKeysCount !== bKeysCount) {
      return false;
    }

    for (var key in a) {
      var aHasKey = a.hasOwnProperty(key);
      var bHasKey = b.hasOwnProperty(key);

      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
        return false;
      }
    }
  }

  return String(a) === String(b);
}

function looseIndexOf(arr, val) {
  return arr.findIndex(function (item) {
    return looseEqual(item, val);
  });
}
/**
 * For converting {{ interpolation }} values to displayed strings.
 * @private
 */


var toDisplayString = function toDisplayString(val) {
  return val == null ? '' : isObject(val) ? JSON.stringify(val, replacer, 2) : String(val);
};

var replacer = function replacer(_key, val) {
  if (isMap(val)) {
    return _defineProperty({}, "Map(".concat(val.size, ")"), _toConsumableArray(val.entries()).reduce(function (entries, _ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          key = _ref2[0],
          val = _ref2[1];

      entries["".concat(key, " =>")] = val;
      return entries;
    }, {}));
  } else if (isSet(val)) {
    return _defineProperty({}, "Set(".concat(val.size, ")"), _toConsumableArray(val.values()));
  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
    return String(val);
  }

  return val;
};
/**
 * List of @babel/parser plugins that are used for template expression
 * transforms and SFC script transforms. By default we enable proposals slated
 * for ES2020. This will need to be updated as the spec moves forward.
 * Full list at https://babeljs.io/docs/en/next/babel-parser#plugins
 */


var babelParserDefaultPlugins = ['bigInt', 'optionalChaining', 'nullishCoalescingOperator'];
var EMPTY_OBJ =  true ? Object.freeze({}) : 0;
var EMPTY_ARR =  true ? Object.freeze([]) : 0;

var NOOP = function NOOP() {};
/**
 * Always return false.
 */


var NO = function NO() {
  return false;
};

var onRE = /^on[^a-z]/;

var isOn = function isOn(key) {
  return onRE.test(key);
};

var isModelListener = function isModelListener(key) {
  return key.startsWith('onUpdate:');
};

var extend = Object.assign;

var remove = function remove(arr, el) {
  var i = arr.indexOf(el);

  if (i > -1) {
    arr.splice(i, 1);
  }
};

var hasOwnProperty = Object.prototype.hasOwnProperty;

var hasOwn = function hasOwn(val, key) {
  return hasOwnProperty.call(val, key);
};

var isArray = Array.isArray;

var isMap = function isMap(val) {
  return toTypeString(val) === '[object Map]';
};

var isSet = function isSet(val) {
  return toTypeString(val) === '[object Set]';
};

var isDate = function isDate(val) {
  return val instanceof Date;
};

var isFunction = function isFunction(val) {
  return typeof val === 'function';
};

var isString = function isString(val) {
  return typeof val === 'string';
};

var isSymbol = function isSymbol(val) {
  return _typeof(val) === 'symbol';
};

var isObject = function isObject(val) {
  return val !== null && _typeof(val) === 'object';
};

var isPromise = function isPromise(val) {
  return isObject(val) && isFunction(val.then) && isFunction(val.catch);
};

var objectToString = Object.prototype.toString;

var toTypeString = function toTypeString(value) {
  return objectToString.call(value);
};

var toRawType = function toRawType(value) {
  // extract "RawType" from strings like "[object RawType]"
  return toTypeString(value).slice(8, -1);
};

var isPlainObject = function isPlainObject(val) {
  return toTypeString(val) === '[object Object]';
};

var isIntegerKey = function isIntegerKey(key) {
  return isString(key) && key !== 'NaN' && key[0] !== '-' && '' + parseInt(key, 10) === key;
};

var isReservedProp = /*#__PURE__*/makeMap( // the leading comma is intentional so empty string "" is also included
',key,ref,' + 'onVnodeBeforeMount,onVnodeMounted,' + 'onVnodeBeforeUpdate,onVnodeUpdated,' + 'onVnodeBeforeUnmount,onVnodeUnmounted');

var cacheStringFunction = function cacheStringFunction(fn) {
  var cache = Object.create(null);
  return function (str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};

var camelizeRE = /-(\w)/g;
/**
 * @private
 */

var camelize = cacheStringFunction(function (str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : '';
  });
});
var hyphenateRE = /\B([A-Z])/g;
/**
 * @private
 */

var hyphenate = cacheStringFunction(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase();
});
/**
 * @private
 */

var capitalize = cacheStringFunction(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
/**
 * @private
 */

var toHandlerKey = cacheStringFunction(function (str) {
  return str ? "on".concat(capitalize(str)) : "";
}); // compare whether a value has changed, accounting for NaN.

var hasChanged = function hasChanged(value, oldValue) {
  return value !== oldValue && (value === value || oldValue === oldValue);
};

var invokeArrayFns = function invokeArrayFns(fns, arg) {
  for (var i = 0; i < fns.length; i++) {
    fns[i](arg);
  }
};

var def = function def(obj, key, value) {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value: value
  });
};

var toNumber = function toNumber(val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n;
};

var _globalThis;

var getGlobalThis = function getGlobalThis() {
  return _globalThis || (_globalThis = typeof globalThis !== 'undefined' ? globalThis : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : {});
};



/***/ }),

/***/ "./node_modules/orb-array/src/index.js":
/*!*********************************************!*\
  !*** ./node_modules/orb-array/src/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var _require = __webpack_require__(/*! orb-functions */ "./node_modules/orb-functions/src/index.js"),
    self = _require.self,
    constant = _require.constant;

var get = function get(a) {
  return a || [];
};

var split = function split() {
  var o = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var ways = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
  var chunk = Math.ceil(o.length / ways);
  return range(ways).map(function (v) {
    return o.slice(v * chunk, (v + 1) * chunk);
  });
};

var range = function range() {
  var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  return new Array(n < 0 ? 0 : n).fill(0).map(function (_, index) {
    return index;
  });
};

var fill = function fill(n) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : self;
  return range(n).map(function (v) {
    return typeof fn === "function" ? fn(v) : fn;
  });
};

var zip = function zip() {
  for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {
    arrays[_key] = arguments[_key];
  }

  arrays = get(arrays); // Output length is the smallest of all input lengths

  var n = arrays.length > 0 ? Math.min.apply(Math, _toConsumableArray(arrays.map(function (a) {
    return get(a).length;
  }))) : 0;
  return range(n).map(function (index) {
    return arrays.map(function (a) {
      return a[index];
    });
  });
};

var reduce = {
  o: function o() {
    var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$key = _ref.key,
        kfn = _ref$key === void 0 ? self : _ref$key,
        _ref$value = _ref.value,
        vfn = _ref$value === void 0 ? self : _ref$value;

    return items.reduce(function (c
    /** container */
    , v, index) {
      return c[kfn(v, index)] = vfn(v, index), c;
    }, {});
  },
  a: function a() {
    var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref2$value = _ref2.value,
        vfn = _ref2$value === void 0 ? self : _ref2$value,
        _ref2$container = _ref2.container,
        container = _ref2$container === void 0 ? [] : _ref2$container;

    return items.reduce(function (c
    /** container */
    , v, index) {
      return c.push(vfn(v, index)), c;
    }, container);
  },
  mul: function mul() {
    var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    return items.reduce(function (v, vi) {
      return v * vi;
    }, 1);
  },
  rollingmul: function rollingmul() {
    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [],
        _ref4 = _toArray(_ref3),
        first = _ref4[0],
        rest = _ref4.slice(1);

    return rest.reduce(function (container, item) {
      return container.push(item * last(container)), container;
    }, first ? [first] : []);
  },
  sum: function sum() {
    var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    return items.reduce(function (v, vi) {
      return v + vi;
    }, 0);
  }
};
var map = {
  scale: function scale() {
    var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var factor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    return items.map(function (item) {
      return item * factor;
    });
  }
};

var ranges = function ranges()
/** range sizes */
{
  for (var _len2 = arguments.length, ns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    ns[_key2] = arguments[_key2];
  }

  var cs = reduce.rollingmul(ns.reverse()).reverse(); // range container sizes in decreasing order

  var nes = cs.shift(); // total number of elements.

  var addressFn = function addressFn(index) {
    return cs.reduce(function (_ref5, csi) {
      var _ref6 = _slicedToArray(_ref5, 2),
          rs
      /**remaining size */
      = _ref6[0],
          address = _ref6[1];

      return [rs % csi, (address.push(Math.floor(rs / csi)), address)];
    }, [index, []]);
  };

  cs.push(1); // Deepest container size

  return range(nes).map(function (index) {
    return addressFn(index)[1];
  });
};

var last = function last() {
  var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return !(array instanceof Array) ? array : array[array.length - 1];
};
/**
 * It resolves an address in an Array/Object
 * 
 * @param {Array} value 
 * @param {Array} address 
 * @returns 
 */


var resolveAddress = function resolveAddress() {
  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var address = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  return address.reduce(function (v, ai) {
    return v[ai];
  }, value);
};
/**
 * Repeats the input object {count} times. 
 * 
 * @param {Object} o 
 * @param {number} count
 * @returns 
 */


var repeat = function repeat(o) {
  var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  return fill(count + 1, constant(o));
};

module.exports = {
  split: split,
  range: range,
  reduce: reduce,
  map: map,
  fill: fill,
  zip: zip,
  last: last,
  ranges: ranges,
  resolveAddress: resolveAddress,
  repeat: repeat
};

/***/ }),

/***/ "./node_modules/orb-functions/src/index.js":
/*!*************************************************!*\
  !*** ./node_modules/orb-functions/src/index.js ***!
  \*************************************************/
/***/ ((module) => {

var self = function self(x) {
  return x;
};

var constant = function constant(x) {
  return function (_) {
    return x;
  };
};

module.exports = {
  self: self,
  constant: constant
};

/***/ }),

/***/ "./node_modules/vue/dist/vue.esm-bundler.js":
/*!**************************************************!*\
  !*** ./node_modules/vue/dist/vue.esm-bundler.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseTransition": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.BaseTransition),
/* harmony export */   "Comment": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Comment),
/* harmony export */   "Fragment": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Fragment),
/* harmony export */   "KeepAlive": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.KeepAlive),
/* harmony export */   "Static": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Static),
/* harmony export */   "Suspense": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Suspense),
/* harmony export */   "Teleport": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Teleport),
/* harmony export */   "Text": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Text),
/* harmony export */   "Transition": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Transition),
/* harmony export */   "TransitionGroup": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.TransitionGroup),
/* harmony export */   "callWithAsyncErrorHandling": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling),
/* harmony export */   "callWithErrorHandling": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling),
/* harmony export */   "camelize": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.camelize),
/* harmony export */   "capitalize": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.capitalize),
/* harmony export */   "cloneVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.cloneVNode),
/* harmony export */   "compatUtils": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.compatUtils),
/* harmony export */   "computed": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.computed),
/* harmony export */   "createApp": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createApp),
/* harmony export */   "createBlock": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createBlock),
/* harmony export */   "createCommentVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode),
/* harmony export */   "createHydrationRenderer": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer),
/* harmony export */   "createRenderer": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createRenderer),
/* harmony export */   "createSSRApp": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createSSRApp),
/* harmony export */   "createSlots": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createSlots),
/* harmony export */   "createStaticVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createStaticVNode),
/* harmony export */   "createTextVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createTextVNode),
/* harmony export */   "createVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createVNode),
/* harmony export */   "customRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.customRef),
/* harmony export */   "defineAsyncComponent": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineAsyncComponent),
/* harmony export */   "defineComponent": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineComponent),
/* harmony export */   "defineEmit": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineEmit),
/* harmony export */   "defineProps": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineProps),
/* harmony export */   "devtools": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.devtools),
/* harmony export */   "getCurrentInstance": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance),
/* harmony export */   "getTransitionRawChildren": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren),
/* harmony export */   "h": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.h),
/* harmony export */   "handleError": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.handleError),
/* harmony export */   "hydrate": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.hydrate),
/* harmony export */   "initCustomFormatter": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.initCustomFormatter),
/* harmony export */   "inject": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.inject),
/* harmony export */   "isProxy": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isProxy),
/* harmony export */   "isReactive": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isReactive),
/* harmony export */   "isReadonly": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isReadonly),
/* harmony export */   "isRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isRef),
/* harmony export */   "isRuntimeOnly": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly),
/* harmony export */   "isVNode": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isVNode),
/* harmony export */   "markRaw": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.markRaw),
/* harmony export */   "mergeProps": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.mergeProps),
/* harmony export */   "nextTick": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.nextTick),
/* harmony export */   "onActivated": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onActivated),
/* harmony export */   "onBeforeMount": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeMount),
/* harmony export */   "onBeforeUnmount": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount),
/* harmony export */   "onBeforeUpdate": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeUpdate),
/* harmony export */   "onDeactivated": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onDeactivated),
/* harmony export */   "onErrorCaptured": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onErrorCaptured),
/* harmony export */   "onMounted": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onMounted),
/* harmony export */   "onRenderTracked": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onRenderTracked),
/* harmony export */   "onRenderTriggered": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onRenderTriggered),
/* harmony export */   "onServerPrefetch": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onServerPrefetch),
/* harmony export */   "onUnmounted": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onUnmounted),
/* harmony export */   "onUpdated": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onUpdated),
/* harmony export */   "openBlock": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.openBlock),
/* harmony export */   "popScopeId": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.popScopeId),
/* harmony export */   "provide": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.provide),
/* harmony export */   "proxyRefs": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.proxyRefs),
/* harmony export */   "pushScopeId": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.pushScopeId),
/* harmony export */   "queuePostFlushCb": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.queuePostFlushCb),
/* harmony export */   "reactive": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.reactive),
/* harmony export */   "readonly": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.readonly),
/* harmony export */   "ref": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ref),
/* harmony export */   "registerRuntimeCompiler": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeCompiler),
/* harmony export */   "render": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "renderList": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.renderList),
/* harmony export */   "renderSlot": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.renderSlot),
/* harmony export */   "resolveComponent": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveComponent),
/* harmony export */   "resolveDirective": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveDirective),
/* harmony export */   "resolveDynamicComponent": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent),
/* harmony export */   "resolveFilter": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveFilter),
/* harmony export */   "resolveTransitionHooks": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks),
/* harmony export */   "setBlockTracking": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setBlockTracking),
/* harmony export */   "setDevtoolsHook": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setDevtoolsHook),
/* harmony export */   "setTransitionHooks": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks),
/* harmony export */   "shallowReactive": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowReactive),
/* harmony export */   "shallowReadonly": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly),
/* harmony export */   "shallowRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowRef),
/* harmony export */   "ssrContextKey": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ssrContextKey),
/* harmony export */   "ssrUtils": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ssrUtils),
/* harmony export */   "toDisplayString": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey),
/* harmony export */   "toHandlers": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toHandlers),
/* harmony export */   "toRaw": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRaw),
/* harmony export */   "toRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRef),
/* harmony export */   "toRefs": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRefs),
/* harmony export */   "transformVNodeArgs": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.transformVNodeArgs),
/* harmony export */   "triggerRef": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.triggerRef),
/* harmony export */   "unref": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.unref),
/* harmony export */   "useContext": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useContext),
/* harmony export */   "useCssModule": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useCssModule),
/* harmony export */   "useCssVars": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useCssVars),
/* harmony export */   "useSSRContext": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useSSRContext),
/* harmony export */   "useTransitionState": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useTransitionState),
/* harmony export */   "vModelCheckbox": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelCheckbox),
/* harmony export */   "vModelDynamic": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelDynamic),
/* harmony export */   "vModelRadio": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelRadio),
/* harmony export */   "vModelSelect": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelSelect),
/* harmony export */   "vModelText": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelText),
/* harmony export */   "vShow": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vShow),
/* harmony export */   "version": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.version),
/* harmony export */   "warn": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.warn),
/* harmony export */   "watch": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watch),
/* harmony export */   "watchEffect": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchEffect),
/* harmony export */   "withCtx": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withCtx),
/* harmony export */   "withDirectives": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withDirectives),
/* harmony export */   "withKeys": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withKeys),
/* harmony export */   "withModifiers": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withModifiers),
/* harmony export */   "withScopeId": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withScopeId),
/* harmony export */   "compile": () => (/* binding */ compileToFunction)
/* harmony export */ });
/* harmony import */ var _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/runtime-dom */ "./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js");
/* harmony import */ var _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vue/runtime-dom */ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js");
/* harmony import */ var _vue_compiler_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @vue/compiler-dom */ "./node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js");
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ "./node_modules/@vue/shared/dist/shared.esm-bundler.js");






function initDev() {
  {
    (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_2__.initCustomFormatter)();
  }
} // This entry is the "full-build" that includes both the runtime


if (true) {
  initDev();
}

var compileCache = Object.create(null);

function compileToFunction(template, options) {
  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(template)) {
    if (template.nodeType) {
      template = template.innerHTML;
    } else {
       true && (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_2__.warn)("invalid template option: ", template);
      return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;
    }
  }

  var key = template;
  var cached = compileCache[key];

  if (cached) {
    return cached;
  }

  if (template[0] === '#') {
    var el = document.querySelector(template);

    if ( true && !el) {
      (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_2__.warn)("Template element not found or is empty: ".concat(template));
    } // __UNSAFE__
    // Reason: potential execution of JS expressions in in-DOM template.
    // The user must make sure the in-DOM template is trusted. If it's rendered
    // by the server, the template should not contain any user data.


    template = el ? el.innerHTML : "";
  }

  var _compile = (0,_vue_compiler_dom__WEBPACK_IMPORTED_MODULE_3__.compile)(template, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({
    hoistStatic: true,
    onError:  true ? onError : 0,
    onWarn:  true ? function (e) {
      return onError(e, true);
    } : 0
  }, options)),
      code = _compile.code;

  function onError(err) {
    var asWarning = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var message = asWarning ? err.message : "Template compilation error: ".concat(err.message);
    var codeFrame = err.loc && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.generateCodeFrame)(template, err.loc.start.offset, err.loc.end.offset);
    (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_2__.warn)(codeFrame ? "".concat(message, "\n").concat(codeFrame) : message);
  } // The wildcard import results in a huge object with every export
  // with keys that cannot be mangled, and can be quite heavy size-wise.
  // In the global build we know `Vue` is available globally so we can avoid
  // the wildcard object.


  var render = new Function('Vue', code)(_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__);
  render._rc = true;
  return compileCache[key] = render;
}

(0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_2__.registerRuntimeCompiler)(compileToFunction);


/***/ }),

/***/ "./public/js/arraymap.js":
/*!*******************************!*\
  !*** ./public/js/arraymap.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "arraymap": () => (/* binding */ arraymap)
/* harmony export */ });
/* harmony import */ var orb_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! orb-array */ "./node_modules/orb-array/src/index.js");
/* harmony import */ var orb_array__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(orb_array__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




var ArrayMap = function ArrayMap() {
  var _this = this;

  var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    key: orbfns.self
  },
      _key = _ref.key;

  _classCallCheck(this, ArrayMap);

  _defineProperty(this, "push", function (v) {
    var key = _this.keyFn(v);

    _this.map[key] = v;
    return _this.items.push(v);
  });

  _defineProperty(this, "pop", function (_) {
    var popped = _this.items.pop();

    var key = _this.keyFn(popped);

    delete _this.map[key];
    return popped;
  });

  _defineProperty(this, "remove", function (key) {
    var removed = _this.map[key];

    var index = _this.items.indexOf(removed);

    _this.items.splice(index, 1);

    delete _this.map[key];
    return removed;
  });

  _defineProperty(this, "at", function (index) {
    return _this.items[index];
  });

  _defineProperty(this, "get", function (key) {
    return _this.map[key];
  });

  _defineProperty(this, "length", function (_) {
    return _this.items.length;
  });

  this.keyFn = _key;
  this.map = (0,vue__WEBPACK_IMPORTED_MODULE_1__.reactive)(orb_array__WEBPACK_IMPORTED_MODULE_0__.reduce.o(items, {
    key: _key
  }));
  this.items = (0,vue__WEBPACK_IMPORTED_MODULE_1__.reactive)(items);
};

var arraymap = function arraymap(items, key) {
  return new ArrayMap(items, key);
};

/***/ }),

/***/ "./public/js/components/drag.js":
/*!**************************************!*\
  !*** ./public/js/components/drag.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "drag": () => (/* binding */ drag),
/* harmony export */   "drop": () => (/* binding */ drop),
/* harmony export */   "dragdrop": () => (/* binding */ dragdrop)
/* harmony export */ });
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var dataTransfer = {
  dragged: undefined
};
var drag = {
  emits: [],
  methods: {
    dragging: function dragging(evt) {
      dataTransfer.dragged = evt.target;
    }
  },
  template: "\n  <div draggable=\"true\" @dragstart=\"dragging\">\n    <slot></slot>\n  </div>\n  "
};
var drop = {
  emits: ['dropped', 'dragover'],
  methods: {
    source: function source() {
      return dataTransfer.dragged;
    },
    drop: function drop(evt) {
      evt.currentTarget.isSameNode(this.source()) ? {} : this.$emit('dropped', {
        target: evt.currentTarget,
        source: this.source()
      });
    },
    over: function over(evt) {
      this.$emit('dragover', evt);
    }
  },
  template: "\n  <div @drop.prevent=\"drop\" @dragover.prevent=\"over\">\n    <slot></slot>\n  </div>\n  "
};
var dragdrop = {
  emits: [].concat(_toConsumableArray(drag.emits), _toConsumableArray(drop.emits)),
  methods: _objectSpread(_objectSpread({}, drag.methods), drop.methods),
  template: "\n  <div draggable=\"true\" @dragstart=\"dragging\" @drop.prevent=\"drop\" @dragover.prevent=\"over\">\n    <slot></slot>\n  </div>\n  "
};

/***/ }),

/***/ "./public/js/components/externalValue.js":
/*!***********************************************!*\
  !*** ./public/js/components/externalValue.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "externalValue": () => (/* binding */ externalValue)
/* harmony export */ });
var externalValue = {
  props: ['item', 'show'],
  emits: ['update:show'],
  methods: {
    valued: function valued() {
      this.$emit('update:show', false);
    }
  },
  template: "\n  <div class=\"value\">\n    <textarea v-model=\"item.value\"></textarea>\n    <div>\n      <button>Cancel</button>\n      <button @click=\"valued\">Set</button>\n    </div>\n  </div>\n  "
};

/***/ }),

/***/ "./public/js/components/wbench.js":
/*!****************************************!*\
  !*** ./public/js/components/wbench.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "wbench": () => (/* binding */ wbench)
/* harmony export */ });
/* harmony import */ var _drag__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./drag */ "./public/js/components/drag.js");
/* harmony import */ var _externalValue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./externalValue */ "./public/js/components/externalValue.js");
/* harmony import */ var _wtobject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wtobject */ "./public/js/components/wtobject.js");
/* harmony import */ var _wtype__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./wtype */ "./public/js/components/wtype.js");
/* harmony import */ var _wobject__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./wobject */ "./public/js/components/wobject.js");
/* harmony import */ var _arraymap__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../arraymap */ "./public/js/arraymap.js");
/* harmony import */ var _random__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../random */ "./public/js/random.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }








var wbench = {
  components: {
    drag: _drag__WEBPACK_IMPORTED_MODULE_0__.drag,
    drop: _drag__WEBPACK_IMPORTED_MODULE_0__.drop,
    dragdrop: _drag__WEBPACK_IMPORTED_MODULE_0__.dragdrop,
    externalValue: _externalValue__WEBPACK_IMPORTED_MODULE_1__.externalValue,
    wtype: _wtype__WEBPACK_IMPORTED_MODULE_3__.wtype,
    wobject: _wobject__WEBPACK_IMPORTED_MODULE_4__.wobject,
    wtobject: _wtobject__WEBPACK_IMPORTED_MODULE_2__.wtobject
  },
  props: ['types', 'objects'],
  data: function data() {
    return {
      wobjects: {},
      benchObjects: (0,_arraymap__WEBPACK_IMPORTED_MODULE_5__.arraymap)([], {
        key: function key(_ref) {
          var id = _ref.id;
          return id;
        }
      }),
      externalValue: {
        showUi: false,
        source: {}
      }
    };
  },
  computed: {
    watchableBos: function watchableBos() {
      return this.benchObjects.items;
    }
  },
  methods: {
    elid: function elid(el) {
      return el.getAttribute('id');
    },
    elname: function elname(el) {
      return el.getAttribute('name');
    },
    elcname: function elcname(el) {
      return el.getAttribute('cname');
    },
    elprops: function elprops(el) {
      return {
        id: this.elid(el),
        name: this.elname(el),
        cname: this.elcname(el)
      };
    },
    // dropped object props
    chprops: function chprops(el) {
      var _el$getElementsByTagN = el.getElementsByTagName('div'),
          _el$getElementsByTagN2 = _slicedToArray(_el$getElementsByTagN, 1),
          chel = _el$getElementsByTagN2[0]; // child element


      return this.elprops(chel);
    },
    // child element props
    benched: function benched(_ref2) {
      var el = _ref2.source;
      // const withIn = (bo) => bo.isSameNode(bo)
      // const withInIndex = this.benchObjects.findIndex(withIn)
      // withInIndex != -1? this.benchObjects.splice(withInIndex, 1): ({});
      var bo = this.chprops(el); // bench object

      var dropElements = ['wtype', 'wobject'];
      dropElements.some(function (type) {
        return type === bo.cname;
      }) ? this.benchObjects.push({
        id: (0,_random__WEBPACK_IMPORTED_MODULE_6__.makeId)(),
        name: "",
        items: [bo]
      }) : {};
    },
    combination: function combination(_ref3) {
      var _this = this;

      var target = _ref3.target,
          source = _ref3.source;
      var cop = this.chprops(source); // combination candidate props

      var ctp = this.chprops(target); // combination target props

      var dropElements = ['wtobject'];

      var combine = function combine() {
        var _ct$items;

        var co = _this.benchObjects.get(cop.id);

        var ct = _this.benchObjects.get(ctp.id); // Remove the dragged object from the bench


        _this.benchObjects.remove(cop.id); // Combine dragged and dragover objects


        (_ct$items = ct.items).push.apply(_ct$items, _toConsumableArray(co.items));
      };

      dropElements.some(function (type) {
        return type === cop.cname;
      }) ? combine() : {};
    },
    dragover: function dragover(evt
    /** dragover event object*/
    ) {
      evt.dataTransfer.action = "move";
    }
  },
  template: "\n  <externalValue\n    v-if=\"this.externalValue.showUi\"\n    v-model:show=\"this.externalValue.showUi\"\n    :item=\"this.externalValue.source\"\n  >\n  </externalValue>\n  <drop v-else class=\"wbench\" @dropped=\"benched\" @dragover=\"dragover\">\n    <p v-if=\"benchObjects.length() == 0\">Drop types and objects...</p>\n    <ul>\n      <li v-for=\"bo in benchObjects.items\">\n        <dragdrop @dropped=\"combination\" @dragover=\"dragover\">\n          <wtobject\n            :base=\"bo\"\n            @externalValue=\"(this.externalValue.source = bo, this.externalValue.showUi = true)\"\n          >\n          </wtobject>\n          {{bo}}\n        </dragdrop>\n      </li>\n    </ul>\n  </drop>\n  "
};

/***/ }),

/***/ "./public/js/components/wobject.js":
/*!*****************************************!*\
  !*** ./public/js/components/wobject.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "wobject": () => (/* binding */ wobject)
/* harmony export */ });
var wobject = {
  props: ['name'],
  template: "\n  <div :name=\"name\" class=\"wobject\" cname=\"wobject\">\n    {{name}}\n  </div>\n  "
};

/***/ }),

/***/ "./public/js/components/workshop.js":
/*!******************************************!*\
  !*** ./public/js/components/workshop.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "workshop": () => (/* binding */ workshop)
/* harmony export */ });
/* harmony import */ var _wtype__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wtype */ "./public/js/components/wtype.js");
/* harmony import */ var _wobject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wobject */ "./public/js/components/wobject.js");
/* harmony import */ var _wtobject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wtobject */ "./public/js/components/wtobject.js");
/* harmony import */ var _wbench__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./wbench */ "./public/js/components/wbench.js");
/* harmony import */ var _drag__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./drag */ "./public/js/components/drag.js");
/* harmony import */ var _types_basic__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../types/basic */ "./public/js/types/basic.js");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







var workshop = {
  components: {
    wtype: _wtype__WEBPACK_IMPORTED_MODULE_0__.wtype,
    wobject: _wobject__WEBPACK_IMPORTED_MODULE_1__.wobject,
    wtobject: _wtobject__WEBPACK_IMPORTED_MODULE_2__.wtobject,
    wbench: _wbench__WEBPACK_IMPORTED_MODULE_3__.wbench,
    drag: _drag__WEBPACK_IMPORTED_MODULE_4__.drag
  },
  data: function data() {
    var _types;

    return {
      typeDef: '',
      typeError: false,
      types: (_types = {}, _defineProperty(_types, _types_basic__WEBPACK_IMPORTED_MODULE_5__.string.name, _types_basic__WEBPACK_IMPORTED_MODULE_5__.string.func), _defineProperty(_types, _types_basic__WEBPACK_IMPORTED_MODULE_5__.number.name, _types_basic__WEBPACK_IMPORTED_MODULE_5__.number.func), _defineProperty(_types, _types_basic__WEBPACK_IMPORTED_MODULE_5__.array.name, _types_basic__WEBPACK_IMPORTED_MODULE_5__.array.func), _defineProperty(_types, _types_basic__WEBPACK_IMPORTED_MODULE_5__.object.name, _types_basic__WEBPACK_IMPORTED_MODULE_5__.object.func), _defineProperty(_types, _types_basic__WEBPACK_IMPORTED_MODULE_5__.value.name, _types_basic__WEBPACK_IMPORTED_MODULE_5__.value.func), _defineProperty(_types, 'tf.model', tf.model), _types),
      objects: []
    };
  },
  methods: {
    newType: function newType() {
      try {
        this.typeDef == undefined || this.typeDef == '' ? this.setError() : this.types[this.typeDef] = new Function("return ".concat(this.typeDef))();
      } catch (e) {
        console.error(e);
        this.setError();
      }
    },
    setError: function setError() {
      this.typeError = true;
    },
    resetError: function resetError() {
      this.typeError = false;
    }
  },
  template: "\n  <div class=\"workshop-header\">\n    <input\n      placeholder=\"Type Reference\"\n      v-model.trim=\"typeDef\"\n      v-on:keyup.enter=\"newType\"\n      @input=\"resetError\"\n      class=\"workshop-form-elems\"\n      >\n    <!--<button\n      @click=\"newType\"\n      title=\"New type\"\n      class=\"workshop-form-elems\"\n      >New Type</button>-->\n  \n    <p v-if=\"typeError\">{{typeDef}} <em>is invalid</em></p>\n    <p v-else=\"!typeError\"></p>\n    <h5>Types</h5>\n    <ul>\n      <li v-for=\"(type, name) in types\">\n        <drag>\n          <wtype :name=\"name\"></wtype>\n        </drag>\n      </li>\n    </ul>\n    <h5>Bench</h5>\n    <wbench :types=\"types\" :objects=\"objects\"></wbench>\n    <h5>Objects</h5>\n    <ul>\n      <li v-for=\"ob in objects\">\n        <drag>\n          <wobject></wobject>\n        </drag>\n      </li>\n    </ul>\n  </div>\n  "
};

/***/ }),

/***/ "./public/js/components/wtobject.js":
/*!******************************************!*\
  !*** ./public/js/components/wtobject.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "wtobject": () => (/* binding */ wtobject)
/* harmony export */ });
/* harmony import */ var _wtype__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wtype */ "./public/js/components/wtype.js");
/* harmony import */ var _wobject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wobject */ "./public/js/components/wobject.js");


var wtobject = {
  components: {
    wtype: _wtype__WEBPACK_IMPORTED_MODULE_0__.wtype,
    wobject: _wobject__WEBPACK_IMPORTED_MODULE_1__.wobject
  },
  props: ['base'],
  emits: ['externalValue'],
  methods: {
    valueType: function valueType() {
      this.base.items.length == 1 && this.base.items[0].name === 'value';
    },
    externalValue: function externalValue() {
      this.valueType() ? this.$emit('externalValue') : {};
    },
    evaluate: function evaluate() {
      return this.valueType() ? this.base.value : graphValue(this.base.items);
    }
  },
  template: "\n  <div\n    class=\"wtobject\"\n    cname=\"wtobject\"\n    :id=\"base.id\"\n    :value=\"base.value\"\n    @dblclick.stop.prevent=\"externalValue\"\n  >\n    <input placeholder=\"name\" v-model=\"base.name\">\n    {{base.value}}\n\n\n    <!-- Iterate over bench object items -->\n    <component v-for=\"item in base.items\" :is=\"item.cname\" :name=\"item.name\"></component>\n    <button @click=\"evaluate\">Evaluate</button>\n  </div>\n  "
};

/***/ }),

/***/ "./public/js/components/wtype.js":
/*!***************************************!*\
  !*** ./public/js/components/wtype.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "wtype": () => (/* binding */ wtype)
/* harmony export */ });
var wtype = {
  components: {},
  props: ['name'],
  template: "\n  <div :name=\"name\" class=\"wtype\" cname=\"wtype\">\n    {{name}}\n  </div>\n  "
};

/***/ }),

/***/ "./public/js/random.js":
/*!*****************************!*\
  !*** ./public/js/random.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "makeId": () => (/* binding */ makeId)
/* harmony export */ });
/* harmony import */ var orb_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! orb-array */ "./node_modules/orb-array/src/index.js");
/* harmony import */ var orb_array__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(orb_array__WEBPACK_IMPORTED_MODULE_0__);

var makeId = function makeId() {
  var chars = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "abcdefghijklmnopqrstuvwxyz0123456789";
  var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;
  return (0,orb_array__WEBPACK_IMPORTED_MODULE_0__.range)(size).reduce(function (cid
  /**current id */
  ) {
    return cid + chars.charAt(Math.floor(Math.random() * chars.length));
  }, "");
};

/***/ }),

/***/ "./public/js/types/basic.js":
/*!**********************************!*\
  !*** ./public/js/types/basic.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "string": () => (/* binding */ string),
/* harmony export */   "number": () => (/* binding */ number),
/* harmony export */   "array": () => (/* binding */ array),
/* harmony export */   "object": () => (/* binding */ object),
/* harmony export */   "value": () => (/* binding */ value)
/* harmony export */ });
/* harmony import */ var orb_functions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! orb-functions */ "./node_modules/orb-functions/src/index.js");
/* harmony import */ var orb_functions__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(orb_functions__WEBPACK_IMPORTED_MODULE_0__);

var funcs = {
  number: function number(v) {
    return Number(v);
  },
  array: function array(_) {
    return [];
  },
  object: function object(_) {},
  value: function value(v) {
    return new Function("return (".concat(v, ")"))();
  }
};
var string = {
  name: 'string',
  func: orb_functions__WEBPACK_IMPORTED_MODULE_0__.self
};
var number = {
  name: 'number',
  func: funcs.number
};
var array = {
  name: 'array',
  func: funcs.array
};
var object = {
  name: 'object',
  func: funcs.object
};
var value = {
  name: 'value',
  func: funcs.value
};

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!****************************!*\
  !*** ./public/js/index.js ***!
  \****************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-bundler.js");
/* harmony import */ var _components_workshop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/workshop */ "./public/js/components/workshop.js");


var app = (0,vue__WEBPACK_IMPORTED_MODULE_0__.createApp)({
  data: function data() {
    return {};
  }
});
app.component('workshop', _components_workshop__WEBPACK_IMPORTED_MODULE_1__.workshop);
app.mount('#app');
})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mdXp6eS1wb3RhdG8vLi9ub2RlX21vZHVsZXMvQHZ1ZS9jb21waWxlci1jb3JlL2Rpc3QvY29tcGlsZXItY29yZS5lc20tYnVuZGxlci5qcyIsIndlYnBhY2s6Ly9mdXp6eS1wb3RhdG8vLi9ub2RlX21vZHVsZXMvQHZ1ZS9jb21waWxlci1kb20vZGlzdC9jb21waWxlci1kb20uZXNtLWJ1bmRsZXIuanMiLCJ3ZWJwYWNrOi8vZnV6enktcG90YXRvLy4vbm9kZV9tb2R1bGVzL0B2dWUvcmVhY3Rpdml0eS9kaXN0L3JlYWN0aXZpdHkuZXNtLWJ1bmRsZXIuanMiLCJ3ZWJwYWNrOi8vZnV6enktcG90YXRvLy4vbm9kZV9tb2R1bGVzL0B2dWUvcnVudGltZS1jb3JlL2Rpc3QvcnVudGltZS1jb3JlLmVzbS1idW5kbGVyLmpzIiwid2VicGFjazovL2Z1enp5LXBvdGF0by8uL25vZGVfbW9kdWxlcy9AdnVlL3J1bnRpbWUtZG9tL2Rpc3QvcnVudGltZS1kb20uZXNtLWJ1bmRsZXIuanMiLCJ3ZWJwYWNrOi8vZnV6enktcG90YXRvLy4vbm9kZV9tb2R1bGVzL0B2dWUvc2hhcmVkL2Rpc3Qvc2hhcmVkLmVzbS1idW5kbGVyLmpzIiwid2VicGFjazovL2Z1enp5LXBvdGF0by8uL25vZGVfbW9kdWxlcy9vcmItYXJyYXkvc3JjL2luZGV4LmpzIiwid2VicGFjazovL2Z1enp5LXBvdGF0by8uL25vZGVfbW9kdWxlcy9vcmItZnVuY3Rpb25zL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly9mdXp6eS1wb3RhdG8vLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmVzbS1idW5kbGVyLmpzIiwid2VicGFjazovL2Z1enp5LXBvdGF0by8uL3B1YmxpYy9qcy9hcnJheW1hcC5qcyIsIndlYnBhY2s6Ly9mdXp6eS1wb3RhdG8vLi9wdWJsaWMvanMvY29tcG9uZW50cy9kcmFnLmpzIiwid2VicGFjazovL2Z1enp5LXBvdGF0by8uL3B1YmxpYy9qcy9jb21wb25lbnRzL2V4dGVybmFsVmFsdWUuanMiLCJ3ZWJwYWNrOi8vZnV6enktcG90YXRvLy4vcHVibGljL2pzL2NvbXBvbmVudHMvd2JlbmNoLmpzIiwid2VicGFjazovL2Z1enp5LXBvdGF0by8uL3B1YmxpYy9qcy9jb21wb25lbnRzL3dvYmplY3QuanMiLCJ3ZWJwYWNrOi8vZnV6enktcG90YXRvLy4vcHVibGljL2pzL2NvbXBvbmVudHMvd29ya3Nob3AuanMiLCJ3ZWJwYWNrOi8vZnV6enktcG90YXRvLy4vcHVibGljL2pzL2NvbXBvbmVudHMvd3RvYmplY3QuanMiLCJ3ZWJwYWNrOi8vZnV6enktcG90YXRvLy4vcHVibGljL2pzL2NvbXBvbmVudHMvd3R5cGUuanMiLCJ3ZWJwYWNrOi8vZnV6enktcG90YXRvLy4vcHVibGljL2pzL3JhbmRvbS5qcyIsIndlYnBhY2s6Ly9mdXp6eS1wb3RhdG8vLi9wdWJsaWMvanMvdHlwZXMvYmFzaWMuanMiLCJ3ZWJwYWNrOi8vZnV6enktcG90YXRvL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2Z1enp5LXBvdGF0by93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9mdXp6eS1wb3RhdG8vd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL2Z1enp5LXBvdGF0by93ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsIiwid2VicGFjazovL2Z1enp5LXBvdGF0by93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL2Z1enp5LXBvdGF0by93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL2Z1enp5LXBvdGF0by8uL3B1YmxpYy9qcy9pbmRleC5qcyJdLCJuYW1lcyI6WyJkZWZhdWx0T25FcnJvciIsImVycm9yIiwiZGVmYXVsdE9uV2FybiIsIm1zZyIsInByb2Nlc3MiLCJjb25zb2xlIiwid2FybiIsIm1lc3NhZ2UiLCJjcmVhdGVDb21waWxlckVycm9yIiwiY29kZSIsImxvYyIsIm1lc3NhZ2VzIiwiYWRkaXRpb25hbE1lc3NhZ2UiLCJlcnJvck1lc3NhZ2VzIiwiU3ludGF4RXJyb3IiLCJTdHJpbmciLCJGUkFHTUVOVCIsIlN5bWJvbCIsIlRFTEVQT1JUIiwiU1VTUEVOU0UiLCJLRUVQX0FMSVZFIiwiQkFTRV9UUkFOU0lUSU9OIiwiT1BFTl9CTE9DSyIsIkNSRUFURV9CTE9DSyIsIkNSRUFURV9WTk9ERSIsIkNSRUFURV9DT01NRU5UIiwiQ1JFQVRFX1RFWFQiLCJDUkVBVEVfU1RBVElDIiwiUkVTT0xWRV9DT01QT05FTlQiLCJSRVNPTFZFX0RZTkFNSUNfQ09NUE9ORU5UIiwiUkVTT0xWRV9ESVJFQ1RJVkUiLCJSRVNPTFZFX0ZJTFRFUiIsIldJVEhfRElSRUNUSVZFUyIsIlJFTkRFUl9MSVNUIiwiUkVOREVSX1NMT1QiLCJDUkVBVEVfU0xPVFMiLCJUT19ESVNQTEFZX1NUUklORyIsIk1FUkdFX1BST1BTIiwiVE9fSEFORExFUlMiLCJDQU1FTElaRSIsIkNBUElUQUxJWkUiLCJUT19IQU5ETEVSX0tFWSIsIlNFVF9CTE9DS19UUkFDS0lORyIsIlBVU0hfU0NPUEVfSUQiLCJQT1BfU0NPUEVfSUQiLCJXSVRIX1NDT1BFX0lEIiwiV0lUSF9DVFgiLCJVTlJFRiIsIklTX1JFRiIsImhlbHBlck5hbWVNYXAiLCJyZWdpc3RlclJ1bnRpbWVIZWxwZXJzIiwiaGVscGVycyIsIk9iamVjdCIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZvckVhY2giLCJzIiwibG9jU3R1YiIsInNvdXJjZSIsInN0YXJ0IiwibGluZSIsImNvbHVtbiIsIm9mZnNldCIsImVuZCIsImNyZWF0ZVJvb3QiLCJjaGlsZHJlbiIsInR5cGUiLCJjb21wb25lbnRzIiwiZGlyZWN0aXZlcyIsImhvaXN0cyIsImltcG9ydHMiLCJjYWNoZWQiLCJ0ZW1wcyIsImNvZGVnZW5Ob2RlIiwidW5kZWZpbmVkIiwiY3JlYXRlVk5vZGVDYWxsIiwiY29udGV4dCIsInRhZyIsInByb3BzIiwicGF0Y2hGbGFnIiwiZHluYW1pY1Byb3BzIiwiaXNCbG9jayIsImRpc2FibGVUcmFja2luZyIsImhlbHBlciIsImNyZWF0ZUFycmF5RXhwcmVzc2lvbiIsImVsZW1lbnRzIiwiY3JlYXRlT2JqZWN0RXhwcmVzc2lvbiIsInByb3BlcnRpZXMiLCJjcmVhdGVPYmplY3RQcm9wZXJ0eSIsImtleSIsInZhbHVlIiwiaXNTdHJpbmciLCJjcmVhdGVTaW1wbGVFeHByZXNzaW9uIiwiY29udGVudCIsImlzU3RhdGljIiwiY29uc3RUeXBlIiwiY3JlYXRlSW50ZXJwb2xhdGlvbiIsImNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbiIsImNyZWF0ZUNhbGxFeHByZXNzaW9uIiwiY2FsbGVlIiwiYXJncyIsImFyZ3VtZW50cyIsImNyZWF0ZUZ1bmN0aW9uRXhwcmVzc2lvbiIsInBhcmFtcyIsInJldHVybnMiLCJuZXdsaW5lIiwiaXNTbG90IiwiY3JlYXRlQ29uZGl0aW9uYWxFeHByZXNzaW9uIiwidGVzdCIsImNvbnNlcXVlbnQiLCJhbHRlcm5hdGUiLCJjcmVhdGVDYWNoZUV4cHJlc3Npb24iLCJpbmRleCIsImlzVk5vZGUiLCJjcmVhdGVCbG9ja1N0YXRlbWVudCIsImJvZHkiLCJjcmVhdGVUZW1wbGF0ZUxpdGVyYWwiLCJjcmVhdGVJZlN0YXRlbWVudCIsImNyZWF0ZUFzc2lnbm1lbnRFeHByZXNzaW9uIiwibGVmdCIsInJpZ2h0IiwiY3JlYXRlU2VxdWVuY2VFeHByZXNzaW9uIiwiZXhwcmVzc2lvbnMiLCJjcmVhdGVSZXR1cm5TdGF0ZW1lbnQiLCJpc1N0YXRpY0V4cCIsInAiLCJpc0J1aWx0SW5UeXBlIiwiZXhwZWN0ZWQiLCJoeXBoZW5hdGUiLCJpc0NvcmVDb21wb25lbnQiLCJub25JZGVudGlmaWVyUkUiLCJpc1NpbXBsZUlkZW50aWZpZXIiLCJuYW1lIiwibWVtYmVyRXhwUkUiLCJpc01lbWJlckV4cHJlc3Npb24iLCJwYXRoIiwibWF0Y2hlZCIsImV4ZWMiLCJ0cmltIiwiZ2V0SW5uZXJSYW5nZSIsImxlbmd0aCIsInN1YnN0ciIsIm5ld0xvYyIsImFkdmFuY2VQb3NpdGlvbldpdGhDbG9uZSIsInBvcyIsIm51bWJlck9mQ2hhcmFjdGVycyIsImFkdmFuY2VQb3NpdGlvbldpdGhNdXRhdGlvbiIsImV4dGVuZCIsImxpbmVzQ291bnQiLCJsYXN0TmV3TGluZVBvcyIsImkiLCJjaGFyQ29kZUF0IiwiYXNzZXJ0IiwiY29uZGl0aW9uIiwiRXJyb3IiLCJmaW5kRGlyIiwibm9kZSIsImFsbG93RW1wdHkiLCJleHAiLCJmaW5kUHJvcCIsImR5bmFtaWNPbmx5IiwiaXNCaW5kS2V5IiwiYXJnIiwiaGFzRHluYW1pY0tleVZCaW5kIiwic29tZSIsImlzVGV4dCIsImlzVlNsb3QiLCJpc1RlbXBsYXRlTm9kZSIsInRhZ1R5cGUiLCJpc1Nsb3RPdXRsZXQiLCJpbmplY3RQcm9wIiwicHJvcCIsInByb3BzV2l0aEluamVjdGlvbiIsImZpcnN0IiwidW5zaGlmdCIsImFscmVhZHlFeGlzdHMiLCJwcm9wS2V5TmFtZSIsInRvVmFsaWRBc3NldElkIiwicmVwbGFjZSIsImhhc1Njb3BlUmVmIiwiaWRzIiwia2V5cyIsImMiLCJicmFuY2hlcyIsImIiLCJpc09iamVjdCIsImRlcHJlY2F0aW9uRGF0YSIsImxpbmsiLCJnZXRDb21wYXRWYWx1ZSIsImNvbmZpZyIsIm9wdGlvbnMiLCJjb21wYXRDb25maWciLCJpc0NvbXBhdEVuYWJsZWQiLCJtb2RlIiwiY2hlY2tDb21wYXRFbmFibGVkIiwiZW5hYmxlZCIsIndhcm5EZXByZWNhdGlvbiIsInZhbCIsImVyciIsIm9uV2FybiIsImRlY29kZVJFIiwiZGVjb2RlTWFwIiwiZ3QiLCJsdCIsImFtcCIsImFwb3MiLCJxdW90IiwiZGVmYXVsdFBhcnNlck9wdGlvbnMiLCJkZWxpbWl0ZXJzIiwiZ2V0TmFtZXNwYWNlIiwiZ2V0VGV4dE1vZGUiLCJpc1ZvaWRUYWciLCJOTyIsImlzUHJlVGFnIiwiaXNDdXN0b21FbGVtZW50IiwiZGVjb2RlRW50aXRpZXMiLCJyYXdUZXh0IiwiXyIsInAxIiwib25FcnJvciIsImNvbW1lbnRzIiwiYmFzZVBhcnNlIiwiY3JlYXRlUGFyc2VyQ29udGV4dCIsImdldEN1cnNvciIsInBhcnNlQ2hpbGRyZW4iLCJnZXRTZWxlY3Rpb24iLCJyYXdPcHRpb25zIiwib3JpZ2luYWxTb3VyY2UiLCJpblByZSIsImluVlByZSIsImFuY2VzdG9ycyIsInBhcmVudCIsImxhc3QiLCJucyIsIm5vZGVzIiwiaXNFbmQiLCJzdGFydHNXaXRoIiwicGFyc2VJbnRlcnBvbGF0aW9uIiwiZW1pdEVycm9yIiwicGFyc2VDb21tZW50IiwicGFyc2VCb2d1c0NvbW1lbnQiLCJwYXJzZUNEQVRBIiwiYWR2YW5jZUJ5IiwicGFyc2VUYWciLCJwYXJzZUVsZW1lbnQiLCJpc1NwZWNpYWxUZW1wbGF0ZURpcmVjdGl2ZSIsInBhcnNlVGV4dCIsImlzQXJyYXkiLCJwdXNoTm9kZSIsInJlbW92ZWRXaGl0ZXNwYWNlIiwicHJlc2VydmUiLCJ3aGl0ZXNwYWNlIiwicHJldiIsIm5leHQiLCJmaWx0ZXIiLCJCb29sZWFuIiwicHVzaCIsIm1hdGNoIiwic2xpY2UiLCJwcmV2SW5kZXgiLCJuZXN0ZWRJbmRleCIsImluZGV4T2YiLCJjb250ZW50U3RhcnQiLCJjbG9zZUluZGV4Iiwid2FzSW5QcmUiLCJ3YXNJblZQcmUiLCJlbGVtZW50IiwiaXNQcmVCb3VuZGFyeSIsImlzVlByZUJvdW5kYXJ5IiwiaXNTZWxmQ2xvc2luZyIsInBvcCIsImlubGluZVRlbXBsYXRlUHJvcCIsImZpbmQiLCJzdGFydHNXaXRoRW5kVGFnT3BlbiIsInRvTG93ZXJDYXNlIiwibWFrZU1hcCIsImFkdmFuY2VTcGFjZXMiLCJjdXJzb3IiLCJjdXJyZW50U291cmNlIiwicGFyc2VBdHRyaWJ1dGVzIiwiaGFzSWYiLCJoYXNGb3IiLCJoYXNWSXMiLCJpc05hdGl2ZVRhZyIsImlzQnVpbHRJbkNvbXBvbmVudCIsImF0dHJpYnV0ZU5hbWVzIiwiU2V0IiwiYXR0ciIsInBhcnNlQXR0cmlidXRlIiwibmFtZVNldCIsImhhcyIsImFkZCIsInBhdHRlcm4iLCJtIiwicGFyc2VBdHRyaWJ1dGVWYWx1ZSIsImRpck5hbWUiLCJzdGFydE9mZnNldCIsImxhc3RJbmRleE9mIiwiZ2V0TmV3UG9zaXRpb24iLCJlbmRzV2l0aCIsImlzUXVvdGVkIiwidmFsdWVMb2MiLCJtb2RpZmllcnMiLCJzcGxpdCIsImluY2x1ZGVzIiwic3BsaWNlIiwicXVvdGUiLCJlbmRJbmRleCIsInBhcnNlVGV4dERhdGEiLCJ1bmV4cGVjdGVkQ2hhcnMiLCJvcGVuIiwiY2xvc2UiLCJpbm5lclN0YXJ0IiwiaW5uZXJFbmQiLCJyYXdDb250ZW50TGVuZ3RoIiwicmF3Q29udGVudCIsInByZVRyaW1Db250ZW50IiwiZW5kT2Zmc2V0IiwiZW5kVG9rZW5zIiwieHMiLCJzZWFyY2hTdHJpbmciLCJob2lzdFN0YXRpYyIsInJvb3QiLCJ3YWxrIiwiaXNTaW5nbGVFbGVtZW50Um9vdCIsImNoaWxkIiwiZG9Ob3RIb2lzdE5vZGUiLCJoYXNIb2lzdGVkTm9kZSIsImNhblN0cmluZ2lmeSIsImNvbnN0YW50VHlwZSIsImdldENvbnN0YW50VHlwZSIsImhvaXN0IiwiZmxhZyIsImdldFBhdGNoRmxhZyIsImdldEdlbmVyYXRlZFByb3BzQ29uc3RhbnRUeXBlIiwiZ2V0Tm9kZVByb3BzIiwiY29udGVudFR5cGUiLCJpc0NvbXBvbmVudCIsInNjb3BlcyIsInZTbG90IiwidHJhbnNmb3JtSG9pc3QiLCJjb25zdGFudENhY2hlIiwiZ2V0IiwicmV0dXJuVHlwZSIsImdlbmVyYXRlZFByb3BzVHlwZSIsInNldCIsImNoaWxkVHlwZSIsImV4cFR5cGUiLCJyZW1vdmVIZWxwZXIiLCJpc1N5bWJvbCIsImtleVR5cGUiLCJ2YWx1ZVR5cGUiLCJwYXJzZUludCIsImNyZWF0ZVRyYW5zZm9ybUNvbnRleHQiLCJmaWxlbmFtZSIsInByZWZpeElkZW50aWZpZXJzIiwiY2FjaGVIYW5kbGVycyIsIm5vZGVUcmFuc2Zvcm1zIiwiZGlyZWN0aXZlVHJhbnNmb3JtcyIsIk5PT1AiLCJleHByZXNzaW9uUGx1Z2lucyIsInNjb3BlSWQiLCJzbG90dGVkIiwic3NyIiwic3NyQ3NzVmFycyIsImJpbmRpbmdNZXRhZGF0YSIsIkVNUFRZX09CSiIsImlubGluZSIsImlzVFMiLCJuYW1lTWF0Y2giLCJzZWxmTmFtZSIsImNhcGl0YWxpemUiLCJjYW1lbGl6ZSQxIiwiTWFwIiwiaWRlbnRpZmllcnMiLCJjcmVhdGUiLCJ2Rm9yIiwidlByZSIsInZPbmNlIiwiY3VycmVudE5vZGUiLCJjaGlsZEluZGV4IiwiY291bnQiLCJjdXJyZW50Q291bnQiLCJkZWxldGUiLCJoZWxwZXJTdHJpbmciLCJyZXBsYWNlTm9kZSIsInJlbW92ZU5vZGUiLCJsaXN0IiwicmVtb3ZhbEluZGV4Iiwib25Ob2RlUmVtb3ZlZCIsImFkZElkZW50aWZpZXJzIiwicmVtb3ZlSWRlbnRpZmllcnMiLCJpZGVudGlmaWVyIiwiaG9pc3RlZCIsImNhY2hlIiwiZmlsdGVycyIsInRyYW5zZm9ybSIsInRyYXZlcnNlTm9kZSIsImNyZWF0ZVJvb3RDb2RlZ2VuIiwicGF0Y2hGbGFnVGV4dCIsIlBhdGNoRmxhZ05hbWVzIiwidHJhdmVyc2VDaGlsZHJlbiIsIm5vZGVSZW1vdmVkIiwiZXhpdEZucyIsIm9uRXhpdCIsImNyZWF0ZVN0cnVjdHVyYWxEaXJlY3RpdmVUcmFuc2Zvcm0iLCJmbiIsIm1hdGNoZXMiLCJuIiwiUFVSRV9BTk5PVEFUSU9OIiwiY3JlYXRlQ29kZWdlbkNvbnRleHQiLCJhc3QiLCJzb3VyY2VNYXAiLCJvcHRpbWl6ZUltcG9ydHMiLCJydW50aW1lR2xvYmFsTmFtZSIsInJ1bnRpbWVNb2R1bGVOYW1lIiwiaW5kZW50TGV2ZWwiLCJwdXJlIiwibWFwIiwiaW5kZW50IiwiZGVpbmRlbnQiLCJ3aXRob3V0TmV3TGluZSIsInJlcGVhdCIsImdlbmVyYXRlIiwib25Db250ZXh0Q3JlYXRlZCIsImhhc0hlbHBlcnMiLCJ1c2VXaXRoQmxvY2siLCJwcmVhbWJsZUNvbnRleHQiLCJnZW5GdW5jdGlvblByZWFtYmxlIiwiZnVuY3Rpb25OYW1lIiwic2lnbmF0dXJlIiwiam9pbiIsImdlbkFzc2V0cyIsImdlbk5vZGUiLCJwcmVhbWJsZSIsInRvSlNPTiIsIlZ1ZUJpbmRpbmciLCJhbGlhc0hlbHBlciIsInN0YXRpY0hlbHBlcnMiLCJnZW5Ib2lzdHMiLCJhc3NldHMiLCJyZXNvbHZlciIsImlkIiwibWF5YmVTZWxmUmVmZXJlbmNlIiwiSlNPTiIsInN0cmluZ2lmeSIsImlzVGV4dCQxIiwiZ2VuTm9kZUxpc3RBc0FycmF5IiwibXVsdGlsaW5lcyIsImdlbk5vZGVMaXN0IiwiY29tbWEiLCJnZW5UZXh0IiwiZ2VuRXhwcmVzc2lvbiIsImdlbkludGVycG9sYXRpb24iLCJnZW5Db21wb3VuZEV4cHJlc3Npb24iLCJnZW5Db21tZW50IiwiZ2VuVk5vZGVDYWxsIiwiZ2VuQ2FsbEV4cHJlc3Npb24iLCJnZW5PYmplY3RFeHByZXNzaW9uIiwiZ2VuQXJyYXlFeHByZXNzaW9uIiwiZ2VuRnVuY3Rpb25FeHByZXNzaW9uIiwiZ2VuQ29uZGl0aW9uYWxFeHByZXNzaW9uIiwiZ2VuQ2FjaGVFeHByZXNzaW9uIiwiZXhoYXVzdGl2ZUNoZWNrIiwiZ2VuRXhwcmVzc2lvbkFzUHJvcGVydHlLZXkiLCJ0ZXh0IiwiZ2VuTnVsbGFibGVBcmdzIiwiaXNOb25TY29wZWRTbG90IiwibmVlZE5ld2xpbmUiLCJuZWVkc1BhcmVucyIsImlzTmVzdGVkIiwicHJvaGliaXRlZEtleXdvcmRSRSIsIlJlZ0V4cCIsInN0cmlwU3RyaW5nUkUiLCJ2YWxpZGF0ZUJyb3dzZXJFeHByZXNzaW9uIiwiYXNQYXJhbXMiLCJhc1Jhd1N0YXRlbWVudHMiLCJGdW5jdGlvbiIsImUiLCJrZXl3b3JkTWF0Y2giLCJ0cmFuc2Zvcm1FeHByZXNzaW9uIiwicHJvY2Vzc0V4cHJlc3Npb24iLCJkaXIiLCJ0cmFuc2Zvcm1JZiIsInByb2Nlc3NJZiIsImlmTm9kZSIsImJyYW5jaCIsImlzUm9vdCIsInNpYmxpbmdzIiwic2libGluZyIsImNyZWF0ZUNvZGVnZW5Ob2RlRm9yQnJhbmNoIiwicGFyZW50Q29uZGl0aW9uIiwiZ2V0UGFyZW50Q29uZGl0aW9uIiwicHJvY2Vzc0NvZGVnZW4iLCJjcmVhdGVJZkJyYW5jaCIsInVzZXJLZXkiLCJpc1NhbWVLZXkiLCJrZXlJbmRleCIsImNyZWF0ZUNoaWxkcmVuQ29kZWdlbk5vZGUiLCJrZXlQcm9wZXJ0eSIsImZpcnN0Q2hpbGQiLCJuZWVkRnJhZ21lbnRXcmFwcGVyIiwidm5vZGVDYWxsIiwiYSIsImJyYW5jaEV4cCIsInRyYW5zZm9ybUZvciIsInByb2Nlc3NGb3IiLCJmb3JOb2RlIiwicmVuZGVyRXhwIiwia2V5UHJvcCIsImlzU3RhYmxlRnJhZ21lbnQiLCJmcmFnbWVudEZsYWciLCJjaGlsZEJsb2NrIiwiaXNUZW1wbGF0ZSIsInNsb3RPdXRsZXQiLCJjcmVhdGVGb3JMb29wUGFyYW1zIiwicGFyc2VSZXN1bHQiLCJwYXJzZUZvckV4cHJlc3Npb24iLCJ2YWx1ZUFsaWFzIiwia2V5QWxpYXMiLCJvYmplY3RJbmRleEFsaWFzIiwiZm9yQWxpYXNSRSIsImZvckl0ZXJhdG9yUkUiLCJzdHJpcFBhcmVuc1JFIiwiaW5wdXQiLCJpbk1hdGNoIiwiTEhTIiwiUkhTIiwicmVzdWx0IiwiY3JlYXRlQWxpYXNFeHByZXNzaW9uIiwidmFsdWVDb250ZW50IiwidHJpbW1lZE9mZnNldCIsIml0ZXJhdG9yTWF0Y2giLCJrZXlDb250ZW50Iiwia2V5T2Zmc2V0IiwiaW5kZXhDb250ZW50IiwicmFuZ2UiLCJkZWZhdWx0RmFsbGJhY2siLCJ0cmFja1Nsb3RTY29wZXMiLCJ0cmFja1ZGb3JTbG90U2NvcGVzIiwiYnVpbGRDbGllbnRTbG90Rm4iLCJidWlsZFNsb3RzIiwiYnVpbGRTbG90Rm4iLCJzbG90c1Byb3BlcnRpZXMiLCJkeW5hbWljU2xvdHMiLCJoYXNEeW5hbWljU2xvdHMiLCJvbkNvbXBvbmVudFNsb3QiLCJoYXNUZW1wbGF0ZVNsb3RzIiwiaGFzTmFtZWREZWZhdWx0U2xvdCIsImltcGxpY2l0RGVmYXVsdENoaWxkcmVuIiwic2VlblNsb3ROYW1lcyIsInNsb3RFbGVtZW50Iiwic2xvdERpciIsInNsb3RDaGlsZHJlbiIsInNsb3RMb2MiLCJzbG90TmFtZSIsInNsb3RQcm9wcyIsImRpckxvYyIsInN0YXRpY1Nsb3ROYW1lIiwic2xvdEZ1bmN0aW9uIiwidklmIiwidkVsc2UiLCJidWlsZER5bmFtaWNTbG90IiwiaiIsImNvbmRpdGlvbmFsIiwiYnVpbGREZWZhdWx0U2xvdFByb3BlcnR5IiwiaXNOb25XaGl0ZXNwYWNlQ29udGVudCIsInNsb3RGbGFnIiwiaGFzRm9yd2FyZGVkU2xvdHMiLCJzbG90cyIsImNvbmNhdCIsInNsb3RGbGFnc1RleHQiLCJkaXJlY3RpdmVJbXBvcnRNYXAiLCJXZWFrTWFwIiwidHJhbnNmb3JtRWxlbWVudCIsInBvc3RUcmFuc2Zvcm1FbGVtZW50Iiwidm5vZGVUYWciLCJyZXNvbHZlQ29tcG9uZW50VHlwZSIsImlzRHluYW1pY0NvbXBvbmVudCIsInZub2RlUHJvcHMiLCJ2bm9kZUNoaWxkcmVuIiwidm5vZGVQYXRjaEZsYWciLCJ2bm9kZUR5bmFtaWNQcm9wcyIsImR5bmFtaWNQcm9wTmFtZXMiLCJ2bm9kZURpcmVjdGl2ZXMiLCJzaG91bGRVc2VCbG9jayIsInByb3BzQnVpbGRSZXN1bHQiLCJidWlsZFByb3BzIiwiYnVpbGREaXJlY3RpdmVBcmdzIiwic2hvdWxkQnVpbGRBc1Nsb3RzIiwiaGFzRHluYW1pY1RleHRDaGlsZCIsImZsYWdOYW1lcyIsIk51bWJlciIsInN0cmluZ2lmeUR5bmFtaWNQcm9wTmFtZXMiLCJpc0V4cGxpY2l0RHluYW1pYyIsImlzQ29tcG9uZW50VGFnIiwiaXNQcm9wIiwiYnVpbHRJbiIsImVsZW1lbnRMb2MiLCJtZXJnZUFyZ3MiLCJydW50aW1lRGlyZWN0aXZlcyIsImhhc1JlZiIsImhhc0NsYXNzQmluZGluZyIsImhhc1N0eWxlQmluZGluZyIsImhhc0h5ZHJhdGlvbkV2ZW50QmluZGluZyIsImhhc0R5bmFtaWNLZXlzIiwiaGFzVm5vZGVIb29rIiwiYW5hbHl6ZVBhdGNoRmxhZyIsImlzRXZlbnRIYW5kbGVyIiwiaXNPbiIsImlzUmVzZXJ2ZWRQcm9wIiwiaXNWQmluZCIsImlzVk9uIiwiZGVkdXBlUHJvcGVydGllcyIsImhhc092ZXJyaWRhYmxlS2V5cyIsImRpcmVjdGl2ZVRyYW5zZm9ybSIsIm5lZWRSdW50aW1lIiwicHJvcHNFeHByZXNzaW9uIiwia25vd25Qcm9wcyIsImRlZHVwZWQiLCJleGlzdGluZyIsIm1lcmdlQXNBcnJheSIsImluY29taW5nIiwiZGlyQXJncyIsInJ1bnRpbWUiLCJ0cnVlRXhwcmVzc2lvbiIsIm1vZGlmaWVyIiwicHJvcHNOYW1lc1N0cmluZyIsImwiLCJmcmVlemUiLCJjYWNoZVN0cmluZ0Z1bmN0aW9uIiwic3RyIiwiaGl0IiwiY2FtZWxpemVSRSIsImNhbWVsaXplIiwidG9VcHBlckNhc2UiLCJ0cmFuc2Zvcm1TbG90T3V0bGV0IiwicHJvY2Vzc1Nsb3RPdXRsZXQiLCJzbG90QXJncyIsIm5vbk5hbWVQcm9wcyIsImZuRXhwUkUiLCJ0cmFuc2Zvcm1PbiIsImF1Z21lbnRvciIsImV2ZW50TmFtZSIsInJhd05hbWUiLCJ0b0hhbmRsZXJLZXkiLCJzaG91bGRDYWNoZSIsImlzTWVtYmVyRXhwIiwiaXNJbmxpbmVTdGF0ZW1lbnQiLCJoYXNNdWx0aXBsZVN0YXRlbWVudHMiLCJyZXQiLCJ0cmFuc2Zvcm1CaW5kIiwiX25vZGUiLCJ0cmFuc2Zvcm1UZXh0IiwiY3VycmVudENvbnRhaW5lciIsImhhc1RleHQiLCJjYWxsQXJncyIsInNlZW4iLCJXZWFrU2V0IiwidHJhbnNmb3JtT25jZSIsImN1ciIsInRyYW5zZm9ybU1vZGVsIiwiY3JlYXRlVHJhbnNmb3JtUHJvcHMiLCJyYXdFeHAiLCJleHBTdHJpbmciLCJtYXliZVJlZiIsInByb3BOYW1lIiwiYXNzaWdubWVudEV4cCIsImV2ZW50QXJnIiwibW9kaWZpZXJzS2V5IiwidmFsaWREaXZpc2lvbkNoYXJSRSIsInRyYW5zZm9ybUZpbHRlciIsInJld3JpdGVGaWx0ZXIiLCJwYXJzZUZpbHRlciIsImluU2luZ2xlIiwiaW5Eb3VibGUiLCJpblRlbXBsYXRlU3RyaW5nIiwiaW5SZWdleCIsImN1cmx5Iiwic3F1YXJlIiwicGFyZW4iLCJsYXN0RmlsdGVySW5kZXgiLCJleHByZXNzaW9uIiwicHVzaEZpbHRlciIsImNoYXJBdCIsIndyYXBGaWx0ZXIiLCJnZXRCYXNlVHJhbnNmb3JtUHJlc2V0Iiwib24iLCJiaW5kIiwibW9kZWwiLCJiYXNlQ29tcGlsZSIsInRlbXBsYXRlIiwiaXNNb2R1bGVNb2RlIiwibm9vcERpcmVjdGl2ZVRyYW5zZm9ybSIsIlZfTU9ERUxfUkFESU8iLCJWX01PREVMX0NIRUNLQk9YIiwiVl9NT0RFTF9URVhUIiwiVl9NT0RFTF9TRUxFQ1QiLCJWX01PREVMX0RZTkFNSUMiLCJWX09OX1dJVEhfTU9ESUZJRVJTIiwiVl9PTl9XSVRIX0tFWVMiLCJWX1NIT1ciLCJUUkFOU0lUSU9OIiwiVFJBTlNJVElPTl9HUk9VUCIsImRlY29kZXIiLCJkZWNvZGVIdG1sQnJvd3NlciIsInJhdyIsImFzQXR0ciIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImlubmVySFRNTCIsImdldEF0dHJpYnV0ZSIsInRleHRDb250ZW50IiwiaXNSYXdUZXh0Q29udGFpbmVyIiwicGFyc2VyT3B0aW9ucyIsImlzSFRNTFRhZyIsImlzU1ZHVGFnIiwidHJhbnNmb3JtU3R5bGUiLCJwYXJzZUlubGluZUNTUyIsImNzc1RleHQiLCJub3JtYWxpemVkIiwicGFyc2VTdHJpbmdTdHlsZSIsImNyZWF0ZURPTUNvbXBpbGVyRXJyb3IiLCJET01FcnJvck1lc3NhZ2VzIiwidHJhbnNmb3JtVkh0bWwiLCJ0cmFuc2Zvcm1WVGV4dCIsImJhc2VSZXN1bHQiLCJ0cmFuc2Zvcm1Nb2RlbCQxIiwiY2hlY2tEdXBsaWNhdGVkVmFsdWUiLCJkaXJlY3RpdmVUb1VzZSIsImlzSW52YWxpZFR5cGUiLCJpc0V2ZW50T3B0aW9uTW9kaWZpZXIiLCJpc05vbktleU1vZGlmaWVyIiwibWF5YmVLZXlNb2RpZmllciIsImlzS2V5Ym9hcmRFdmVudCIsInJlc29sdmVNb2RpZmllcnMiLCJrZXlNb2RpZmllcnMiLCJub25LZXlNb2RpZmllcnMiLCJldmVudE9wdGlvbk1vZGlmaWVycyIsInRyYW5zZm9ybUNsaWNrIiwiZXZlbnQiLCJpc1N0YXRpY0NsaWNrIiwidHJhbnNmb3JtT24kMSIsImhhbmRsZXJFeHAiLCJtb2RpZmllclBvc3RmaXgiLCJ0cmFuc2Zvcm1TaG93Iiwid2FyblRyYW5zaXRpb25DaGlsZHJlbiIsImNvbXBvbmVudCIsImhhc011bHRpcGxlQ2hpbGRyZW4iLCJpZ25vcmVTaWRlRWZmZWN0VGFncyIsIkRPTU5vZGVUcmFuc2Zvcm1zIiwiRE9NRGlyZWN0aXZlVHJhbnNmb3JtcyIsImNsb2FrIiwiaHRtbCIsInNob3ciLCJjb21waWxlIiwicGFyc2UiLCJ0YXJnZXRNYXAiLCJlZmZlY3RTdGFjayIsImFjdGl2ZUVmZmVjdCIsIklURVJBVEVfS0VZIiwiTUFQX0tFWV9JVEVSQVRFX0tFWSIsImlzRWZmZWN0IiwiX2lzRWZmZWN0IiwiZWZmZWN0IiwiY3JlYXRlUmVhY3RpdmVFZmZlY3QiLCJsYXp5Iiwic3RvcCIsImFjdGl2ZSIsImNsZWFudXAiLCJvblN0b3AiLCJ1aWQiLCJyZWFjdGl2ZUVmZmVjdCIsImVuYWJsZVRyYWNraW5nIiwicmVzZXRUcmFja2luZyIsImFsbG93UmVjdXJzZSIsImRlcHMiLCJzaG91bGRUcmFjayIsInRyYWNrU3RhY2siLCJwYXVzZVRyYWNraW5nIiwidHJhY2siLCJ0YXJnZXQiLCJkZXBzTWFwIiwiZGVwIiwib25UcmFjayIsInRyaWdnZXIiLCJuZXdWYWx1ZSIsIm9sZFZhbHVlIiwib2xkVGFyZ2V0IiwiZWZmZWN0cyIsImVmZmVjdHNUb0FkZCIsImlzTWFwIiwiaXNJbnRlZ2VyS2V5IiwicnVuIiwib25UcmlnZ2VyIiwic2NoZWR1bGVyIiwiaXNOb25UcmFja2FibGVLZXlzIiwiYnVpbHRJblN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiY3JlYXRlR2V0dGVyIiwic2hhbGxvd0dldCIsInJlYWRvbmx5R2V0Iiwic2hhbGxvd1JlYWRvbmx5R2V0IiwiYXJyYXlJbnN0cnVtZW50YXRpb25zIiwibWV0aG9kIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJhcnIiLCJ0b1JhdyIsInJlcyIsImFwcGx5IiwiaXNSZWFkb25seSIsInNoYWxsb3ciLCJyZWNlaXZlciIsInNoYWxsb3dSZWFkb25seU1hcCIsInJlYWRvbmx5TWFwIiwic2hhbGxvd1JlYWN0aXZlTWFwIiwicmVhY3RpdmVNYXAiLCJ0YXJnZXRJc0FycmF5IiwiaGFzT3duIiwiUmVmbGVjdCIsImlzUmVmIiwic2hvdWxkVW53cmFwIiwicmVhZG9ubHkiLCJyZWFjdGl2ZSIsImNyZWF0ZVNldHRlciIsInNoYWxsb3dTZXQiLCJoYWRLZXkiLCJoYXNDaGFuZ2VkIiwiZGVsZXRlUHJvcGVydHkiLCJvd25LZXlzIiwibXV0YWJsZUhhbmRsZXJzIiwicmVhZG9ubHlIYW5kbGVycyIsInNoYWxsb3dSZWFjdGl2ZUhhbmRsZXJzIiwic2hhbGxvd1JlYWRvbmx5SGFuZGxlcnMiLCJ0b1JlYWN0aXZlIiwidG9SZWFkb25seSIsInRvU2hhbGxvdyIsImdldFByb3RvIiwidiIsImdldFByb3RvdHlwZU9mIiwiZ2V0JDEiLCJpc1NoYWxsb3ciLCJyYXdUYXJnZXQiLCJyYXdLZXkiLCJ3cmFwIiwiY2FsbCIsImhhcyQxIiwic2l6ZSIsInByb3RvIiwic2V0JDEiLCJjaGVja0lkZW50aXR5S2V5cyIsImRlbGV0ZUVudHJ5IiwiY2xlYXIiLCJoYWRJdGVtcyIsImNyZWF0ZUZvckVhY2giLCJjYWxsYmFjayIsInRoaXNBcmciLCJvYnNlcnZlZCIsImNyZWF0ZUl0ZXJhYmxlTWV0aG9kIiwidGFyZ2V0SXNNYXAiLCJpc1BhaXIiLCJpdGVyYXRvciIsImlzS2V5T25seSIsImlubmVySXRlcmF0b3IiLCJkb25lIiwiY3JlYXRlUmVhZG9ubHlNZXRob2QiLCJtdXRhYmxlSW5zdHJ1bWVudGF0aW9ucyIsInNoYWxsb3dJbnN0cnVtZW50YXRpb25zIiwicmVhZG9ubHlJbnN0cnVtZW50YXRpb25zIiwic2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9ucyIsIml0ZXJhdG9yTWV0aG9kcyIsImNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlciIsImluc3RydW1lbnRhdGlvbnMiLCJtdXRhYmxlQ29sbGVjdGlvbkhhbmRsZXJzIiwic2hhbGxvd0NvbGxlY3Rpb25IYW5kbGVycyIsInJlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzIiwic2hhbGxvd1JlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzIiwidG9SYXdUeXBlIiwidGFyZ2V0VHlwZU1hcCIsInJhd1R5cGUiLCJnZXRUYXJnZXRUeXBlIiwiaXNFeHRlbnNpYmxlIiwiY3JlYXRlUmVhY3RpdmVPYmplY3QiLCJzaGFsbG93UmVhY3RpdmUiLCJzaGFsbG93UmVhZG9ubHkiLCJiYXNlSGFuZGxlcnMiLCJjb2xsZWN0aW9uSGFuZGxlcnMiLCJwcm94eU1hcCIsImV4aXN0aW5nUHJveHkiLCJ0YXJnZXRUeXBlIiwicHJveHkiLCJQcm94eSIsImlzUmVhY3RpdmUiLCJpc1Byb3h5IiwibWFya1JhdyIsImRlZiIsImNvbnZlcnQiLCJyIiwiX192X2lzUmVmIiwicmVmIiwiY3JlYXRlUmVmIiwic2hhbGxvd1JlZiIsIlJlZkltcGwiLCJfcmF3VmFsdWUiLCJfc2hhbGxvdyIsIl92YWx1ZSIsIm5ld1ZhbCIsInJhd1ZhbHVlIiwidHJpZ2dlclJlZiIsInVucmVmIiwic2hhbGxvd1Vud3JhcEhhbmRsZXJzIiwicHJveHlSZWZzIiwib2JqZWN0V2l0aFJlZnMiLCJDdXN0b21SZWZJbXBsIiwiZmFjdG9yeSIsIl9nZXQiLCJfc2V0IiwiY3VzdG9tUmVmIiwidG9SZWZzIiwib2JqZWN0IiwidG9SZWYiLCJPYmplY3RSZWZJbXBsIiwiX29iamVjdCIsIl9rZXkiLCJDb21wdXRlZFJlZkltcGwiLCJnZXR0ZXIiLCJfc2V0dGVyIiwiX2RpcnR5Iiwic2VsZiIsImNvbXB1dGVkIiwiZ2V0dGVyT3JPcHRpb25zIiwic2V0dGVyIiwiaXNGdW5jdGlvbiIsInN0YWNrIiwicHVzaFdhcm5pbmdDb250ZXh0Iiwidm5vZGUiLCJwb3BXYXJuaW5nQ29udGV4dCIsImluc3RhbmNlIiwiYXBwV2FybkhhbmRsZXIiLCJhcHBDb250ZXh0Iiwid2FybkhhbmRsZXIiLCJ0cmFjZSIsImdldENvbXBvbmVudFRyYWNlIiwiY2FsbFdpdGhFcnJvckhhbmRsaW5nIiwiZm9ybWF0Q29tcG9uZW50TmFtZSIsIndhcm5BcmdzIiwiZm9ybWF0VHJhY2UiLCJjdXJyZW50Vk5vZGUiLCJub3JtYWxpemVkU3RhY2siLCJyZWN1cnNlQ291bnQiLCJwYXJlbnRJbnN0YW5jZSIsImxvZ3MiLCJlbnRyeSIsImZvcm1hdFRyYWNlRW50cnkiLCJwb3N0Zml4IiwiZm9ybWF0UHJvcHMiLCJmb3JtYXRQcm9wIiwiRXJyb3JUeXBlU3RyaW5ncyIsImhhbmRsZUVycm9yIiwiY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmciLCJpc1Byb21pc2UiLCJjYXRjaCIsInZhbHVlcyIsInRocm93SW5EZXYiLCJjb250ZXh0Vk5vZGUiLCJleHBvc2VkSW5zdGFuY2UiLCJlcnJvckluZm8iLCJlcnJvckNhcHR1cmVkSG9va3MiLCJlYyIsImFwcEVycm9ySGFuZGxlciIsImVycm9ySGFuZGxlciIsImxvZ0Vycm9yIiwiaW5mbyIsImlzRmx1c2hpbmciLCJpc0ZsdXNoUGVuZGluZyIsInF1ZXVlIiwiZmx1c2hJbmRleCIsInBlbmRpbmdQcmVGbHVzaENicyIsImFjdGl2ZVByZUZsdXNoQ2JzIiwicHJlRmx1c2hJbmRleCIsInBlbmRpbmdQb3N0Rmx1c2hDYnMiLCJhY3RpdmVQb3N0Rmx1c2hDYnMiLCJwb3N0Rmx1c2hJbmRleCIsInJlc29sdmVkUHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwiY3VycmVudEZsdXNoUHJvbWlzZSIsImN1cnJlbnRQcmVGbHVzaFBhcmVudEpvYiIsIlJFQ1VSU0lPTl9MSU1JVCIsIm5leHRUaWNrIiwidGhlbiIsImZpbmRJbnNlcnRpb25JbmRleCIsImpvYiIsImpvYklkIiwiZ2V0SWQiLCJtaWRkbGUiLCJtaWRkbGVKb2JJZCIsInF1ZXVlSm9iIiwicXVldWVGbHVzaCIsImZsdXNoSm9icyIsImludmFsaWRhdGVKb2IiLCJxdWV1ZUNiIiwiY2IiLCJhY3RpdmVRdWV1ZSIsInBlbmRpbmdRdWV1ZSIsInF1ZXVlUHJlRmx1c2hDYiIsInF1ZXVlUG9zdEZsdXNoQ2IiLCJmbHVzaFByZUZsdXNoQ2JzIiwicGFyZW50Sm9iIiwiY2hlY2tSZWN1cnNpdmVVcGRhdGVzIiwiZmx1c2hQb3N0Rmx1c2hDYnMiLCJzb3J0IiwiSW5maW5pdHkiLCJvd25lckluc3RhbmNlIiwiY29tcG9uZW50TmFtZSIsImdldENvbXBvbmVudE5hbWUiLCJpc0htclVwZGF0aW5nIiwiaG1yRGlydHlDb21wb25lbnRzIiwiZ2xvYmFsT2JqZWN0IiwiZ2xvYmFsIiwid2luZG93IiwiX19WVUVfSE1SX1JVTlRJTUVfXyIsImNyZWF0ZVJlY29yZCIsInRyeVdyYXAiLCJyZXJlbmRlciIsInJlbG9hZCIsInJlZ2lzdGVySE1SIiwiX19obXJJZCIsInJlY29yZCIsImluc3RhbmNlcyIsInVucmVnaXN0ZXJITVIiLCJpc0NsYXNzQ29tcG9uZW50IiwiX192Y2NPcHRzIiwibmV3UmVuZGVyIiwicmVuZGVyIiwiZnJvbSIsInJlbmRlckNhY2hlIiwidXBkYXRlIiwibmV3Q29tcCIsImxvY2F0aW9uIiwiZGV2dG9vbHMiLCJzZXREZXZ0b29sc0hvb2siLCJob29rIiwiZGV2dG9vbHNJbml0QXBwIiwiYXBwIiwidmVyc2lvbiIsImVtaXQiLCJGcmFnbWVudCIsIlRleHQiLCJDb21tZW50IiwiQ29tbWVudCQxIiwiU3RhdGljIiwiZGV2dG9vbHNVbm1vdW50QXBwIiwiZGV2dG9vbHNDb21wb25lbnRBZGRlZCIsImNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayIsImRldnRvb2xzQ29tcG9uZW50VXBkYXRlZCIsImRldnRvb2xzQ29tcG9uZW50UmVtb3ZlZCIsImRldnRvb2xzUGVyZlN0YXJ0IiwiY3JlYXRlRGV2dG9vbHNQZXJmb3JtYW5jZUhvb2siLCJkZXZ0b29sc1BlcmZFbmQiLCJ0aW1lIiwiZGV2dG9vbHNDb21wb25lbnRFbWl0IiwiaXNSdW50aW1lT25seSIsImxlZ2FjeUhvb2siLCJuZXdIb29rIiwiY29lcmNlZCIsImNvbXAiLCJjb25maWdNc2ciLCJpbnN0YW5jZVdhcm5lZCIsIndhcm5Db3VudCIsImdldEN1cnJlbnRJbnN0YW5jZSIsImdldENvbXBhdENvbmZpZ0ZvcktleSIsImR1cEtleSIsImNvbXBJZCIsImNvbXBvbmVudER1cEtleSIsImdsb2JhbENvbXBhdENvbmZpZyIsIk1PREUiLCJpbnN0YW5jZUNvbmZpZyIsImVuYWJsZUZvckJ1aWx0SW4iLCJfX2lzQnVpbHRJbiIsInJhd01vZGUiLCJyYXdBcmdzIiwiZW1pdHNPcHRpb25zIiwicHJvcHNPcHRpb25zIiwidmFsaWRhdG9yIiwiaXNWYWxpZCIsImlzTW9kZWxMaXN0ZW5lciIsIm1vZGVsQXJnIiwibnVtYmVyIiwidG9OdW1iZXIiLCJsb3dlckNhc2VFdmVudCIsImhhbmRsZXJOYW1lIiwiaGFuZGxlciIsIm9uY2VIYW5kbGVyIiwiZW1pdHRlZCIsIm5vcm1hbGl6ZUVtaXRzT3B0aW9ucyIsImFzTWl4aW4iLCJlbWl0c0NhY2hlIiwiZW1pdHMiLCJoYXNFeHRlbmRzIiwiX19WVUVfT1BUSU9OU19BUElfXyIsImV4dGVuZEVtaXRzIiwibm9ybWFsaXplZEZyb21FeHRlbmQiLCJtaXhpbnMiLCJleHRlbmRzIiwiaXNFbWl0TGlzdGVuZXIiLCJjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UiLCJjdXJyZW50U2NvcGVJZCIsInNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSIsIl9fc2NvcGVJZCIsInB1c2hTY29wZUlkIiwicG9wU2NvcGVJZCIsIndpdGhTY29wZUlkIiwiX2lkIiwid2l0aEN0eCIsImN0eCIsIl9uIiwicmVuZGVyRm5XaXRoQ29udGV4dCIsIl9kIiwic2V0QmxvY2tUcmFja2luZyIsInByZXZJbnN0YW5jZSIsIl9jIiwiYWNjZXNzZWRBdHRycyIsIm1hcmtBdHRyc0FjY2Vzc2VkIiwicmVuZGVyQ29tcG9uZW50Um9vdCIsIkNvbXBvbmVudCIsIndpdGhQcm94eSIsImF0dHJzIiwiZGF0YSIsInNldHVwU3RhdGUiLCJpbmhlcml0QXR0cnMiLCJmYWxsdGhyb3VnaEF0dHJzIiwic2hhcGVGbGFnIiwicHJveHlUb1VzZSIsIm5vcm1hbGl6ZVZOb2RlIiwiZ2V0RnVuY3Rpb25hbEZhbGx0aHJvdWdoIiwic2V0Um9vdCIsImdldENoaWxkUm9vdCIsImZpbHRlck1vZGVsTGlzdGVuZXJzIiwiY2xvbmVWTm9kZSIsImFsbEF0dHJzIiwiZXZlbnRBdHRycyIsImV4dHJhQXR0cnMiLCJkaXJzIiwiaXNFbGVtZW50Um9vdCIsInRyYW5zaXRpb24iLCJibG9ja1N0YWNrIiwiY3JlYXRlVk5vZGUiLCJyYXdDaGlsZHJlbiIsImR5bmFtaWNDaGlsZHJlbiIsImNoaWxkUm9vdCIsImZpbHRlclNpbmdsZVJvb3QiLCJkeW5hbWljSW5kZXgiLCJ1cGRhdGVkUm9vdCIsInNpbmdsZVJvb3QiLCJzaG91bGRVcGRhdGVDb21wb25lbnQiLCJwcmV2Vk5vZGUiLCJuZXh0Vk5vZGUiLCJvcHRpbWl6ZWQiLCJwcmV2UHJvcHMiLCJwcmV2Q2hpbGRyZW4iLCJuZXh0UHJvcHMiLCJuZXh0Q2hpbGRyZW4iLCJoYXNQcm9wc0NoYW5nZWQiLCIkc3RhYmxlIiwibmV4dEtleXMiLCJ1cGRhdGVIT0NIb3N0RWwiLCJlbCIsInN1YlRyZWUiLCJpc1N1c3BlbnNlIiwiX19pc1N1c3BlbnNlIiwiU3VzcGVuc2VJbXBsIiwibjEiLCJuMiIsImNvbnRhaW5lciIsImFuY2hvciIsInBhcmVudENvbXBvbmVudCIsInBhcmVudFN1c3BlbnNlIiwiaXNTVkciLCJzbG90U2NvcGVJZHMiLCJyZW5kZXJlckludGVybmFscyIsIm1vdW50U3VzcGVuc2UiLCJwYXRjaFN1c3BlbnNlIiwiaHlkcmF0ZSIsImh5ZHJhdGVTdXNwZW5zZSIsImNyZWF0ZVN1c3BlbnNlQm91bmRhcnkiLCJub3JtYWxpemUiLCJub3JtYWxpemVTdXNwZW5zZUNoaWxkcmVuIiwiU3VzcGVuc2UiLCJwYXRjaCIsIm8iLCJoaWRkZW5Db250YWluZXIiLCJzdXNwZW5zZSIsInBlbmRpbmdCcmFuY2giLCJzc0NvbnRlbnQiLCJzc0ZhbGxiYWNrIiwic2V0QWN0aXZlQnJhbmNoIiwidW5tb3VudCIsInVtIiwibmV3QnJhbmNoIiwibmV3RmFsbGJhY2siLCJhY3RpdmVCcmFuY2giLCJpc0luRmFsbGJhY2siLCJpc0h5ZHJhdGluZyIsImlzU2FtZVZOb2RlVHlwZSIsInBlbmRpbmdJZCIsIm9uUGVuZGluZyIsInRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiZmFsbGJhY2siLCJoYXNXYXJuZWQiLCJtb3ZlIiwicGFyZW50Tm9kZSIsInJlbW92ZSIsImlzVW5tb3VudGVkIiwicmVzdW1lIiwiZGVsYXlFbnRlciIsImFmdGVyTGVhdmUiLCJoYXNVbnJlc29sdmVkQW5jZXN0b3IiLCJvblJlc29sdmUiLCJmYWxsYmFja1ZOb2RlIiwib25GYWxsYmFjayIsIm1vdW50RmFsbGJhY2siLCJyZWdpc3RlckRlcCIsInNldHVwUmVuZGVyRWZmZWN0IiwiaXNJblBlbmRpbmdTdXNwZW5zZSIsImh5ZHJhdGVkRWwiLCJhc3luY0RlcCIsImFzeW5jU2V0dXBSZXN1bHQiLCJzdXNwZW5zZUlkIiwiYXN5bmNSZXNvbHZlZCIsImhhbmRsZVNldHVwUmVzdWx0IiwicGxhY2Vob2xkZXIiLCJkb1JlbW92ZSIsImh5ZHJhdGVOb2RlIiwiaXNTbG90Q2hpbGRyZW4iLCJub3JtYWxpemVTdXNwZW5zZVNsb3QiLCJkZWZhdWx0IiwiYmxvY2siLCJpc0NvbXBpbGVkU2xvdCIsIm9wZW5CbG9jayIsImN1cnJlbnRCbG9jayIsImNsb3NlQmxvY2siLCJzaW5nbGVDaGlsZCIsInF1ZXVlRWZmZWN0V2l0aFN1c3BlbnNlIiwicHJvdmlkZSIsImN1cnJlbnRJbnN0YW5jZSIsInByb3ZpZGVzIiwicGFyZW50UHJvdmlkZXMiLCJpbmplY3QiLCJkZWZhdWx0VmFsdWUiLCJ0cmVhdERlZmF1bHRBc0ZhY3RvcnkiLCJ3YXRjaEVmZmVjdCIsImRvV2F0Y2giLCJJTklUSUFMX1dBVENIRVJfVkFMVUUiLCJ3YXRjaCIsImltbWVkaWF0ZSIsImRlZXAiLCJmbHVzaCIsIndhcm5JbnZhbGlkU291cmNlIiwiZm9yY2VUcmlnZ2VyIiwiaXNNdWx0aVNvdXJjZSIsInRyYXZlcnNlIiwib25JbnZhbGlkYXRlIiwiYmFzZUdldHRlciIsInJ1bm5lciIsInF1ZXVlUG9zdFJlbmRlckVmZmVjdCIsImlzTW91bnRlZCIsInJlY29yZEluc3RhbmNlQm91bmRFZmZlY3QiLCJpbnN0YW5jZVdhdGNoIiwicHVibGljVGhpcyIsImNyZWF0ZVBhdGhHZXR0ZXIiLCJzZWdtZW50cyIsImlzU2V0IiwiaXNQbGFpbk9iamVjdCIsInVzZVRyYW5zaXRpb25TdGF0ZSIsInN0YXRlIiwiaXNMZWF2aW5nIiwiaXNVbm1vdW50aW5nIiwibGVhdmluZ1ZOb2RlcyIsIm9uTW91bnRlZCIsIm9uQmVmb3JlVW5tb3VudCIsIlRyYW5zaXRpb25Ib29rVmFsaWRhdG9yIiwiQmFzZVRyYW5zaXRpb25JbXBsIiwiYXBwZWFyIiwicGVyc2lzdGVkIiwib25CZWZvcmVFbnRlciIsIm9uRW50ZXIiLCJvbkFmdGVyRW50ZXIiLCJvbkVudGVyQ2FuY2VsbGVkIiwib25CZWZvcmVMZWF2ZSIsIm9uTGVhdmUiLCJvbkFmdGVyTGVhdmUiLCJvbkxlYXZlQ2FuY2VsbGVkIiwib25CZWZvcmVBcHBlYXIiLCJvbkFwcGVhciIsIm9uQWZ0ZXJBcHBlYXIiLCJvbkFwcGVhckNhbmNlbGxlZCIsInNldHVwIiwicHJldlRyYW5zaXRpb25LZXkiLCJnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4iLCJyYXdQcm9wcyIsImVtcHR5UGxhY2Vob2xkZXIiLCJpbm5lckNoaWxkIiwiZ2V0S2VlcEFsaXZlQ2hpbGQiLCJlbnRlckhvb2tzIiwicmVzb2x2ZVRyYW5zaXRpb25Ib29rcyIsInNldFRyYW5zaXRpb25Ib29rcyIsIm9sZENoaWxkIiwib2xkSW5uZXJDaGlsZCIsInRyYW5zaXRpb25LZXlDaGFuZ2VkIiwiZ2V0VHJhbnNpdGlvbktleSIsImxlYXZpbmdIb29rcyIsImRlbGF5TGVhdmUiLCJlYXJseVJlbW92ZSIsImRlbGF5ZWRMZWF2ZSIsImxlYXZpbmdWTm9kZXNDYWNoZSIsImdldExlYXZpbmdOb2Rlc0ZvclR5cGUiLCJfbGVhdmVDYiIsIkJhc2VUcmFuc2l0aW9uIiwiY2FsbEhvb2siLCJob29rcyIsImJlZm9yZUVudGVyIiwibGVhdmluZ1ZOb2RlIiwiZW50ZXIiLCJhZnRlckhvb2siLCJjYW5jZWxIb29rIiwiY2FsbGVkIiwiX2VudGVyQ2IiLCJjYW5jZWxsZWQiLCJsZWF2ZSIsImNsb25lIiwiaXNLZWVwQWxpdmUiLCJrZWVwQ29tbWVudCIsImtleWVkRnJhZ21lbnRDb3VudCIsImRlZmluZUNvbXBvbmVudCIsImlzQXN5bmNXcmFwcGVyIiwiX19hc3luY0xvYWRlciIsImRlZmluZUFzeW5jQ29tcG9uZW50IiwibG9hZGVyIiwibG9hZGluZ0NvbXBvbmVudCIsImVycm9yQ29tcG9uZW50IiwiZGVsYXkiLCJzdXNwZW5zaWJsZSIsInVzZXJPbkVycm9yIiwicGVuZGluZ1JlcXVlc3QiLCJyZXNvbHZlZENvbXAiLCJyZXRyaWVzIiwicmV0cnkiLCJsb2FkIiwidGhpc1JlcXVlc3QiLCJyZWplY3QiLCJ1c2VyUmV0cnkiLCJ1c2VyRmFpbCIsIl9fZXNNb2R1bGUiLCJ0b1N0cmluZ1RhZyIsIl9fYXN5bmNSZXNvbHZlZCIsImNyZWF0ZUlubmVyQ29tcCIsImxvYWRlZCIsImRlbGF5ZWQiLCJfX2lzS2VlcEFsaXZlIiwiS2VlcEFsaXZlSW1wbCIsImluY2x1ZGUiLCJleGNsdWRlIiwibWF4Iiwic2hhcmVkQ29udGV4dCIsInJlbmRlcmVyIiwiY3VycmVudCIsIl9fdl9jYWNoZSIsIl91bm1vdW50Iiwic3RvcmFnZUNvbnRhaW5lciIsImFjdGl2YXRlIiwiaXNEZWFjdGl2YXRlZCIsImludm9rZUFycmF5Rm5zIiwidm5vZGVIb29rIiwib25Wbm9kZU1vdW50ZWQiLCJpbnZva2VWTm9kZUhvb2siLCJkZWFjdGl2YXRlIiwiZGEiLCJvblZub2RlVW5tb3VudGVkIiwicmVzZXRTaGFwZUZsYWciLCJwcnVuZUNhY2hlIiwicHJ1bmVDYWNoZUVudHJ5IiwicGVuZGluZ0NhY2hlS2V5IiwiY2FjaGVTdWJ0cmVlIiwiZ2V0SW5uZXJDaGlsZCIsIm9uVXBkYXRlZCIsInJhd1ZOb2RlIiwiY2FjaGVkVk5vZGUiLCJLZWVwQWxpdmUiLCJvbkFjdGl2YXRlZCIsInJlZ2lzdGVyS2VlcEFsaXZlSG9vayIsIm9uRGVhY3RpdmF0ZWQiLCJ3cmFwcGVkSG9vayIsIl9fd2RjIiwiaW5qZWN0SG9vayIsImluamVjdFRvS2VlcEFsaXZlUm9vdCIsImtlZXBBbGl2ZVJvb3QiLCJpbmplY3RlZCIsIm9uVW5tb3VudGVkIiwicHJlcGVuZCIsIl9fd2VoIiwic2V0Q3VycmVudEluc3RhbmNlIiwiYXBpTmFtZSIsImNyZWF0ZUhvb2siLCJsaWZlY3ljbGUiLCJpc0luU1NSQ29tcG9uZW50U2V0dXAiLCJvbkJlZm9yZU1vdW50Iiwib25CZWZvcmVVcGRhdGUiLCJvblNlcnZlclByZWZldGNoIiwib25SZW5kZXJUcmlnZ2VyZWQiLCJvblJlbmRlclRyYWNrZWQiLCJvbkVycm9yQ2FwdHVyZWQiLCJjcmVhdGVEdXBsaWNhdGVDaGVja2VyIiwic2hvdWxkQ2FjaGVBY2Nlc3MiLCJhcHBseU9wdGlvbnMiLCJyZXNvbHZlTWVyZ2VkT3B0aW9ucyIsImJlZm9yZUNyZWF0ZSIsImRhdGFPcHRpb25zIiwiY29tcHV0ZWRPcHRpb25zIiwibWV0aG9kcyIsIndhdGNoT3B0aW9ucyIsInByb3ZpZGVPcHRpb25zIiwiaW5qZWN0T3B0aW9ucyIsImNyZWF0ZWQiLCJiZWZvcmVNb3VudCIsIm1vdW50ZWQiLCJiZWZvcmVVcGRhdGUiLCJ1cGRhdGVkIiwiYWN0aXZhdGVkIiwiZGVhY3RpdmF0ZWQiLCJiZWZvcmVEZXN0cm95IiwiYmVmb3JlVW5tb3VudCIsImRlc3Ryb3llZCIsInVubW91bnRlZCIsInJlbmRlclRyYWNrZWQiLCJyZW5kZXJUcmlnZ2VyZWQiLCJlcnJvckNhcHR1cmVkIiwic2VydmVyUHJlZmV0Y2giLCJleHBvc2UiLCJjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMiLCJyZXNvbHZlSW5qZWN0aW9ucyIsIm1ldGhvZEhhbmRsZXIiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsIm9wdCIsImNyZWF0ZVdhdGNoZXIiLCJyZWdpc3RlckxpZmVjeWNsZUhvb2siLCJyZWdpc3RlciIsIl9ob29rIiwiZXhwb3NlZCIsIm5vcm1hbGl6ZUluamVjdCIsImgiLCJiYXNlIiwiZXh0ZW5kc09wdGlvbnMiLCJnbG9iYWxNaXhpbnMiLCJvcHRpb25zQ2FjaGUiLCJvcHRpb25NZXJnZVN0cmF0ZWdpZXMiLCJyZXNvbHZlZCIsIm1lcmdlT3B0aW9ucyIsInRvIiwic3RyYXRzIiwic3RyYXQiLCJpbnRlcm5hbE9wdGlvbk1lcmdlU3RyYXRzIiwibWVyZ2VEYXRhRm4iLCJtZXJnZU9iamVjdE9wdGlvbnMiLCJtZXJnZUhvb2siLCJtZXJnZUluamVjdCIsIm1lcmdlZERhdGFGbiIsImluaXRQcm9wcyIsImlzU3RhdGVmdWwiLCJpc1NTUiIsIkludGVybmFsT2JqZWN0S2V5IiwicHJvcHNEZWZhdWx0cyIsInNldEZ1bGxQcm9wcyIsInZhbGlkYXRlUHJvcHMiLCJ1cGRhdGVQcm9wcyIsInJhd1ByZXZQcm9wcyIsInJhd0N1cnJlbnRQcm9wcyIsImhhc0F0dHJzQ2hhbmdlZCIsInByb3BzVG9VcGRhdGUiLCJjYW1lbGl6ZWRLZXkiLCJyZXNvbHZlUHJvcFZhbHVlIiwia2ViYWJLZXkiLCJuZWVkQ2FzdEtleXMiLCJyYXdDYXN0VmFsdWVzIiwiY2FtZWxLZXkiLCJjYXN0VmFsdWVzIiwiaXNBYnNlbnQiLCJoYXNEZWZhdWx0Iiwibm9ybWFsaXplUHJvcHNPcHRpb25zIiwicHJvcHNDYWNoZSIsImV4dGVuZFByb3BzIiwiRU1QVFlfQVJSIiwibm9ybWFsaXplZEtleSIsInZhbGlkYXRlUHJvcE5hbWUiLCJib29sZWFuSW5kZXgiLCJnZXRUeXBlSW5kZXgiLCJzdHJpbmdJbmRleCIsImdldFR5cGUiLCJjdG9yIiwidG9TdHJpbmciLCJpc1NhbWVUeXBlIiwiZXhwZWN0ZWRUeXBlcyIsImZpbmRJbmRleCIsInQiLCJyZXNvbHZlZFZhbHVlcyIsInZhbGlkYXRlUHJvcCIsInJlcXVpcmVkIiwidHlwZXMiLCJhc3NlcnRUeXBlIiwidmFsaWQiLCJleHBlY3RlZFR5cGUiLCJnZXRJbnZhbGlkVHlwZU1lc3NhZ2UiLCJpc1NpbXBsZVR5cGUiLCJyZWNlaXZlZFR5cGUiLCJleHBlY3RlZFZhbHVlIiwic3R5bGVWYWx1ZSIsInJlY2VpdmVkVmFsdWUiLCJpc0V4cGxpY2FibGUiLCJpc0Jvb2xlYW4iLCJleHBsaWNpdFR5cGVzIiwiZWxlbSIsImlzSW50ZXJuYWxLZXkiLCJub3JtYWxpemVTbG90VmFsdWUiLCJub3JtYWxpemVTbG90IiwicmF3U2xvdCIsIm5vcm1hbGl6ZU9iamVjdFNsb3RzIiwicmF3U2xvdHMiLCJfY3R4Iiwibm9ybWFsaXplVk5vZGVTbG90cyIsImluaXRTbG90cyIsInVwZGF0ZVNsb3RzIiwibmVlZERlbGV0aW9uQ2hlY2siLCJkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQiLCJpc0J1aWx0SW5EaXJlY3RpdmUiLCJ2YWxpZGF0ZURpcmVjdGl2ZU5hbWUiLCJ3aXRoRGlyZWN0aXZlcyIsImludGVybmFsSW5zdGFuY2UiLCJiaW5kaW5ncyIsImludm9rZURpcmVjdGl2ZUhvb2siLCJvbGRCaW5kaW5ncyIsImJpbmRpbmciLCJjcmVhdGVBcHBDb250ZXh0IiwicGVyZm9ybWFuY2UiLCJnbG9iYWxQcm9wZXJ0aWVzIiwiY29tcGlsZXJPcHRpb25zIiwiY3JlYXRlQXBwQVBJIiwiY3JlYXRlQXBwIiwicm9vdENvbXBvbmVudCIsInJvb3RQcm9wcyIsImluc3RhbGxlZFBsdWdpbnMiLCJfdWlkIiwiX2NvbXBvbmVudCIsIl9wcm9wcyIsIl9jb250YWluZXIiLCJfY29udGV4dCIsInVzZSIsInBsdWdpbiIsImluc3RhbGwiLCJtaXhpbiIsInZhbGlkYXRlQ29tcG9uZW50TmFtZSIsImRpcmVjdGl2ZSIsIm1vdW50Iiwicm9vdENvbnRhaW5lciIsImlzSHlkcmF0ZSIsIl9fdnVlX2FwcF9fIiwiaGFzTWlzbWF0Y2giLCJpc1NWR0NvbnRhaW5lciIsIm5hbWVzcGFjZVVSSSIsInRhZ05hbWUiLCJpc0NvbW1lbnQiLCJub2RlVHlwZSIsImNyZWF0ZUh5ZHJhdGlvbkZ1bmN0aW9ucyIsIm1vdW50Q29tcG9uZW50IiwibXQiLCJwYXRjaFByb3AiLCJuZXh0U2libGluZyIsImluc2VydCIsImNyZWF0ZUNvbW1lbnQiLCJoYXNDaGlsZE5vZGVzIiwiaXNGcmFnbWVudFN0YXJ0Iiwib25NaXNtYXRjaCIsImhhbmRsZU1pc21hdGNoIiwiZG9tVHlwZSIsIm5leHROb2RlIiwibmVlZFRvQWRvcHRDb250ZW50Iiwic3RhdGljQ291bnQiLCJvdXRlckhUTUwiLCJoeWRyYXRlRnJhZ21lbnQiLCJoeWRyYXRlRWxlbWVudCIsImxvY2F0ZUNsb3NpbmdBc3luY0FuY2hvciIsInByZXZpb3VzU2libGluZyIsImxhc3RDaGlsZCIsImNyZWF0ZVRleHRWTm9kZSIsImh5ZHJhdGVDaGlsZHJlbiIsInNldFJlZiIsIm9uQ2xpY2siLCJ2bm9kZUhvb2tzIiwib25Wbm9kZUJlZm9yZU1vdW50IiwicGFyZW50Vk5vZGUiLCJmcmFnbWVudFNsb3RTY29wZUlkcyIsImlzRnJhZ21lbnQiLCJzdXBwb3J0ZWQiLCJwZXJmIiwic3RhcnRNZWFzdXJlIiwiaXNTdXBwb3J0ZWQiLCJtYXJrIiwibm93IiwiRGF0ZSIsImVuZE1lYXN1cmUiLCJzdGFydFRhZyIsImVuZFRhZyIsIm1lYXN1cmUiLCJjbGVhck1hcmtzIiwiaW5pdEZlYXR1cmVGbGFncyIsIm5lZWRXYXJuIiwicHJvZEVmZmVjdE9wdGlvbnMiLCJjcmVhdGVEZXZFZmZlY3RPcHRpb25zIiwicnRjIiwicnRnIiwicmF3UmVmIiwib2xkUmF3UmVmIiwiaXNVbm1vdW50IiwicmVmVmFsdWUiLCJvd25lciIsIm9sZFJlZiIsInJlZnMiLCJkb1NldCIsImNyZWF0ZVJlbmRlcmVyIiwiYmFzZUNyZWF0ZVJlbmRlcmVyIiwiY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIiLCJjcmVhdGVIeWRyYXRpb25GbnMiLCJnZXRHbG9iYWxUaGlzIiwiX19WVUVfXyIsIl9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJob3N0SW5zZXJ0IiwiaG9zdFJlbW92ZSIsImhvc3RQYXRjaFByb3AiLCJob3N0Rm9yY2VQYXRjaFByb3AiLCJmb3JjZVBhdGNoUHJvcCIsImhvc3RDcmVhdGVFbGVtZW50IiwiaG9zdENyZWF0ZVRleHQiLCJjcmVhdGVUZXh0IiwiaG9zdENyZWF0ZUNvbW1lbnQiLCJob3N0U2V0VGV4dCIsInNldFRleHQiLCJob3N0U2V0RWxlbWVudFRleHQiLCJzZXRFbGVtZW50VGV4dCIsImhvc3RQYXJlbnROb2RlIiwiaG9zdE5leHRTaWJsaW5nIiwic2V0U2NvcGVJZCIsImhvc3RTZXRTY29wZUlkIiwiaG9zdENsb25lTm9kZSIsImNsb25lTm9kZSIsImhvc3RJbnNlcnRTdGF0aWNDb250ZW50IiwiaW5zZXJ0U3RhdGljQ29udGVudCIsImdldE5leHRIb3N0Tm9kZSIsInByb2Nlc3NUZXh0IiwicHJvY2Vzc0NvbW1lbnROb2RlIiwibW91bnRTdGF0aWNOb2RlIiwicGF0Y2hTdGF0aWNOb2RlIiwicHJvY2Vzc0ZyYWdtZW50IiwicHJvY2Vzc0VsZW1lbnQiLCJwcm9jZXNzQ29tcG9uZW50IiwiaW50ZXJuYWxzIiwicmVtb3ZlU3RhdGljTm9kZSIsIm1vdmVTdGF0aWNOb2RlIiwibW91bnRFbGVtZW50IiwicGF0Y2hFbGVtZW50IiwiaXMiLCJtb3VudENoaWxkcmVuIiwidW5tb3VudENoaWxkcmVuIiwibmVlZENhbGxUcmFuc2l0aW9uSG9va3MiLCJjbG9uZUlmTW91bnRlZCIsIm9sZFByb3BzIiwibmV3UHJvcHMiLCJvblZub2RlQmVmb3JlVXBkYXRlIiwicGF0Y2hQcm9wcyIsImNsYXNzIiwic3R5bGUiLCJhcmVDaGlsZHJlblNWRyIsInBhdGNoQmxvY2tDaGlsZHJlbiIsInRyYXZlcnNlU3RhdGljQ2hpbGRyZW4iLCJwYXRjaENoaWxkcmVuIiwib25Wbm9kZVVwZGF0ZWQiLCJvbGRDaGlsZHJlbiIsIm5ld0NoaWxkcmVuIiwiZmFsbGJhY2tDb250YWluZXIiLCJvbGRWTm9kZSIsIm5ld1ZOb2RlIiwiZnJhZ21lbnRTdGFydEFuY2hvciIsImZyYWdtZW50RW5kQW5jaG9yIiwidXBkYXRlQ29tcG9uZW50IiwiaW5pdGlhbFZOb2RlIiwiY3JlYXRlQ29tcG9uZW50SW5zdGFuY2UiLCJzZXR1cENvbXBvbmVudCIsInVwZGF0ZUNvbXBvbmVudFByZVJlbmRlciIsImNvbXBvbmVudEVmZmVjdCIsImJtIiwiaHlkcmF0ZVN1YlRyZWUiLCJzY29wZWRJbml0aWFsVk5vZGUiLCJidSIsInUiLCJvcmlnaW5OZXh0IiwibmV4dFRyZWUiLCJwcmV2VHJlZSIsImMxIiwicHJldlNoYXBlRmxhZyIsImMyIiwicGF0Y2hLZXllZENoaWxkcmVuIiwicGF0Y2hVbmtleWVkQ2hpbGRyZW4iLCJvbGRMZW5ndGgiLCJuZXdMZW5ndGgiLCJjb21tb25MZW5ndGgiLCJNYXRoIiwibWluIiwibmV4dENoaWxkIiwicGFyZW50QW5jaG9yIiwibDIiLCJlMSIsImUyIiwibmV4dFBvcyIsInMxIiwiczIiLCJrZXlUb05ld0luZGV4TWFwIiwicGF0Y2hlZCIsInRvQmVQYXRjaGVkIiwibW92ZWQiLCJtYXhOZXdJbmRleFNvRmFyIiwibmV3SW5kZXhUb09sZEluZGV4TWFwIiwicHJldkNoaWxkIiwibmV3SW5kZXgiLCJpbmNyZWFzaW5nTmV3SW5kZXhTZXF1ZW5jZSIsImdldFNlcXVlbmNlIiwibmV4dEluZGV4IiwibW92ZVR5cGUiLCJuZWVkVHJhbnNpdGlvbiIsInBlcmZvcm1MZWF2ZSIsInNob3VsZEludm9rZURpcnMiLCJvblZub2RlQmVmb3JlVW5tb3VudCIsInVubW91bnRDb21wb25lbnQiLCJyZW1vdmVGcmFnbWVudCIsInBlcmZvcm1SZW1vdmUiLCJidW0iLCJfdm5vZGUiLCJtYyIsInBjIiwicGJjIiwiY2gxIiwiY2gyIiwibGVuIiwiYXJySSIsImlzVGVsZXBvcnQiLCJfX2lzVGVsZXBvcnQiLCJpc1RlbGVwb3J0RGlzYWJsZWQiLCJkaXNhYmxlZCIsImlzVGFyZ2V0U1ZHIiwiU1ZHRWxlbWVudCIsInJlc29sdmVUYXJnZXQiLCJzZWxlY3QiLCJ0YXJnZXRTZWxlY3RvciIsIlRlbGVwb3J0SW1wbCIsInF1ZXJ5U2VsZWN0b3IiLCJtYWluQW5jaG9yIiwidGFyZ2V0QW5jaG9yIiwid2FzRGlzYWJsZWQiLCJjdXJyZW50QW5jaG9yIiwibW92ZVRlbGVwb3J0IiwibmV4dFRhcmdldCIsImh5ZHJhdGVUZWxlcG9ydCIsImlzUmVvcmRlciIsInRhcmdldE5vZGUiLCJfbHBhIiwiVGVsZXBvcnQiLCJDT01QT05FTlRTIiwiRElSRUNUSVZFUyIsInJlc29sdmVDb21wb25lbnQiLCJyZXNvbHZlQXNzZXQiLCJOVUxMX0RZTkFNSUNfQ09NUE9ORU5UIiwicmVzb2x2ZUR5bmFtaWNDb21wb25lbnQiLCJyZXNvbHZlRGlyZWN0aXZlIiwid2Fybk1pc3NpbmciLCJyZWdpc3RyeSIsImlzQmxvY2tUcmVlRW5hYmxlZCIsImNyZWF0ZUJsb2NrIiwiX192X2lzVk5vZGUiLCJ2bm9kZUFyZ3NUcmFuc2Zvcm1lciIsInRyYW5zZm9ybVZOb2RlQXJncyIsInRyYW5zZm9ybWVyIiwiY3JlYXRlVk5vZGVXaXRoQXJnc1RyYW5zZm9ybSIsIl9jcmVhdGVWTm9kZSIsIm5vcm1hbGl6ZUtleSIsIm5vcm1hbGl6ZVJlZiIsImlzQmxvY2tOb2RlIiwiY2xvbmVkIiwibm9ybWFsaXplQ2hpbGRyZW4iLCJrbGFzcyIsIm5vcm1hbGl6ZUNsYXNzIiwibm9ybWFsaXplU3R5bGUiLCJfX3Zfc2tpcCIsImV4dHJhUHJvcHMiLCJtZXJnZVJlZiIsIm1lcmdlZFByb3BzIiwibWVyZ2VQcm9wcyIsImRlZXBDbG9uZVZOb2RlIiwiY3JlYXRlU3RhdGljVk5vZGUiLCJudW1iZXJPZk5vZGVzIiwiY3JlYXRlQ29tbWVudFZOb2RlIiwiYXNCbG9jayIsInNsb3QiLCJ0b01lcmdlIiwicmVuZGVyTGlzdCIsInJlbmRlckl0ZW0iLCJpc0ludGVnZXIiLCJjcmVhdGVTbG90cyIsInJlbmRlclNsb3QiLCJub1Nsb3R0ZWQiLCJ2YWxpZFNsb3RDb250ZW50IiwiZW5zdXJlVmFsaWRWTm9kZSIsInJlbmRlcmVkIiwidm5vZGVzIiwidG9IYW5kbGVycyIsIm9iaiIsImdldFB1YmxpY0luc3RhbmNlIiwiaXNTdGF0ZWZ1bENvbXBvbmVudCIsInB1YmxpY1Byb3BlcnRpZXNNYXAiLCIkIiwiJGVsIiwiJGRhdGEiLCIkcHJvcHMiLCIkYXR0cnMiLCIkc2xvdHMiLCIkcmVmcyIsIiRwYXJlbnQiLCIkcm9vdCIsIiRlbWl0IiwiJG9wdGlvbnMiLCIkZm9yY2VVcGRhdGUiLCIkbmV4dFRpY2siLCIkd2F0Y2giLCJQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMiLCJhY2Nlc3NDYWNoZSIsIm5vcm1hbGl6ZWRQcm9wcyIsInB1YmxpY0dldHRlciIsImNzc01vZHVsZSIsIl9fY3NzTW9kdWxlcyIsIlJ1bnRpbWVDb21waWxlZFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyIsInVuc2NvcGFibGVzIiwiaXNHbG9iYWxseVdoaXRlbGlzdGVkIiwiY3JlYXRlUmVuZGVyQ29udGV4dCIsImV4cG9zZVByb3BzT25SZW5kZXJDb250ZXh0IiwiZXhwb3NlU2V0dXBTdGF0ZU9uUmVuZGVyQ29udGV4dCIsImVtcHR5QXBwQ29udGV4dCIsInVpZCQxIiwic2V0dXBDb250ZXh0IiwiYmMiLCJzcCIsImlzQnVpbHRJblRhZyIsImFwcElzTmF0aXZlVGFnIiwic2V0dXBSZXN1bHQiLCJzZXR1cFN0YXRlZnVsQ29tcG9uZW50IiwibmFtZXMiLCJjcmVhdGVTZXR1cENvbnRleHQiLCJyZXNvbHZlZFJlc3VsdCIsImZpbmlzaENvbXBvbmVudFNldHVwIiwiZGV2dG9vbHNSYXdTZXR1cFN0YXRlIiwicmVnaXN0ZXJSdW50aW1lQ29tcGlsZXIiLCJfY29tcGlsZSIsInNraXBPcHRpb25zIiwiY29tcG9uZW50Q29tcGlsZXJPcHRpb25zIiwiZmluYWxDb21waWxlck9wdGlvbnMiLCJfcmMiLCJhdHRySGFuZGxlcnMiLCJjbGFzc2lmeVJFIiwiY2xhc3NpZnkiLCJkaXNwbGF5TmFtZSIsIl9fZmlsZSIsImluZmVyRnJvbVJlZ2lzdHJ5IiwiY29tcHV0ZWQkMSIsImRlZmluZVByb3BzIiwiZGVmaW5lRW1pdCIsInVzZUNvbnRleHQiLCJwcm9wc09yQ2hpbGRyZW4iLCJzc3JDb250ZXh0S2V5IiwidXNlU1NSQ29udGV4dCIsImluaXRDdXN0b21Gb3JtYXR0ZXIiLCJ2dWVTdHlsZSIsIm51bWJlclN0eWxlIiwic3RyaW5nU3R5bGUiLCJrZXl3b3JkU3R5bGUiLCJmb3JtYXR0ZXIiLCJoZWFkZXIiLCJfX2lzVnVlIiwiZ2VuUmVmRmxhZyIsImZvcm1hdFZhbHVlIiwiaGFzQm9keSIsImZvcm1hdEluc3RhbmNlIiwiYmxvY2tzIiwiY3JlYXRlSW5zdGFuY2VCbG9jayIsImV4dHJhY3RLZXlzIiwiYXNSYXciLCJDb21wIiwiZXh0cmFjdGVkIiwiaXNLZXlPZlR5cGUiLCJvcHRzIiwiZGV2dG9vbHNGb3JtYXR0ZXJzIiwic3NyVXRpbHMiLCJyZXNvbHZlRmlsdGVyIiwiY29tcGF0VXRpbHMiLCJzdmdOUyIsImRvYyIsInRlbXBDb250YWluZXIiLCJ0ZW1wU1ZHQ29udGFpbmVyIiwibm9kZU9wcyIsImluc2VydEJlZm9yZSIsInJlbW92ZUNoaWxkIiwiY3JlYXRlRWxlbWVudE5TIiwibXVsdGlwbGUiLCJzZXRBdHRyaWJ1dGUiLCJjcmVhdGVUZXh0Tm9kZSIsIm5vZGVWYWx1ZSIsInNlbGVjdG9yIiwidGVtcCIsInBhdGNoQ2xhc3MiLCJ0cmFuc2l0aW9uQ2xhc3NlcyIsIl92dGMiLCJjbGFzc05hbWUiLCJwYXRjaFN0eWxlIiwicmVtb3ZlQXR0cmlidXRlIiwiZGlzcGxheSIsInNldFN0eWxlIiwiaW1wb3J0YW50UkUiLCJzZXRQcm9wZXJ0eSIsInByZWZpeGVkIiwiYXV0b1ByZWZpeCIsInByZWZpeGVzIiwicHJlZml4Q2FjaGUiLCJ4bGlua05TIiwicGF0Y2hBdHRyIiwicmVtb3ZlQXR0cmlidXRlTlMiLCJzZXRBdHRyaWJ1dGVOUyIsImlzU3BlY2lhbEJvb2xlYW5BdHRyIiwicGF0Y2hET01Qcm9wIiwiX2dldE5vdyIsInNraXBUaW1lc3RhbXBDaGVjayIsImNyZWF0ZUV2ZW50IiwidGltZVN0YW1wIiwiZmZNYXRjaCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImNhY2hlZE5vdyIsInJlc2V0IiwiZ2V0Tm93IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJwYXRjaEV2ZW50IiwicHJldlZhbHVlIiwibmV4dFZhbHVlIiwiaW52b2tlcnMiLCJfdmVpIiwiZXhpc3RpbmdJbnZva2VyIiwicGFyc2VOYW1lIiwiaW52b2tlciIsImNyZWF0ZUludm9rZXIiLCJvcHRpb25zTW9kaWZpZXJSRSIsImluaXRpYWxWYWx1ZSIsImF0dGFjaGVkIiwicGF0Y2hTdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJvcmlnaW5hbFN0b3AiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJfc3RvcHBlZCIsIm5hdGl2ZU9uUkUiLCJzaG91bGRTZXRBc1Byb3AiLCJfdHJ1ZVZhbHVlIiwiX2ZhbHNlVmFsdWUiLCJ1c2VDc3NNb2R1bGUiLCJtb2R1bGVzIiwibW9kIiwidXNlQ3NzVmFycyIsInNldFZhcnMiLCJzZXRWYXJzT25WTm9kZSIsInZhcnMiLCJBTklNQVRJT04iLCJUcmFuc2l0aW9uIiwicmVzb2x2ZVRyYW5zaXRpb25Qcm9wcyIsIkRPTVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMiLCJjc3MiLCJkdXJhdGlvbiIsImVudGVyRnJvbUNsYXNzIiwiZW50ZXJBY3RpdmVDbGFzcyIsImVudGVyVG9DbGFzcyIsImFwcGVhckZyb21DbGFzcyIsImFwcGVhckFjdGl2ZUNsYXNzIiwiYXBwZWFyVG9DbGFzcyIsImxlYXZlRnJvbUNsYXNzIiwibGVhdmVBY3RpdmVDbGFzcyIsImxlYXZlVG9DbGFzcyIsIlRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMiLCJoYXNFeHBsaWNpdENhbGxiYWNrIiwiYmFzZVByb3BzIiwiZHVyYXRpb25zIiwibm9ybWFsaXplRHVyYXRpb24iLCJlbnRlckR1cmF0aW9uIiwibGVhdmVEdXJhdGlvbiIsImZpbmlzaEVudGVyIiwiaXNBcHBlYXIiLCJyZW1vdmVUcmFuc2l0aW9uQ2xhc3MiLCJmaW5pc2hMZWF2ZSIsIm1ha2VFbnRlckhvb2siLCJuZXh0RnJhbWUiLCJhZGRUcmFuc2l0aW9uQ2xhc3MiLCJ3aGVuVHJhbnNpdGlvbkVuZHMiLCJmb3JjZVJlZmxvdyIsIk51bWJlck9mIiwidmFsaWRhdGVEdXJhdGlvbiIsImlzTmFOIiwiY2xzIiwiY2xhc3NMaXN0IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiZW5kSWQiLCJleHBsaWNpdFRpbWVvdXQiLCJfZW5kSWQiLCJyZXNvbHZlSWZOb3RTdGFsZSIsImdldFRyYW5zaXRpb25JbmZvIiwicHJvcENvdW50IiwiZW5kRXZlbnQiLCJlbmRlZCIsIm9uRW5kIiwic3R5bGVzIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImdldFN0eWxlUHJvcGVydGllcyIsInRyYW5zaXRpb25EZWxheXMiLCJ0cmFuc2l0aW9uRHVyYXRpb25zIiwidHJhbnNpdGlvblRpbWVvdXQiLCJnZXRUaW1lb3V0IiwiYW5pbWF0aW9uRGVsYXlzIiwiYW5pbWF0aW9uRHVyYXRpb25zIiwiYW5pbWF0aW9uVGltZW91dCIsImhhc1RyYW5zZm9ybSIsImRlbGF5cyIsImQiLCJ0b01zIiwib2Zmc2V0SGVpZ2h0IiwicG9zaXRpb25NYXAiLCJuZXdQb3NpdGlvbk1hcCIsIlRyYW5zaXRpb25Hcm91cEltcGwiLCJtb3ZlQ2xhc3MiLCJoYXNDU1NUcmFuc2Zvcm0iLCJjYWxsUGVuZGluZ0NicyIsInJlY29yZFBvc2l0aW9uIiwibW92ZWRDaGlsZHJlbiIsImFwcGx5VHJhbnNsYXRpb24iLCJ3ZWJraXRUcmFuc2Zvcm0iLCJ0cmFuc2l0aW9uRHVyYXRpb24iLCJfbW92ZUNiIiwicHJvcGVydHlOYW1lIiwiY3NzVHJhbnNpdGlvblByb3BzIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiVHJhbnNpdGlvbkdyb3VwIiwib2xkUG9zIiwibmV3UG9zIiwiZHgiLCJkeSIsInRvcCIsImFwcGVuZENoaWxkIiwiZ2V0TW9kZWxBc3NpZ25lciIsIm9uQ29tcG9zaXRpb25TdGFydCIsImNvbXBvc2luZyIsIm9uQ29tcG9zaXRpb25FbmQiLCJpbml0RXZlbnQiLCJkaXNwYXRjaEV2ZW50Iiwidk1vZGVsVGV4dCIsIl9hc3NpZ24iLCJjYXN0VG9OdW1iZXIiLCJkb21WYWx1ZSIsImFjdGl2ZUVsZW1lbnQiLCJ2TW9kZWxDaGVja2JveCIsIm1vZGVsVmFsdWUiLCJfbW9kZWxWYWx1ZSIsImVsZW1lbnRWYWx1ZSIsImdldFZhbHVlIiwiY2hlY2tlZCIsImFzc2lnbiIsImxvb3NlSW5kZXhPZiIsImZvdW5kIiwiZmlsdGVyZWQiLCJnZXRDaGVja2JveFZhbHVlIiwic2V0Q2hlY2tlZCIsImxvb3NlRXF1YWwiLCJ2TW9kZWxSYWRpbyIsInZNb2RlbFNlbGVjdCIsImlzU2V0TW9kZWwiLCJzZWxlY3RlZFZhbCIsInNlbGVjdGVkIiwic2V0U2VsZWN0ZWQiLCJfYmluZGluZyIsImlzTXVsdGlwbGUiLCJvcHRpb24iLCJvcHRpb25WYWx1ZSIsInNlbGVjdGVkSW5kZXgiLCJ2TW9kZWxEeW5hbWljIiwiY2FsbE1vZGVsSG9vayIsIm1vZGVsVG9Vc2UiLCJzeXN0ZW1Nb2RpZmllcnMiLCJtb2RpZmllckd1YXJkcyIsInN0b3BQcm9wYWdhdGlvbiIsInByZXZlbnQiLCJwcmV2ZW50RGVmYXVsdCIsImN1cnJlbnRUYXJnZXQiLCJjdHJsIiwiY3RybEtleSIsInNoaWZ0Iiwic2hpZnRLZXkiLCJhbHQiLCJhbHRLZXkiLCJtZXRhIiwibWV0YUtleSIsImJ1dHRvbiIsImV4YWN0Iiwid2l0aE1vZGlmaWVycyIsImd1YXJkIiwia2V5TmFtZXMiLCJlc2MiLCJzcGFjZSIsInVwIiwiZG93biIsIndpdGhLZXlzIiwiZXZlbnRLZXkiLCJrIiwidlNob3ciLCJfdm9kIiwic2V0RGlzcGxheSIsInJlbmRlcmVyT3B0aW9ucyIsImVuYWJsZWRIeWRyYXRpb24iLCJlbnN1cmVSZW5kZXJlciIsImVuc3VyZUh5ZHJhdGlvblJlbmRlcmVyIiwiaW5qZWN0TmF0aXZlVGFnQ2hlY2siLCJpbmplY3RDb21waWxlck9wdGlvbnNDaGVjayIsImNvbnRhaW5lck9yU2VsZWN0b3IiLCJub3JtYWxpemVDb250YWluZXIiLCJFbGVtZW50IiwiY3JlYXRlU1NSQXBwIiwiU2hhZG93Um9vdCIsImV4cGVjdHNMb3dlckNhc2UiLCJHTE9CQUxTX1dISVRFX0xJU1RFRCIsImdlbmVyYXRlQ29kZUZyYW1lIiwibGluZXMiLCJsaW5lTGVuZ3RoIiwicGFkIiwic3BlY2lhbEJvb2xlYW5BdHRycyIsImlzQm9vbGVhbkF0dHIiLCJ1bnNhZmVBdHRyQ2hhclJFIiwiYXR0clZhbGlkYXRpb25DYWNoZSIsImlzU1NSU2FmZUF0dHJOYW1lIiwiaGFzT3duUHJvcGVydHkiLCJpc1Vuc2FmZSIsInByb3BzVG9BdHRyTWFwIiwiYWNjZXB0Q2hhcnNldCIsImh0bWxGb3IiLCJodHRwRXF1aXYiLCJpc05vVW5pdE51bWVyaWNTdHlsZVByb3AiLCJpc0tub3duQXR0ciIsIml0ZW0iLCJsaXN0RGVsaW1pdGVyUkUiLCJwcm9wZXJ0eURlbGltaXRlclJFIiwidG1wIiwic3RyaW5naWZ5U3R5bGUiLCJIVE1MX1RBR1MiLCJTVkdfVEFHUyIsIlZPSURfVEFHUyIsImVzY2FwZVJFIiwiZXNjYXBlSHRtbCIsInN0cmluZyIsImVzY2FwZWQiLCJsYXN0SW5kZXgiLCJzdWJzdHJpbmciLCJjb21tZW50U3RyaXBSRSIsImVzY2FwZUh0bWxDb21tZW50Iiwic3JjIiwibG9vc2VDb21wYXJlQXJyYXlzIiwiZXF1YWwiLCJhVmFsaWRUeXBlIiwiaXNEYXRlIiwiYlZhbGlkVHlwZSIsImdldFRpbWUiLCJhS2V5c0NvdW50IiwiYktleXNDb3VudCIsImFIYXNLZXkiLCJiSGFzS2V5IiwidG9EaXNwbGF5U3RyaW5nIiwicmVwbGFjZXIiLCJlbnRyaWVzIiwicmVkdWNlIiwiYmFiZWxQYXJzZXJEZWZhdWx0UGx1Z2lucyIsIm9uUkUiLCJ0b1R5cGVTdHJpbmciLCJvYmplY3RUb1N0cmluZyIsImh5cGhlbmF0ZVJFIiwiZm5zIiwicGFyc2VGbG9hdCIsIl9nbG9iYWxUaGlzIiwiZ2xvYmFsVGhpcyIsInJlcXVpcmUiLCJjb25zdGFudCIsIndheXMiLCJjaHVuayIsImNlaWwiLCJmaWxsIiwiemlwIiwiYXJyYXlzIiwiaXRlbXMiLCJrZm4iLCJ2Zm4iLCJtdWwiLCJ2aSIsInJvbGxpbmdtdWwiLCJyZXN0Iiwic3VtIiwic2NhbGUiLCJmYWN0b3IiLCJyYW5nZXMiLCJjcyIsInJldmVyc2UiLCJuZXMiLCJhZGRyZXNzRm4iLCJjc2kiLCJycyIsImFkZHJlc3MiLCJmbG9vciIsImFycmF5IiwicmVzb2x2ZUFkZHJlc3MiLCJhaSIsIm1vZHVsZSIsImV4cG9ydHMiLCJ4IiwiaW5pdERldiIsImNvbXBpbGVDYWNoZSIsImNvbXBpbGVUb0Z1bmN0aW9uIiwiYXNXYXJuaW5nIiwiY29kZUZyYW1lIiwicnVudGltZURvbSIsIkFycmF5TWFwIiwib3JiZm5zIiwia2V5Rm4iLCJwb3BwZWQiLCJyZW1vdmVkIiwiYXJyYXltYXAiLCJkYXRhVHJhbnNmZXIiLCJkcmFnZ2VkIiwiZHJhZyIsImRyYWdnaW5nIiwiZXZ0IiwiZHJvcCIsImlzU2FtZU5vZGUiLCJvdmVyIiwiZHJhZ2Ryb3AiLCJleHRlcm5hbFZhbHVlIiwidmFsdWVkIiwid2JlbmNoIiwid3R5cGUiLCJ3b2JqZWN0Iiwid3RvYmplY3QiLCJ3b2JqZWN0cyIsImJlbmNoT2JqZWN0cyIsInNob3dVaSIsIndhdGNoYWJsZUJvcyIsImVsaWQiLCJlbG5hbWUiLCJlbGNuYW1lIiwiZWxwcm9wcyIsImNuYW1lIiwiY2hwcm9wcyIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiY2hlbCIsImJlbmNoZWQiLCJibyIsImRyb3BFbGVtZW50cyIsIm1ha2VJZCIsImNvbWJpbmF0aW9uIiwiY29wIiwiY3RwIiwiY29tYmluZSIsImNvIiwiY3QiLCJkcmFnb3ZlciIsImFjdGlvbiIsIndvcmtzaG9wIiwidHlwZURlZiIsInR5cGVFcnJvciIsInRmIiwib2JqZWN0cyIsIm5ld1R5cGUiLCJzZXRFcnJvciIsInJlc2V0RXJyb3IiLCJldmFsdWF0ZSIsImdyYXBoVmFsdWUiLCJjaGFycyIsImNpZCIsInJhbmRvbSIsImZ1bmNzIiwiZnVuYyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQSxTQUFTQSxjQUFULENBQXdCQyxLQUF4QixFQUErQjtBQUMzQixRQUFNQSxLQUFOO0FBQ0g7O0FBQ0QsU0FBU0MsYUFBVCxDQUF1QkMsR0FBdkIsRUFBNEI7QUFDdkJDLE9BQUQsSUFBMkNDLE9BQU8sQ0FBQ0MsSUFBUixzQkFBMkJILEdBQUcsQ0FBQ0ksT0FBL0IsRUFBM0M7QUFDSDs7QUFDRCxTQUFTQyxtQkFBVCxDQUE2QkMsSUFBN0IsRUFBbUNDLEdBQW5DLEVBQXdDQyxRQUF4QyxFQUFrREMsaUJBQWxELEVBQXFFO0FBQ2pFLE1BQU1ULEdBQUcsR0FBSUMsS0FBRCxHQUNOLENBQUNPLFFBQVEsSUFBSUUsYUFBYixFQUE0QkosSUFBNUIsS0FBcUNHLGlCQUFpQixNQUF0RCxDQURNLEdBRU5ILENBRk47QUFHQSxNQUFNUixLQUFLLEdBQUcsSUFBSWEsV0FBSixDQUFnQkMsTUFBTSxDQUFDWixHQUFELENBQXRC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QUFJLEVBQUVELEtBQUssQ0FBQ3JxRTtBQUE1QixDQUFkLEM7Ozs7OztVQ2RQO1VBQ0E7O1VBRUE7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7Ozs7O1dDdEJBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxnQ0FBZ0MsWUFBWTtXQUM1QztXQUNBLEU7Ozs7O1dDUEE7V0FDQTtXQUNBO1dBQ0E7V0FDQSx3Q0FBd0MseUNBQXlDO1dBQ2pGO1dBQ0E7V0FDQSxFOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsRUFBRTtXQUNGO1dBQ0E7V0FDQSxDQUFDLEk7Ozs7O1dDUEQsd0Y7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0Esc0RBQXNELGtCQUFrQjtXQUN4RTtXQUNBLCtDQUErQyxjQUFjO1dBQzdELEU7Ozs7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTtBQUVBLElBQU0yN0IsR0FBRyxHQUFHMGYsOENBQVMsQ0FBQztBQUNwQnRhLE1BRG9CLGtCQUNiO0FBQ0wsV0FBTyxFQUFQO0FBQ0Q7QUFIbUIsQ0FBRCxDQUFyQjtBQU1BcEYsR0FBRyxDQUFDMVMsU0FBSixDQUFjLFVBQWQsRUFBMEJ1Z0QsMERBQTFCO0FBQ0E3dEMsR0FBRyxDQUFDeWdCLEtBQUosQ0FBVSxNQUFWLEUiLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1N0cmluZywgaHlwaGVuYXRlLCBleHRlbmQsIGlzT2JqZWN0LCBpc0FycmF5LCBtYWtlTWFwLCBOTywgaXNTeW1ib2wsIE5PT1AsIEVNUFRZX09CSiwgY2FwaXRhbGl6ZSwgY2FtZWxpemUgYXMgY2FtZWxpemUkMSwgUGF0Y2hGbGFnTmFtZXMsIHNsb3RGbGFnc1RleHQsIGlzT24sIGlzUmVzZXJ2ZWRQcm9wLCB0b0hhbmRsZXJLZXkgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5leHBvcnQgeyBnZW5lcmF0ZUNvZGVGcmFtZSB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxuZnVuY3Rpb24gZGVmYXVsdE9uRXJyb3IoZXJyb3IpIHtcclxuICAgIHRocm93IGVycm9yO1xyXG59XHJcbmZ1bmN0aW9uIGRlZmF1bHRPbldhcm4obXNnKSB7XHJcbiAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgY29uc29sZS53YXJuKGBbVnVlIHdhcm5dICR7bXNnLm1lc3NhZ2V9YCk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXJFcnJvcihjb2RlLCBsb2MsIG1lc3NhZ2VzLCBhZGRpdGlvbmFsTWVzc2FnZSkge1xyXG4gICAgY29uc3QgbXNnID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8ICF0cnVlXHJcbiAgICAgICAgPyAobWVzc2FnZXMgfHwgZXJyb3JNZXNzYWdlcylbY29kZV0gKyAoYWRkaXRpb25hbE1lc3NhZ2UgfHwgYGApXHJcbiAgICAgICAgOiBjb2RlO1xyXG4gICAgY29uc3QgZXJyb3IgPSBuZXcgU3ludGF4RXJyb3IoU3RyaW5nKG1zZykpO1xyXG4gICAgZXJyb3IuY29kZSA9IGNvZGU7XHJcbiAgICBlcnJvci5sb2MgPSBsb2M7XHJcbiAgICByZXR1cm4gZXJyb3I7XHJcbn1cclxuY29uc3QgZXJyb3JNZXNzYWdlcyA9IHtcclxuICAgIC8vIHBhcnNlIGVycm9yc1xyXG4gICAgWzAgLyogQUJSVVBUX0NMT1NJTkdfT0ZfRU1QVFlfQ09NTUVOVCAqL106ICdJbGxlZ2FsIGNvbW1lbnQuJyxcclxuICAgIFsxIC8qIENEQVRBX0lOX0hUTUxfQ09OVEVOVCAqL106ICdDREFUQSBzZWN0aW9uIGlzIGFsbG93ZWQgb25seSBpbiBYTUwgY29udGV4dC4nLFxyXG4gICAgWzIgLyogRFVQTElDQVRFX0FUVFJJQlVURSAqL106ICdEdXBsaWNhdGUgYXR0cmlidXRlLicsXHJcbiAgICBbMyAvKiBFTkRfVEFHX1dJVEhfQVRUUklCVVRFUyAqL106ICdFbmQgdGFnIGNhbm5vdCBoYXZlIGF0dHJpYnV0ZXMuJyxcclxuICAgIFs0IC8qIEVORF9UQUdfV0lUSF9UUkFJTElOR19TT0xJRFVTICovXTogXCJJbGxlZ2FsICcvJyBpbiB0YWdzLlwiLFxyXG4gICAgWzUgLyogRU9GX0JFRk9SRV9UQUdfTkFNRSAqL106ICdVbmV4cGVjdGVkIEVPRiBpbiB0YWcuJyxcclxuICAgIFs2IC8qIEVPRl9JTl9DREFUQSAqL106ICdVbmV4cGVjdGVkIEVPRiBpbiBDREFUQSBzZWN0aW9uLicsXHJcbiAgICBbNyAvKiBFT0ZfSU5fQ09NTUVOVCAqL106ICdVbmV4cGVjdGVkIEVPRiBpbiBjb21tZW50LicsXHJcbiAgICBbOCAvKiBFT0ZfSU5fU0NSSVBUX0hUTUxfQ09NTUVOVF9MSUtFX1RFWFQgKi9dOiAnVW5leHBlY3RlZCBFT0YgaW4gc2NyaXB0LicsXHJcbiAgICBbOSAvKiBFT0ZfSU5fVEFHICovXTogJ1VuZXhwZWN0ZWQgRU9GIGluIHRhZy4nLFxyXG4gICAgWzEwIC8qIElOQ09SUkVDVExZX0NMT1NFRF9DT01NRU5UICovXTogJ0luY29ycmVjdGx5IGNsb3NlZCBjb21tZW50LicsXHJcbiAgICBbMTEgLyogSU5DT1JSRUNUTFlfT1BFTkVEX0NPTU1FTlQgKi9dOiAnSW5jb3JyZWN0bHkgb3BlbmVkIGNvbW1lbnQuJyxcclxuICAgIFsxMiAvKiBJTlZBTElEX0ZJUlNUX0NIQVJBQ1RFUl9PRl9UQUdfTkFNRSAqL106IFwiSWxsZWdhbCB0YWcgbmFtZS4gVXNlICcmbHQ7JyB0byBwcmludCAnPCcuXCIsXHJcbiAgICBbMTMgLyogTUlTU0lOR19BVFRSSUJVVEVfVkFMVUUgKi9dOiAnQXR0cmlidXRlIHZhbHVlIHdhcyBleHBlY3RlZC4nLFxyXG4gICAgWzE0IC8qIE1JU1NJTkdfRU5EX1RBR19OQU1FICovXTogJ0VuZCB0YWcgbmFtZSB3YXMgZXhwZWN0ZWQuJyxcclxuICAgIFsxNSAvKiBNSVNTSU5HX1dISVRFU1BBQ0VfQkVUV0VFTl9BVFRSSUJVVEVTICovXTogJ1doaXRlc3BhY2Ugd2FzIGV4cGVjdGVkLicsXHJcbiAgICBbMTYgLyogTkVTVEVEX0NPTU1FTlQgKi9dOiBcIlVuZXhwZWN0ZWQgJzwhLS0nIGluIGNvbW1lbnQuXCIsXHJcbiAgICBbMTcgLyogVU5FWFBFQ1RFRF9DSEFSQUNURVJfSU5fQVRUUklCVVRFX05BTUUgKi9dOiAnQXR0cmlidXRlIG5hbWUgY2Fubm90IGNvbnRhaW4gVSswMDIyIChcIiksIFUrMDAyNyAoXFwnKSwgYW5kIFUrMDAzQyAoPCkuJyxcclxuICAgIFsxOCAvKiBVTkVYUEVDVEVEX0NIQVJBQ1RFUl9JTl9VTlFVT1RFRF9BVFRSSUJVVEVfVkFMVUUgKi9dOiAnVW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlIGNhbm5vdCBjb250YWluIFUrMDAyMiAoXCIpLCBVKzAwMjcgKFxcJyksIFUrMDAzQyAoPCksIFUrMDAzRCAoPSksIGFuZCBVKzAwNjAgKGApLicsXHJcbiAgICBbMTkgLyogVU5FWFBFQ1RFRF9FUVVBTFNfU0lHTl9CRUZPUkVfQVRUUklCVVRFX05BTUUgKi9dOiBcIkF0dHJpYnV0ZSBuYW1lIGNhbm5vdCBzdGFydCB3aXRoICc9Jy5cIixcclxuICAgIFsyMSAvKiBVTkVYUEVDVEVEX1FVRVNUSU9OX01BUktfSU5TVEVBRF9PRl9UQUdfTkFNRSAqL106IFwiJzw/JyBpcyBhbGxvd2VkIG9ubHkgaW4gWE1MIGNvbnRleHQuXCIsXHJcbiAgICBbMjAgLyogVU5FWFBFQ1RFRF9OVUxMX0NIQVJBQ1RFUiAqL106IGBVbmV4cGVjdGVkIG51bGwgY2FocmFjdGVyLmAsXHJcbiAgICBbMjIgLyogVU5FWFBFQ1RFRF9TT0xJRFVTX0lOX1RBRyAqL106IFwiSWxsZWdhbCAnLycgaW4gdGFncy5cIixcclxuICAgIC8vIFZ1ZS1zcGVjaWZpYyBwYXJzZSBlcnJvcnNcclxuICAgIFsyMyAvKiBYX0lOVkFMSURfRU5EX1RBRyAqL106ICdJbnZhbGlkIGVuZCB0YWcuJyxcclxuICAgIFsyNCAvKiBYX01JU1NJTkdfRU5EX1RBRyAqL106ICdFbGVtZW50IGlzIG1pc3NpbmcgZW5kIHRhZy4nLFxyXG4gICAgWzI1IC8qIFhfTUlTU0lOR19JTlRFUlBPTEFUSU9OX0VORCAqL106ICdJbnRlcnBvbGF0aW9uIGVuZCBzaWduIHdhcyBub3QgZm91bmQuJyxcclxuICAgIFsyNiAvKiBYX01JU1NJTkdfRFlOQU1JQ19ESVJFQ1RJVkVfQVJHVU1FTlRfRU5EICovXTogJ0VuZCBicmFja2V0IGZvciBkeW5hbWljIGRpcmVjdGl2ZSBhcmd1bWVudCB3YXMgbm90IGZvdW5kLiAnICtcclxuICAgICAgICAnTm90ZSB0aGF0IGR5bmFtaWMgZGlyZWN0aXZlIGFyZ3VtZW50IGNhbm5vdCBjb250YWluIHNwYWNlcy4nLFxyXG4gICAgLy8gdHJhbnNmb3JtIGVycm9yc1xyXG4gICAgWzI3IC8qIFhfVl9JRl9OT19FWFBSRVNTSU9OICovXTogYHYtaWYvdi1lbHNlLWlmIGlzIG1pc3NpbmcgZXhwcmVzc2lvbi5gLFxyXG4gICAgWzI4IC8qIFhfVl9JRl9TQU1FX0tFWSAqL106IGB2LWlmL2Vsc2UgYnJhbmNoZXMgbXVzdCB1c2UgdW5pcXVlIGtleXMuYCxcclxuICAgIFsyOSAvKiBYX1ZfRUxTRV9OT19BREpBQ0VOVF9JRiAqL106IGB2LWVsc2Uvdi1lbHNlLWlmIGhhcyBubyBhZGphY2VudCB2LWlmLmAsXHJcbiAgICBbMzAgLyogWF9WX0ZPUl9OT19FWFBSRVNTSU9OICovXTogYHYtZm9yIGlzIG1pc3NpbmcgZXhwcmVzc2lvbi5gLFxyXG4gICAgWzMxIC8qIFhfVl9GT1JfTUFMRk9STUVEX0VYUFJFU1NJT04gKi9dOiBgdi1mb3IgaGFzIGludmFsaWQgZXhwcmVzc2lvbi5gLFxyXG4gICAgWzMyIC8qIFhfVl9GT1JfVEVNUExBVEVfS0VZX1BMQUNFTUVOVCAqL106IGA8dGVtcGxhdGUgdi1mb3I+IGtleSBzaG91bGQgYmUgcGxhY2VkIG9uIHRoZSA8dGVtcGxhdGU+IHRhZy5gLFxyXG4gICAgWzMzIC8qIFhfVl9CSU5EX05PX0VYUFJFU1NJT04gKi9dOiBgdi1iaW5kIGlzIG1pc3NpbmcgZXhwcmVzc2lvbi5gLFxyXG4gICAgWzM0IC8qIFhfVl9PTl9OT19FWFBSRVNTSU9OICovXTogYHYtb24gaXMgbWlzc2luZyBleHByZXNzaW9uLmAsXHJcbiAgICBbMzUgLyogWF9WX1NMT1RfVU5FWFBFQ1RFRF9ESVJFQ1RJVkVfT05fU0xPVF9PVVRMRVQgKi9dOiBgVW5leHBlY3RlZCBjdXN0b20gZGlyZWN0aXZlIG9uIDxzbG90PiBvdXRsZXQuYCxcclxuICAgIFszNiAvKiBYX1ZfU0xPVF9NSVhFRF9TTE9UX1VTQUdFICovXTogYE1peGVkIHYtc2xvdCB1c2FnZSBvbiBib3RoIHRoZSBjb21wb25lbnQgYW5kIG5lc3RlZCA8dGVtcGxhdGU+LmAgK1xyXG4gICAgICAgIGBXaGVuIHRoZXJlIGFyZSBtdWx0aXBsZSBuYW1lZCBzbG90cywgYWxsIHNsb3RzIHNob3VsZCB1c2UgPHRlbXBsYXRlPiBgICtcclxuICAgICAgICBgc3ludGF4IHRvIGF2b2lkIHNjb3BlIGFtYmlndWl0eS5gLFxyXG4gICAgWzM3IC8qIFhfVl9TTE9UX0RVUExJQ0FURV9TTE9UX05BTUVTICovXTogYER1cGxpY2F0ZSBzbG90IG5hbWVzIGZvdW5kLiBgLFxyXG4gICAgWzM4IC8qIFhfVl9TTE9UX0VYVFJBTkVPVVNfREVGQVVMVF9TTE9UX0NISUxEUkVOICovXTogYEV4dHJhbmVvdXMgY2hpbGRyZW4gZm91bmQgd2hlbiBjb21wb25lbnQgYWxyZWFkeSBoYXMgZXhwbGljaXRseSBuYW1lZCBgICtcclxuICAgICAgICBgZGVmYXVsdCBzbG90LiBUaGVzZSBjaGlsZHJlbiB3aWxsIGJlIGlnbm9yZWQuYCxcclxuICAgIFszOSAvKiBYX1ZfU0xPVF9NSVNQTEFDRUQgKi9dOiBgdi1zbG90IGNhbiBvbmx5IGJlIHVzZWQgb24gY29tcG9uZW50cyBvciA8dGVtcGxhdGU+IHRhZ3MuYCxcclxuICAgIFs0MCAvKiBYX1ZfTU9ERUxfTk9fRVhQUkVTU0lPTiAqL106IGB2LW1vZGVsIGlzIG1pc3NpbmcgZXhwcmVzc2lvbi5gLFxyXG4gICAgWzQxIC8qIFhfVl9NT0RFTF9NQUxGT1JNRURfRVhQUkVTU0lPTiAqL106IGB2LW1vZGVsIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBKYXZhU2NyaXB0IG1lbWJlciBleHByZXNzaW9uLmAsXHJcbiAgICBbNDIgLyogWF9WX01PREVMX09OX1NDT1BFX1ZBUklBQkxFICovXTogYHYtbW9kZWwgY2Fubm90IGJlIHVzZWQgb24gdi1mb3Igb3Igdi1zbG90IHNjb3BlIHZhcmlhYmxlcyBiZWNhdXNlIHRoZXkgYXJlIG5vdCB3cml0YWJsZS5gLFxyXG4gICAgWzQzIC8qIFhfSU5WQUxJRF9FWFBSRVNTSU9OICovXTogYEVycm9yIHBhcnNpbmcgSmF2YVNjcmlwdCBleHByZXNzaW9uOiBgLFxyXG4gICAgWzQ0IC8qIFhfS0VFUF9BTElWRV9JTlZBTElEX0NISUxEUkVOICovXTogYDxLZWVwQWxpdmU+IGV4cGVjdHMgZXhhY3RseSBvbmUgY2hpbGQgY29tcG9uZW50LmAsXHJcbiAgICAvLyBnZW5lcmljIGVycm9yc1xyXG4gICAgWzQ1IC8qIFhfUFJFRklYX0lEX05PVF9TVVBQT1JURUQgKi9dOiBgXCJwcmVmaXhJZGVudGlmaWVyc1wiIG9wdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnVpbGQgb2YgY29tcGlsZXIuYCxcclxuICAgIFs0NiAvKiBYX01PRFVMRV9NT0RFX05PVF9TVVBQT1JURUQgKi9dOiBgRVMgbW9kdWxlIG1vZGUgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJ1aWxkIG9mIGNvbXBpbGVyLmAsXHJcbiAgICBbNDcgLyogWF9DQUNIRV9IQU5ETEVSX05PVF9TVVBQT1JURUQgKi9dOiBgXCJjYWNoZUhhbmRsZXJzXCIgb3B0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIHdoZW4gdGhlIFwicHJlZml4SWRlbnRpZmllcnNcIiBvcHRpb24gaXMgZW5hYmxlZC5gLFxyXG4gICAgWzQ4IC8qIFhfU0NPUEVfSURfTk9UX1NVUFBPUlRFRCAqL106IGBcInNjb3BlSWRcIiBvcHRpb24gaXMgb25seSBzdXBwb3J0ZWQgaW4gbW9kdWxlIG1vZGUuYCxcclxuICAgIC8vIGp1c3QgdG8gZnVsbGZpbGwgdHlwZXNcclxuICAgIFs0OSAvKiBfX0VYVEVORF9QT0lOVF9fICovXTogYGBcclxufTtcblxuY29uc3QgRlJBR01FTlQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYEZyYWdtZW50YCA6IGBgKTtcclxuY29uc3QgVEVMRVBPUlQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYFRlbGVwb3J0YCA6IGBgKTtcclxuY29uc3QgU1VTUEVOU0UgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYFN1c3BlbnNlYCA6IGBgKTtcclxuY29uc3QgS0VFUF9BTElWRSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgS2VlcEFsaXZlYCA6IGBgKTtcclxuY29uc3QgQkFTRV9UUkFOU0lUSU9OID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBCYXNlVHJhbnNpdGlvbmAgOiBgYCk7XHJcbmNvbnN0IE9QRU5fQkxPQ0sgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYG9wZW5CbG9ja2AgOiBgYCk7XHJcbmNvbnN0IENSRUFURV9CTE9DSyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgY3JlYXRlQmxvY2tgIDogYGApO1xyXG5jb25zdCBDUkVBVEVfVk5PREUgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYGNyZWF0ZVZOb2RlYCA6IGBgKTtcclxuY29uc3QgQ1JFQVRFX0NPTU1FTlQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYGNyZWF0ZUNvbW1lbnRWTm9kZWAgOiBgYCk7XHJcbmNvbnN0IENSRUFURV9URVhUID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBjcmVhdGVUZXh0Vk5vZGVgIDogYGApO1xyXG5jb25zdCBDUkVBVEVfU1RBVElDID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBjcmVhdGVTdGF0aWNWTm9kZWAgOiBgYCk7XHJcbmNvbnN0IFJFU09MVkVfQ09NUE9ORU5UID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGByZXNvbHZlQ29tcG9uZW50YCA6IGBgKTtcclxuY29uc3QgUkVTT0xWRV9EWU5BTUlDX0NPTVBPTkVOVCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgcmVzb2x2ZUR5bmFtaWNDb21wb25lbnRgIDogYGApO1xyXG5jb25zdCBSRVNPTFZFX0RJUkVDVElWRSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgcmVzb2x2ZURpcmVjdGl2ZWAgOiBgYCk7XHJcbmNvbnN0IFJFU09MVkVfRklMVEVSID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGByZXNvbHZlRmlsdGVyYCA6IGBgKTtcclxuY29uc3QgV0lUSF9ESVJFQ1RJVkVTID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB3aXRoRGlyZWN0aXZlc2AgOiBgYCk7XHJcbmNvbnN0IFJFTkRFUl9MSVNUID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGByZW5kZXJMaXN0YCA6IGBgKTtcclxuY29uc3QgUkVOREVSX1NMT1QgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHJlbmRlclNsb3RgIDogYGApO1xyXG5jb25zdCBDUkVBVEVfU0xPVFMgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYGNyZWF0ZVNsb3RzYCA6IGBgKTtcclxuY29uc3QgVE9fRElTUExBWV9TVFJJTkcgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHRvRGlzcGxheVN0cmluZ2AgOiBgYCk7XHJcbmNvbnN0IE1FUkdFX1BST1BTID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBtZXJnZVByb3BzYCA6IGBgKTtcclxuY29uc3QgVE9fSEFORExFUlMgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHRvSGFuZGxlcnNgIDogYGApO1xyXG5jb25zdCBDQU1FTElaRSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgY2FtZWxpemVgIDogYGApO1xyXG5jb25zdCBDQVBJVEFMSVpFID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBjYXBpdGFsaXplYCA6IGBgKTtcclxuY29uc3QgVE9fSEFORExFUl9LRVkgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHRvSGFuZGxlcktleWAgOiBgYCk7XHJcbmNvbnN0IFNFVF9CTE9DS19UUkFDS0lORyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgc2V0QmxvY2tUcmFja2luZ2AgOiBgYCk7XHJcbmNvbnN0IFBVU0hfU0NPUEVfSUQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHB1c2hTY29wZUlkYCA6IGBgKTtcclxuY29uc3QgUE9QX1NDT1BFX0lEID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBwb3BTY29wZUlkYCA6IGBgKTtcclxuY29uc3QgV0lUSF9TQ09QRV9JRCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgd2l0aFNjb3BlSWRgIDogYGApO1xyXG5jb25zdCBXSVRIX0NUWCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgd2l0aEN0eGAgOiBgYCk7XHJcbmNvbnN0IFVOUkVGID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB1bnJlZmAgOiBgYCk7XHJcbmNvbnN0IElTX1JFRiA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgaXNSZWZgIDogYGApO1xyXG4vLyBOYW1lIG1hcHBpbmcgZm9yIHJ1bnRpbWUgaGVscGVycyB0aGF0IG5lZWQgdG8gYmUgaW1wb3J0ZWQgZnJvbSAndnVlJyBpblxyXG4vLyBnZW5lcmF0ZWQgY29kZS4gTWFrZSBzdXJlIHRoZXNlIGFyZSBjb3JyZWN0bHkgZXhwb3J0ZWQgaW4gdGhlIHJ1bnRpbWUhXHJcbi8vIFVzaW5nIGBhbnlgIGhlcmUgYmVjYXVzZSBUUyBkb2Vzbid0IGFsbG93IHN5bWJvbHMgYXMgaW5kZXggdHlwZS5cclxuY29uc3QgaGVscGVyTmFtZU1hcCA9IHtcclxuICAgIFtGUkFHTUVOVF06IGBGcmFnbWVudGAsXHJcbiAgICBbVEVMRVBPUlRdOiBgVGVsZXBvcnRgLFxyXG4gICAgW1NVU1BFTlNFXTogYFN1c3BlbnNlYCxcclxuICAgIFtLRUVQX0FMSVZFXTogYEtlZXBBbGl2ZWAsXHJcbiAgICBbQkFTRV9UUkFOU0lUSU9OXTogYEJhc2VUcmFuc2l0aW9uYCxcclxuICAgIFtPUEVOX0JMT0NLXTogYG9wZW5CbG9ja2AsXHJcbiAgICBbQ1JFQVRFX0JMT0NLXTogYGNyZWF0ZUJsb2NrYCxcclxuICAgIFtDUkVBVEVfVk5PREVdOiBgY3JlYXRlVk5vZGVgLFxyXG4gICAgW0NSRUFURV9DT01NRU5UXTogYGNyZWF0ZUNvbW1lbnRWTm9kZWAsXHJcbiAgICBbQ1JFQVRFX1RFWFRdOiBgY3JlYXRlVGV4dFZOb2RlYCxcclxuICAgIFtDUkVBVEVfU1RBVElDXTogYGNyZWF0ZVN0YXRpY1ZOb2RlYCxcclxuICAgIFtSRVNPTFZFX0NPTVBPTkVOVF06IGByZXNvbHZlQ29tcG9uZW50YCxcclxuICAgIFtSRVNPTFZFX0RZTkFNSUNfQ09NUE9ORU5UXTogYHJlc29sdmVEeW5hbWljQ29tcG9uZW50YCxcclxuICAgIFtSRVNPTFZFX0RJUkVDVElWRV06IGByZXNvbHZlRGlyZWN0aXZlYCxcclxuICAgIFtSRVNPTFZFX0ZJTFRFUl06IGByZXNvbHZlRmlsdGVyYCxcclxuICAgIFtXSVRIX0RJUkVDVElWRVNdOiBgd2l0aERpcmVjdGl2ZXNgLFxyXG4gICAgW1JFTkRFUl9MSVNUXTogYHJlbmRlckxpc3RgLFxyXG4gICAgW1JFTkRFUl9TTE9UXTogYHJlbmRlclNsb3RgLFxyXG4gICAgW0NSRUFURV9TTE9UU106IGBjcmVhdGVTbG90c2AsXHJcbiAgICBbVE9fRElTUExBWV9TVFJJTkddOiBgdG9EaXNwbGF5U3RyaW5nYCxcclxuICAgIFtNRVJHRV9QUk9QU106IGBtZXJnZVByb3BzYCxcclxuICAgIFtUT19IQU5ETEVSU106IGB0b0hhbmRsZXJzYCxcclxuICAgIFtDQU1FTElaRV06IGBjYW1lbGl6ZWAsXHJcbiAgICBbQ0FQSVRBTElaRV06IGBjYXBpdGFsaXplYCxcclxuICAgIFtUT19IQU5ETEVSX0tFWV06IGB0b0hhbmRsZXJLZXlgLFxyXG4gICAgW1NFVF9CTE9DS19UUkFDS0lOR106IGBzZXRCbG9ja1RyYWNraW5nYCxcclxuICAgIFtQVVNIX1NDT1BFX0lEXTogYHB1c2hTY29wZUlkYCxcclxuICAgIFtQT1BfU0NPUEVfSURdOiBgcG9wU2NvcGVJZGAsXHJcbiAgICBbV0lUSF9TQ09QRV9JRF06IGB3aXRoU2NvcGVJZGAsXHJcbiAgICBbV0lUSF9DVFhdOiBgd2l0aEN0eGAsXHJcbiAgICBbVU5SRUZdOiBgdW5yZWZgLFxyXG4gICAgW0lTX1JFRl06IGBpc1JlZmBcclxufTtcclxuZnVuY3Rpb24gcmVnaXN0ZXJSdW50aW1lSGVscGVycyhoZWxwZXJzKSB7XHJcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGhlbHBlcnMpLmZvckVhY2gocyA9PiB7XHJcbiAgICAgICAgaGVscGVyTmFtZU1hcFtzXSA9IGhlbHBlcnNbc107XHJcbiAgICB9KTtcclxufVxuXG4vLyBBU1QgVXRpbGl0aWVzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBTb21lIGV4cHJlc3Npb25zLCBlLmcuIHNlcXVlbmNlIGFuZCBjb25kaXRpb25hbCBleHByZXNzaW9ucywgYXJlIG5ldmVyXHJcbi8vIGFzc29jaWF0ZWQgd2l0aCB0ZW1wbGF0ZSBub2Rlcywgc28gdGhlaXIgc291cmNlIGxvY2F0aW9ucyBhcmUganVzdCBhIHN0dWIuXHJcbi8vIENvbnRhaW5lciB0eXBlcyBsaWtlIENvbXBvdW5kRXhwcmVzc2lvbiBhbHNvIGRvbid0IG5lZWQgYSByZWFsIGxvY2F0aW9uLlxyXG5jb25zdCBsb2NTdHViID0ge1xyXG4gICAgc291cmNlOiAnJyxcclxuICAgIHN0YXJ0OiB7IGxpbmU6IDEsIGNvbHVtbjogMSwgb2Zmc2V0OiAwIH0sXHJcbiAgICBlbmQ6IHsgbGluZTogMSwgY29sdW1uOiAxLCBvZmZzZXQ6IDAgfVxyXG59O1xyXG5mdW5jdGlvbiBjcmVhdGVSb290KGNoaWxkcmVuLCBsb2MgPSBsb2NTdHViKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDAgLyogUk9PVCAqLyxcclxuICAgICAgICBjaGlsZHJlbixcclxuICAgICAgICBoZWxwZXJzOiBbXSxcclxuICAgICAgICBjb21wb25lbnRzOiBbXSxcclxuICAgICAgICBkaXJlY3RpdmVzOiBbXSxcclxuICAgICAgICBob2lzdHM6IFtdLFxyXG4gICAgICAgIGltcG9ydHM6IFtdLFxyXG4gICAgICAgIGNhY2hlZDogMCxcclxuICAgICAgICB0ZW1wczogMCxcclxuICAgICAgICBjb2RlZ2VuTm9kZTogdW5kZWZpbmVkLFxyXG4gICAgICAgIGxvY1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVWTm9kZUNhbGwoY29udGV4dCwgdGFnLCBwcm9wcywgY2hpbGRyZW4sIHBhdGNoRmxhZywgZHluYW1pY1Byb3BzLCBkaXJlY3RpdmVzLCBpc0Jsb2NrID0gZmFsc2UsIGRpc2FibGVUcmFja2luZyA9IGZhbHNlLCBsb2MgPSBsb2NTdHViKSB7XHJcbiAgICBpZiAoY29udGV4dCkge1xyXG4gICAgICAgIGlmIChpc0Jsb2NrKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuaGVscGVyKE9QRU5fQkxPQ0spO1xyXG4gICAgICAgICAgICBjb250ZXh0LmhlbHBlcihDUkVBVEVfQkxPQ0spO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29udGV4dC5oZWxwZXIoQ1JFQVRFX1ZOT0RFKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRpcmVjdGl2ZXMpIHtcclxuICAgICAgICAgICAgY29udGV4dC5oZWxwZXIoV0lUSF9ESVJFQ1RJVkVTKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDEzIC8qIFZOT0RFX0NBTEwgKi8sXHJcbiAgICAgICAgdGFnLFxyXG4gICAgICAgIHByb3BzLFxyXG4gICAgICAgIGNoaWxkcmVuLFxyXG4gICAgICAgIHBhdGNoRmxhZyxcclxuICAgICAgICBkeW5hbWljUHJvcHMsXHJcbiAgICAgICAgZGlyZWN0aXZlcyxcclxuICAgICAgICBpc0Jsb2NrLFxyXG4gICAgICAgIGRpc2FibGVUcmFja2luZyxcclxuICAgICAgICBsb2NcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQXJyYXlFeHByZXNzaW9uKGVsZW1lbnRzLCBsb2MgPSBsb2NTdHViKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDE3IC8qIEpTX0FSUkFZX0VYUFJFU1NJT04gKi8sXHJcbiAgICAgICAgbG9jLFxyXG4gICAgICAgIGVsZW1lbnRzXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZU9iamVjdEV4cHJlc3Npb24ocHJvcGVydGllcywgbG9jID0gbG9jU3R1Yikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAxNSAvKiBKU19PQkpFQ1RfRVhQUkVTU0lPTiAqLyxcclxuICAgICAgICBsb2MsXHJcbiAgICAgICAgcHJvcGVydGllc1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVPYmplY3RQcm9wZXJ0eShrZXksIHZhbHVlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDE2IC8qIEpTX1BST1BFUlRZICovLFxyXG4gICAgICAgIGxvYzogbG9jU3R1YixcclxuICAgICAgICBrZXk6IGlzU3RyaW5nKGtleSkgPyBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGtleSwgdHJ1ZSkgOiBrZXksXHJcbiAgICAgICAgdmFsdWVcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihjb250ZW50LCBpc1N0YXRpYywgbG9jID0gbG9jU3R1YiwgY29uc3RUeXBlID0gMCAvKiBOT1RfQ09OU1RBTlQgKi8pIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyxcclxuICAgICAgICBsb2MsXHJcbiAgICAgICAgY29udGVudCxcclxuICAgICAgICBpc1N0YXRpYyxcclxuICAgICAgICBjb25zdFR5cGU6IGlzU3RhdGljID8gMyAvKiBDQU5fU1RSSU5HSUZZICovIDogY29uc3RUeXBlXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUludGVycG9sYXRpb24oY29udGVudCwgbG9jKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDUgLyogSU5URVJQT0xBVElPTiAqLyxcclxuICAgICAgICBsb2MsXHJcbiAgICAgICAgY29udGVudDogaXNTdHJpbmcoY29udGVudClcclxuICAgICAgICAgICAgPyBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGNvbnRlbnQsIGZhbHNlLCBsb2MpXHJcbiAgICAgICAgICAgIDogY29udGVudFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24oY2hpbGRyZW4sIGxvYyA9IGxvY1N0dWIpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogOCAvKiBDT01QT1VORF9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgIGxvYyxcclxuICAgICAgICBjaGlsZHJlblxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVDYWxsRXhwcmVzc2lvbihjYWxsZWUsIGFyZ3MgPSBbXSwgbG9jID0gbG9jU3R1Yikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAxNCAvKiBKU19DQUxMX0VYUFJFU1NJT04gKi8sXHJcbiAgICAgICAgbG9jLFxyXG4gICAgICAgIGNhbGxlZSxcclxuICAgICAgICBhcmd1bWVudHM6IGFyZ3NcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uKHBhcmFtcywgcmV0dXJucyA9IHVuZGVmaW5lZCwgbmV3bGluZSA9IGZhbHNlLCBpc1Nsb3QgPSBmYWxzZSwgbG9jID0gbG9jU3R1Yikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAxOCAvKiBKU19GVU5DVElPTl9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgIHBhcmFtcyxcclxuICAgICAgICByZXR1cm5zLFxyXG4gICAgICAgIG5ld2xpbmUsXHJcbiAgICAgICAgaXNTbG90LFxyXG4gICAgICAgIGxvY1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVDb25kaXRpb25hbEV4cHJlc3Npb24odGVzdCwgY29uc2VxdWVudCwgYWx0ZXJuYXRlLCBuZXdsaW5lID0gdHJ1ZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAxOSAvKiBKU19DT05ESVRJT05BTF9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgIHRlc3QsXHJcbiAgICAgICAgY29uc2VxdWVudCxcclxuICAgICAgICBhbHRlcm5hdGUsXHJcbiAgICAgICAgbmV3bGluZSxcclxuICAgICAgICBsb2M6IGxvY1N0dWJcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQ2FjaGVFeHByZXNzaW9uKGluZGV4LCB2YWx1ZSwgaXNWTm9kZSA9IGZhbHNlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDIwIC8qIEpTX0NBQ0hFX0VYUFJFU1NJT04gKi8sXHJcbiAgICAgICAgaW5kZXgsXHJcbiAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgaXNWTm9kZSxcclxuICAgICAgICBsb2M6IGxvY1N0dWJcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQmxvY2tTdGF0ZW1lbnQoYm9keSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAyMSAvKiBKU19CTE9DS19TVEFURU1FTlQgKi8sXHJcbiAgICAgICAgYm9keSxcclxuICAgICAgICBsb2M6IGxvY1N0dWJcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlVGVtcGxhdGVMaXRlcmFsKGVsZW1lbnRzKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDIyIC8qIEpTX1RFTVBMQVRFX0xJVEVSQUwgKi8sXHJcbiAgICAgICAgZWxlbWVudHMsXHJcbiAgICAgICAgbG9jOiBsb2NTdHViXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUlmU3RhdGVtZW50KHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAyMyAvKiBKU19JRl9TVEFURU1FTlQgKi8sXHJcbiAgICAgICAgdGVzdCxcclxuICAgICAgICBjb25zZXF1ZW50LFxyXG4gICAgICAgIGFsdGVybmF0ZSxcclxuICAgICAgICBsb2M6IGxvY1N0dWJcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQXNzaWdubWVudEV4cHJlc3Npb24obGVmdCwgcmlnaHQpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMjQgLyogSlNfQVNTSUdOTUVOVF9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgIGxlZnQsXHJcbiAgICAgICAgcmlnaHQsXHJcbiAgICAgICAgbG9jOiBsb2NTdHViXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVNlcXVlbmNlRXhwcmVzc2lvbihleHByZXNzaW9ucykge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAyNSAvKiBKU19TRVFVRU5DRV9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgIGV4cHJlc3Npb25zLFxyXG4gICAgICAgIGxvYzogbG9jU3R1YlxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVSZXR1cm5TdGF0ZW1lbnQocmV0dXJucykge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAyNiAvKiBKU19SRVRVUk5fU1RBVEVNRU5UICovLFxyXG4gICAgICAgIHJldHVybnMsXHJcbiAgICAgICAgbG9jOiBsb2NTdHViXHJcbiAgICB9O1xyXG59XG5cbmNvbnN0IGlzU3RhdGljRXhwID0gKHApID0+IHAudHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyAmJiBwLmlzU3RhdGljO1xyXG5jb25zdCBpc0J1aWx0SW5UeXBlID0gKHRhZywgZXhwZWN0ZWQpID0+IHRhZyA9PT0gZXhwZWN0ZWQgfHwgdGFnID09PSBoeXBoZW5hdGUoZXhwZWN0ZWQpO1xyXG5mdW5jdGlvbiBpc0NvcmVDb21wb25lbnQodGFnKSB7XHJcbiAgICBpZiAoaXNCdWlsdEluVHlwZSh0YWcsICdUZWxlcG9ydCcpKSB7XHJcbiAgICAgICAgcmV0dXJuIFRFTEVQT1JUO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNCdWlsdEluVHlwZSh0YWcsICdTdXNwZW5zZScpKSB7XHJcbiAgICAgICAgcmV0dXJuIFNVU1BFTlNFO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNCdWlsdEluVHlwZSh0YWcsICdLZWVwQWxpdmUnKSkge1xyXG4gICAgICAgIHJldHVybiBLRUVQX0FMSVZFO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNCdWlsdEluVHlwZSh0YWcsICdCYXNlVHJhbnNpdGlvbicpKSB7XHJcbiAgICAgICAgcmV0dXJuIEJBU0VfVFJBTlNJVElPTjtcclxuICAgIH1cclxufVxyXG5jb25zdCBub25JZGVudGlmaWVyUkUgPSAvXlxcZHxbXlxcJFxcd10vO1xyXG5jb25zdCBpc1NpbXBsZUlkZW50aWZpZXIgPSAobmFtZSkgPT4gIW5vbklkZW50aWZpZXJSRS50ZXN0KG5hbWUpO1xyXG5jb25zdCBtZW1iZXJFeHBSRSA9IC9eW0EtWmEtel8kXFx4QTAtXFx1RkZGRl1bXFx3JFxceEEwLVxcdUZGRkZdKig/OlxccypcXC5cXHMqW0EtWmEtel8kXFx4QTAtXFx1RkZGRl1bXFx3JFxceEEwLVxcdUZGRkZdKnxcXFsoLispXFxdKSokLztcclxuY29uc3QgaXNNZW1iZXJFeHByZXNzaW9uID0gKHBhdGgpID0+IHtcclxuICAgIGlmICghcGF0aClcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICBjb25zdCBtYXRjaGVkID0gbWVtYmVyRXhwUkUuZXhlYyhwYXRoLnRyaW0oKSk7XHJcbiAgICBpZiAoIW1hdGNoZWQpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgaWYgKCFtYXRjaGVkWzFdKVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgaWYgKCEvW1xcW1xcXV0vLnRlc3QobWF0Y2hlZFsxXSkpXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICByZXR1cm4gaXNNZW1iZXJFeHByZXNzaW9uKG1hdGNoZWRbMV0udHJpbSgpKTtcclxufTtcclxuZnVuY3Rpb24gZ2V0SW5uZXJSYW5nZShsb2MsIG9mZnNldCwgbGVuZ3RoKSB7XHJcbiAgICBjb25zdCBzb3VyY2UgPSBsb2Muc291cmNlLnN1YnN0cihvZmZzZXQsIGxlbmd0aCk7XHJcbiAgICBjb25zdCBuZXdMb2MgPSB7XHJcbiAgICAgICAgc291cmNlLFxyXG4gICAgICAgIHN0YXJ0OiBhZHZhbmNlUG9zaXRpb25XaXRoQ2xvbmUobG9jLnN0YXJ0LCBsb2Muc291cmNlLCBvZmZzZXQpLFxyXG4gICAgICAgIGVuZDogbG9jLmVuZFxyXG4gICAgfTtcclxuICAgIGlmIChsZW5ndGggIT0gbnVsbCkge1xyXG4gICAgICAgIG5ld0xvYy5lbmQgPSBhZHZhbmNlUG9zaXRpb25XaXRoQ2xvbmUobG9jLnN0YXJ0LCBsb2Muc291cmNlLCBvZmZzZXQgKyBsZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ld0xvYztcclxufVxyXG5mdW5jdGlvbiBhZHZhbmNlUG9zaXRpb25XaXRoQ2xvbmUocG9zLCBzb3VyY2UsIG51bWJlck9mQ2hhcmFjdGVycyA9IHNvdXJjZS5sZW5ndGgpIHtcclxuICAgIHJldHVybiBhZHZhbmNlUG9zaXRpb25XaXRoTXV0YXRpb24oZXh0ZW5kKHt9LCBwb3MpLCBzb3VyY2UsIG51bWJlck9mQ2hhcmFjdGVycyk7XHJcbn1cclxuLy8gYWR2YW5jZSBieSBtdXRhdGlvbiB3aXRob3V0IGNsb25pbmcgKGZvciBwZXJmb3JtYW5jZSByZWFzb25zKSwgc2luY2UgdGhpc1xyXG4vLyBnZXRzIGNhbGxlZCBhIGxvdCBpbiB0aGUgcGFyc2VyXHJcbmZ1bmN0aW9uIGFkdmFuY2VQb3NpdGlvbldpdGhNdXRhdGlvbihwb3MsIHNvdXJjZSwgbnVtYmVyT2ZDaGFyYWN0ZXJzID0gc291cmNlLmxlbmd0aCkge1xyXG4gICAgbGV0IGxpbmVzQ291bnQgPSAwO1xyXG4gICAgbGV0IGxhc3ROZXdMaW5lUG9zID0gLTE7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mQ2hhcmFjdGVyczsgaSsrKSB7XHJcbiAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGkpID09PSAxMCAvKiBuZXdsaW5lIGNoYXIgY29kZSAqLykge1xyXG4gICAgICAgICAgICBsaW5lc0NvdW50Kys7XHJcbiAgICAgICAgICAgIGxhc3ROZXdMaW5lUG9zID0gaTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwb3Mub2Zmc2V0ICs9IG51bWJlck9mQ2hhcmFjdGVycztcclxuICAgIHBvcy5saW5lICs9IGxpbmVzQ291bnQ7XHJcbiAgICBwb3MuY29sdW1uID1cclxuICAgICAgICBsYXN0TmV3TGluZVBvcyA9PT0gLTFcclxuICAgICAgICAgICAgPyBwb3MuY29sdW1uICsgbnVtYmVyT2ZDaGFyYWN0ZXJzXHJcbiAgICAgICAgICAgIDogbnVtYmVyT2ZDaGFyYWN0ZXJzIC0gbGFzdE5ld0xpbmVQb3M7XHJcbiAgICByZXR1cm4gcG9zO1xyXG59XHJcbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1zZykge1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoIWNvbmRpdGlvbikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cgfHwgYHVuZXhwZWN0ZWQgY29tcGlsZXIgY29uZGl0aW9uYCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZmluZERpcihub2RlLCBuYW1lLCBhbGxvd0VtcHR5ID0gZmFsc2UpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5wcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHAgPSBub2RlLnByb3BzW2ldO1xyXG4gICAgICAgIGlmIChwLnR5cGUgPT09IDcgLyogRElSRUNUSVZFICovICYmXHJcbiAgICAgICAgICAgIChhbGxvd0VtcHR5IHx8IHAuZXhwKSAmJlxyXG4gICAgICAgICAgICAoaXNTdHJpbmcobmFtZSkgPyBwLm5hbWUgPT09IG5hbWUgOiBuYW1lLnRlc3QocC5uYW1lKSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGZpbmRQcm9wKG5vZGUsIG5hbWUsIGR5bmFtaWNPbmx5ID0gZmFsc2UsIGFsbG93RW1wdHkgPSBmYWxzZSkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLnByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgcCA9IG5vZGUucHJvcHNbaV07XHJcbiAgICAgICAgaWYgKHAudHlwZSA9PT0gNiAvKiBBVFRSSUJVVEUgKi8pIHtcclxuICAgICAgICAgICAgaWYgKGR5bmFtaWNPbmx5KVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIGlmIChwLm5hbWUgPT09IG5hbWUgJiYgKHAudmFsdWUgfHwgYWxsb3dFbXB0eSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHAubmFtZSA9PT0gJ2JpbmQnICYmXHJcbiAgICAgICAgICAgIChwLmV4cCB8fCBhbGxvd0VtcHR5KSAmJlxyXG4gICAgICAgICAgICBpc0JpbmRLZXkocC5hcmcsIG5hbWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc0JpbmRLZXkoYXJnLCBuYW1lKSB7XHJcbiAgICByZXR1cm4gISEoYXJnICYmIGlzU3RhdGljRXhwKGFyZykgJiYgYXJnLmNvbnRlbnQgPT09IG5hbWUpO1xyXG59XHJcbmZ1bmN0aW9uIGhhc0R5bmFtaWNLZXlWQmluZChub2RlKSB7XHJcbiAgICByZXR1cm4gbm9kZS5wcm9wcy5zb21lKHAgPT4gcC50eXBlID09PSA3IC8qIERJUkVDVElWRSAqLyAmJlxyXG4gICAgICAgIHAubmFtZSA9PT0gJ2JpbmQnICYmXHJcbiAgICAgICAgKCFwLmFyZyB8fCAvLyB2LWJpbmQ9XCJvYmpcIlxyXG4gICAgICAgICAgICBwLmFyZy50eXBlICE9PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovIHx8IC8vIHYtYmluZDpbX2N0eC5mb29dXHJcbiAgICAgICAgICAgICFwLmFyZy5pc1N0YXRpYykgLy8gdi1iaW5kOltmb29dXHJcbiAgICApO1xyXG59XHJcbmZ1bmN0aW9uIGlzVGV4dChub2RlKSB7XHJcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSA1IC8qIElOVEVSUE9MQVRJT04gKi8gfHwgbm9kZS50eXBlID09PSAyIC8qIFRFWFQgKi87XHJcbn1cclxuZnVuY3Rpb24gaXNWU2xvdChwKSB7XHJcbiAgICByZXR1cm4gcC50eXBlID09PSA3IC8qIERJUkVDVElWRSAqLyAmJiBwLm5hbWUgPT09ICdzbG90JztcclxufVxyXG5mdW5jdGlvbiBpc1RlbXBsYXRlTm9kZShub2RlKSB7XHJcbiAgICByZXR1cm4gKG5vZGUudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovICYmIG5vZGUudGFnVHlwZSA9PT0gMyAvKiBURU1QTEFURSAqLyk7XHJcbn1cclxuZnVuY3Rpb24gaXNTbG90T3V0bGV0KG5vZGUpIHtcclxuICAgIHJldHVybiBub2RlLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyAmJiBub2RlLnRhZ1R5cGUgPT09IDIgLyogU0xPVCAqLztcclxufVxyXG5mdW5jdGlvbiBpbmplY3RQcm9wKG5vZGUsIHByb3AsIGNvbnRleHQpIHtcclxuICAgIGxldCBwcm9wc1dpdGhJbmplY3Rpb247XHJcbiAgICBjb25zdCBwcm9wcyA9IG5vZGUudHlwZSA9PT0gMTMgLyogVk5PREVfQ0FMTCAqLyA/IG5vZGUucHJvcHMgOiBub2RlLmFyZ3VtZW50c1syXTtcclxuICAgIGlmIChwcm9wcyA9PSBudWxsIHx8IGlzU3RyaW5nKHByb3BzKSkge1xyXG4gICAgICAgIHByb3BzV2l0aEluamVjdGlvbiA9IGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oW3Byb3BdKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHByb3BzLnR5cGUgPT09IDE0IC8qIEpTX0NBTExfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgIC8vIG1lcmdlZCBwcm9wcy4uLiBhZGQgb3Vyc1xyXG4gICAgICAgIC8vIG9ubHkgaW5qZWN0IGtleSB0byBvYmplY3QgbGl0ZXJhbCBpZiBpdCdzIHRoZSBmaXJzdCBhcmd1bWVudCBzbyB0aGF0XHJcbiAgICAgICAgLy8gaWYgZG9lc24ndCBvdmVycmlkZSB1c2VyIHByb3ZpZGVkIGtleXNcclxuICAgICAgICBjb25zdCBmaXJzdCA9IHByb3BzLmFyZ3VtZW50c1swXTtcclxuICAgICAgICBpZiAoIWlzU3RyaW5nKGZpcnN0KSAmJiBmaXJzdC50eXBlID09PSAxNSAvKiBKU19PQkpFQ1RfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgICAgICBmaXJzdC5wcm9wZXJ0aWVzLnVuc2hpZnQocHJvcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAocHJvcHMuY2FsbGVlID09PSBUT19IQU5ETEVSUykge1xyXG4gICAgICAgICAgICAgICAgLy8gIzIzNjZcclxuICAgICAgICAgICAgICAgIHByb3BzV2l0aEluamVjdGlvbiA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKE1FUkdFX1BST1BTKSwgW1xyXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oW3Byb3BdKSxcclxuICAgICAgICAgICAgICAgICAgICBwcm9wc1xyXG4gICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwcm9wcy5hcmd1bWVudHMudW5zaGlmdChjcmVhdGVPYmplY3RFeHByZXNzaW9uKFtwcm9wXSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgICFwcm9wc1dpdGhJbmplY3Rpb24gJiYgKHByb3BzV2l0aEluamVjdGlvbiA9IHByb3BzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHByb3BzLnR5cGUgPT09IDE1IC8qIEpTX09CSkVDVF9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgbGV0IGFscmVhZHlFeGlzdHMgPSBmYWxzZTtcclxuICAgICAgICAvLyBjaGVjayBleGlzdGluZyBrZXkgdG8gYXZvaWQgb3ZlcnJpZGluZyB1c2VyIHByb3ZpZGVkIGtleXNcclxuICAgICAgICBpZiAocHJvcC5rZXkudHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgICAgICBjb25zdCBwcm9wS2V5TmFtZSA9IHByb3Aua2V5LmNvbnRlbnQ7XHJcbiAgICAgICAgICAgIGFscmVhZHlFeGlzdHMgPSBwcm9wcy5wcm9wZXJ0aWVzLnNvbWUocCA9PiBwLmtleS50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovICYmXHJcbiAgICAgICAgICAgICAgICBwLmtleS5jb250ZW50ID09PSBwcm9wS2V5TmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghYWxyZWFkeUV4aXN0cykge1xyXG4gICAgICAgICAgICBwcm9wcy5wcm9wZXJ0aWVzLnVuc2hpZnQocHJvcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb3BzV2l0aEluamVjdGlvbiA9IHByb3BzO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gc2luZ2xlIHYtYmluZCB3aXRoIGV4cHJlc3Npb24sIHJldHVybiBhIG1lcmdlZCByZXBsYWNlbWVudFxyXG4gICAgICAgIHByb3BzV2l0aEluamVjdGlvbiA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKE1FUkdFX1BST1BTKSwgW1xyXG4gICAgICAgICAgICBjcmVhdGVPYmplY3RFeHByZXNzaW9uKFtwcm9wXSksXHJcbiAgICAgICAgICAgIHByb3BzXHJcbiAgICAgICAgXSk7XHJcbiAgICB9XHJcbiAgICBpZiAobm9kZS50eXBlID09PSAxMyAvKiBWTk9ERV9DQUxMICovKSB7XHJcbiAgICAgICAgbm9kZS5wcm9wcyA9IHByb3BzV2l0aEluamVjdGlvbjtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIG5vZGUuYXJndW1lbnRzWzJdID0gcHJvcHNXaXRoSW5qZWN0aW9uO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRvVmFsaWRBc3NldElkKG5hbWUsIHR5cGUpIHtcclxuICAgIHJldHVybiBgXyR7dHlwZX1fJHtuYW1lLnJlcGxhY2UoL1teXFx3XS9nLCAnXycpfWA7XHJcbn1cclxuLy8gQ2hlY2sgaWYgYSBub2RlIGNvbnRhaW5zIGV4cHJlc3Npb25zIHRoYXQgcmVmZXJlbmNlIGN1cnJlbnQgY29udGV4dCBzY29wZSBpZHNcclxuZnVuY3Rpb24gaGFzU2NvcGVSZWYobm9kZSwgaWRzKSB7XHJcbiAgICBpZiAoIW5vZGUgfHwgT2JqZWN0LmtleXMoaWRzKS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xyXG4gICAgICAgIGNhc2UgMSAvKiBFTEVNRU5UICovOlxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUucHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBub2RlLnByb3BzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHAudHlwZSA9PT0gNyAvKiBESVJFQ1RJVkUgKi8gJiZcclxuICAgICAgICAgICAgICAgICAgICAoaGFzU2NvcGVSZWYocC5hcmcsIGlkcykgfHwgaGFzU2NvcGVSZWYocC5leHAsIGlkcykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuY2hpbGRyZW4uc29tZShjID0+IGhhc1Njb3BlUmVmKGMsIGlkcykpO1xyXG4gICAgICAgIGNhc2UgMTEgLyogRk9SICovOlxyXG4gICAgICAgICAgICBpZiAoaGFzU2NvcGVSZWYobm9kZS5zb3VyY2UsIGlkcykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuLnNvbWUoYyA9PiBoYXNTY29wZVJlZihjLCBpZHMpKTtcclxuICAgICAgICBjYXNlIDkgLyogSUYgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLmJyYW5jaGVzLnNvbWUoYiA9PiBoYXNTY29wZVJlZihiLCBpZHMpKTtcclxuICAgICAgICBjYXNlIDEwIC8qIElGX0JSQU5DSCAqLzpcclxuICAgICAgICAgICAgaWYgKGhhc1Njb3BlUmVmKG5vZGUuY29uZGl0aW9uLCBpZHMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5jaGlsZHJlbi5zb21lKGMgPT4gaGFzU2NvcGVSZWYoYywgaWRzKSk7XHJcbiAgICAgICAgY2FzZSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovOlxyXG4gICAgICAgICAgICByZXR1cm4gKCFub2RlLmlzU3RhdGljICYmXHJcbiAgICAgICAgICAgICAgICBpc1NpbXBsZUlkZW50aWZpZXIobm9kZS5jb250ZW50KSAmJlxyXG4gICAgICAgICAgICAgICAgISFpZHNbbm9kZS5jb250ZW50XSk7XHJcbiAgICAgICAgY2FzZSA4IC8qIENPTVBPVU5EX0VYUFJFU1NJT04gKi86XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuLnNvbWUoYyA9PiBpc09iamVjdChjKSAmJiBoYXNTY29wZVJlZihjLCBpZHMpKTtcclxuICAgICAgICBjYXNlIDUgLyogSU5URVJQT0xBVElPTiAqLzpcclxuICAgICAgICBjYXNlIDEyIC8qIFRFWFRfQ0FMTCAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIGhhc1Njb3BlUmVmKG5vZGUuY29udGVudCwgaWRzKTtcclxuICAgICAgICBjYXNlIDIgLyogVEVYVCAqLzpcclxuICAgICAgICBjYXNlIDMgLyogQ09NTUVOVCAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIDtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IGRlcHJlY2F0aW9uRGF0YSA9IHtcclxuICAgIFtcIkNPTVBJTEVSX0lTX09OX0VMRU1FTlRcIiAvKiBDT01QSUxFUl9JU19PTl9FTEVNRU5UICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGBQbGF0Zm9ybS1uYXRpdmUgZWxlbWVudHMgd2l0aCBcImlzXCIgcHJvcCB3aWxsIG5vIGxvbmdlciBiZSBgICtcclxuICAgICAgICAgICAgYHRyZWF0ZWQgYXMgY29tcG9uZW50cyBpbiBWdWUgMyB1bmxlc3MgdGhlIFwiaXNcIiB2YWx1ZSBpcyBleHBsaWNpdGx5IGAgK1xyXG4gICAgICAgICAgICBgcHJlZml4ZWQgd2l0aCBcInZ1ZTpcIi5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vY3VzdG9tLWVsZW1lbnRzLWludGVyb3AuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJDT01QSUxFUl9WX0JJTkRfU1lOQ1wiIC8qIENPTVBJTEVSX1ZfQklORF9TWU5DICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGtleSA9PiBgLnN5bmMgbW9kaWZpZXIgZm9yIHYtYmluZCBoYXMgYmVlbiByZW1vdmVkLiBVc2Ugdi1tb2RlbCB3aXRoIGAgK1xyXG4gICAgICAgICAgICBgYXJndW1lbnQgaW5zdGVhZC4gXFxgdi1iaW5kOiR7a2V5fS5zeW5jXFxgIHNob3VsZCBiZSBjaGFuZ2VkIHRvIGAgK1xyXG4gICAgICAgICAgICBgXFxgdi1tb2RlbDoke2tleX1cXGAuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL3YtbW9kZWwuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJDT01QSUxFUl9WX0JJTkRfUFJPUFwiIC8qIENPTVBJTEVSX1ZfQklORF9QUk9QICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGAucHJvcCBtb2RpZmllciBmb3Igdi1iaW5kIGhhcyBiZWVuIHJlbW92ZWQgYW5kIG5vIGxvbmdlciBuZWNlc3NhcnkuIGAgK1xyXG4gICAgICAgICAgICBgVnVlIDMgd2lsbCBhdXRvbWF0aWNhbGx5IHNldCBhIGJpbmRpbmcgYXMgRE9NIHByb3BlcnR5IHdoZW4gYXBwcm9wcmlhdGUuYFxyXG4gICAgfSxcclxuICAgIFtcIkNPTVBJTEVSX1ZfQklORF9PQkpFQ1RfT1JERVJcIiAvKiBDT01QSUxFUl9WX0JJTkRfT0JKRUNUX09SREVSICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGB2LWJpbmQ9XCJvYmpcIiB1c2FnZSBpcyBub3cgb3JkZXIgc2Vuc2l0aXZlIGFuZCBiZWhhdmVzIGxpa2UgSmF2YVNjcmlwdCBgICtcclxuICAgICAgICAgICAgYG9iamVjdCBzcHJlYWQ6IGl0IHdpbGwgbm93IG92ZXJ3cml0ZSBhbiBleGlzdGluZyBub24tbWVyZ2VhYmxlIGF0dHJpYnV0ZSBgICtcclxuICAgICAgICAgICAgYHRoYXQgYXBwZWFycyBiZWZvcmUgdi1iaW5kIGluIHRoZSBjYXNlIG9mIGNvbmZsaWN0LiBgICtcclxuICAgICAgICAgICAgYFRvIHJldGFpbiAyLnggYmVoYXZpb3IsIG1vdmUgdi1iaW5kIHRvIG1ha2UgaXQgdGhlIGZpcnN0IGF0dHJpYnV0ZS4gYCArXHJcbiAgICAgICAgICAgIGBZb3UgY2FuIGFsc28gc3VwcHJlc3MgdGhpcyB3YXJuaW5nIGlmIHRoZSB1c2FnZSBpcyBpbnRlbmRlZC5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vdi1iaW5kLmh0bWxgXHJcbiAgICB9LFxyXG4gICAgW1wiQ09NUElMRVJfVl9PTl9OQVRJVkVcIiAvKiBDT01QSUxFUl9WX09OX05BVElWRSAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgLm5hdGl2ZSBtb2RpZmllciBmb3Igdi1vbiBoYXMgYmVlbiByZW1vdmVkIGFzIGlzIG5vIGxvbmdlciBuZWNlc3NhcnkuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL3Ytb24tbmF0aXZlLW1vZGlmaWVyLXJlbW92ZWQuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJDT01QSUxFUl9WX0lGX1ZfRk9SX1BSRUNFREVOQ0VcIiAvKiBDT01QSUxFUl9WX0lGX1ZfRk9SX1BSRUNFREVOQ0UgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYHYtaWYgLyB2LWZvciBwcmVjZWRlbmNlIHdoZW4gdXNlZCBvbiB0aGUgc2FtZSBlbGVtZW50IGhhcyBjaGFuZ2VkIGAgK1xyXG4gICAgICAgICAgICBgaW4gVnVlIDM6IHYtaWYgbm93IHRha2VzIGhpZ2hlciBwcmVjZWRlbmNlIGFuZCB3aWxsIG5vIGxvbmdlciBoYXZlIGAgK1xyXG4gICAgICAgICAgICBgYWNjZXNzIHRvIHYtZm9yIHNjb3BlIHZhcmlhYmxlcy4gSXQgaXMgYmVzdCB0byBhdm9pZCB0aGUgYW1iaWd1aXR5IGAgK1xyXG4gICAgICAgICAgICBgd2l0aCA8dGVtcGxhdGU+IHRhZ3Mgb3IgdXNlIGEgY29tcHV0ZWQgcHJvcGVydHkgdGhhdCBmaWx0ZXJzIHYtZm9yIGAgK1xyXG4gICAgICAgICAgICBgZGF0YSBzb3VyY2UuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL3YtaWYtdi1mb3IuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJDT01QSUxFUl9WX0ZPUl9SRUZcIiAvKiBDT01QSUxFUl9WX0ZPUl9SRUYgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYFJlZiB1c2FnZSBvbiB2LWZvciBubyBsb25nZXIgY3JlYXRlcyBhcnJheSByZWYgdmFsdWVzIGluIFZ1ZSAzLiBgICtcclxuICAgICAgICAgICAgYENvbnNpZGVyIHVzaW5nIGZ1bmN0aW9uIHJlZnMgb3IgcmVmYWN0b3IgdG8gYXZvaWQgcmVmIHVzYWdlIGFsdG9nZXRoZXIuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL2FycmF5LXJlZnMuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJDT01QSUxFUl9OQVRJVkVfVEVNUExBVEVcIiAvKiBDT01QSUxFUl9OQVRJVkVfVEVNUExBVEUgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYDx0ZW1wbGF0ZT4gd2l0aCBubyBzcGVjaWFsIGRpcmVjdGl2ZXMgd2lsbCByZW5kZXIgYXMgYSBuYXRpdmUgdGVtcGxhdGUgYCArXHJcbiAgICAgICAgICAgIGBlbGVtZW50IGluc3RlYWQgb2YgaXRzIGlubmVyIGNvbnRlbnQgaW4gVnVlIDMuYFxyXG4gICAgfSxcclxuICAgIFtcIkNPTVBJTEVSX0lOTElORV9URU1QTEFURVwiIC8qIENPTVBJTEVSX0lOTElORV9URU1QTEFURSAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgXCJpbmxpbmUtdGVtcGxhdGVcIiBoYXMgYmVlbiByZW1vdmVkIGluIFZ1ZSAzLmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMudnVlanMub3JnL2d1aWRlL21pZ3JhdGlvbi9pbmxpbmUtdGVtcGxhdGUtYXR0cmlidXRlLmh0bWxgXHJcbiAgICB9LFxyXG4gICAgW1wiQ09NUElMRVJfRklMVEVSXCIgLyogQ09NUElMRVJfRklMVEVSUyAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgZmlsdGVycyBoYXZlIGJlZW4gcmVtb3ZlZCBpbiBWdWUgMy4gYCArXHJcbiAgICAgICAgICAgIGBUaGUgXCJ8XCIgc3ltYm9sIHdpbGwgYmUgdHJlYXRlZCBhcyBuYXRpdmUgSmF2YVNjcmlwdCBiaXR3aXNlIE9SIG9wZXJhdG9yLiBgICtcclxuICAgICAgICAgICAgYFVzZSBtZXRob2QgY2FsbHMgb3IgY29tcHV0ZWQgcHJvcGVydGllcyBpbnN0ZWFkLmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMudnVlanMub3JnL2d1aWRlL21pZ3JhdGlvbi9maWx0ZXJzLmh0bWxgXHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIGdldENvbXBhdFZhbHVlKGtleSwgY29udGV4dCkge1xyXG4gICAgY29uc3QgY29uZmlnID0gY29udGV4dC5vcHRpb25zXHJcbiAgICAgICAgPyBjb250ZXh0Lm9wdGlvbnMuY29tcGF0Q29uZmlnXHJcbiAgICAgICAgOiBjb250ZXh0LmNvbXBhdENvbmZpZztcclxuICAgIGNvbnN0IHZhbHVlID0gY29uZmlnICYmIGNvbmZpZ1trZXldO1xyXG4gICAgaWYgKGtleSA9PT0gJ01PREUnKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlIHx8IDM7IC8vIGNvbXBpbGVyIGRlZmF1bHRzIHRvIHYzIGJlaGF2aW9yXHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaXNDb21wYXRFbmFibGVkKGtleSwgY29udGV4dCkge1xyXG4gICAgY29uc3QgbW9kZSA9IGdldENvbXBhdFZhbHVlKCdNT0RFJywgY29udGV4dCk7XHJcbiAgICBjb25zdCB2YWx1ZSA9IGdldENvbXBhdFZhbHVlKGtleSwgY29udGV4dCk7XHJcbiAgICAvLyBpbiB2MyBtb2RlLCBvbmx5IGVuYWJsZSBpZiBleHBsaWNpdGx5IHNldCB0byB0cnVlXHJcbiAgICAvLyBvdGhlcndpc2UgZW5hYmxlIGZvciBhbnkgbm9uLWZhbHNlIHZhbHVlXHJcbiAgICByZXR1cm4gbW9kZSA9PT0gMyA/IHZhbHVlID09PSB0cnVlIDogdmFsdWUgIT09IGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIGNoZWNrQ29tcGF0RW5hYmxlZChrZXksIGNvbnRleHQsIGxvYywgLi4uYXJncykge1xyXG4gICAgY29uc3QgZW5hYmxlZCA9IGlzQ29tcGF0RW5hYmxlZChrZXksIGNvbnRleHQpO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBlbmFibGVkKSB7XHJcbiAgICAgICAgd2FybkRlcHJlY2F0aW9uKGtleSwgY29udGV4dCwgbG9jLCAuLi5hcmdzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBlbmFibGVkO1xyXG59XHJcbmZ1bmN0aW9uIHdhcm5EZXByZWNhdGlvbihrZXksIGNvbnRleHQsIGxvYywgLi4uYXJncykge1xyXG4gICAgY29uc3QgdmFsID0gZ2V0Q29tcGF0VmFsdWUoa2V5LCBjb250ZXh0KTtcclxuICAgIGlmICh2YWwgPT09ICdzdXBwcmVzcy13YXJuaW5nJykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgbWVzc2FnZSwgbGluayB9ID0gZGVwcmVjYXRpb25EYXRhW2tleV07XHJcbiAgICBjb25zdCBtc2cgPSBgKGRlcHJlY2F0aW9uICR7a2V5fSkgJHt0eXBlb2YgbWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJyA/IG1lc3NhZ2UoLi4uYXJncykgOiBtZXNzYWdlfSR7bGluayA/IGBcXG4gIERldGFpbHM6ICR7bGlua31gIDogYGB9YDtcclxuICAgIGNvbnN0IGVyciA9IG5ldyBTeW50YXhFcnJvcihtc2cpO1xyXG4gICAgZXJyLmNvZGUgPSBrZXk7XHJcbiAgICBpZiAobG9jKVxyXG4gICAgICAgIGVyci5sb2MgPSBsb2M7XHJcbiAgICBjb250ZXh0Lm9uV2FybihlcnIpO1xyXG59XG5cbi8vIFRoZSBkZWZhdWx0IGRlY29kZXIgb25seSBwcm92aWRlcyBlc2NhcGVzIGZvciBjaGFyYWN0ZXJzIHJlc2VydmVkIGFzIHBhcnQgb2ZcclxuLy8gdGhlIHRlbXBsYXRlIHN5bnRheCwgYW5kIGlzIG9ubHkgdXNlZCBpZiB0aGUgY3VzdG9tIHJlbmRlcmVyIGRpZCBub3QgcHJvdmlkZVxyXG4vLyBhIHBsYXRmb3JtLXNwZWNpZmljIGRlY29kZXIuXHJcbmNvbnN0IGRlY29kZVJFID0gLyYoZ3R8bHR8YW1wfGFwb3N8cXVvdCk7L2c7XHJcbmNvbnN0IGRlY29kZU1hcCA9IHtcclxuICAgIGd0OiAnPicsXHJcbiAgICBsdDogJzwnLFxyXG4gICAgYW1wOiAnJicsXHJcbiAgICBhcG9zOiBcIidcIixcclxuICAgIHF1b3Q6ICdcIidcclxufTtcclxuY29uc3QgZGVmYXVsdFBhcnNlck9wdGlvbnMgPSB7XHJcbiAgICBkZWxpbWl0ZXJzOiBbYHt7YCwgYH19YF0sXHJcbiAgICBnZXROYW1lc3BhY2U6ICgpID0+IDAgLyogSFRNTCAqLyxcclxuICAgIGdldFRleHRNb2RlOiAoKSA9PiAwIC8qIERBVEEgKi8sXHJcbiAgICBpc1ZvaWRUYWc6IE5PLFxyXG4gICAgaXNQcmVUYWc6IE5PLFxyXG4gICAgaXNDdXN0b21FbGVtZW50OiBOTyxcclxuICAgIGRlY29kZUVudGl0aWVzOiAocmF3VGV4dCkgPT4gcmF3VGV4dC5yZXBsYWNlKGRlY29kZVJFLCAoXywgcDEpID0+IGRlY29kZU1hcFtwMV0pLFxyXG4gICAgb25FcnJvcjogZGVmYXVsdE9uRXJyb3IsXHJcbiAgICBvbldhcm46IGRlZmF1bHRPbldhcm4sXHJcbiAgICBjb21tZW50czogZmFsc2VcclxufTtcclxuZnVuY3Rpb24gYmFzZVBhcnNlKGNvbnRlbnQsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZVBhcnNlckNvbnRleHQoY29udGVudCwgb3B0aW9ucyk7XHJcbiAgICBjb25zdCBzdGFydCA9IGdldEN1cnNvcihjb250ZXh0KTtcclxuICAgIHJldHVybiBjcmVhdGVSb290KHBhcnNlQ2hpbGRyZW4oY29udGV4dCwgMCAvKiBEQVRBICovLCBbXSksIGdldFNlbGVjdGlvbihjb250ZXh0LCBzdGFydCkpO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVBhcnNlckNvbnRleHQoY29udGVudCwgcmF3T3B0aW9ucykge1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IGV4dGVuZCh7fSwgZGVmYXVsdFBhcnNlck9wdGlvbnMpO1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gcmF3T3B0aW9ucykge1xyXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICBvcHRpb25zW2tleV0gPSByYXdPcHRpb25zW2tleV0gfHwgZGVmYXVsdFBhcnNlck9wdGlvbnNba2V5XTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgb3B0aW9ucyxcclxuICAgICAgICBjb2x1bW46IDEsXHJcbiAgICAgICAgbGluZTogMSxcclxuICAgICAgICBvZmZzZXQ6IDAsXHJcbiAgICAgICAgb3JpZ2luYWxTb3VyY2U6IGNvbnRlbnQsXHJcbiAgICAgICAgc291cmNlOiBjb250ZW50LFxyXG4gICAgICAgIGluUHJlOiBmYWxzZSxcclxuICAgICAgICBpblZQcmU6IGZhbHNlLFxyXG4gICAgICAgIG9uV2Fybjogb3B0aW9ucy5vbldhcm5cclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VDaGlsZHJlbihjb250ZXh0LCBtb2RlLCBhbmNlc3RvcnMpIHtcclxuICAgIGNvbnN0IHBhcmVudCA9IGxhc3QoYW5jZXN0b3JzKTtcclxuICAgIGNvbnN0IG5zID0gcGFyZW50ID8gcGFyZW50Lm5zIDogMCAvKiBIVE1MICovO1xyXG4gICAgY29uc3Qgbm9kZXMgPSBbXTtcclxuICAgIHdoaWxlICghaXNFbmQoY29udGV4dCwgbW9kZSwgYW5jZXN0b3JzKSkge1xyXG4gICAgICAgIGNvbnN0IHMgPSBjb250ZXh0LnNvdXJjZTtcclxuICAgICAgICBsZXQgbm9kZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAobW9kZSA9PT0gMCAvKiBEQVRBICovIHx8IG1vZGUgPT09IDEgLyogUkNEQVRBICovKSB7XHJcbiAgICAgICAgICAgIGlmICghY29udGV4dC5pblZQcmUgJiYgc3RhcnRzV2l0aChzLCBjb250ZXh0Lm9wdGlvbnMuZGVsaW1pdGVyc1swXSkpIHtcclxuICAgICAgICAgICAgICAgIC8vICd7eydcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJzZUludGVycG9sYXRpb24oY29udGV4dCwgbW9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobW9kZSA9PT0gMCAvKiBEQVRBICovICYmIHNbMF0gPT09ICc8Jykge1xyXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvcGFyc2luZy5odG1sI3RhZy1vcGVuLXN0YXRlXHJcbiAgICAgICAgICAgICAgICBpZiAocy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgNSAvKiBFT0ZfQkVGT1JFX1RBR19OQU1FICovLCAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNbMV0gPT09ICchJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3BhcnNpbmcuaHRtbCNtYXJrdXAtZGVjbGFyYXRpb24tb3Blbi1zdGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydHNXaXRoKHMsICc8IS0tJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHBhcnNlQ29tbWVudChjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnRzV2l0aChzLCAnPCFET0NUWVBFJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIERPQ1RZUEUgYnkgYSBsaW1pdGF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gcGFyc2VCb2d1c0NvbW1lbnQoY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJ0c1dpdGgocywgJzwhW0NEQVRBWycpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChucyAhPT0gMCAvKiBIVE1MICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gcGFyc2VDREFUQShjb250ZXh0LCBhbmNlc3RvcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDEgLyogQ0RBVEFfSU5fSFRNTF9DT05URU5UICovKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJzZUJvZ3VzQ29tbWVudChjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDExIC8qIElOQ09SUkVDVExZX09QRU5FRF9DT01NRU5UICovKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHBhcnNlQm9ndXNDb21tZW50KGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNbMV0gPT09ICcvJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3BhcnNpbmcuaHRtbCNlbmQtdGFnLW9wZW4tc3RhdGVcclxuICAgICAgICAgICAgICAgICAgICBpZiAocy5sZW5ndGggPT09IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDUgLyogRU9GX0JFRk9SRV9UQUdfTkFNRSAqLywgMik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNbMl0gPT09ICc+Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMTQgLyogTUlTU0lOR19FTkRfVEFHX05BTUUgKi8sIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgMyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgvW2Etel0vaS50ZXN0KHNbMl0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAyMyAvKiBYX0lOVkFMSURfRU5EX1RBRyAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlVGFnKGNvbnRleHQsIDEgLyogRW5kICovLCBwYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxMiAvKiBJTlZBTElEX0ZJUlNUX0NIQVJBQ1RFUl9PRl9UQUdfTkFNRSAqLywgMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJzZUJvZ3VzQ29tbWVudChjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgvW2Etel0vaS50ZXN0KHNbMV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHBhcnNlRWxlbWVudChjb250ZXh0LCBhbmNlc3RvcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIDIueCA8dGVtcGxhdGU+IHdpdGggbm8gZGlyZWN0aXZlIGNvbXBhdFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9OQVRJVkVfVEVNUExBVEVcIiAvKiBDT01QSUxFUl9OQVRJVkVfVEVNUExBVEUgKi8sIGNvbnRleHQpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS50YWcgPT09ICd0ZW1wbGF0ZScgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgIW5vZGUucHJvcHMuc29tZShwID0+IHAudHlwZSA9PT0gNyAvKiBESVJFQ1RJVkUgKi8gJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzU3BlY2lhbFRlbXBsYXRlRGlyZWN0aXZlKHAubmFtZSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybkRlcHJlY2F0aW9uKFwiQ09NUElMRVJfTkFUSVZFX1RFTVBMQVRFXCIgLyogQ09NUElMRVJfTkFUSVZFX1RFTVBMQVRFICovLCBjb250ZXh0LCBub2RlLmxvYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNbMV0gPT09ICc/Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAyMSAvKiBVTkVYUEVDVEVEX1FVRVNUSU9OX01BUktfSU5TVEVBRF9PRl9UQUdfTkFNRSAqLywgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHBhcnNlQm9ndXNDb21tZW50KGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDEyIC8qIElOVkFMSURfRklSU1RfQ0hBUkFDVEVSX09GX1RBR19OQU1FICovLCAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgICAgICAgbm9kZSA9IHBhcnNlVGV4dChjb250ZXh0LCBtb2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzQXJyYXkobm9kZSkpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBwdXNoTm9kZShub2Rlcywgbm9kZVtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHB1c2hOb2RlKG5vZGVzLCBub2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBXaGl0ZXNwYWNlIGhhbmRsaW5nIHN0cmF0ZWd5IGxpa2UgdjJcclxuICAgIGxldCByZW1vdmVkV2hpdGVzcGFjZSA9IGZhbHNlO1xyXG4gICAgaWYgKG1vZGUgIT09IDIgLyogUkFXVEVYVCAqLyAmJiBtb2RlICE9PSAxIC8qIFJDREFUQSAqLykge1xyXG4gICAgICAgIGNvbnN0IHByZXNlcnZlID0gY29udGV4dC5vcHRpb25zLndoaXRlc3BhY2UgPT09ICdwcmVzZXJ2ZSc7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XHJcbiAgICAgICAgICAgIGlmICghY29udGV4dC5pblByZSAmJiBub2RlLnR5cGUgPT09IDIgLyogVEVYVCAqLykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCEvW15cXHRcXHJcXG5cXGYgXS8udGVzdChub2RlLmNvbnRlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IG5vZGVzW2kgLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gbm9kZXNbaSArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBpZjpcclxuICAgICAgICAgICAgICAgICAgICAvLyAtIHRoZSB3aGl0ZXNwYWNlIGlzIHRoZSBmaXJzdCBvciBsYXN0IG5vZGUsIG9yOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIC0gKGNvbmRlbnNlIG1vZGUpIHRoZSB3aGl0ZXNwYWNlIGlzIGFkamFjZW50IHRvIGEgY29tbWVudCwgb3I6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gLSAoY29uZGVuc2UgbW9kZSkgdGhlIHdoaXRlc3BhY2UgaXMgYmV0d2VlbiB0d28gZWxlbWVudHMgQU5EIGNvbnRhaW5zIG5ld2xpbmVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXByZXYgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgIW5leHQgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKCFwcmVzZXJ2ZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHByZXYudHlwZSA9PT0gMyAvKiBDT01NRU5UICovIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC50eXBlID09PSAzIC8qIENPTU1FTlQgKi8gfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocHJldi50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgL1tcXHJcXG5dLy50ZXN0KG5vZGUuY29udGVudCkpKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZFdoaXRlc3BhY2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlc1tpXSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIHRoZSB3aGl0ZXNwYWNlIGlzIGNvbmRlbnNlZCBpbnRvIGEgc2luZ2xlIHNwYWNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuY29udGVudCA9ICcgJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghcHJlc2VydmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpbiBjb25kZW5zZSBtb2RlLCBjb25zZWN1dGl2ZSB3aGl0ZXNwYWNlcyBpbiB0ZXh0IGFyZSBjb25kZW5zZWRcclxuICAgICAgICAgICAgICAgICAgICAvLyBkb3duIHRvIGEgc2luZ2xlIHNwYWNlLlxyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuY29udGVudCA9IG5vZGUuY29udGVudC5yZXBsYWNlKC9bXFx0XFxyXFxuXFxmIF0rL2csICcgJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gYWxzbyByZW1vdmUgY29tbWVudCBub2RlcyBpbiBwcm9kIGJ5IGRlZmF1bHRcclxuICAgICAgICAgICAgaWYgKCEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgIG5vZGUudHlwZSA9PT0gMyAvKiBDT01NRU5UICovICYmXHJcbiAgICAgICAgICAgICAgICAhY29udGV4dC5vcHRpb25zLmNvbW1lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVkV2hpdGVzcGFjZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBub2Rlc1tpXSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbnRleHQuaW5QcmUgJiYgcGFyZW50ICYmIGNvbnRleHQub3B0aW9ucy5pc1ByZVRhZyhwYXJlbnQudGFnKSkge1xyXG4gICAgICAgICAgICAvLyByZW1vdmUgbGVhZGluZyBuZXdsaW5lIHBlciBodG1sIHNwZWNcclxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZ3JvdXBpbmctY29udGVudC5odG1sI3RoZS1wcmUtZWxlbWVudFxyXG4gICAgICAgICAgICBjb25zdCBmaXJzdCA9IG5vZGVzWzBdO1xyXG4gICAgICAgICAgICBpZiAoZmlyc3QgJiYgZmlyc3QudHlwZSA9PT0gMiAvKiBURVhUICovKSB7XHJcbiAgICAgICAgICAgICAgICBmaXJzdC5jb250ZW50ID0gZmlyc3QuY29udGVudC5yZXBsYWNlKC9eXFxyP1xcbi8sICcnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZW1vdmVkV2hpdGVzcGFjZSA/IG5vZGVzLmZpbHRlcihCb29sZWFuKSA6IG5vZGVzO1xyXG59XHJcbmZ1bmN0aW9uIHB1c2hOb2RlKG5vZGVzLCBub2RlKSB7XHJcbiAgICBpZiAobm9kZS50eXBlID09PSAyIC8qIFRFWFQgKi8pIHtcclxuICAgICAgICBjb25zdCBwcmV2ID0gbGFzdChub2Rlcyk7XHJcbiAgICAgICAgLy8gTWVyZ2UgaWYgYm90aCB0aGlzIGFuZCB0aGUgcHJldmlvdXMgbm9kZSBhcmUgdGV4dCBhbmQgdGhvc2UgYXJlXHJcbiAgICAgICAgLy8gY29uc2VjdXRpdmUuIFRoaXMgaGFwcGVucyBmb3IgY2FzZXMgbGlrZSBcImEgPCBiXCIuXHJcbiAgICAgICAgaWYgKHByZXYgJiZcclxuICAgICAgICAgICAgcHJldi50eXBlID09PSAyIC8qIFRFWFQgKi8gJiZcclxuICAgICAgICAgICAgcHJldi5sb2MuZW5kLm9mZnNldCA9PT0gbm9kZS5sb2Muc3RhcnQub2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHByZXYuY29udGVudCArPSBub2RlLmNvbnRlbnQ7XHJcbiAgICAgICAgICAgIHByZXYubG9jLmVuZCA9IG5vZGUubG9jLmVuZDtcclxuICAgICAgICAgICAgcHJldi5sb2Muc291cmNlICs9IG5vZGUubG9jLnNvdXJjZTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG5vZGVzLnB1c2gobm9kZSk7XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VDREFUQShjb250ZXh0LCBhbmNlc3RvcnMpIHtcclxuICAgIGFkdmFuY2VCeShjb250ZXh0LCA5KTtcclxuICAgIGNvbnN0IG5vZGVzID0gcGFyc2VDaGlsZHJlbihjb250ZXh0LCAzIC8qIENEQVRBICovLCBhbmNlc3RvcnMpO1xyXG4gICAgaWYgKGNvbnRleHQuc291cmNlLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCA2IC8qIEVPRl9JTl9DREFUQSAqLyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgMyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbm9kZXM7XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VDb21tZW50KGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Q3Vyc29yKGNvbnRleHQpO1xyXG4gICAgbGV0IGNvbnRlbnQ7XHJcbiAgICAvLyBSZWd1bGFyIGNvbW1lbnQuXHJcbiAgICBjb25zdCBtYXRjaCA9IC8tLShcXCEpPz4vLmV4ZWMoY29udGV4dC5zb3VyY2UpO1xyXG4gICAgaWYgKCFtYXRjaCkge1xyXG4gICAgICAgIGNvbnRlbnQgPSBjb250ZXh0LnNvdXJjZS5zbGljZSg0KTtcclxuICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgY29udGV4dC5zb3VyY2UubGVuZ3RoKTtcclxuICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgNyAvKiBFT0ZfSU5fQ09NTUVOVCAqLyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAobWF0Y2guaW5kZXggPD0gMykge1xyXG4gICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMCAvKiBBQlJVUFRfQ0xPU0lOR19PRl9FTVBUWV9DT01NRU5UICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1hdGNoWzFdKSB7XHJcbiAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxMCAvKiBJTkNPUlJFQ1RMWV9DTE9TRURfQ09NTUVOVCAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnRlbnQgPSBjb250ZXh0LnNvdXJjZS5zbGljZSg0LCBtYXRjaC5pbmRleCk7XHJcbiAgICAgICAgLy8gQWR2YW5jaW5nIHdpdGggcmVwb3J0aW5nIG5lc3RlZCBjb21tZW50cy5cclxuICAgICAgICBjb25zdCBzID0gY29udGV4dC5zb3VyY2Uuc2xpY2UoMCwgbWF0Y2guaW5kZXgpO1xyXG4gICAgICAgIGxldCBwcmV2SW5kZXggPSAxLCBuZXN0ZWRJbmRleCA9IDA7XHJcbiAgICAgICAgd2hpbGUgKChuZXN0ZWRJbmRleCA9IHMuaW5kZXhPZignPCEtLScsIHByZXZJbmRleCkpICE9PSAtMSkge1xyXG4gICAgICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgbmVzdGVkSW5kZXggLSBwcmV2SW5kZXggKyAxKTtcclxuICAgICAgICAgICAgaWYgKG5lc3RlZEluZGV4ICsgNCA8IHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMTYgLyogTkVTVEVEX0NPTU1FTlQgKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHByZXZJbmRleCA9IG5lc3RlZEluZGV4ICsgMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoIC0gcHJldkluZGV4ICsgMSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDMgLyogQ09NTUVOVCAqLyxcclxuICAgICAgICBjb250ZW50LFxyXG4gICAgICAgIGxvYzogZ2V0U2VsZWN0aW9uKGNvbnRleHQsIHN0YXJ0KVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZUJvZ3VzQ29tbWVudChjb250ZXh0KSB7XHJcbiAgICBjb25zdCBzdGFydCA9IGdldEN1cnNvcihjb250ZXh0KTtcclxuICAgIGNvbnN0IGNvbnRlbnRTdGFydCA9IGNvbnRleHQuc291cmNlWzFdID09PSAnPycgPyAxIDogMjtcclxuICAgIGxldCBjb250ZW50O1xyXG4gICAgY29uc3QgY2xvc2VJbmRleCA9IGNvbnRleHQuc291cmNlLmluZGV4T2YoJz4nKTtcclxuICAgIGlmIChjbG9zZUluZGV4ID09PSAtMSkge1xyXG4gICAgICAgIGNvbnRlbnQgPSBjb250ZXh0LnNvdXJjZS5zbGljZShjb250ZW50U3RhcnQpO1xyXG4gICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCBjb250ZXh0LnNvdXJjZS5sZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29udGVudCA9IGNvbnRleHQuc291cmNlLnNsaWNlKGNvbnRlbnRTdGFydCwgY2xvc2VJbmRleCk7XHJcbiAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIGNsb3NlSW5kZXggKyAxKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMyAvKiBDT01NRU5UICovLFxyXG4gICAgICAgIGNvbnRlbnQsXHJcbiAgICAgICAgbG9jOiBnZXRTZWxlY3Rpb24oY29udGV4dCwgc3RhcnQpXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlRWxlbWVudChjb250ZXh0LCBhbmNlc3RvcnMpIHtcclxuICAgIC8vIFN0YXJ0IHRhZy5cclxuICAgIGNvbnN0IHdhc0luUHJlID0gY29udGV4dC5pblByZTtcclxuICAgIGNvbnN0IHdhc0luVlByZSA9IGNvbnRleHQuaW5WUHJlO1xyXG4gICAgY29uc3QgcGFyZW50ID0gbGFzdChhbmNlc3RvcnMpO1xyXG4gICAgY29uc3QgZWxlbWVudCA9IHBhcnNlVGFnKGNvbnRleHQsIDAgLyogU3RhcnQgKi8sIHBhcmVudCk7XHJcbiAgICBjb25zdCBpc1ByZUJvdW5kYXJ5ID0gY29udGV4dC5pblByZSAmJiAhd2FzSW5QcmU7XHJcbiAgICBjb25zdCBpc1ZQcmVCb3VuZGFyeSA9IGNvbnRleHQuaW5WUHJlICYmICF3YXNJblZQcmU7XHJcbiAgICBpZiAoZWxlbWVudC5pc1NlbGZDbG9zaW5nIHx8IGNvbnRleHQub3B0aW9ucy5pc1ZvaWRUYWcoZWxlbWVudC50YWcpKSB7XHJcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XHJcbiAgICB9XHJcbiAgICAvLyBDaGlsZHJlbi5cclxuICAgIGFuY2VzdG9ycy5wdXNoKGVsZW1lbnQpO1xyXG4gICAgY29uc3QgbW9kZSA9IGNvbnRleHQub3B0aW9ucy5nZXRUZXh0TW9kZShlbGVtZW50LCBwYXJlbnQpO1xyXG4gICAgY29uc3QgY2hpbGRyZW4gPSBwYXJzZUNoaWxkcmVuKGNvbnRleHQsIG1vZGUsIGFuY2VzdG9ycyk7XHJcbiAgICBhbmNlc3RvcnMucG9wKCk7XHJcbiAgICAvLyAyLnggaW5saW5lLXRlbXBsYXRlIGNvbXBhdFxyXG4gICAge1xyXG4gICAgICAgIGNvbnN0IGlubGluZVRlbXBsYXRlUHJvcCA9IGVsZW1lbnQucHJvcHMuZmluZChwID0+IHAudHlwZSA9PT0gNiAvKiBBVFRSSUJVVEUgKi8gJiYgcC5uYW1lID09PSAnaW5saW5lLXRlbXBsYXRlJyk7XHJcbiAgICAgICAgaWYgKGlubGluZVRlbXBsYXRlUHJvcCAmJlxyXG4gICAgICAgICAgICBjaGVja0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9JTkxJTkVfVEVNUExBVEVcIiAvKiBDT01QSUxFUl9JTkxJTkVfVEVNUExBVEUgKi8sIGNvbnRleHQsIGlubGluZVRlbXBsYXRlUHJvcC5sb2MpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxvYyA9IGdldFNlbGVjdGlvbihjb250ZXh0LCBlbGVtZW50LmxvYy5lbmQpO1xyXG4gICAgICAgICAgICBpbmxpbmVUZW1wbGF0ZVByb3AudmFsdWUgPSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAyIC8qIFRFWFQgKi8sXHJcbiAgICAgICAgICAgICAgICBjb250ZW50OiBsb2Muc291cmNlLFxyXG4gICAgICAgICAgICAgICAgbG9jXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxlbWVudC5jaGlsZHJlbiA9IGNoaWxkcmVuO1xyXG4gICAgLy8gRW5kIHRhZy5cclxuICAgIGlmIChzdGFydHNXaXRoRW5kVGFnT3Blbihjb250ZXh0LnNvdXJjZSwgZWxlbWVudC50YWcpKSB7XHJcbiAgICAgICAgcGFyc2VUYWcoY29udGV4dCwgMSAvKiBFbmQgKi8sIHBhcmVudCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMjQgLyogWF9NSVNTSU5HX0VORF9UQUcgKi8sIDAsIGVsZW1lbnQubG9jLnN0YXJ0KTtcclxuICAgICAgICBpZiAoY29udGV4dC5zb3VyY2UubGVuZ3RoID09PSAwICYmIGVsZW1lbnQudGFnLnRvTG93ZXJDYXNlKCkgPT09ICdzY3JpcHQnKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0ID0gY2hpbGRyZW5bMF07XHJcbiAgICAgICAgICAgIGlmIChmaXJzdCAmJiBzdGFydHNXaXRoKGZpcnN0LmxvYy5zb3VyY2UsICc8IS0tJykpIHtcclxuICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCA4IC8qIEVPRl9JTl9TQ1JJUFRfSFRNTF9DT01NRU5UX0xJS0VfVEVYVCAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbGVtZW50LmxvYyA9IGdldFNlbGVjdGlvbihjb250ZXh0LCBlbGVtZW50LmxvYy5zdGFydCk7XHJcbiAgICBpZiAoaXNQcmVCb3VuZGFyeSkge1xyXG4gICAgICAgIGNvbnRleHQuaW5QcmUgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChpc1ZQcmVCb3VuZGFyeSkge1xyXG4gICAgICAgIGNvbnRleHQuaW5WUHJlID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZWxlbWVudDtcclxufVxyXG5jb25zdCBpc1NwZWNpYWxUZW1wbGF0ZURpcmVjdGl2ZSA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChgaWYsZWxzZSxlbHNlLWlmLGZvcixzbG90YCk7XHJcbmZ1bmN0aW9uIHBhcnNlVGFnKGNvbnRleHQsIHR5cGUsIHBhcmVudCkge1xyXG4gICAgLy8gVGFnIG9wZW4uXHJcbiAgICBjb25zdCBzdGFydCA9IGdldEN1cnNvcihjb250ZXh0KTtcclxuICAgIGNvbnN0IG1hdGNoID0gL148XFwvPyhbYS16XVteXFx0XFxyXFxuXFxmIC8+XSopL2kuZXhlYyhjb250ZXh0LnNvdXJjZSk7XHJcbiAgICBjb25zdCB0YWcgPSBtYXRjaFsxXTtcclxuICAgIGNvbnN0IG5zID0gY29udGV4dC5vcHRpb25zLmdldE5hbWVzcGFjZSh0YWcsIHBhcmVudCk7XHJcbiAgICBhZHZhbmNlQnkoY29udGV4dCwgbWF0Y2hbMF0ubGVuZ3RoKTtcclxuICAgIGFkdmFuY2VTcGFjZXMoY29udGV4dCk7XHJcbiAgICAvLyBzYXZlIGN1cnJlbnQgc3RhdGUgaW4gY2FzZSB3ZSBuZWVkIHRvIHJlLXBhcnNlIGF0dHJpYnV0ZXMgd2l0aCB2LXByZVxyXG4gICAgY29uc3QgY3Vyc29yID0gZ2V0Q3Vyc29yKGNvbnRleHQpO1xyXG4gICAgY29uc3QgY3VycmVudFNvdXJjZSA9IGNvbnRleHQuc291cmNlO1xyXG4gICAgLy8gQXR0cmlidXRlcy5cclxuICAgIGxldCBwcm9wcyA9IHBhcnNlQXR0cmlidXRlcyhjb250ZXh0LCB0eXBlKTtcclxuICAgIC8vIGNoZWNrIDxwcmU+IHRhZ1xyXG4gICAgaWYgKGNvbnRleHQub3B0aW9ucy5pc1ByZVRhZyh0YWcpKSB7XHJcbiAgICAgICAgY29udGV4dC5pblByZSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICAvLyBjaGVjayB2LXByZVxyXG4gICAgaWYgKHR5cGUgPT09IDAgLyogU3RhcnQgKi8gJiZcclxuICAgICAgICAhY29udGV4dC5pblZQcmUgJiZcclxuICAgICAgICBwcm9wcy5zb21lKHAgPT4gcC50eXBlID09PSA3IC8qIERJUkVDVElWRSAqLyAmJiBwLm5hbWUgPT09ICdwcmUnKSkge1xyXG4gICAgICAgIGNvbnRleHQuaW5WUHJlID0gdHJ1ZTtcclxuICAgICAgICAvLyByZXNldCBjb250ZXh0XHJcbiAgICAgICAgZXh0ZW5kKGNvbnRleHQsIGN1cnNvcik7XHJcbiAgICAgICAgY29udGV4dC5zb3VyY2UgPSBjdXJyZW50U291cmNlO1xyXG4gICAgICAgIC8vIHJlLXBhcnNlIGF0dHJzIGFuZCBmaWx0ZXIgb3V0IHYtcHJlIGl0c2VsZlxyXG4gICAgICAgIHByb3BzID0gcGFyc2VBdHRyaWJ1dGVzKGNvbnRleHQsIHR5cGUpLmZpbHRlcihwID0+IHAubmFtZSAhPT0gJ3YtcHJlJyk7XHJcbiAgICB9XHJcbiAgICAvLyBUYWcgY2xvc2UuXHJcbiAgICBsZXQgaXNTZWxmQ2xvc2luZyA9IGZhbHNlO1xyXG4gICAgaWYgKGNvbnRleHQuc291cmNlLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCA5IC8qIEVPRl9JTl9UQUcgKi8pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaXNTZWxmQ2xvc2luZyA9IHN0YXJ0c1dpdGgoY29udGV4dC5zb3VyY2UsICcvPicpO1xyXG4gICAgICAgIGlmICh0eXBlID09PSAxIC8qIEVuZCAqLyAmJiBpc1NlbGZDbG9zaW5nKSB7XHJcbiAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCA0IC8qIEVORF9UQUdfV0lUSF9UUkFJTElOR19TT0xJRFVTICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIGlzU2VsZkNsb3NpbmcgPyAyIDogMSk7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZSA9PT0gMSAvKiBFbmQgKi8pIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyAyLnggZGVwcmVjYXRpb24gY2hlY2tzXHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgaXNDb21wYXRFbmFibGVkKFwiQ09NUElMRVJfVl9JRl9WX0ZPUl9QUkVDRURFTkNFXCIgLyogQ09NUElMRVJfVl9JRl9WX0ZPUl9QUkVDRURFTkNFICovLCBjb250ZXh0KSkge1xyXG4gICAgICAgIGxldCBoYXNJZiA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBoYXNGb3IgPSBmYWxzZTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHAgPSBwcm9wc1tpXTtcclxuICAgICAgICAgICAgaWYgKHAudHlwZSA9PT0gNyAvKiBESVJFQ1RJVkUgKi8pIHtcclxuICAgICAgICAgICAgICAgIGlmIChwLm5hbWUgPT09ICdpZicpIHtcclxuICAgICAgICAgICAgICAgICAgICBoYXNJZiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwLm5hbWUgPT09ICdmb3InKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzRm9yID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaGFzSWYgJiYgaGFzRm9yKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuRGVwcmVjYXRpb24oXCJDT01QSUxFUl9WX0lGX1ZfRk9SX1BSRUNFREVOQ0VcIiAvKiBDT01QSUxFUl9WX0lGX1ZfRk9SX1BSRUNFREVOQ0UgKi8sIGNvbnRleHQsIGdldFNlbGVjdGlvbihjb250ZXh0LCBzdGFydCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbGV0IHRhZ1R5cGUgPSAwIC8qIEVMRU1FTlQgKi87XHJcbiAgICBjb25zdCBvcHRpb25zID0gY29udGV4dC5vcHRpb25zO1xyXG4gICAgaWYgKCFjb250ZXh0LmluVlByZSAmJiAhb3B0aW9ucy5pc0N1c3RvbUVsZW1lbnQodGFnKSkge1xyXG4gICAgICAgIGNvbnN0IGhhc1ZJcyA9IHByb3BzLnNvbWUocCA9PiB7XHJcbiAgICAgICAgICAgIGlmIChwLm5hbWUgIT09ICdpcycpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIC8vIHYtaXM9XCJ4eHhcIiAoVE9ETzogZGVwcmVjYXRlKVxyXG4gICAgICAgICAgICBpZiAocC50eXBlID09PSA3IC8qIERJUkVDVElWRSAqLykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaXM9XCJ2dWU6eHh4XCJcclxuICAgICAgICAgICAgaWYgKHAudmFsdWUgJiYgcC52YWx1ZS5jb250ZW50LnN0YXJ0c1dpdGgoJ3Z1ZTonKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaW4gY29tcGF0IG1vZGUsIGFueSBpcyB1c2FnZSBpcyBjb25zaWRlcmVkIGEgY29tcG9uZW50XHJcbiAgICAgICAgICAgIGlmIChjaGVja0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9JU19PTl9FTEVNRU5UXCIgLyogQ09NUElMRVJfSVNfT05fRUxFTUVOVCAqLywgY29udGV4dCwgcC5sb2MpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChvcHRpb25zLmlzTmF0aXZlVGFnICYmICFoYXNWSXMpIHtcclxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmlzTmF0aXZlVGFnKHRhZykpXHJcbiAgICAgICAgICAgICAgICB0YWdUeXBlID0gMSAvKiBDT01QT05FTlQgKi87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGhhc1ZJcyB8fFxyXG4gICAgICAgICAgICBpc0NvcmVDb21wb25lbnQodGFnKSB8fFxyXG4gICAgICAgICAgICAob3B0aW9ucy5pc0J1aWx0SW5Db21wb25lbnQgJiYgb3B0aW9ucy5pc0J1aWx0SW5Db21wb25lbnQodGFnKSkgfHxcclxuICAgICAgICAgICAgL15bQS1aXS8udGVzdCh0YWcpIHx8XHJcbiAgICAgICAgICAgIHRhZyA9PT0gJ2NvbXBvbmVudCcpIHtcclxuICAgICAgICAgICAgdGFnVHlwZSA9IDEgLyogQ09NUE9ORU5UICovO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGFnID09PSAnc2xvdCcpIHtcclxuICAgICAgICAgICAgdGFnVHlwZSA9IDIgLyogU0xPVCAqLztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGFnID09PSAndGVtcGxhdGUnICYmXHJcbiAgICAgICAgICAgIHByb3BzLnNvbWUocCA9PiBwLnR5cGUgPT09IDcgLyogRElSRUNUSVZFICovICYmIGlzU3BlY2lhbFRlbXBsYXRlRGlyZWN0aXZlKHAubmFtZSkpKSB7XHJcbiAgICAgICAgICAgIHRhZ1R5cGUgPSAzIC8qIFRFTVBMQVRFICovO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMSAvKiBFTEVNRU5UICovLFxyXG4gICAgICAgIG5zLFxyXG4gICAgICAgIHRhZyxcclxuICAgICAgICB0YWdUeXBlLFxyXG4gICAgICAgIHByb3BzLFxyXG4gICAgICAgIGlzU2VsZkNsb3NpbmcsXHJcbiAgICAgICAgY2hpbGRyZW46IFtdLFxyXG4gICAgICAgIGxvYzogZ2V0U2VsZWN0aW9uKGNvbnRleHQsIHN0YXJ0KSxcclxuICAgICAgICBjb2RlZ2VuTm9kZTogdW5kZWZpbmVkIC8vIHRvIGJlIGNyZWF0ZWQgZHVyaW5nIHRyYW5zZm9ybSBwaGFzZVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZUF0dHJpYnV0ZXMoY29udGV4dCwgdHlwZSkge1xyXG4gICAgY29uc3QgcHJvcHMgPSBbXTtcclxuICAgIGNvbnN0IGF0dHJpYnV0ZU5hbWVzID0gbmV3IFNldCgpO1xyXG4gICAgd2hpbGUgKGNvbnRleHQuc291cmNlLmxlbmd0aCA+IDAgJiZcclxuICAgICAgICAhc3RhcnRzV2l0aChjb250ZXh0LnNvdXJjZSwgJz4nKSAmJlxyXG4gICAgICAgICFzdGFydHNXaXRoKGNvbnRleHQuc291cmNlLCAnLz4nKSkge1xyXG4gICAgICAgIGlmIChzdGFydHNXaXRoKGNvbnRleHQuc291cmNlLCAnLycpKSB7XHJcbiAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAyMiAvKiBVTkVYUEVDVEVEX1NPTElEVVNfSU5fVEFHICovKTtcclxuICAgICAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIDEpO1xyXG4gICAgICAgICAgICBhZHZhbmNlU3BhY2VzKGNvbnRleHQpO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IDEgLyogRW5kICovKSB7XHJcbiAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAzIC8qIEVORF9UQUdfV0lUSF9BVFRSSUJVVEVTICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYXR0ciA9IHBhcnNlQXR0cmlidXRlKGNvbnRleHQsIGF0dHJpYnV0ZU5hbWVzKTtcclxuICAgICAgICBpZiAodHlwZSA9PT0gMCAvKiBTdGFydCAqLykge1xyXG4gICAgICAgICAgICBwcm9wcy5wdXNoKGF0dHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoL15bXlxcdFxcclxcblxcZiAvPl0vLnRlc3QoY29udGV4dC5zb3VyY2UpKSB7XHJcbiAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxNSAvKiBNSVNTSU5HX1dISVRFU1BBQ0VfQkVUV0VFTl9BVFRSSUJVVEVTICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWR2YW5jZVNwYWNlcyhjb250ZXh0KTtcclxuICAgIH1cclxuICAgIHJldHVybiBwcm9wcztcclxufVxyXG5mdW5jdGlvbiBwYXJzZUF0dHJpYnV0ZShjb250ZXh0LCBuYW1lU2V0KSB7XHJcbiAgICAvLyBOYW1lLlxyXG4gICAgY29uc3Qgc3RhcnQgPSBnZXRDdXJzb3IoY29udGV4dCk7XHJcbiAgICBjb25zdCBtYXRjaCA9IC9eW15cXHRcXHJcXG5cXGYgLz5dW15cXHRcXHJcXG5cXGYgLz49XSovLmV4ZWMoY29udGV4dC5zb3VyY2UpO1xyXG4gICAgY29uc3QgbmFtZSA9IG1hdGNoWzBdO1xyXG4gICAgaWYgKG5hbWVTZXQuaGFzKG5hbWUpKSB7XHJcbiAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDIgLyogRFVQTElDQVRFX0FUVFJJQlVURSAqLyk7XHJcbiAgICB9XHJcbiAgICBuYW1lU2V0LmFkZChuYW1lKTtcclxuICAgIGlmIChuYW1lWzBdID09PSAnPScpIHtcclxuICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMTkgLyogVU5FWFBFQ1RFRF9FUVVBTFNfU0lHTl9CRUZPUkVfQVRUUklCVVRFX05BTUUgKi8pO1xyXG4gICAgfVxyXG4gICAge1xyXG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSAvW1wiJzxdL2c7XHJcbiAgICAgICAgbGV0IG07XHJcbiAgICAgICAgd2hpbGUgKChtID0gcGF0dGVybi5leGVjKG5hbWUpKSkge1xyXG4gICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMTcgLyogVU5FWFBFQ1RFRF9DSEFSQUNURVJfSU5fQVRUUklCVVRFX05BTUUgKi8sIG0uaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFkdmFuY2VCeShjb250ZXh0LCBuYW1lLmxlbmd0aCk7XHJcbiAgICAvLyBWYWx1ZVxyXG4gICAgbGV0IHZhbHVlID0gdW5kZWZpbmVkO1xyXG4gICAgaWYgKC9eW1xcdFxcclxcblxcZiBdKj0vLnRlc3QoY29udGV4dC5zb3VyY2UpKSB7XHJcbiAgICAgICAgYWR2YW5jZVNwYWNlcyhjb250ZXh0KTtcclxuICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgMSk7XHJcbiAgICAgICAgYWR2YW5jZVNwYWNlcyhjb250ZXh0KTtcclxuICAgICAgICB2YWx1ZSA9IHBhcnNlQXR0cmlidXRlVmFsdWUoY29udGV4dCk7XHJcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xyXG4gICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMTMgLyogTUlTU0lOR19BVFRSSUJVVEVfVkFMVUUgKi8pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IGxvYyA9IGdldFNlbGVjdGlvbihjb250ZXh0LCBzdGFydCk7XHJcbiAgICBpZiAoIWNvbnRleHQuaW5WUHJlICYmIC9eKHYtfDp8QHwjKS8udGVzdChuYW1lKSkge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gLyg/Ol52LShbYS16MC05LV0rKSk/KD86KD86OnxeQHxeIykoXFxbW15cXF1dK1xcXXxbXlxcLl0rKSk/KC4rKT8kL2kuZXhlYyhuYW1lKTtcclxuICAgICAgICBsZXQgZGlyTmFtZSA9IG1hdGNoWzFdIHx8XHJcbiAgICAgICAgICAgIChzdGFydHNXaXRoKG5hbWUsICc6JykgPyAnYmluZCcgOiBzdGFydHNXaXRoKG5hbWUsICdAJykgPyAnb24nIDogJ3Nsb3QnKTtcclxuICAgICAgICBsZXQgYXJnO1xyXG4gICAgICAgIGlmIChtYXRjaFsyXSkge1xyXG4gICAgICAgICAgICBjb25zdCBpc1Nsb3QgPSBkaXJOYW1lID09PSAnc2xvdCc7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gbmFtZS5sYXN0SW5kZXhPZihtYXRjaFsyXSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxvYyA9IGdldFNlbGVjdGlvbihjb250ZXh0LCBnZXROZXdQb3NpdGlvbihjb250ZXh0LCBzdGFydCwgc3RhcnRPZmZzZXQpLCBnZXROZXdQb3NpdGlvbihjb250ZXh0LCBzdGFydCwgc3RhcnRPZmZzZXQgKyBtYXRjaFsyXS5sZW5ndGggKyAoKGlzU2xvdCAmJiBtYXRjaFszXSkgfHwgJycpLmxlbmd0aCkpO1xyXG4gICAgICAgICAgICBsZXQgY29udGVudCA9IG1hdGNoWzJdO1xyXG4gICAgICAgICAgICBsZXQgaXNTdGF0aWMgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoY29udGVudC5zdGFydHNXaXRoKCdbJykpIHtcclxuICAgICAgICAgICAgICAgIGlzU3RhdGljID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRlbnQuZW5kc1dpdGgoJ10nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAyNiAvKiBYX01JU1NJTkdfRFlOQU1JQ19ESVJFQ1RJVkVfQVJHVU1FTlRfRU5EICovKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnN1YnN0cigxLCBjb250ZW50Lmxlbmd0aCAtIDIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzU2xvdCkge1xyXG4gICAgICAgICAgICAgICAgLy8gIzEyNDEgc3BlY2lhbCBjYXNlIGZvciB2LXNsb3Q6IHZ1ZXRpZnkgcmVsaWVzIGV4dGVuc2l2ZWx5IG9uIHNsb3RcclxuICAgICAgICAgICAgICAgIC8vIG5hbWVzIGNvbnRhaW5pbmcgZG90cy4gdi1zbG90IGRvZXNuJ3QgaGF2ZSBhbnkgbW9kaWZpZXJzIGFuZCBWdWUgMi54XHJcbiAgICAgICAgICAgICAgICAvLyBzdXBwb3J0cyBzdWNoIHVzYWdlIHNvIHdlIGFyZSBrZWVwaW5nIGl0IGNvbnNpc3RlbnQgd2l0aCAyLnguXHJcbiAgICAgICAgICAgICAgICBjb250ZW50ICs9IG1hdGNoWzNdIHx8ICcnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFyZyA9IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8sXHJcbiAgICAgICAgICAgICAgICBjb250ZW50LFxyXG4gICAgICAgICAgICAgICAgaXNTdGF0aWMsXHJcbiAgICAgICAgICAgICAgICBjb25zdFR5cGU6IGlzU3RhdGljXHJcbiAgICAgICAgICAgICAgICAgICAgPyAzIC8qIENBTl9TVFJJTkdJRlkgKi9cclxuICAgICAgICAgICAgICAgICAgICA6IDAgLyogTk9UX0NPTlNUQU5UICovLFxyXG4gICAgICAgICAgICAgICAgbG9jXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5pc1F1b3RlZCkge1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZUxvYyA9IHZhbHVlLmxvYztcclxuICAgICAgICAgICAgdmFsdWVMb2Muc3RhcnQub2Zmc2V0Kys7XHJcbiAgICAgICAgICAgIHZhbHVlTG9jLnN0YXJ0LmNvbHVtbisrO1xyXG4gICAgICAgICAgICB2YWx1ZUxvYy5lbmQgPSBhZHZhbmNlUG9zaXRpb25XaXRoQ2xvbmUodmFsdWVMb2Muc3RhcnQsIHZhbHVlLmNvbnRlbnQpO1xyXG4gICAgICAgICAgICB2YWx1ZUxvYy5zb3VyY2UgPSB2YWx1ZUxvYy5zb3VyY2Uuc2xpY2UoMSwgLTEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBtb2RpZmllcnMgPSBtYXRjaFszXSA/IG1hdGNoWzNdLnN1YnN0cigxKS5zcGxpdCgnLicpIDogW107XHJcbiAgICAgICAgLy8gMi54IGNvbXBhdCB2LWJpbmQ6Zm9vLnN5bmMgLT4gdi1tb2RlbDpmb29cclxuICAgICAgICBpZiAoZGlyTmFtZSA9PT0gJ2JpbmQnICYmIGFyZykge1xyXG4gICAgICAgICAgICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKCdzeW5jJykgJiZcclxuICAgICAgICAgICAgICAgIGNoZWNrQ29tcGF0RW5hYmxlZChcIkNPTVBJTEVSX1ZfQklORF9TWU5DXCIgLyogQ09NUElMRVJfVl9CSU5EX1NZTkMgKi8sIGNvbnRleHQsIGxvYywgYXJnLmxvYy5zb3VyY2UpKSB7XHJcbiAgICAgICAgICAgICAgICBkaXJOYW1lID0gJ21vZGVsJztcclxuICAgICAgICAgICAgICAgIG1vZGlmaWVycy5zcGxpY2UobW9kaWZpZXJzLmluZGV4T2YoJ3N5bmMnKSwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBtb2RpZmllcnMuaW5jbHVkZXMoJ3Byb3AnKSkge1xyXG4gICAgICAgICAgICAgICAgY2hlY2tDb21wYXRFbmFibGVkKFwiQ09NUElMRVJfVl9CSU5EX1BST1BcIiAvKiBDT01QSUxFUl9WX0JJTkRfUFJPUCAqLywgY29udGV4dCwgbG9jKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiA3IC8qIERJUkVDVElWRSAqLyxcclxuICAgICAgICAgICAgbmFtZTogZGlyTmFtZSxcclxuICAgICAgICAgICAgZXhwOiB2YWx1ZSAmJiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgICAgICAgICAgY29udGVudDogdmFsdWUuY29udGVudCxcclxuICAgICAgICAgICAgICAgIGlzU3RhdGljOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIC8vIFRyZWF0IGFzIG5vbi1jb25zdGFudCBieSBkZWZhdWx0LiBUaGlzIGNhbiBiZSBwb3RlbnRpYWxseSBzZXQgdG9cclxuICAgICAgICAgICAgICAgIC8vIG90aGVyIHZhbHVlcyBieSBgdHJhbnNmb3JtRXhwcmVzc2lvbmAgdG8gbWFrZSBpdCBlbGlnaWJsZSBmb3IgaG9pc3RpbmcuXHJcbiAgICAgICAgICAgICAgICBjb25zdFR5cGU6IDAgLyogTk9UX0NPTlNUQU5UICovLFxyXG4gICAgICAgICAgICAgICAgbG9jOiB2YWx1ZS5sb2NcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYXJnLFxyXG4gICAgICAgICAgICBtb2RpZmllcnMsXHJcbiAgICAgICAgICAgIGxvY1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDYgLyogQVRUUklCVVRFICovLFxyXG4gICAgICAgIG5hbWUsXHJcbiAgICAgICAgdmFsdWU6IHZhbHVlICYmIHtcclxuICAgICAgICAgICAgdHlwZTogMiAvKiBURVhUICovLFxyXG4gICAgICAgICAgICBjb250ZW50OiB2YWx1ZS5jb250ZW50LFxyXG4gICAgICAgICAgICBsb2M6IHZhbHVlLmxvY1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbG9jXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlQXR0cmlidXRlVmFsdWUoY29udGV4dCkge1xyXG4gICAgY29uc3Qgc3RhcnQgPSBnZXRDdXJzb3IoY29udGV4dCk7XHJcbiAgICBsZXQgY29udGVudDtcclxuICAgIGNvbnN0IHF1b3RlID0gY29udGV4dC5zb3VyY2VbMF07XHJcbiAgICBjb25zdCBpc1F1b3RlZCA9IHF1b3RlID09PSBgXCJgIHx8IHF1b3RlID09PSBgJ2A7XHJcbiAgICBpZiAoaXNRdW90ZWQpIHtcclxuICAgICAgICAvLyBRdW90ZWQgdmFsdWUuXHJcbiAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIDEpO1xyXG4gICAgICAgIGNvbnN0IGVuZEluZGV4ID0gY29udGV4dC5zb3VyY2UuaW5kZXhPZihxdW90ZSk7XHJcbiAgICAgICAgaWYgKGVuZEluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICBjb250ZW50ID0gcGFyc2VUZXh0RGF0YShjb250ZXh0LCBjb250ZXh0LnNvdXJjZS5sZW5ndGgsIDQgLyogQVRUUklCVVRFX1ZBTFVFICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnRlbnQgPSBwYXJzZVRleHREYXRhKGNvbnRleHQsIGVuZEluZGV4LCA0IC8qIEFUVFJJQlVURV9WQUxVRSAqLyk7XHJcbiAgICAgICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCAxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBVbnF1b3RlZFxyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gL15bXlxcdFxcclxcblxcZiA+XSsvLmV4ZWMoY29udGV4dC5zb3VyY2UpO1xyXG4gICAgICAgIGlmICghbWF0Y2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdW5leHBlY3RlZENoYXJzID0gL1tcIic8PWBdL2c7XHJcbiAgICAgICAgbGV0IG07XHJcbiAgICAgICAgd2hpbGUgKChtID0gdW5leHBlY3RlZENoYXJzLmV4ZWMobWF0Y2hbMF0pKSkge1xyXG4gICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMTggLyogVU5FWFBFQ1RFRF9DSEFSQUNURVJfSU5fVU5RVU9URURfQVRUUklCVVRFX1ZBTFVFICovLCBtLmluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29udGVudCA9IHBhcnNlVGV4dERhdGEoY29udGV4dCwgbWF0Y2hbMF0ubGVuZ3RoLCA0IC8qIEFUVFJJQlVURV9WQUxVRSAqLyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBjb250ZW50LCBpc1F1b3RlZCwgbG9jOiBnZXRTZWxlY3Rpb24oY29udGV4dCwgc3RhcnQpIH07XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VJbnRlcnBvbGF0aW9uKGNvbnRleHQsIG1vZGUpIHtcclxuICAgIGNvbnN0IFtvcGVuLCBjbG9zZV0gPSBjb250ZXh0Lm9wdGlvbnMuZGVsaW1pdGVycztcclxuICAgIGNvbnN0IGNsb3NlSW5kZXggPSBjb250ZXh0LnNvdXJjZS5pbmRleE9mKGNsb3NlLCBvcGVuLmxlbmd0aCk7XHJcbiAgICBpZiAoY2xvc2VJbmRleCA9PT0gLTEpIHtcclxuICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMjUgLyogWF9NSVNTSU5HX0lOVEVSUE9MQVRJT05fRU5EICovKTtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc3RhcnQgPSBnZXRDdXJzb3IoY29udGV4dCk7XHJcbiAgICBhZHZhbmNlQnkoY29udGV4dCwgb3Blbi5sZW5ndGgpO1xyXG4gICAgY29uc3QgaW5uZXJTdGFydCA9IGdldEN1cnNvcihjb250ZXh0KTtcclxuICAgIGNvbnN0IGlubmVyRW5kID0gZ2V0Q3Vyc29yKGNvbnRleHQpO1xyXG4gICAgY29uc3QgcmF3Q29udGVudExlbmd0aCA9IGNsb3NlSW5kZXggLSBvcGVuLmxlbmd0aDtcclxuICAgIGNvbnN0IHJhd0NvbnRlbnQgPSBjb250ZXh0LnNvdXJjZS5zbGljZSgwLCByYXdDb250ZW50TGVuZ3RoKTtcclxuICAgIGNvbnN0IHByZVRyaW1Db250ZW50ID0gcGFyc2VUZXh0RGF0YShjb250ZXh0LCByYXdDb250ZW50TGVuZ3RoLCBtb2RlKTtcclxuICAgIGNvbnN0IGNvbnRlbnQgPSBwcmVUcmltQ29udGVudC50cmltKCk7XHJcbiAgICBjb25zdCBzdGFydE9mZnNldCA9IHByZVRyaW1Db250ZW50LmluZGV4T2YoY29udGVudCk7XHJcbiAgICBpZiAoc3RhcnRPZmZzZXQgPiAwKSB7XHJcbiAgICAgICAgYWR2YW5jZVBvc2l0aW9uV2l0aE11dGF0aW9uKGlubmVyU3RhcnQsIHJhd0NvbnRlbnQsIHN0YXJ0T2Zmc2V0KTtcclxuICAgIH1cclxuICAgIGNvbnN0IGVuZE9mZnNldCA9IHJhd0NvbnRlbnRMZW5ndGggLSAocHJlVHJpbUNvbnRlbnQubGVuZ3RoIC0gY29udGVudC5sZW5ndGggLSBzdGFydE9mZnNldCk7XHJcbiAgICBhZHZhbmNlUG9zaXRpb25XaXRoTXV0YXRpb24oaW5uZXJFbmQsIHJhd0NvbnRlbnQsIGVuZE9mZnNldCk7XHJcbiAgICBhZHZhbmNlQnkoY29udGV4dCwgY2xvc2UubGVuZ3RoKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogNSAvKiBJTlRFUlBPTEFUSU9OICovLFxyXG4gICAgICAgIGNvbnRlbnQ6IHtcclxuICAgICAgICAgICAgdHlwZTogNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyxcclxuICAgICAgICAgICAgaXNTdGF0aWM6IGZhbHNlLFxyXG4gICAgICAgICAgICAvLyBTZXQgYGlzQ29uc3RhbnRgIHRvIGZhbHNlIGJ5IGRlZmF1bHQgYW5kIHdpbGwgZGVjaWRlIGluIHRyYW5zZm9ybUV4cHJlc3Npb25cclxuICAgICAgICAgICAgY29uc3RUeXBlOiAwIC8qIE5PVF9DT05TVEFOVCAqLyxcclxuICAgICAgICAgICAgY29udGVudCxcclxuICAgICAgICAgICAgbG9jOiBnZXRTZWxlY3Rpb24oY29udGV4dCwgaW5uZXJTdGFydCwgaW5uZXJFbmQpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBsb2M6IGdldFNlbGVjdGlvbihjb250ZXh0LCBzdGFydClcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VUZXh0KGNvbnRleHQsIG1vZGUpIHtcclxuICAgIGNvbnN0IGVuZFRva2VucyA9IFsnPCcsIGNvbnRleHQub3B0aW9ucy5kZWxpbWl0ZXJzWzBdXTtcclxuICAgIGlmIChtb2RlID09PSAzIC8qIENEQVRBICovKSB7XHJcbiAgICAgICAgZW5kVG9rZW5zLnB1c2goJ11dPicpO1xyXG4gICAgfVxyXG4gICAgbGV0IGVuZEluZGV4ID0gY29udGV4dC5zb3VyY2UubGVuZ3RoO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmRUb2tlbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBpbmRleCA9IGNvbnRleHQuc291cmNlLmluZGV4T2YoZW5kVG9rZW5zW2ldLCAxKTtcclxuICAgICAgICBpZiAoaW5kZXggIT09IC0xICYmIGVuZEluZGV4ID4gaW5kZXgpIHtcclxuICAgICAgICAgICAgZW5kSW5kZXggPSBpbmRleDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBzdGFydCA9IGdldEN1cnNvcihjb250ZXh0KTtcclxuICAgIGNvbnN0IGNvbnRlbnQgPSBwYXJzZVRleHREYXRhKGNvbnRleHQsIGVuZEluZGV4LCBtb2RlKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogMiAvKiBURVhUICovLFxyXG4gICAgICAgIGNvbnRlbnQsXHJcbiAgICAgICAgbG9jOiBnZXRTZWxlY3Rpb24oY29udGV4dCwgc3RhcnQpXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBHZXQgdGV4dCBkYXRhIHdpdGggYSBnaXZlbiBsZW5ndGggZnJvbSB0aGUgY3VycmVudCBsb2NhdGlvbi5cclxuICogVGhpcyB0cmFuc2xhdGVzIEhUTUwgZW50aXRpZXMgaW4gdGhlIHRleHQgZGF0YS5cclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlVGV4dERhdGEoY29udGV4dCwgbGVuZ3RoLCBtb2RlKSB7XHJcbiAgICBjb25zdCByYXdUZXh0ID0gY29udGV4dC5zb3VyY2Uuc2xpY2UoMCwgbGVuZ3RoKTtcclxuICAgIGFkdmFuY2VCeShjb250ZXh0LCBsZW5ndGgpO1xyXG4gICAgaWYgKG1vZGUgPT09IDIgLyogUkFXVEVYVCAqLyB8fFxyXG4gICAgICAgIG1vZGUgPT09IDMgLyogQ0RBVEEgKi8gfHxcclxuICAgICAgICByYXdUZXh0LmluZGV4T2YoJyYnKSA9PT0gLTEpIHtcclxuICAgICAgICByZXR1cm4gcmF3VGV4dDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIERBVEEgb3IgUkNEQVRBIGNvbnRhaW5pbmcgXCImXCJcIi4gRW50aXR5IGRlY29kaW5nIHJlcXVpcmVkLlxyXG4gICAgICAgIHJldHVybiBjb250ZXh0Lm9wdGlvbnMuZGVjb2RlRW50aXRpZXMocmF3VGV4dCwgbW9kZSA9PT0gNCAvKiBBVFRSSUJVVEVfVkFMVUUgKi8pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldEN1cnNvcihjb250ZXh0KSB7XHJcbiAgICBjb25zdCB7IGNvbHVtbiwgbGluZSwgb2Zmc2V0IH0gPSBjb250ZXh0O1xyXG4gICAgcmV0dXJuIHsgY29sdW1uLCBsaW5lLCBvZmZzZXQgfTtcclxufVxyXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24oY29udGV4dCwgc3RhcnQsIGVuZCkge1xyXG4gICAgZW5kID0gZW5kIHx8IGdldEN1cnNvcihjb250ZXh0KTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc3RhcnQsXHJcbiAgICAgICAgZW5kLFxyXG4gICAgICAgIHNvdXJjZTogY29udGV4dC5vcmlnaW5hbFNvdXJjZS5zbGljZShzdGFydC5vZmZzZXQsIGVuZC5vZmZzZXQpXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGxhc3QoeHMpIHtcclxuICAgIHJldHVybiB4c1t4cy5sZW5ndGggLSAxXTtcclxufVxyXG5mdW5jdGlvbiBzdGFydHNXaXRoKHNvdXJjZSwgc2VhcmNoU3RyaW5nKSB7XHJcbiAgICByZXR1cm4gc291cmNlLnN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nKTtcclxufVxyXG5mdW5jdGlvbiBhZHZhbmNlQnkoY29udGV4dCwgbnVtYmVyT2ZDaGFyYWN0ZXJzKSB7XHJcbiAgICBjb25zdCB7IHNvdXJjZSB9ID0gY29udGV4dDtcclxuICAgIGFkdmFuY2VQb3NpdGlvbldpdGhNdXRhdGlvbihjb250ZXh0LCBzb3VyY2UsIG51bWJlck9mQ2hhcmFjdGVycyk7XHJcbiAgICBjb250ZXh0LnNvdXJjZSA9IHNvdXJjZS5zbGljZShudW1iZXJPZkNoYXJhY3RlcnMpO1xyXG59XHJcbmZ1bmN0aW9uIGFkdmFuY2VTcGFjZXMoY29udGV4dCkge1xyXG4gICAgY29uc3QgbWF0Y2ggPSAvXltcXHRcXHJcXG5cXGYgXSsvLmV4ZWMoY29udGV4dC5zb3VyY2UpO1xyXG4gICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIG1hdGNoWzBdLmxlbmd0aCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0TmV3UG9zaXRpb24oY29udGV4dCwgc3RhcnQsIG51bWJlck9mQ2hhcmFjdGVycykge1xyXG4gICAgcmV0dXJuIGFkdmFuY2VQb3NpdGlvbldpdGhDbG9uZShzdGFydCwgY29udGV4dC5vcmlnaW5hbFNvdXJjZS5zbGljZShzdGFydC5vZmZzZXQsIG51bWJlck9mQ2hhcmFjdGVycyksIG51bWJlck9mQ2hhcmFjdGVycyk7XHJcbn1cclxuZnVuY3Rpb24gZW1pdEVycm9yKGNvbnRleHQsIGNvZGUsIG9mZnNldCwgbG9jID0gZ2V0Q3Vyc29yKGNvbnRleHQpKSB7XHJcbiAgICBpZiAob2Zmc2V0KSB7XHJcbiAgICAgICAgbG9jLm9mZnNldCArPSBvZmZzZXQ7XHJcbiAgICAgICAgbG9jLmNvbHVtbiArPSBvZmZzZXQ7XHJcbiAgICB9XHJcbiAgICBjb250ZXh0Lm9wdGlvbnMub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKGNvZGUsIHtcclxuICAgICAgICBzdGFydDogbG9jLFxyXG4gICAgICAgIGVuZDogbG9jLFxyXG4gICAgICAgIHNvdXJjZTogJydcclxuICAgIH0pKTtcclxufVxyXG5mdW5jdGlvbiBpc0VuZChjb250ZXh0LCBtb2RlLCBhbmNlc3RvcnMpIHtcclxuICAgIGNvbnN0IHMgPSBjb250ZXh0LnNvdXJjZTtcclxuICAgIHN3aXRjaCAobW9kZSkge1xyXG4gICAgICAgIGNhc2UgMCAvKiBEQVRBICovOlxyXG4gICAgICAgICAgICBpZiAoc3RhcnRzV2l0aChzLCAnPC8nKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogcHJvYmFibHkgYmFkIHBlcmZvcm1hbmNlXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gYW5jZXN0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0c1dpdGhFbmRUYWdPcGVuKHMsIGFuY2VzdG9yc1tpXS50YWcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDEgLyogUkNEQVRBICovOlxyXG4gICAgICAgIGNhc2UgMiAvKiBSQVdURVhUICovOiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IGxhc3QoYW5jZXN0b3JzKTtcclxuICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBzdGFydHNXaXRoRW5kVGFnT3BlbihzLCBwYXJlbnQudGFnKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgMyAvKiBDREFUQSAqLzpcclxuICAgICAgICAgICAgaWYgKHN0YXJ0c1dpdGgocywgJ11dPicpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIHJldHVybiAhcztcclxufVxyXG5mdW5jdGlvbiBzdGFydHNXaXRoRW5kVGFnT3Blbihzb3VyY2UsIHRhZykge1xyXG4gICAgcmV0dXJuIChzdGFydHNXaXRoKHNvdXJjZSwgJzwvJykgJiZcclxuICAgICAgICBzb3VyY2Uuc3Vic3RyKDIsIHRhZy5sZW5ndGgpLnRvTG93ZXJDYXNlKCkgPT09IHRhZy50b0xvd2VyQ2FzZSgpICYmXHJcbiAgICAgICAgL1tcXHRcXHJcXG5cXGYgLz5dLy50ZXN0KHNvdXJjZVsyICsgdGFnLmxlbmd0aF0gfHwgJz4nKSk7XHJcbn1cblxuZnVuY3Rpb24gaG9pc3RTdGF0aWMocm9vdCwgY29udGV4dCkge1xyXG4gICAgd2Fsayhyb290LCBjb250ZXh0LCBcclxuICAgIC8vIFJvb3Qgbm9kZSBpcyB1bmZvcnR1bmF0ZWx5IG5vbi1ob2lzdGFibGUgZHVlIHRvIHBvdGVudGlhbCBwYXJlbnRcclxuICAgIC8vIGZhbGx0aHJvdWdoIGF0dHJpYnV0ZXMuXHJcbiAgICBpc1NpbmdsZUVsZW1lbnRSb290KHJvb3QsIHJvb3QuY2hpbGRyZW5bMF0pKTtcclxufVxyXG5mdW5jdGlvbiBpc1NpbmdsZUVsZW1lbnRSb290KHJvb3QsIGNoaWxkKSB7XHJcbiAgICBjb25zdCB7IGNoaWxkcmVuIH0gPSByb290O1xyXG4gICAgcmV0dXJuIChjaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcclxuICAgICAgICBjaGlsZC50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICAhaXNTbG90T3V0bGV0KGNoaWxkKSk7XHJcbn1cclxuZnVuY3Rpb24gd2Fsayhub2RlLCBjb250ZXh0LCBkb05vdEhvaXN0Tm9kZSA9IGZhbHNlKSB7XHJcbiAgICBsZXQgaGFzSG9pc3RlZE5vZGUgPSBmYWxzZTtcclxuICAgIC8vIFNvbWUgdHJhbnNmb3JtcywgZS5nLiB0cmFuc2Zvcm1Bc3NldFVybHMgZnJvbSBAdnVlL2NvbXBpbGVyLXNmYywgcmVwbGFjZXNcclxuICAgIC8vIHN0YXRpYyBiaW5kaW5ncyB3aXRoIGV4cHJlc3Npb25zLiBUaGVzZSBleHByZXNzaW9ucyBhcmUgZ3VhcmFudGVlZCB0byBiZVxyXG4gICAgLy8gY29uc3RhbnQgc28gdGhleSBhcmUgc3RpbGwgZWxpZ2libGUgZm9yIGhvaXN0aW5nLCBidXQgdGhleSBhcmUgb25seVxyXG4gICAgLy8gYXZhaWxhYmxlIGF0IHJ1bnRpbWUgYW5kIHRoZXJlZm9yZSBjYW5ub3QgYmUgZXZhbHVhdGVkIGFoZWFkIG9mIHRpbWUuXHJcbiAgICAvLyBUaGlzIGlzIG9ubHkgYSBjb25jZXJuIGZvciBwcmUtc3RyaW5naWZpY2F0aW9uICh2aWEgdHJhbnNmb3JtSG9pc3QgYnlcclxuICAgIC8vIEB2dWUvY29tcGlsZXItZG9tKSwgYnV0IGRvaW5nIGl0IGhlcmUgYWxsb3dzIHVzIHRvIHBlcmZvcm0gb25seSBvbmUgZnVsbFxyXG4gICAgLy8gd2FsayBvZiB0aGUgQVNUIGFuZCBhbGxvdyBgc3RyaW5naWZ5U3RhdGljYCB0byBzdG9wIHdhbGtpbmcgYXMgc29vbiBhcyBpdHNcclxuICAgIC8vIHN0cmluZ2ZpY2lhdGlvbiB0aHJlc2hvbGQgaXMgbWV0LlxyXG4gICAgbGV0IGNhblN0cmluZ2lmeSA9IHRydWU7XHJcbiAgICBjb25zdCB7IGNoaWxkcmVuIH0gPSBub2RlO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgLy8gb25seSBwbGFpbiBlbGVtZW50cyAmIHRleHQgY2FsbHMgYXJlIGVsaWdpYmxlIGZvciBob2lzdGluZy5cclxuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovICYmXHJcbiAgICAgICAgICAgIGNoaWxkLnRhZ1R5cGUgPT09IDAgLyogRUxFTUVOVCAqLykge1xyXG4gICAgICAgICAgICBjb25zdCBjb25zdGFudFR5cGUgPSBkb05vdEhvaXN0Tm9kZVxyXG4gICAgICAgICAgICAgICAgPyAwIC8qIE5PVF9DT05TVEFOVCAqL1xyXG4gICAgICAgICAgICAgICAgOiBnZXRDb25zdGFudFR5cGUoY2hpbGQsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBpZiAoY29uc3RhbnRUeXBlID4gMCAvKiBOT1RfQ09OU1RBTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb25zdGFudFR5cGUgPCAzIC8qIENBTl9TVFJJTkdJRlkgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBjYW5TdHJpbmdpZnkgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjb25zdGFudFR5cGUgPj0gMiAvKiBDQU5fSE9JU1QgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5jb2RlZ2VuTm9kZS5wYXRjaEZsYWcgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAtMSAvKiBIT0lTVEVEICovICsgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGAgLyogSE9JU1RFRCAqL2AgOiBgYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuY29kZWdlbk5vZGUgPSBjb250ZXh0LmhvaXN0KGNoaWxkLmNvZGVnZW5Ob2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBoYXNIb2lzdGVkTm9kZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBub2RlIG1heSBjb250YWluIGR5bmFtaWMgY2hpbGRyZW4sIGJ1dCBpdHMgcHJvcHMgbWF5IGJlIGVsaWdpYmxlIGZvclxyXG4gICAgICAgICAgICAgICAgLy8gaG9pc3RpbmcuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlZ2VuTm9kZSA9IGNoaWxkLmNvZGVnZW5Ob2RlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvZGVnZW5Ob2RlLnR5cGUgPT09IDEzIC8qIFZOT0RFX0NBTEwgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmbGFnID0gZ2V0UGF0Y2hGbGFnKGNvZGVnZW5Ob2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKCFmbGFnIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWcgPT09IDUxMiAvKiBORUVEX1BBVENIICovIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWcgPT09IDEgLyogVEVYVCAqLykgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0R2VuZXJhdGVkUHJvcHNDb25zdGFudFR5cGUoY2hpbGQsIGNvbnRleHQpID49XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAyIC8qIENBTl9IT0lTVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wcyA9IGdldE5vZGVQcm9wcyhjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZWdlbk5vZGUucHJvcHMgPSBjb250ZXh0LmhvaXN0KHByb3BzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjaGlsZC50eXBlID09PSAxMiAvKiBURVhUX0NBTEwgKi8pIHtcclxuICAgICAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSBnZXRDb25zdGFudFR5cGUoY2hpbGQuY29udGVudCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGlmIChjb250ZW50VHlwZSA+IDApIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb250ZW50VHlwZSA8IDMgLyogQ0FOX1NUUklOR0lGWSAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhblN0cmluZ2lmeSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlID49IDIgLyogQ0FOX0hPSVNUICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuY29kZWdlbk5vZGUgPSBjb250ZXh0LmhvaXN0KGNoaWxkLmNvZGVnZW5Ob2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBoYXNIb2lzdGVkTm9kZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gd2FsayBmdXJ0aGVyXHJcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLykge1xyXG4gICAgICAgICAgICBjb25zdCBpc0NvbXBvbmVudCA9IGNoaWxkLnRhZ1R5cGUgPT09IDEgLyogQ09NUE9ORU5UICovO1xyXG4gICAgICAgICAgICBpZiAoaXNDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuc2NvcGVzLnZTbG90Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd2FsayhjaGlsZCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGlmIChpc0NvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5zY29wZXMudlNsb3QtLTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjaGlsZC50eXBlID09PSAxMSAvKiBGT1IgKi8pIHtcclxuICAgICAgICAgICAgLy8gRG8gbm90IGhvaXN0IHYtZm9yIHNpbmdsZSBjaGlsZCBiZWNhdXNlIGl0IGhhcyB0byBiZSBhIGJsb2NrXHJcbiAgICAgICAgICAgIHdhbGsoY2hpbGQsIGNvbnRleHQsIGNoaWxkLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNoaWxkLnR5cGUgPT09IDkgLyogSUYgKi8pIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZC5icmFuY2hlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IGhvaXN0IHYtaWYgc2luZ2xlIGNoaWxkIGJlY2F1c2UgaXQgaGFzIHRvIGJlIGEgYmxvY2tcclxuICAgICAgICAgICAgICAgIHdhbGsoY2hpbGQuYnJhbmNoZXNbaV0sIGNvbnRleHQsIGNoaWxkLmJyYW5jaGVzW2ldLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoY2FuU3RyaW5naWZ5ICYmIGhhc0hvaXN0ZWROb2RlICYmIGNvbnRleHQudHJhbnNmb3JtSG9pc3QpIHtcclxuICAgICAgICBjb250ZXh0LnRyYW5zZm9ybUhvaXN0KGNoaWxkcmVuLCBjb250ZXh0LCBub2RlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRDb25zdGFudFR5cGUobm9kZSwgY29udGV4dCkge1xyXG4gICAgY29uc3QgeyBjb25zdGFudENhY2hlIH0gPSBjb250ZXh0O1xyXG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcclxuICAgICAgICBjYXNlIDEgLyogRUxFTUVOVCAqLzpcclxuICAgICAgICAgICAgaWYgKG5vZGUudGFnVHlwZSAhPT0gMCAvKiBFTEVNRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBOT1RfQ09OU1RBTlQgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgY2FjaGVkID0gY29uc3RhbnRDYWNoZS5nZXQobm9kZSk7XHJcbiAgICAgICAgICAgIGlmIChjYWNoZWQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBjb2RlZ2VuTm9kZSA9IG5vZGUuY29kZWdlbk5vZGU7XHJcbiAgICAgICAgICAgIGlmIChjb2RlZ2VuTm9kZS50eXBlICE9PSAxMyAvKiBWTk9ERV9DQUxMICovKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBOT1RfQ09OU1RBTlQgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZmxhZyA9IGdldFBhdGNoRmxhZyhjb2RlZ2VuTm9kZSk7XHJcbiAgICAgICAgICAgIGlmICghZmxhZykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHJldHVyblR5cGUgPSAzIC8qIENBTl9TVFJJTkdJRlkgKi87XHJcbiAgICAgICAgICAgICAgICAvLyBFbGVtZW50IGl0c2VsZiBoYXMgbm8gcGF0Y2ggZmxhZy4gSG93ZXZlciB3ZSBzdGlsbCBuZWVkIHRvIGNoZWNrOlxyXG4gICAgICAgICAgICAgICAgLy8gMS4gRXZlbiBmb3IgYSBub2RlIHdpdGggbm8gcGF0Y2ggZmxhZywgaXQgaXMgcG9zc2libGUgZm9yIGl0IHRvIGNvbnRhaW5cclxuICAgICAgICAgICAgICAgIC8vIG5vbi1ob2lzdGFibGUgZXhwcmVzc2lvbnMgdGhhdCByZWZlcnMgdG8gc2NvcGUgdmFyaWFibGVzLCBlLmcuIGNvbXBpbGVyXHJcbiAgICAgICAgICAgICAgICAvLyBpbmplY3RlZCBrZXlzIG9yIGNhY2hlZCBldmVudCBoYW5kbGVycy4gVGhlcmVmb3JlIHdlIG5lZWQgdG8gYWx3YXlzXHJcbiAgICAgICAgICAgICAgICAvLyBjaGVjayB0aGUgY29kZWdlbk5vZGUncyBwcm9wcyB0byBiZSBzdXJlLlxyXG4gICAgICAgICAgICAgICAgY29uc3QgZ2VuZXJhdGVkUHJvcHNUeXBlID0gZ2V0R2VuZXJhdGVkUHJvcHNDb25zdGFudFR5cGUobm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ2VuZXJhdGVkUHJvcHNUeXBlID09PSAwIC8qIE5PVF9DT05TVEFOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0YW50Q2FjaGUuc2V0KG5vZGUsIDAgLyogTk9UX0NPTlNUQU5UICovKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBOT1RfQ09OU1RBTlQgKi87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZ2VuZXJhdGVkUHJvcHNUeXBlIDwgcmV0dXJuVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblR5cGUgPSBnZW5lcmF0ZWRQcm9wc1R5cGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyAyLiBpdHMgY2hpbGRyZW4uXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZFR5cGUgPSBnZXRDb25zdGFudFR5cGUobm9kZS5jaGlsZHJlbltpXSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkVHlwZSA9PT0gMCAvKiBOT1RfQ09OU1RBTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RhbnRDYWNoZS5zZXQobm9kZSwgMCAvKiBOT1RfQ09OU1RBTlQgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBOT1RfQ09OU1RBTlQgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZFR5cGUgPCByZXR1cm5UeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblR5cGUgPSBjaGlsZFR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gMy4gaWYgdGhlIHR5cGUgaXMgbm90IGFscmVhZHkgQ0FOX1NLSVBfUEFUQ0ggd2hpY2ggaXMgdGhlIGxvd2VzdCBub24tMFxyXG4gICAgICAgICAgICAgICAgLy8gdHlwZSwgY2hlY2sgaWYgYW55IG9mIHRoZSBwcm9wcyBjYW4gY2F1c2UgdGhlIHR5cGUgdG8gYmUgbG93ZXJlZFxyXG4gICAgICAgICAgICAgICAgLy8gd2UgY2FuIHNraXAgY2FuX3BhdGNoIGJlY2F1c2UgaXQncyBndWFyYW50ZWVkIGJ5IHRoZSBhYnNlbmNlIG9mIGFcclxuICAgICAgICAgICAgICAgIC8vIHBhdGNoRmxhZy5cclxuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5UeXBlID4gMSAvKiBDQU5fU0tJUF9QQVRDSCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5wcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gbm9kZS5wcm9wc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAudHlwZSA9PT0gNyAvKiBESVJFQ1RJVkUgKi8gJiYgcC5uYW1lID09PSAnYmluZCcgJiYgcC5leHApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cFR5cGUgPSBnZXRDb25zdGFudFR5cGUocC5leHAsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cFR5cGUgPT09IDAgLyogTk9UX0NPTlNUQU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RhbnRDYWNoZS5zZXQobm9kZSwgMCAvKiBOT1RfQ09OU1RBTlQgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIE5PVF9DT05TVEFOVCAqLztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHBUeXBlIDwgcmV0dXJuVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblR5cGUgPSBleHBUeXBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gb25seSBzdmcvZm9yZWlnbk9iamVjdCBjb3VsZCBiZSBibG9jayBoZXJlLCBob3dldmVyIGlmIHRoZXkgYXJlXHJcbiAgICAgICAgICAgICAgICAvLyBzdGF0aWMgdGhlbiB0aGV5IGRvbid0IG5lZWQgdG8gYmUgYmxvY2tzIHNpbmNlIHRoZXJlIHdpbGwgYmUgbm9cclxuICAgICAgICAgICAgICAgIC8vIG5lc3RlZCB1cGRhdGVzLlxyXG4gICAgICAgICAgICAgICAgaWYgKGNvZGVnZW5Ob2RlLmlzQmxvY2spIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJlbW92ZUhlbHBlcihPUEVOX0JMT0NLKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJlbW92ZUhlbHBlcihDUkVBVEVfQkxPQ0spO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvZGVnZW5Ob2RlLmlzQmxvY2sgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmhlbHBlcihDUkVBVEVfVk5PREUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3RhbnRDYWNoZS5zZXQobm9kZSwgcmV0dXJuVHlwZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuVHlwZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0YW50Q2FjaGUuc2V0KG5vZGUsIDAgLyogTk9UX0NPTlNUQU5UICovKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIE5PVF9DT05TVEFOVCAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgMiAvKiBURVhUICovOlxyXG4gICAgICAgIGNhc2UgMyAvKiBDT01NRU5UICovOlxyXG4gICAgICAgICAgICByZXR1cm4gMyAvKiBDQU5fU1RSSU5HSUZZICovO1xyXG4gICAgICAgIGNhc2UgOSAvKiBJRiAqLzpcclxuICAgICAgICBjYXNlIDExIC8qIEZPUiAqLzpcclxuICAgICAgICBjYXNlIDEwIC8qIElGX0JSQU5DSCAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIDAgLyogTk9UX0NPTlNUQU5UICovO1xyXG4gICAgICAgIGNhc2UgNSAvKiBJTlRFUlBPTEFUSU9OICovOlxyXG4gICAgICAgIGNhc2UgMTIgLyogVEVYVF9DQUxMICovOlxyXG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29uc3RhbnRUeXBlKG5vZGUuY29udGVudCwgY29udGV4dCk7XHJcbiAgICAgICAgY2FzZSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovOlxyXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5jb25zdFR5cGU7XHJcbiAgICAgICAgY2FzZSA4IC8qIENPTVBPVU5EX0VYUFJFU1NJT04gKi86XHJcbiAgICAgICAgICAgIGxldCByZXR1cm5UeXBlID0gMyAvKiBDQU5fU1RSSU5HSUZZICovO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyhjaGlsZCkgfHwgaXNTeW1ib2woY2hpbGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZFR5cGUgPSBnZXRDb25zdGFudFR5cGUoY2hpbGQsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkVHlwZSA9PT0gMCAvKiBOT1RfQ09OU1RBTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBOT1RfQ09OU1RBTlQgKi87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGlsZFR5cGUgPCByZXR1cm5UeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuVHlwZSA9IGNoaWxkVHlwZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVHlwZTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSA7XHJcbiAgICAgICAgICAgIHJldHVybiAwIC8qIE5PVF9DT05TVEFOVCAqLztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRHZW5lcmF0ZWRQcm9wc0NvbnN0YW50VHlwZShub2RlLCBjb250ZXh0KSB7XHJcbiAgICBsZXQgcmV0dXJuVHlwZSA9IDMgLyogQ0FOX1NUUklOR0lGWSAqLztcclxuICAgIGNvbnN0IHByb3BzID0gZ2V0Tm9kZVByb3BzKG5vZGUpO1xyXG4gICAgaWYgKHByb3BzICYmIHByb3BzLnR5cGUgPT09IDE1IC8qIEpTX09CSkVDVF9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgY29uc3QgeyBwcm9wZXJ0aWVzIH0gPSBwcm9wcztcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgeyBrZXksIHZhbHVlIH0gPSBwcm9wZXJ0aWVzW2ldO1xyXG4gICAgICAgICAgICBjb25zdCBrZXlUeXBlID0gZ2V0Q29uc3RhbnRUeXBlKGtleSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGlmIChrZXlUeXBlID09PSAwIC8qIE5PVF9DT05TVEFOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleVR5cGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGtleVR5cGUgPCByZXR1cm5UeXBlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm5UeXBlID0ga2V5VHlwZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodmFsdWUudHlwZSAhPT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDAgLyogTk9UX0NPTlNUQU5UICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IGdldENvbnN0YW50VHlwZSh2YWx1ZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZVR5cGUgPT09IDAgLyogTk9UX0NPTlNUQU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVUeXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZVR5cGUgPCByZXR1cm5UeXBlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm5UeXBlID0gdmFsdWVUeXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldHVyblR5cGU7XHJcbn1cclxuZnVuY3Rpb24gZ2V0Tm9kZVByb3BzKG5vZGUpIHtcclxuICAgIGNvbnN0IGNvZGVnZW5Ob2RlID0gbm9kZS5jb2RlZ2VuTm9kZTtcclxuICAgIGlmIChjb2RlZ2VuTm9kZS50eXBlID09PSAxMyAvKiBWTk9ERV9DQUxMICovKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvZGVnZW5Ob2RlLnByb3BzO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldFBhdGNoRmxhZyhub2RlKSB7XHJcbiAgICBjb25zdCBmbGFnID0gbm9kZS5wYXRjaEZsYWc7XHJcbiAgICByZXR1cm4gZmxhZyA/IHBhcnNlSW50KGZsYWcsIDEwKSA6IHVuZGVmaW5lZDtcclxufVxuXG5mdW5jdGlvbiBjcmVhdGVUcmFuc2Zvcm1Db250ZXh0KHJvb3QsIHsgZmlsZW5hbWUgPSAnJywgcHJlZml4SWRlbnRpZmllcnMgPSBmYWxzZSwgaG9pc3RTdGF0aWMgPSBmYWxzZSwgY2FjaGVIYW5kbGVycyA9IGZhbHNlLCBub2RlVHJhbnNmb3JtcyA9IFtdLCBkaXJlY3RpdmVUcmFuc2Zvcm1zID0ge30sIHRyYW5zZm9ybUhvaXN0ID0gbnVsbCwgaXNCdWlsdEluQ29tcG9uZW50ID0gTk9PUCwgaXNDdXN0b21FbGVtZW50ID0gTk9PUCwgZXhwcmVzc2lvblBsdWdpbnMgPSBbXSwgc2NvcGVJZCA9IG51bGwsIHNsb3R0ZWQgPSB0cnVlLCBzc3IgPSBmYWxzZSwgc3NyQ3NzVmFycyA9IGBgLCBiaW5kaW5nTWV0YWRhdGEgPSBFTVBUWV9PQkosIGlubGluZSA9IGZhbHNlLCBpc1RTID0gZmFsc2UsIG9uRXJyb3IgPSBkZWZhdWx0T25FcnJvciwgb25XYXJuID0gZGVmYXVsdE9uV2FybiwgY29tcGF0Q29uZmlnIH0pIHtcclxuICAgIGNvbnN0IG5hbWVNYXRjaCA9IGZpbGVuYW1lLnJlcGxhY2UoL1xcPy4qJC8sICcnKS5tYXRjaCgvKFteL1xcXFxdKylcXC5cXHcrJC8pO1xyXG4gICAgY29uc3QgY29udGV4dCA9IHtcclxuICAgICAgICAvLyBvcHRpb25zXHJcbiAgICAgICAgc2VsZk5hbWU6IG5hbWVNYXRjaCAmJiBjYXBpdGFsaXplKGNhbWVsaXplJDEobmFtZU1hdGNoWzFdKSksXHJcbiAgICAgICAgcHJlZml4SWRlbnRpZmllcnMsXHJcbiAgICAgICAgaG9pc3RTdGF0aWMsXHJcbiAgICAgICAgY2FjaGVIYW5kbGVycyxcclxuICAgICAgICBub2RlVHJhbnNmb3JtcyxcclxuICAgICAgICBkaXJlY3RpdmVUcmFuc2Zvcm1zLFxyXG4gICAgICAgIHRyYW5zZm9ybUhvaXN0LFxyXG4gICAgICAgIGlzQnVpbHRJbkNvbXBvbmVudCxcclxuICAgICAgICBpc0N1c3RvbUVsZW1lbnQsXHJcbiAgICAgICAgZXhwcmVzc2lvblBsdWdpbnMsXHJcbiAgICAgICAgc2NvcGVJZCxcclxuICAgICAgICBzbG90dGVkLFxyXG4gICAgICAgIHNzcixcclxuICAgICAgICBzc3JDc3NWYXJzLFxyXG4gICAgICAgIGJpbmRpbmdNZXRhZGF0YSxcclxuICAgICAgICBpbmxpbmUsXHJcbiAgICAgICAgaXNUUyxcclxuICAgICAgICBvbkVycm9yLFxyXG4gICAgICAgIG9uV2FybixcclxuICAgICAgICBjb21wYXRDb25maWcsXHJcbiAgICAgICAgLy8gc3RhdGVcclxuICAgICAgICByb290LFxyXG4gICAgICAgIGhlbHBlcnM6IG5ldyBNYXAoKSxcclxuICAgICAgICBjb21wb25lbnRzOiBuZXcgU2V0KCksXHJcbiAgICAgICAgZGlyZWN0aXZlczogbmV3IFNldCgpLFxyXG4gICAgICAgIGhvaXN0czogW10sXHJcbiAgICAgICAgaW1wb3J0czogW10sXHJcbiAgICAgICAgY29uc3RhbnRDYWNoZTogbmV3IE1hcCgpLFxyXG4gICAgICAgIHRlbXBzOiAwLFxyXG4gICAgICAgIGNhY2hlZDogMCxcclxuICAgICAgICBpZGVudGlmaWVyczogT2JqZWN0LmNyZWF0ZShudWxsKSxcclxuICAgICAgICBzY29wZXM6IHtcclxuICAgICAgICAgICAgdkZvcjogMCxcclxuICAgICAgICAgICAgdlNsb3Q6IDAsXHJcbiAgICAgICAgICAgIHZQcmU6IDAsXHJcbiAgICAgICAgICAgIHZPbmNlOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICBwYXJlbnQ6IG51bGwsXHJcbiAgICAgICAgY3VycmVudE5vZGU6IHJvb3QsXHJcbiAgICAgICAgY2hpbGRJbmRleDogMCxcclxuICAgICAgICAvLyBtZXRob2RzXHJcbiAgICAgICAgaGVscGVyKG5hbWUpIHtcclxuICAgICAgICAgICAgY29uc3QgY291bnQgPSBjb250ZXh0LmhlbHBlcnMuZ2V0KG5hbWUpIHx8IDA7XHJcbiAgICAgICAgICAgIGNvbnRleHQuaGVscGVycy5zZXQobmFtZSwgY291bnQgKyAxKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZW1vdmVIZWxwZXIobmFtZSkge1xyXG4gICAgICAgICAgICBjb25zdCBjb3VudCA9IGNvbnRleHQuaGVscGVycy5nZXQobmFtZSk7XHJcbiAgICAgICAgICAgIGlmIChjb3VudCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudENvdW50ID0gY291bnQgLSAxO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50Q291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmhlbHBlcnMuZGVsZXRlKG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5oZWxwZXJzLnNldChuYW1lLCBjdXJyZW50Q291bnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBoZWxwZXJTdHJpbmcobmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYF8ke2hlbHBlck5hbWVNYXBbY29udGV4dC5oZWxwZXIobmFtZSldfWA7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZXBsYWNlTm9kZShub2RlKSB7XHJcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHQuY3VycmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vZGUgYmVpbmcgcmVwbGFjZWQgaXMgYWxyZWFkeSByZW1vdmVkLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFjb250ZXh0LnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlcGxhY2Ugcm9vdCBub2RlLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnRleHQucGFyZW50LmNoaWxkcmVuW2NvbnRleHQuY2hpbGRJbmRleF0gPSBjb250ZXh0LmN1cnJlbnROb2RlID0gbm9kZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlbW92ZU5vZGUobm9kZSkge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFjb250ZXh0LnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVtb3ZlIHJvb3Qgbm9kZS5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBsaXN0ID0gY29udGV4dC5wYXJlbnQuY2hpbGRyZW47XHJcbiAgICAgICAgICAgIGNvbnN0IHJlbW92YWxJbmRleCA9IG5vZGVcclxuICAgICAgICAgICAgICAgID8gbGlzdC5pbmRleE9mKG5vZGUpXHJcbiAgICAgICAgICAgICAgICA6IGNvbnRleHQuY3VycmVudE5vZGVcclxuICAgICAgICAgICAgICAgICAgICA/IGNvbnRleHQuY2hpbGRJbmRleFxyXG4gICAgICAgICAgICAgICAgICAgIDogLTE7XHJcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHJlbW92YWxJbmRleCA8IDApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbm9kZSBiZWluZyByZW1vdmVkIGlzIG5vdCBhIGNoaWxkIG9mIGN1cnJlbnQgcGFyZW50YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFub2RlIHx8IG5vZGUgPT09IGNvbnRleHQuY3VycmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgbm9kZSByZW1vdmVkXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmN1cnJlbnROb2RlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQub25Ob2RlUmVtb3ZlZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gc2libGluZyBub2RlIHJlbW92ZWRcclxuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LmNoaWxkSW5kZXggPiByZW1vdmFsSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmNoaWxkSW5kZXgtLTtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9uTm9kZVJlbW92ZWQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb250ZXh0LnBhcmVudC5jaGlsZHJlbi5zcGxpY2UocmVtb3ZhbEluZGV4LCAxKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uTm9kZVJlbW92ZWQ6ICgpID0+IHsgfSxcclxuICAgICAgICBhZGRJZGVudGlmaWVycyhleHApIHtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlbW92ZUlkZW50aWZpZXJzKGV4cCkge1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaG9pc3QoZXhwKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuaG9pc3RzLnB1c2goZXhwKTtcclxuICAgICAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYF9ob2lzdGVkXyR7Y29udGV4dC5ob2lzdHMubGVuZ3RofWAsIGZhbHNlLCBleHAubG9jLCAyIC8qIENBTl9IT0lTVCAqLyk7XHJcbiAgICAgICAgICAgIGlkZW50aWZpZXIuaG9pc3RlZCA9IGV4cDtcclxuICAgICAgICAgICAgcmV0dXJuIGlkZW50aWZpZXI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjYWNoZShleHAsIGlzVk5vZGUgPSBmYWxzZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlQ2FjaGVFeHByZXNzaW9uKCsrY29udGV4dC5jYWNoZWQsIGV4cCwgaXNWTm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHtcclxuICAgICAgICBjb250ZXh0LmZpbHRlcnMgPSBuZXcgU2V0KCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29udGV4dDtcclxufVxyXG5mdW5jdGlvbiB0cmFuc2Zvcm0ocm9vdCwgb3B0aW9ucykge1xyXG4gICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZVRyYW5zZm9ybUNvbnRleHQocm9vdCwgb3B0aW9ucyk7XHJcbiAgICB0cmF2ZXJzZU5vZGUocm9vdCwgY29udGV4dCk7XHJcbiAgICBpZiAob3B0aW9ucy5ob2lzdFN0YXRpYykge1xyXG4gICAgICAgIGhvaXN0U3RhdGljKHJvb3QsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFvcHRpb25zLnNzcikge1xyXG4gICAgICAgIGNyZWF0ZVJvb3RDb2RlZ2VuKHJvb3QsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgLy8gZmluYWxpemUgbWV0YSBpbmZvcm1hdGlvblxyXG4gICAgcm9vdC5oZWxwZXJzID0gWy4uLmNvbnRleHQuaGVscGVycy5rZXlzKCldO1xyXG4gICAgcm9vdC5jb21wb25lbnRzID0gWy4uLmNvbnRleHQuY29tcG9uZW50c107XHJcbiAgICByb290LmRpcmVjdGl2ZXMgPSBbLi4uY29udGV4dC5kaXJlY3RpdmVzXTtcclxuICAgIHJvb3QuaW1wb3J0cyA9IGNvbnRleHQuaW1wb3J0cztcclxuICAgIHJvb3QuaG9pc3RzID0gY29udGV4dC5ob2lzdHM7XHJcbiAgICByb290LnRlbXBzID0gY29udGV4dC50ZW1wcztcclxuICAgIHJvb3QuY2FjaGVkID0gY29udGV4dC5jYWNoZWQ7XHJcbiAgICB7XHJcbiAgICAgICAgcm9vdC5maWx0ZXJzID0gWy4uLmNvbnRleHQuZmlsdGVyc107XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUm9vdENvZGVnZW4ocm9vdCwgY29udGV4dCkge1xyXG4gICAgY29uc3QgeyBoZWxwZXIsIHJlbW92ZUhlbHBlciB9ID0gY29udGV4dDtcclxuICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHJvb3Q7XHJcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlblswXTtcclxuICAgICAgICAvLyBpZiB0aGUgc2luZ2xlIGNoaWxkIGlzIGFuIGVsZW1lbnQsIHR1cm4gaXQgaW50byBhIGJsb2NrLlxyXG4gICAgICAgIGlmIChpc1NpbmdsZUVsZW1lbnRSb290KHJvb3QsIGNoaWxkKSAmJiBjaGlsZC5jb2RlZ2VuTm9kZSkge1xyXG4gICAgICAgICAgICAvLyBzaW5nbGUgZWxlbWVudCByb290IGlzIG5ldmVyIGhvaXN0ZWQgc28gY29kZWdlbk5vZGUgd2lsbCBuZXZlciBiZVxyXG4gICAgICAgICAgICAvLyBTaW1wbGVFeHByZXNzaW9uTm9kZVxyXG4gICAgICAgICAgICBjb25zdCBjb2RlZ2VuTm9kZSA9IGNoaWxkLmNvZGVnZW5Ob2RlO1xyXG4gICAgICAgICAgICBpZiAoY29kZWdlbk5vZGUudHlwZSA9PT0gMTMgLyogVk5PREVfQ0FMTCAqLykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjb2RlZ2VuTm9kZS5pc0Jsb2NrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlSGVscGVyKENSRUFURV9WTk9ERSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29kZWdlbk5vZGUuaXNCbG9jayA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVscGVyKE9QRU5fQkxPQ0spO1xyXG4gICAgICAgICAgICAgICAgICAgIGhlbHBlcihDUkVBVEVfQkxPQ0spO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJvb3QuY29kZWdlbk5vZGUgPSBjb2RlZ2VuTm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIC0gc2luZ2xlIDxzbG90Lz4sIElmTm9kZSwgRm9yTm9kZTogYWxyZWFkeSBibG9ja3MuXHJcbiAgICAgICAgICAgIC8vIC0gc2luZ2xlIHRleHQgbm9kZTogYWx3YXlzIHBhdGNoZWQuXHJcbiAgICAgICAgICAgIC8vIHJvb3QgY29kZWdlbiBmYWxscyB0aHJvdWdoIHZpYSBnZW5Ob2RlKClcclxuICAgICAgICAgICAgcm9vdC5jb2RlZ2VuTm9kZSA9IGNoaWxkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAvLyByb290IGhhcyBtdWx0aXBsZSBub2RlcyAtIHJldHVybiBhIGZyYWdtZW50IGJsb2NrLlxyXG4gICAgICAgIGxldCBwYXRjaEZsYWcgPSA2NCAvKiBTVEFCTEVfRlJBR01FTlQgKi87XHJcbiAgICAgICAgbGV0IHBhdGNoRmxhZ1RleHQgPSBQYXRjaEZsYWdOYW1lc1s2NCAvKiBTVEFCTEVfRlJBR01FTlQgKi9dO1xyXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBmcmFnbWVudCBhY3R1YWxseSBjb250YWlucyBhIHNpbmdsZSB2YWxpZCBjaGlsZCB3aXRoXHJcbiAgICAgICAgLy8gdGhlIHJlc3QgYmVpbmcgY29tbWVudHNcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgIGNoaWxkcmVuLmZpbHRlcihjID0+IGMudHlwZSAhPT0gMyAvKiBDT01NRU5UICovKS5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgcGF0Y2hGbGFnIHw9IDIwNDggLyogREVWX1JPT1RfRlJBR01FTlQgKi87XHJcbiAgICAgICAgICAgIHBhdGNoRmxhZ1RleHQgKz0gYCwgJHtQYXRjaEZsYWdOYW1lc1syMDQ4IC8qIERFVl9ST09UX0ZSQUdNRU5UICovXX1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICByb290LmNvZGVnZW5Ob2RlID0gY3JlYXRlVk5vZGVDYWxsKGNvbnRleHQsIGhlbHBlcihGUkFHTUVOVCksIHVuZGVmaW5lZCwgcm9vdC5jaGlsZHJlbiwgcGF0Y2hGbGFnICsgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGAgLyogJHtwYXRjaEZsYWdUZXh0fSAqL2AgOiBgYCksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cnVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgO1xyXG59XHJcbmZ1bmN0aW9uIHRyYXZlcnNlQ2hpbGRyZW4ocGFyZW50LCBjb250ZXh0KSB7XHJcbiAgICBsZXQgaSA9IDA7XHJcbiAgICBjb25zdCBub2RlUmVtb3ZlZCA9ICgpID0+IHtcclxuICAgICAgICBpLS07XHJcbiAgICB9O1xyXG4gICAgZm9yICg7IGkgPCBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBjaGlsZCA9IHBhcmVudC5jaGlsZHJlbltpXTtcclxuICAgICAgICBpZiAoaXNTdHJpbmcoY2hpbGQpKVxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICBjb250ZXh0LnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICBjb250ZXh0LmNoaWxkSW5kZXggPSBpO1xyXG4gICAgICAgIGNvbnRleHQub25Ob2RlUmVtb3ZlZCA9IG5vZGVSZW1vdmVkO1xyXG4gICAgICAgIHRyYXZlcnNlTm9kZShjaGlsZCwgY29udGV4dCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdHJhdmVyc2VOb2RlKG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGNvbnRleHQuY3VycmVudE5vZGUgPSBub2RlO1xyXG4gICAgLy8gYXBwbHkgdHJhbnNmb3JtIHBsdWdpbnNcclxuICAgIGNvbnN0IHsgbm9kZVRyYW5zZm9ybXMgfSA9IGNvbnRleHQ7XHJcbiAgICBjb25zdCBleGl0Rm5zID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVUcmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3Qgb25FeGl0ID0gbm9kZVRyYW5zZm9ybXNbaV0obm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgaWYgKG9uRXhpdCkge1xyXG4gICAgICAgICAgICBpZiAoaXNBcnJheShvbkV4aXQpKSB7XHJcbiAgICAgICAgICAgICAgICBleGl0Rm5zLnB1c2goLi4ub25FeGl0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGV4aXRGbnMucHVzaChvbkV4aXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghY29udGV4dC5jdXJyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAvLyBub2RlIHdhcyByZW1vdmVkXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIG5vZGUgbWF5IGhhdmUgYmVlbiByZXBsYWNlZFxyXG4gICAgICAgICAgICBub2RlID0gY29udGV4dC5jdXJyZW50Tm9kZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xyXG4gICAgICAgIGNhc2UgMyAvKiBDT01NRU5UICovOlxyXG4gICAgICAgICAgICBpZiAoIWNvbnRleHQuc3NyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpbmplY3QgaW1wb3J0IGZvciB0aGUgQ29tbWVudCBzeW1ib2wsIHdoaWNoIGlzIG5lZWRlZCBmb3IgY3JlYXRpbmdcclxuICAgICAgICAgICAgICAgIC8vIGNvbW1lbnQgbm9kZXMgd2l0aCBgY3JlYXRlVk5vZGVgXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmhlbHBlcihDUkVBVEVfQ09NTUVOVCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSA1IC8qIElOVEVSUE9MQVRJT04gKi86XHJcbiAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gdHJhdmVyc2UsIGJ1dCB3ZSBuZWVkIHRvIGluamVjdCB0b1N0cmluZyBoZWxwZXJcclxuICAgICAgICAgICAgaWYgKCFjb250ZXh0LnNzcikge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5oZWxwZXIoVE9fRElTUExBWV9TVFJJTkcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIC8vIGZvciBjb250YWluZXIgdHlwZXMsIGZ1cnRoZXIgdHJhdmVyc2UgZG93bndhcmRzXHJcbiAgICAgICAgY2FzZSA5IC8qIElGICovOlxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuYnJhbmNoZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRyYXZlcnNlTm9kZShub2RlLmJyYW5jaGVzW2ldLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDEwIC8qIElGX0JSQU5DSCAqLzpcclxuICAgICAgICBjYXNlIDExIC8qIEZPUiAqLzpcclxuICAgICAgICBjYXNlIDEgLyogRUxFTUVOVCAqLzpcclxuICAgICAgICBjYXNlIDAgLyogUk9PVCAqLzpcclxuICAgICAgICAgICAgdHJhdmVyc2VDaGlsZHJlbihub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICAvLyBleGl0IHRyYW5zZm9ybXNcclxuICAgIGNvbnRleHQuY3VycmVudE5vZGUgPSBub2RlO1xyXG4gICAgbGV0IGkgPSBleGl0Rm5zLmxlbmd0aDtcclxuICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICBleGl0Rm5zW2ldKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlU3RydWN0dXJhbERpcmVjdGl2ZVRyYW5zZm9ybShuYW1lLCBmbikge1xyXG4gICAgY29uc3QgbWF0Y2hlcyA9IGlzU3RyaW5nKG5hbWUpXHJcbiAgICAgICAgPyAobikgPT4gbiA9PT0gbmFtZVxyXG4gICAgICAgIDogKG4pID0+IG5hbWUudGVzdChuKTtcclxuICAgIHJldHVybiAobm9kZSwgY29udGV4dCkgPT4ge1xyXG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLykge1xyXG4gICAgICAgICAgICBjb25zdCB7IHByb3BzIH0gPSBub2RlO1xyXG4gICAgICAgICAgICAvLyBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZSB0cmFuc2Zvcm1zIGFyZSBub3QgY29uY2VybmVkIHdpdGggc2xvdHNcclxuICAgICAgICAgICAgLy8gYXMgdGhleSBhcmUgaGFuZGxlZCBzZXBhcmF0ZWx5IGluIHZTbG90LnRzXHJcbiAgICAgICAgICAgIGlmIChub2RlLnRhZ1R5cGUgPT09IDMgLyogVEVNUExBVEUgKi8gJiYgcHJvcHMuc29tZShpc1ZTbG90KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGV4aXRGbnMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcCA9IHByb3BzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb3AudHlwZSA9PT0gNyAvKiBESVJFQ1RJVkUgKi8gJiYgbWF0Y2hlcyhwcm9wLm5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RydWN0dXJhbCBkaXJlY3RpdmVzIGFyZSByZW1vdmVkIHRvIGF2b2lkIGluZmluaXRlIHJlY3Vyc2lvblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsc28gd2UgcmVtb3ZlIHRoZW0gKmJlZm9yZSogYXBwbHlpbmcgc28gdGhhdCBpdCBjYW4gZnVydGhlclxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRyYXZlcnNlIGl0c2VsZiBpbiBjYXNlIGl0IG1vdmVzIHRoZSBub2RlIGFyb3VuZFxyXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICBpLS07XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb25FeGl0ID0gZm4obm9kZSwgcHJvcCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uRXhpdClcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhpdEZucy5wdXNoKG9uRXhpdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGV4aXRGbnM7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxuXG5jb25zdCBQVVJFX0FOTk9UQVRJT04gPSBgLyojX19QVVJFX18qL2A7XHJcbmZ1bmN0aW9uIGNyZWF0ZUNvZGVnZW5Db250ZXh0KGFzdCwgeyBtb2RlID0gJ2Z1bmN0aW9uJywgcHJlZml4SWRlbnRpZmllcnMgPSBtb2RlID09PSAnbW9kdWxlJywgc291cmNlTWFwID0gZmFsc2UsIGZpbGVuYW1lID0gYHRlbXBsYXRlLnZ1ZS5odG1sYCwgc2NvcGVJZCA9IG51bGwsIG9wdGltaXplSW1wb3J0cyA9IGZhbHNlLCBydW50aW1lR2xvYmFsTmFtZSA9IGBWdWVgLCBydW50aW1lTW9kdWxlTmFtZSA9IGB2dWVgLCBzc3IgPSBmYWxzZSB9KSB7XHJcbiAgICBjb25zdCBjb250ZXh0ID0ge1xyXG4gICAgICAgIG1vZGUsXHJcbiAgICAgICAgcHJlZml4SWRlbnRpZmllcnMsXHJcbiAgICAgICAgc291cmNlTWFwLFxyXG4gICAgICAgIGZpbGVuYW1lLFxyXG4gICAgICAgIHNjb3BlSWQsXHJcbiAgICAgICAgb3B0aW1pemVJbXBvcnRzLFxyXG4gICAgICAgIHJ1bnRpbWVHbG9iYWxOYW1lLFxyXG4gICAgICAgIHJ1bnRpbWVNb2R1bGVOYW1lLFxyXG4gICAgICAgIHNzcixcclxuICAgICAgICBzb3VyY2U6IGFzdC5sb2Muc291cmNlLFxyXG4gICAgICAgIGNvZGU6IGBgLFxyXG4gICAgICAgIGNvbHVtbjogMSxcclxuICAgICAgICBsaW5lOiAxLFxyXG4gICAgICAgIG9mZnNldDogMCxcclxuICAgICAgICBpbmRlbnRMZXZlbDogMCxcclxuICAgICAgICBwdXJlOiBmYWxzZSxcclxuICAgICAgICBtYXA6IHVuZGVmaW5lZCxcclxuICAgICAgICBoZWxwZXIoa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgXyR7aGVscGVyTmFtZU1hcFtrZXldfWA7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwdXNoKGNvZGUsIG5vZGUpIHtcclxuICAgICAgICAgICAgY29udGV4dC5jb2RlICs9IGNvZGU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpbmRlbnQoKSB7XHJcbiAgICAgICAgICAgIG5ld2xpbmUoKytjb250ZXh0LmluZGVudExldmVsKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlaW5kZW50KHdpdGhvdXROZXdMaW5lID0gZmFsc2UpIHtcclxuICAgICAgICAgICAgaWYgKHdpdGhvdXROZXdMaW5lKSB7XHJcbiAgICAgICAgICAgICAgICAtLWNvbnRleHQuaW5kZW50TGV2ZWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXdsaW5lKC0tY29udGV4dC5pbmRlbnRMZXZlbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG5ld2xpbmUoKSB7XHJcbiAgICAgICAgICAgIG5ld2xpbmUoY29udGV4dC5pbmRlbnRMZXZlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGZ1bmN0aW9uIG5ld2xpbmUobikge1xyXG4gICAgICAgIGNvbnRleHQucHVzaCgnXFxuJyArIGAgIGAucmVwZWF0KG4pKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjb250ZXh0O1xyXG59XHJcbmZ1bmN0aW9uIGdlbmVyYXRlKGFzdCwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlQ29kZWdlbkNvbnRleHQoYXN0LCBvcHRpb25zKTtcclxuICAgIGlmIChvcHRpb25zLm9uQ29udGV4dENyZWF0ZWQpXHJcbiAgICAgICAgb3B0aW9ucy5vbkNvbnRleHRDcmVhdGVkKGNvbnRleHQpO1xyXG4gICAgY29uc3QgeyBtb2RlLCBwdXNoLCBwcmVmaXhJZGVudGlmaWVycywgaW5kZW50LCBkZWluZGVudCwgbmV3bGluZSwgc2NvcGVJZCwgc3NyIH0gPSBjb250ZXh0O1xyXG4gICAgY29uc3QgaGFzSGVscGVycyA9IGFzdC5oZWxwZXJzLmxlbmd0aCA+IDA7XHJcbiAgICBjb25zdCB1c2VXaXRoQmxvY2sgPSAhcHJlZml4SWRlbnRpZmllcnMgJiYgbW9kZSAhPT0gJ21vZHVsZSc7XHJcbiAgICAvLyBwcmVhbWJsZXNcclxuICAgIC8vIGluIHNldHVwKCkgaW5saW5lIG1vZGUsIHRoZSBwcmVhbWJsZSBpcyBnZW5lcmF0ZWQgaW4gYSBzdWIgY29udGV4dFxyXG4gICAgLy8gYW5kIHJldHVybmVkIHNlcGFyYXRlbHkuXHJcbiAgICBjb25zdCBwcmVhbWJsZUNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAge1xyXG4gICAgICAgIGdlbkZ1bmN0aW9uUHJlYW1ibGUoYXN0LCBwcmVhbWJsZUNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgLy8gZW50ZXIgcmVuZGVyIGZ1bmN0aW9uXHJcbiAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSBzc3IgPyBgc3NyUmVuZGVyYCA6IGByZW5kZXJgO1xyXG4gICAgY29uc3QgYXJncyA9IHNzciA/IFsnX2N0eCcsICdfcHVzaCcsICdfcGFyZW50JywgJ19hdHRycyddIDogWydfY3R4JywgJ19jYWNoZSddO1xyXG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYXJncy5qb2luKCcsICcpO1xyXG4gICAge1xyXG4gICAgICAgIHB1c2goYGZ1bmN0aW9uICR7ZnVuY3Rpb25OYW1lfSgke3NpZ25hdHVyZX0pIHtgKTtcclxuICAgIH1cclxuICAgIGluZGVudCgpO1xyXG4gICAgaWYgKHVzZVdpdGhCbG9jaykge1xyXG4gICAgICAgIHB1c2goYHdpdGggKF9jdHgpIHtgKTtcclxuICAgICAgICBpbmRlbnQoKTtcclxuICAgICAgICAvLyBmdW5jdGlvbiBtb2RlIGNvbnN0IGRlY2xhcmF0aW9ucyBzaG91bGQgYmUgaW5zaWRlIHdpdGggYmxvY2tcclxuICAgICAgICAvLyBhbHNvIHRoZXkgc2hvdWxkIGJlIHJlbmFtZWQgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggdXNlciBwcm9wZXJ0aWVzXHJcbiAgICAgICAgaWYgKGhhc0hlbHBlcnMpIHtcclxuICAgICAgICAgICAgcHVzaChgY29uc3QgeyAke2FzdC5oZWxwZXJzXHJcbiAgICAgICAgICAgICAgICAubWFwKHMgPT4gYCR7aGVscGVyTmFtZU1hcFtzXX06IF8ke2hlbHBlck5hbWVNYXBbc119YClcclxuICAgICAgICAgICAgICAgIC5qb2luKCcsICcpfSB9ID0gX1Z1ZWApO1xyXG4gICAgICAgICAgICBwdXNoKGBcXG5gKTtcclxuICAgICAgICAgICAgbmV3bGluZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGdlbmVyYXRlIGFzc2V0IHJlc29sdXRpb24gc3RhdGVtZW50c1xyXG4gICAgaWYgKGFzdC5jb21wb25lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgIGdlbkFzc2V0cyhhc3QuY29tcG9uZW50cywgJ2NvbXBvbmVudCcsIGNvbnRleHQpO1xyXG4gICAgICAgIGlmIChhc3QuZGlyZWN0aXZlcy5sZW5ndGggfHwgYXN0LnRlbXBzID4gMCkge1xyXG4gICAgICAgICAgICBuZXdsaW5lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGFzdC5kaXJlY3RpdmVzLmxlbmd0aCkge1xyXG4gICAgICAgIGdlbkFzc2V0cyhhc3QuZGlyZWN0aXZlcywgJ2RpcmVjdGl2ZScsIGNvbnRleHQpO1xyXG4gICAgICAgIGlmIChhc3QudGVtcHMgPiAwKSB7XHJcbiAgICAgICAgICAgIG5ld2xpbmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoYXN0LmZpbHRlcnMgJiYgYXN0LmZpbHRlcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgbmV3bGluZSgpO1xyXG4gICAgICAgIGdlbkFzc2V0cyhhc3QuZmlsdGVycywgJ2ZpbHRlcicsIGNvbnRleHQpO1xyXG4gICAgICAgIG5ld2xpbmUoKTtcclxuICAgIH1cclxuICAgIGlmIChhc3QudGVtcHMgPiAwKSB7XHJcbiAgICAgICAgcHVzaChgbGV0IGApO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXN0LnRlbXBzOyBpKyspIHtcclxuICAgICAgICAgICAgcHVzaChgJHtpID4gMCA/IGAsIGAgOiBgYH1fdGVtcCR7aX1gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoYXN0LmNvbXBvbmVudHMubGVuZ3RoIHx8IGFzdC5kaXJlY3RpdmVzLmxlbmd0aCB8fCBhc3QudGVtcHMpIHtcclxuICAgICAgICBwdXNoKGBcXG5gKTtcclxuICAgICAgICBuZXdsaW5lKCk7XHJcbiAgICB9XHJcbiAgICAvLyBnZW5lcmF0ZSB0aGUgVk5vZGUgdHJlZSBleHByZXNzaW9uXHJcbiAgICBpZiAoIXNzcikge1xyXG4gICAgICAgIHB1c2goYHJldHVybiBgKTtcclxuICAgIH1cclxuICAgIGlmIChhc3QuY29kZWdlbk5vZGUpIHtcclxuICAgICAgICBnZW5Ob2RlKGFzdC5jb2RlZ2VuTm9kZSwgY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBwdXNoKGBudWxsYCk7XHJcbiAgICB9XHJcbiAgICBpZiAodXNlV2l0aEJsb2NrKSB7XHJcbiAgICAgICAgZGVpbmRlbnQoKTtcclxuICAgICAgICBwdXNoKGB9YCk7XHJcbiAgICB9XHJcbiAgICBkZWluZGVudCgpO1xyXG4gICAgcHVzaChgfWApO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBhc3QsXHJcbiAgICAgICAgY29kZTogY29udGV4dC5jb2RlLFxyXG4gICAgICAgIHByZWFtYmxlOiBgYCxcclxuICAgICAgICAvLyBTb3VyY2VNYXBHZW5lcmF0b3IgZG9lcyBoYXZlIHRvSlNPTigpIG1ldGhvZCBidXQgaXQncyBub3QgaW4gdGhlIHR5cGVzXHJcbiAgICAgICAgbWFwOiBjb250ZXh0Lm1hcCA/IGNvbnRleHQubWFwLnRvSlNPTigpIDogdW5kZWZpbmVkXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGdlbkZ1bmN0aW9uUHJlYW1ibGUoYXN0LCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCB7IHNzciwgcHJlZml4SWRlbnRpZmllcnMsIHB1c2gsIG5ld2xpbmUsIHJ1bnRpbWVNb2R1bGVOYW1lLCBydW50aW1lR2xvYmFsTmFtZSB9ID0gY29udGV4dDtcclxuICAgIGNvbnN0IFZ1ZUJpbmRpbmcgPSBydW50aW1lR2xvYmFsTmFtZTtcclxuICAgIGNvbnN0IGFsaWFzSGVscGVyID0gKHMpID0+IGAke2hlbHBlck5hbWVNYXBbc119OiBfJHtoZWxwZXJOYW1lTWFwW3NdfWA7XHJcbiAgICAvLyBHZW5lcmF0ZSBjb25zdCBkZWNsYXJhdGlvbiBmb3IgaGVscGVyc1xyXG4gICAgLy8gSW4gcHJlZml4IG1vZGUsIHdlIHBsYWNlIHRoZSBjb25zdCBkZWNsYXJhdGlvbiBhdCB0b3Agc28gaXQncyBkb25lXHJcbiAgICAvLyBvbmx5IG9uY2U7IEJ1dCBpZiB3ZSBub3QgcHJlZml4aW5nLCB3ZSBwbGFjZSB0aGUgZGVjbGFyYXRpb24gaW5zaWRlIHRoZVxyXG4gICAgLy8gd2l0aCBibG9jayBzbyBpdCBkb2Vzbid0IGluY3VyIHRoZSBgaW5gIGNoZWNrIGNvc3QgZm9yIGV2ZXJ5IGhlbHBlciBhY2Nlc3MuXHJcbiAgICBpZiAoYXN0LmhlbHBlcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gXCJ3aXRoXCIgbW9kZS5cclxuICAgICAgICAgICAgLy8gc2F2ZSBWdWUgaW4gYSBzZXBhcmF0ZSB2YXJpYWJsZSB0byBhdm9pZCBjb2xsaXNpb25cclxuICAgICAgICAgICAgcHVzaChgY29uc3QgX1Z1ZSA9ICR7VnVlQmluZGluZ31cXG5gKTtcclxuICAgICAgICAgICAgLy8gaW4gXCJ3aXRoXCIgbW9kZSwgaGVscGVycyBhcmUgZGVjbGFyZWQgaW5zaWRlIHRoZSB3aXRoIGJsb2NrIHRvIGF2b2lkXHJcbiAgICAgICAgICAgIC8vIGhhcyBjaGVjayBjb3N0LCBidXQgaG9pc3RzIGFyZSBsaWZ0ZWQgb3V0IG9mIHRoZSBmdW5jdGlvbiAtIHdlIG5lZWRcclxuICAgICAgICAgICAgLy8gdG8gcHJvdmlkZSB0aGUgaGVscGVyIGhlcmUuXHJcbiAgICAgICAgICAgIGlmIChhc3QuaG9pc3RzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdGljSGVscGVycyA9IFtcclxuICAgICAgICAgICAgICAgICAgICBDUkVBVEVfVk5PREUsXHJcbiAgICAgICAgICAgICAgICAgICAgQ1JFQVRFX0NPTU1FTlQsXHJcbiAgICAgICAgICAgICAgICAgICAgQ1JFQVRFX1RFWFQsXHJcbiAgICAgICAgICAgICAgICAgICAgQ1JFQVRFX1NUQVRJQ1xyXG4gICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoaGVscGVyID0+IGFzdC5oZWxwZXJzLmluY2x1ZGVzKGhlbHBlcikpXHJcbiAgICAgICAgICAgICAgICAgICAgLm1hcChhbGlhc0hlbHBlcilcclxuICAgICAgICAgICAgICAgICAgICAuam9pbignLCAnKTtcclxuICAgICAgICAgICAgICAgIHB1c2goYGNvbnN0IHsgJHtzdGF0aWNIZWxwZXJzfSB9ID0gX1Z1ZVxcbmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2VuSG9pc3RzKGFzdC5ob2lzdHMsIGNvbnRleHQpO1xyXG4gICAgbmV3bGluZSgpO1xyXG4gICAgcHVzaChgcmV0dXJuIGApO1xyXG59XHJcbmZ1bmN0aW9uIGdlbkFzc2V0cyhhc3NldHMsIHR5cGUsIHsgaGVscGVyLCBwdXNoLCBuZXdsaW5lIH0pIHtcclxuICAgIGNvbnN0IHJlc29sdmVyID0gaGVscGVyKHR5cGUgPT09ICdmaWx0ZXInXHJcbiAgICAgICAgPyBSRVNPTFZFX0ZJTFRFUlxyXG4gICAgICAgIDogdHlwZSA9PT0gJ2NvbXBvbmVudCdcclxuICAgICAgICAgICAgPyBSRVNPTFZFX0NPTVBPTkVOVFxyXG4gICAgICAgICAgICA6IFJFU09MVkVfRElSRUNUSVZFKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXNzZXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IGlkID0gYXNzZXRzW2ldO1xyXG4gICAgICAgIC8vIHBvdGVudGlhbCBjb21wb25lbnQgaW1wbGljaXQgc2VsZi1yZWZlcmVuY2UgaW5mZXJyZWQgZnJvbSBTRkMgZmlsZW5hbWVcclxuICAgICAgICBjb25zdCBtYXliZVNlbGZSZWZlcmVuY2UgPSBpZC5lbmRzV2l0aCgnX19zZWxmJyk7XHJcbiAgICAgICAgaWYgKG1heWJlU2VsZlJlZmVyZW5jZSkge1xyXG4gICAgICAgICAgICBpZCA9IGlkLnNsaWNlKDAsIC02KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVzaChgY29uc3QgJHt0b1ZhbGlkQXNzZXRJZChpZCwgdHlwZSl9ID0gJHtyZXNvbHZlcn0oJHtKU09OLnN0cmluZ2lmeShpZCl9JHttYXliZVNlbGZSZWZlcmVuY2UgPyBgLCB0cnVlYCA6IGBgfSlgKTtcclxuICAgICAgICBpZiAoaSA8IGFzc2V0cy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgIG5ld2xpbmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2VuSG9pc3RzKGhvaXN0cywgY29udGV4dCkge1xyXG4gICAgaWYgKCFob2lzdHMubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29udGV4dC5wdXJlID0gdHJ1ZTtcclxuICAgIGNvbnN0IHsgcHVzaCwgbmV3bGluZSwgaGVscGVyLCBzY29wZUlkLCBtb2RlIH0gPSBjb250ZXh0O1xyXG4gICAgbmV3bGluZSgpO1xyXG4gICAgaG9pc3RzLmZvckVhY2goKGV4cCwgaSkgPT4ge1xyXG4gICAgICAgIGlmIChleHApIHtcclxuICAgICAgICAgICAgcHVzaChgY29uc3QgX2hvaXN0ZWRfJHtpICsgMX0gPSBgKTtcclxuICAgICAgICAgICAgZ2VuTm9kZShleHAsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBuZXdsaW5lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBjb250ZXh0LnB1cmUgPSBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBpc1RleHQkMShuKSB7XHJcbiAgICByZXR1cm4gKGlzU3RyaW5nKG4pIHx8XHJcbiAgICAgICAgbi50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovIHx8XHJcbiAgICAgICAgbi50eXBlID09PSAyIC8qIFRFWFQgKi8gfHxcclxuICAgICAgICBuLnR5cGUgPT09IDUgLyogSU5URVJQT0xBVElPTiAqLyB8fFxyXG4gICAgICAgIG4udHlwZSA9PT0gOCAvKiBDT01QT1VORF9FWFBSRVNTSU9OICovKTtcclxufVxyXG5mdW5jdGlvbiBnZW5Ob2RlTGlzdEFzQXJyYXkobm9kZXMsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IG11bHRpbGluZXMgPSBub2Rlcy5sZW5ndGggPiAzIHx8XHJcbiAgICAgICAgKCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpICYmIG5vZGVzLnNvbWUobiA9PiBpc0FycmF5KG4pIHx8ICFpc1RleHQkMShuKSkpO1xyXG4gICAgY29udGV4dC5wdXNoKGBbYCk7XHJcbiAgICBtdWx0aWxpbmVzICYmIGNvbnRleHQuaW5kZW50KCk7XHJcbiAgICBnZW5Ob2RlTGlzdChub2RlcywgY29udGV4dCwgbXVsdGlsaW5lcyk7XHJcbiAgICBtdWx0aWxpbmVzICYmIGNvbnRleHQuZGVpbmRlbnQoKTtcclxuICAgIGNvbnRleHQucHVzaChgXWApO1xyXG59XHJcbmZ1bmN0aW9uIGdlbk5vZGVMaXN0KG5vZGVzLCBjb250ZXh0LCBtdWx0aWxpbmVzID0gZmFsc2UsIGNvbW1hID0gdHJ1ZSkge1xyXG4gICAgY29uc3QgeyBwdXNoLCBuZXdsaW5lIH0gPSBjb250ZXh0O1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcclxuICAgICAgICBpZiAoaXNTdHJpbmcobm9kZSkpIHtcclxuICAgICAgICAgICAgcHVzaChub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNBcnJheShub2RlKSkge1xyXG4gICAgICAgICAgICBnZW5Ob2RlTGlzdEFzQXJyYXkobm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBnZW5Ob2RlKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaSA8IG5vZGVzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgaWYgKG11bHRpbGluZXMpIHtcclxuICAgICAgICAgICAgICAgIGNvbW1hICYmIHB1c2goJywnKTtcclxuICAgICAgICAgICAgICAgIG5ld2xpbmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbW1hICYmIHB1c2goJywgJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2VuTm9kZShub2RlLCBjb250ZXh0KSB7XHJcbiAgICBpZiAoaXNTdHJpbmcobm9kZSkpIHtcclxuICAgICAgICBjb250ZXh0LnB1c2gobm9kZSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzU3ltYm9sKG5vZGUpKSB7XHJcbiAgICAgICAgY29udGV4dC5wdXNoKGNvbnRleHQuaGVscGVyKG5vZGUpKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xyXG4gICAgICAgIGNhc2UgMSAvKiBFTEVNRU5UICovOlxyXG4gICAgICAgIGNhc2UgOSAvKiBJRiAqLzpcclxuICAgICAgICBjYXNlIDExIC8qIEZPUiAqLzpcclxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICBhc3NlcnQobm9kZS5jb2RlZ2VuTm9kZSAhPSBudWxsLCBgQ29kZWdlbiBub2RlIGlzIG1pc3NpbmcgZm9yIGVsZW1lbnQvaWYvZm9yIG5vZGUuIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBBcHBseSBhcHByb3ByaWF0ZSB0cmFuc2Zvcm1zIGZpcnN0LmApO1xyXG4gICAgICAgICAgICBnZW5Ob2RlKG5vZGUuY29kZWdlbk5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDIgLyogVEVYVCAqLzpcclxuICAgICAgICAgICAgZ2VuVGV4dChub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovOlxyXG4gICAgICAgICAgICBnZW5FeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDUgLyogSU5URVJQT0xBVElPTiAqLzpcclxuICAgICAgICAgICAgZ2VuSW50ZXJwb2xhdGlvbihub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAxMiAvKiBURVhUX0NBTEwgKi86XHJcbiAgICAgICAgICAgIGdlbk5vZGUobm9kZS5jb2RlZ2VuTm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgOCAvKiBDT01QT1VORF9FWFBSRVNTSU9OICovOlxyXG4gICAgICAgICAgICBnZW5Db21wb3VuZEV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMyAvKiBDT01NRU5UICovOlxyXG4gICAgICAgICAgICBnZW5Db21tZW50KG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDEzIC8qIFZOT0RFX0NBTEwgKi86XHJcbiAgICAgICAgICAgIGdlblZOb2RlQ2FsbChub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAxNCAvKiBKU19DQUxMX0VYUFJFU1NJT04gKi86XHJcbiAgICAgICAgICAgIGdlbkNhbGxFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDE1IC8qIEpTX09CSkVDVF9FWFBSRVNTSU9OICovOlxyXG4gICAgICAgICAgICBnZW5PYmplY3RFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDE3IC8qIEpTX0FSUkFZX0VYUFJFU1NJT04gKi86XHJcbiAgICAgICAgICAgIGdlbkFycmF5RXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAxOCAvKiBKU19GVU5DVElPTl9FWFBSRVNTSU9OICovOlxyXG4gICAgICAgICAgICBnZW5GdW5jdGlvbkV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMTkgLyogSlNfQ09ORElUSU9OQUxfRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgZ2VuQ29uZGl0aW9uYWxFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDIwIC8qIEpTX0NBQ0hFX0VYUFJFU1NJT04gKi86XHJcbiAgICAgICAgICAgIGdlbkNhY2hlRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgLy8gU1NSIG9ubHkgdHlwZXNcclxuICAgICAgICBjYXNlIDIxIC8qIEpTX0JMT0NLX1NUQVRFTUVOVCAqLzpcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAyMiAvKiBKU19URU1QTEFURV9MSVRFUkFMICovOlxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDIzIC8qIEpTX0lGX1NUQVRFTUVOVCAqLzpcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAyNCAvKiBKU19BU1NJR05NRU5UX0VYUFJFU1NJT04gKi86XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMjUgLyogSlNfU0VRVUVOQ0VfRVhQUkVTU0lPTiAqLzpcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAyNiAvKiBKU19SRVRVUk5fU1RBVEVNRU5UICovOlxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGNhc2UgMTAgLyogSUZfQlJBTkNIICovOlxyXG4gICAgICAgICAgICAvLyBub29wXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIGFzc2VydChmYWxzZSwgYHVuaGFuZGxlZCBjb2RlZ2VuIG5vZGUgdHlwZTogJHtub2RlLnR5cGV9YCk7XHJcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgd2UgZXhoYXVzdCBhbGwgcG9zc2libGUgdHlwZXNcclxuICAgICAgICAgICAgICAgIGNvbnN0IGV4aGF1c3RpdmVDaGVjayA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhoYXVzdGl2ZUNoZWNrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2VuVGV4dChub2RlLCBjb250ZXh0KSB7XHJcbiAgICBjb250ZXh0LnB1c2goSlNPTi5zdHJpbmdpZnkobm9kZS5jb250ZW50KSwgbm9kZSk7XHJcbn1cclxuZnVuY3Rpb24gZ2VuRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCB7IGNvbnRlbnQsIGlzU3RhdGljIH0gPSBub2RlO1xyXG4gICAgY29udGV4dC5wdXNoKGlzU3RhdGljID8gSlNPTi5zdHJpbmdpZnkoY29udGVudCkgOiBjb250ZW50LCBub2RlKTtcclxufVxyXG5mdW5jdGlvbiBnZW5JbnRlcnBvbGF0aW9uKG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHsgcHVzaCwgaGVscGVyLCBwdXJlIH0gPSBjb250ZXh0O1xyXG4gICAgaWYgKHB1cmUpXHJcbiAgICAgICAgcHVzaChQVVJFX0FOTk9UQVRJT04pO1xyXG4gICAgcHVzaChgJHtoZWxwZXIoVE9fRElTUExBWV9TVFJJTkcpfShgKTtcclxuICAgIGdlbk5vZGUobm9kZS5jb250ZW50LCBjb250ZXh0KTtcclxuICAgIHB1c2goYClgKTtcclxufVxyXG5mdW5jdGlvbiBnZW5Db21wb3VuZEV4cHJlc3Npb24obm9kZSwgY29udGV4dCkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xyXG4gICAgICAgIGlmIChpc1N0cmluZyhjaGlsZCkpIHtcclxuICAgICAgICAgICAgY29udGV4dC5wdXNoKGNoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGdlbk5vZGUoY2hpbGQsIGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZW5FeHByZXNzaW9uQXNQcm9wZXJ0eUtleShub2RlLCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCB7IHB1c2ggfSA9IGNvbnRleHQ7XHJcbiAgICBpZiAobm9kZS50eXBlID09PSA4IC8qIENPTVBPVU5EX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICBwdXNoKGBbYCk7XHJcbiAgICAgICAgZ2VuQ29tcG91bmRFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgIHB1c2goYF1gKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG5vZGUuaXNTdGF0aWMpIHtcclxuICAgICAgICAvLyBvbmx5IHF1b3RlIGtleXMgaWYgbmVjZXNzYXJ5XHJcbiAgICAgICAgY29uc3QgdGV4dCA9IGlzU2ltcGxlSWRlbnRpZmllcihub2RlLmNvbnRlbnQpXHJcbiAgICAgICAgICAgID8gbm9kZS5jb250ZW50XHJcbiAgICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkobm9kZS5jb250ZW50KTtcclxuICAgICAgICBwdXNoKHRleHQsIG5vZGUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcHVzaChgWyR7bm9kZS5jb250ZW50fV1gLCBub2RlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZW5Db21tZW50KG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHsgcHVzaCwgaGVscGVyLCBwdXJlIH0gPSBjb250ZXh0O1xyXG4gICAgaWYgKHB1cmUpIHtcclxuICAgICAgICBwdXNoKFBVUkVfQU5OT1RBVElPTik7XHJcbiAgICB9XHJcbiAgICBwdXNoKGAke2hlbHBlcihDUkVBVEVfQ09NTUVOVCl9KCR7SlNPTi5zdHJpbmdpZnkobm9kZS5jb250ZW50KX0pYCwgbm9kZSk7XHJcbn1cclxuZnVuY3Rpb24gZ2VuVk5vZGVDYWxsKG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHsgcHVzaCwgaGVscGVyLCBwdXJlIH0gPSBjb250ZXh0O1xyXG4gICAgY29uc3QgeyB0YWcsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHMsIGRpcmVjdGl2ZXMsIGlzQmxvY2ssIGRpc2FibGVUcmFja2luZyB9ID0gbm9kZTtcclxuICAgIGlmIChkaXJlY3RpdmVzKSB7XHJcbiAgICAgICAgcHVzaChoZWxwZXIoV0lUSF9ESVJFQ1RJVkVTKSArIGAoYCk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNCbG9jaykge1xyXG4gICAgICAgIHB1c2goYCgke2hlbHBlcihPUEVOX0JMT0NLKX0oJHtkaXNhYmxlVHJhY2tpbmcgPyBgdHJ1ZWAgOiBgYH0pLCBgKTtcclxuICAgIH1cclxuICAgIGlmIChwdXJlKSB7XHJcbiAgICAgICAgcHVzaChQVVJFX0FOTk9UQVRJT04pO1xyXG4gICAgfVxyXG4gICAgcHVzaChoZWxwZXIoaXNCbG9jayA/IENSRUFURV9CTE9DSyA6IENSRUFURV9WTk9ERSkgKyBgKGAsIG5vZGUpO1xyXG4gICAgZ2VuTm9kZUxpc3QoZ2VuTnVsbGFibGVBcmdzKFt0YWcsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHNdKSwgY29udGV4dCk7XHJcbiAgICBwdXNoKGApYCk7XHJcbiAgICBpZiAoaXNCbG9jaykge1xyXG4gICAgICAgIHB1c2goYClgKTtcclxuICAgIH1cclxuICAgIGlmIChkaXJlY3RpdmVzKSB7XHJcbiAgICAgICAgcHVzaChgLCBgKTtcclxuICAgICAgICBnZW5Ob2RlKGRpcmVjdGl2ZXMsIGNvbnRleHQpO1xyXG4gICAgICAgIHB1c2goYClgKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZW5OdWxsYWJsZUFyZ3MoYXJncykge1xyXG4gICAgbGV0IGkgPSBhcmdzLmxlbmd0aDtcclxuICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICBpZiAoYXJnc1tpXSAhPSBudWxsKVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIHJldHVybiBhcmdzLnNsaWNlKDAsIGkgKyAxKS5tYXAoYXJnID0+IGFyZyB8fCBgbnVsbGApO1xyXG59XHJcbi8vIEphdmFTY3JpcHRcclxuZnVuY3Rpb24gZ2VuQ2FsbEV4cHJlc3Npb24obm9kZSwgY29udGV4dCkge1xyXG4gICAgY29uc3QgeyBwdXNoLCBoZWxwZXIsIHB1cmUgfSA9IGNvbnRleHQ7XHJcbiAgICBjb25zdCBjYWxsZWUgPSBpc1N0cmluZyhub2RlLmNhbGxlZSkgPyBub2RlLmNhbGxlZSA6IGhlbHBlcihub2RlLmNhbGxlZSk7XHJcbiAgICBpZiAocHVyZSkge1xyXG4gICAgICAgIHB1c2goUFVSRV9BTk5PVEFUSU9OKTtcclxuICAgIH1cclxuICAgIHB1c2goY2FsbGVlICsgYChgLCBub2RlKTtcclxuICAgIGdlbk5vZGVMaXN0KG5vZGUuYXJndW1lbnRzLCBjb250ZXh0KTtcclxuICAgIHB1c2goYClgKTtcclxufVxyXG5mdW5jdGlvbiBnZW5PYmplY3RFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHsgcHVzaCwgaW5kZW50LCBkZWluZGVudCwgbmV3bGluZSB9ID0gY29udGV4dDtcclxuICAgIGNvbnN0IHsgcHJvcGVydGllcyB9ID0gbm9kZTtcclxuICAgIGlmICghcHJvcGVydGllcy5sZW5ndGgpIHtcclxuICAgICAgICBwdXNoKGB7fWAsIG5vZGUpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IG11bHRpbGluZXMgPSBwcm9wZXJ0aWVzLmxlbmd0aCA+IDEgfHxcclxuICAgICAgICAoKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkgJiZcclxuICAgICAgICAgICAgcHJvcGVydGllcy5zb21lKHAgPT4gcC52YWx1ZS50eXBlICE9PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovKSk7XHJcbiAgICBwdXNoKG11bHRpbGluZXMgPyBge2AgOiBgeyBgKTtcclxuICAgIG11bHRpbGluZXMgJiYgaW5kZW50KCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCB7IGtleSwgdmFsdWUgfSA9IHByb3BlcnRpZXNbaV07XHJcbiAgICAgICAgLy8ga2V5XHJcbiAgICAgICAgZ2VuRXhwcmVzc2lvbkFzUHJvcGVydHlLZXkoa2V5LCBjb250ZXh0KTtcclxuICAgICAgICBwdXNoKGA6IGApO1xyXG4gICAgICAgIC8vIHZhbHVlXHJcbiAgICAgICAgZ2VuTm9kZSh2YWx1ZSwgY29udGV4dCk7XHJcbiAgICAgICAgaWYgKGkgPCBwcm9wZXJ0aWVzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgLy8gd2lsbCBvbmx5IHJlYWNoIHRoaXMgaWYgaXQncyBtdWx0aWxpbmVzXHJcbiAgICAgICAgICAgIHB1c2goYCxgKTtcclxuICAgICAgICAgICAgbmV3bGluZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG11bHRpbGluZXMgJiYgZGVpbmRlbnQoKTtcclxuICAgIHB1c2gobXVsdGlsaW5lcyA/IGB9YCA6IGAgfWApO1xyXG59XHJcbmZ1bmN0aW9uIGdlbkFycmF5RXhwcmVzc2lvbihub2RlLCBjb250ZXh0KSB7XHJcbiAgICBnZW5Ob2RlTGlzdEFzQXJyYXkobm9kZS5lbGVtZW50cywgY29udGV4dCk7XHJcbn1cclxuZnVuY3Rpb24gZ2VuRnVuY3Rpb25FeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IHsgcHVzaCwgaW5kZW50LCBkZWluZGVudCwgc2NvcGVJZCwgbW9kZSB9ID0gY29udGV4dDtcclxuICAgIGNvbnN0IHsgcGFyYW1zLCByZXR1cm5zLCBib2R5LCBuZXdsaW5lLCBpc1Nsb3QgfSA9IG5vZGU7XHJcbiAgICBpZiAoaXNTbG90KSB7XHJcbiAgICAgICAgLy8gd3JhcCBzbG90IGZ1bmN0aW9ucyB3aXRoIG93bmVyIGNvbnRleHRcclxuICAgICAgICBwdXNoKGBfJHtoZWxwZXJOYW1lTWFwW1dJVEhfQ1RYXX0oYCk7XHJcbiAgICB9XHJcbiAgICBwdXNoKGAoYCwgbm9kZSk7XHJcbiAgICBpZiAoaXNBcnJheShwYXJhbXMpKSB7XHJcbiAgICAgICAgZ2VuTm9kZUxpc3QocGFyYW1zLCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHBhcmFtcykge1xyXG4gICAgICAgIGdlbk5vZGUocGFyYW1zLCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIHB1c2goYCkgPT4gYCk7XHJcbiAgICBpZiAobmV3bGluZSB8fCBib2R5KSB7XHJcbiAgICAgICAgcHVzaChge2ApO1xyXG4gICAgICAgIGluZGVudCgpO1xyXG4gICAgfVxyXG4gICAgaWYgKHJldHVybnMpIHtcclxuICAgICAgICBpZiAobmV3bGluZSkge1xyXG4gICAgICAgICAgICBwdXNoKGByZXR1cm4gYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0FycmF5KHJldHVybnMpKSB7XHJcbiAgICAgICAgICAgIGdlbk5vZGVMaXN0QXNBcnJheShyZXR1cm5zLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGdlbk5vZGUocmV0dXJucywgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYm9keSkge1xyXG4gICAgICAgIGdlbk5vZGUoYm9keSwgY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICBpZiAobmV3bGluZSB8fCBib2R5KSB7XHJcbiAgICAgICAgZGVpbmRlbnQoKTtcclxuICAgICAgICBwdXNoKGB9YCk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNTbG90KSB7XHJcbiAgICAgICAgaWYgKG5vZGUuaXNOb25TY29wZWRTbG90KSB7XHJcbiAgICAgICAgICAgIHB1c2goYCwgdW5kZWZpbmVkLCB0cnVlYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB1c2goYClgKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZW5Db25kaXRpb25hbEV4cHJlc3Npb24obm9kZSwgY29udGV4dCkge1xyXG4gICAgY29uc3QgeyB0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUsIG5ld2xpbmU6IG5lZWROZXdsaW5lIH0gPSBub2RlO1xyXG4gICAgY29uc3QgeyBwdXNoLCBpbmRlbnQsIGRlaW5kZW50LCBuZXdsaW5lIH0gPSBjb250ZXh0O1xyXG4gICAgaWYgKHRlc3QudHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgIGNvbnN0IG5lZWRzUGFyZW5zID0gIWlzU2ltcGxlSWRlbnRpZmllcih0ZXN0LmNvbnRlbnQpO1xyXG4gICAgICAgIG5lZWRzUGFyZW5zICYmIHB1c2goYChgKTtcclxuICAgICAgICBnZW5FeHByZXNzaW9uKHRlc3QsIGNvbnRleHQpO1xyXG4gICAgICAgIG5lZWRzUGFyZW5zICYmIHB1c2goYClgKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHB1c2goYChgKTtcclxuICAgICAgICBnZW5Ob2RlKHRlc3QsIGNvbnRleHQpO1xyXG4gICAgICAgIHB1c2goYClgKTtcclxuICAgIH1cclxuICAgIG5lZWROZXdsaW5lICYmIGluZGVudCgpO1xyXG4gICAgY29udGV4dC5pbmRlbnRMZXZlbCsrO1xyXG4gICAgbmVlZE5ld2xpbmUgfHwgcHVzaChgIGApO1xyXG4gICAgcHVzaChgPyBgKTtcclxuICAgIGdlbk5vZGUoY29uc2VxdWVudCwgY29udGV4dCk7XHJcbiAgICBjb250ZXh0LmluZGVudExldmVsLS07XHJcbiAgICBuZWVkTmV3bGluZSAmJiBuZXdsaW5lKCk7XHJcbiAgICBuZWVkTmV3bGluZSB8fCBwdXNoKGAgYCk7XHJcbiAgICBwdXNoKGA6IGApO1xyXG4gICAgY29uc3QgaXNOZXN0ZWQgPSBhbHRlcm5hdGUudHlwZSA9PT0gMTkgLyogSlNfQ09ORElUSU9OQUxfRVhQUkVTU0lPTiAqLztcclxuICAgIGlmICghaXNOZXN0ZWQpIHtcclxuICAgICAgICBjb250ZXh0LmluZGVudExldmVsKys7XHJcbiAgICB9XHJcbiAgICBnZW5Ob2RlKGFsdGVybmF0ZSwgY29udGV4dCk7XHJcbiAgICBpZiAoIWlzTmVzdGVkKSB7XHJcbiAgICAgICAgY29udGV4dC5pbmRlbnRMZXZlbC0tO1xyXG4gICAgfVxyXG4gICAgbmVlZE5ld2xpbmUgJiYgZGVpbmRlbnQodHJ1ZSAvKiB3aXRob3V0IG5ld2xpbmUgKi8pO1xyXG59XHJcbmZ1bmN0aW9uIGdlbkNhY2hlRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KSB7XHJcbiAgICBjb25zdCB7IHB1c2gsIGhlbHBlciwgaW5kZW50LCBkZWluZGVudCwgbmV3bGluZSB9ID0gY29udGV4dDtcclxuICAgIHB1c2goYF9jYWNoZVske25vZGUuaW5kZXh9XSB8fCAoYCk7XHJcbiAgICBpZiAobm9kZS5pc1ZOb2RlKSB7XHJcbiAgICAgICAgaW5kZW50KCk7XHJcbiAgICAgICAgcHVzaChgJHtoZWxwZXIoU0VUX0JMT0NLX1RSQUNLSU5HKX0oLTEpLGApO1xyXG4gICAgICAgIG5ld2xpbmUoKTtcclxuICAgIH1cclxuICAgIHB1c2goYF9jYWNoZVske25vZGUuaW5kZXh9XSA9IGApO1xyXG4gICAgZ2VuTm9kZShub2RlLnZhbHVlLCBjb250ZXh0KTtcclxuICAgIGlmIChub2RlLmlzVk5vZGUpIHtcclxuICAgICAgICBwdXNoKGAsYCk7XHJcbiAgICAgICAgbmV3bGluZSgpO1xyXG4gICAgICAgIHB1c2goYCR7aGVscGVyKFNFVF9CTE9DS19UUkFDS0lORyl9KDEpLGApO1xyXG4gICAgICAgIG5ld2xpbmUoKTtcclxuICAgICAgICBwdXNoKGBfY2FjaGVbJHtub2RlLmluZGV4fV1gKTtcclxuICAgICAgICBkZWluZGVudCgpO1xyXG4gICAgfVxyXG4gICAgcHVzaChgKWApO1xyXG59XG5cbi8vIHRoZXNlIGtleXdvcmRzIHNob3VsZCBub3QgYXBwZWFyIGluc2lkZSBleHByZXNzaW9ucywgYnV0IG9wZXJhdG9ycyBsaWtlXHJcbi8vIHR5cGVvZiwgaW5zdGFuY2VvZiBhbmQgaW4gYXJlIGFsbG93ZWRcclxuY29uc3QgcHJvaGliaXRlZEtleXdvcmRSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArXHJcbiAgICAoJ2RvLGlmLGZvcixsZXQsbmV3LHRyeSx2YXIsY2FzZSxlbHNlLHdpdGgsYXdhaXQsYnJlYWssY2F0Y2gsY2xhc3MsY29uc3QsJyArXHJcbiAgICAgICAgJ3N1cGVyLHRocm93LHdoaWxlLHlpZWxkLGRlbGV0ZSxleHBvcnQsaW1wb3J0LHJldHVybixzd2l0Y2gsZGVmYXVsdCwnICtcclxuICAgICAgICAnZXh0ZW5kcyxmaW5hbGx5LGNvbnRpbnVlLGRlYnVnZ2VyLGZ1bmN0aW9uLGFyZ3VtZW50cyx0eXBlb2Ysdm9pZCcpXHJcbiAgICAgICAgLnNwbGl0KCcsJylcclxuICAgICAgICAuam9pbignXFxcXGJ8XFxcXGInKSArXHJcbiAgICAnXFxcXGInKTtcclxuLy8gc3RyaXAgc3RyaW5ncyBpbiBleHByZXNzaW9uc1xyXG5jb25zdCBzdHJpcFN0cmluZ1JFID0gLycoPzpbXidcXFxcXXxcXFxcLikqJ3xcIig/OlteXCJcXFxcXXxcXFxcLikqXCJ8YCg/OlteYFxcXFxdfFxcXFwuKSpcXCRcXHt8XFx9KD86W15gXFxcXF18XFxcXC4pKmB8YCg/OlteYFxcXFxdfFxcXFwuKSpgL2c7XHJcbi8qKlxyXG4gKiBWYWxpZGF0ZSBhIG5vbi1wcmVmaXhlZCBleHByZXNzaW9uLlxyXG4gKiBUaGlzIGlzIG9ubHkgY2FsbGVkIHdoZW4gdXNpbmcgdGhlIGluLWJyb3dzZXIgcnVudGltZSBjb21waWxlciBzaW5jZSBpdFxyXG4gKiBkb2Vzbid0IHByZWZpeCBleHByZXNzaW9ucy5cclxuICovXHJcbmZ1bmN0aW9uIHZhbGlkYXRlQnJvd3NlckV4cHJlc3Npb24obm9kZSwgY29udGV4dCwgYXNQYXJhbXMgPSBmYWxzZSwgYXNSYXdTdGF0ZW1lbnRzID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IGV4cCA9IG5vZGUuY29udGVudDtcclxuICAgIC8vIGVtcHR5IGV4cHJlc3Npb25zIGFyZSB2YWxpZGF0ZWQgcGVyLWRpcmVjdGl2ZSBzaW5jZSBzb21lIGRpcmVjdGl2ZXNcclxuICAgIC8vIGRvIGFsbG93IGVtcHR5IGV4cHJlc3Npb25zLlxyXG4gICAgaWYgKCFleHAudHJpbSgpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICBuZXcgRnVuY3Rpb24oYXNSYXdTdGF0ZW1lbnRzXHJcbiAgICAgICAgICAgID8gYCAke2V4cH0gYFxyXG4gICAgICAgICAgICA6IGByZXR1cm4gJHthc1BhcmFtcyA/IGAoJHtleHB9KSA9PiB7fWAgOiBgKCR7ZXhwfSlgfWApO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBsZXQgbWVzc2FnZSA9IGUubWVzc2FnZTtcclxuICAgICAgICBjb25zdCBrZXl3b3JkTWF0Y2ggPSBleHBcclxuICAgICAgICAgICAgLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpXHJcbiAgICAgICAgICAgIC5tYXRjaChwcm9oaWJpdGVkS2V5d29yZFJFKTtcclxuICAgICAgICBpZiAoa2V5d29yZE1hdGNoKSB7XHJcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCBrZXl3b3JkIGFzIHByb3BlcnR5IG5hbWU6IFwiJHtrZXl3b3JkTWF0Y2hbMF19XCJgO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcig0MyAvKiBYX0lOVkFMSURfRVhQUkVTU0lPTiAqLywgbm9kZS5sb2MsIHVuZGVmaW5lZCwgbWVzc2FnZSkpO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IHRyYW5zZm9ybUV4cHJlc3Npb24gPSAobm9kZSwgY29udGV4dCkgPT4ge1xyXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gNSAvKiBJTlRFUlBPTEFUSU9OICovKSB7XHJcbiAgICAgICAgbm9kZS5jb250ZW50ID0gcHJvY2Vzc0V4cHJlc3Npb24obm9kZS5jb250ZW50LCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovKSB7XHJcbiAgICAgICAgLy8gaGFuZGxlIGRpcmVjdGl2ZXMgb24gZWxlbWVudFxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5wcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBkaXIgPSBub2RlLnByb3BzW2ldO1xyXG4gICAgICAgICAgICAvLyBkbyBub3QgcHJvY2VzcyBmb3Igdi1vbiAmIHYtZm9yIHNpbmNlIHRoZXkgYXJlIHNwZWNpYWwgaGFuZGxlZFxyXG4gICAgICAgICAgICBpZiAoZGlyLnR5cGUgPT09IDcgLyogRElSRUNUSVZFICovICYmIGRpci5uYW1lICE9PSAnZm9yJykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXhwID0gZGlyLmV4cDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFyZyA9IGRpci5hcmc7XHJcbiAgICAgICAgICAgICAgICAvLyBkbyBub3QgcHJvY2VzcyBleHAgaWYgdGhpcyBpcyB2LW9uOmFyZyAtIHdlIG5lZWQgc3BlY2lhbCBoYW5kbGluZ1xyXG4gICAgICAgICAgICAgICAgLy8gZm9yIHdyYXBwaW5nIGlubGluZSBzdGF0ZW1lbnRzLlxyXG4gICAgICAgICAgICAgICAgaWYgKGV4cCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGV4cC50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIShkaXIubmFtZSA9PT0gJ29uJyAmJiBhcmcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlyLmV4cCA9IHByb2Nlc3NFeHByZXNzaW9uKGV4cCwgY29udGV4dCwgXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2xvdCBhcmdzIG11c3QgYmUgcHJvY2Vzc2VkIGFzIGZ1bmN0aW9uIHBhcmFtc1xyXG4gICAgICAgICAgICAgICAgICAgIGRpci5uYW1lID09PSAnc2xvdCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGFyZyAmJiBhcmcudHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyAmJiAhYXJnLmlzU3RhdGljKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlyLmFyZyA9IHByb2Nlc3NFeHByZXNzaW9uKGFyZywgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbi8vIEltcG9ydGFudDogc2luY2UgdGhpcyBmdW5jdGlvbiB1c2VzIE5vZGUuanMgb25seSBkZXBlbmRlbmNpZXMsIGl0IHNob3VsZFxyXG4vLyBhbHdheXMgYmUgdXNlZCB3aXRoIGEgbGVhZGluZyAhdHJ1ZSBjaGVjayBzbyB0aGF0IGl0IGNhbiBiZVxyXG4vLyB0cmVlLXNoYWtlbiBmcm9tIHRoZSBicm93c2VyIGJ1aWxkLlxyXG5mdW5jdGlvbiBwcm9jZXNzRXhwcmVzc2lvbihub2RlLCBjb250ZXh0LCBcclxuLy8gc29tZSBleHByZXNzaW9ucyBsaWtlIHYtc2xvdCBwcm9wcyAmIHYtZm9yIGFsaWFzZXMgc2hvdWxkIGJlIHBhcnNlZCBhc1xyXG4vLyBmdW5jdGlvbiBwYXJhbXNcclxuYXNQYXJhbXMgPSBmYWxzZSwgXHJcbi8vIHYtb24gaGFuZGxlciB2YWx1ZXMgbWF5IGNvbnRhaW4gbXVsdGlwbGUgc3RhdGVtZW50c1xyXG5hc1Jhd1N0YXRlbWVudHMgPSBmYWxzZSkge1xyXG4gICAge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgLy8gc2ltcGxlIGluLWJyb3dzZXIgdmFsaWRhdGlvbiAoc2FtZSBsb2dpYyBpbiAyLngpXHJcbiAgICAgICAgICAgIHZhbGlkYXRlQnJvd3NlckV4cHJlc3Npb24obm9kZSwgY29udGV4dCwgYXNQYXJhbXMsIGFzUmF3U3RhdGVtZW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IHRyYW5zZm9ybUlmID0gY3JlYXRlU3RydWN0dXJhbERpcmVjdGl2ZVRyYW5zZm9ybSgvXihpZnxlbHNlfGVsc2UtaWYpJC8sIChub2RlLCBkaXIsIGNvbnRleHQpID0+IHtcclxuICAgIHJldHVybiBwcm9jZXNzSWYobm9kZSwgZGlyLCBjb250ZXh0LCAoaWZOb2RlLCBicmFuY2gsIGlzUm9vdCkgPT4ge1xyXG4gICAgICAgIC8vICMxNTg3OiBXZSBuZWVkIHRvIGR5bmFtaWNhbGx5IGluY3JlbWVudCB0aGUga2V5IGJhc2VkIG9uIHRoZSBjdXJyZW50XHJcbiAgICAgICAgLy8gbm9kZSdzIHNpYmxpbmcgbm9kZXMsIHNpbmNlIGNoYWluZWQgdi1pZi9lbHNlIGJyYW5jaGVzIGFyZVxyXG4gICAgICAgIC8vIHJlbmRlcmVkIGF0IHRoZSBzYW1lIGRlcHRoXHJcbiAgICAgICAgY29uc3Qgc2libGluZ3MgPSBjb250ZXh0LnBhcmVudC5jaGlsZHJlbjtcclxuICAgICAgICBsZXQgaSA9IHNpYmxpbmdzLmluZGV4T2YoaWZOb2RlKTtcclxuICAgICAgICBsZXQga2V5ID0gMDtcclxuICAgICAgICB3aGlsZSAoaS0tID49IDApIHtcclxuICAgICAgICAgICAgY29uc3Qgc2libGluZyA9IHNpYmxpbmdzW2ldO1xyXG4gICAgICAgICAgICBpZiAoc2libGluZyAmJiBzaWJsaW5nLnR5cGUgPT09IDkgLyogSUYgKi8pIHtcclxuICAgICAgICAgICAgICAgIGtleSArPSBzaWJsaW5nLmJyYW5jaGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBFeGl0IGNhbGxiYWNrLiBDb21wbGV0ZSB0aGUgY29kZWdlbk5vZGUgd2hlbiBhbGwgY2hpbGRyZW4gaGF2ZSBiZWVuXHJcbiAgICAgICAgLy8gdHJhbnNmb3JtZWQuXHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKGlzUm9vdCkge1xyXG4gICAgICAgICAgICAgICAgaWZOb2RlLmNvZGVnZW5Ob2RlID0gY3JlYXRlQ29kZWdlbk5vZGVGb3JCcmFuY2goYnJhbmNoLCBrZXksIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gYXR0YWNoIHRoaXMgYnJhbmNoJ3MgY29kZWdlbiBub2RlIHRvIHRoZSB2LWlmIHJvb3QuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRDb25kaXRpb24gPSBnZXRQYXJlbnRDb25kaXRpb24oaWZOb2RlLmNvZGVnZW5Ob2RlKTtcclxuICAgICAgICAgICAgICAgIHBhcmVudENvbmRpdGlvbi5hbHRlcm5hdGUgPSBjcmVhdGVDb2RlZ2VuTm9kZUZvckJyYW5jaChicmFuY2gsIGtleSArIGlmTm9kZS5icmFuY2hlcy5sZW5ndGggLSAxLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxufSk7XHJcbi8vIHRhcmdldC1hZ25vc3RpYyB0cmFuc2Zvcm0gdXNlZCBmb3IgYm90aCBDbGllbnQgYW5kIFNTUlxyXG5mdW5jdGlvbiBwcm9jZXNzSWYobm9kZSwgZGlyLCBjb250ZXh0LCBwcm9jZXNzQ29kZWdlbikge1xyXG4gICAgaWYgKGRpci5uYW1lICE9PSAnZWxzZScgJiZcclxuICAgICAgICAoIWRpci5leHAgfHwgIWRpci5leHAuY29udGVudC50cmltKCkpKSB7XHJcbiAgICAgICAgY29uc3QgbG9jID0gZGlyLmV4cCA/IGRpci5leHAubG9jIDogbm9kZS5sb2M7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMjcgLyogWF9WX0lGX05PX0VYUFJFU1NJT04gKi8sIGRpci5sb2MpKTtcclxuICAgICAgICBkaXIuZXhwID0gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgdHJ1ZWAsIGZhbHNlLCBsb2MpO1xyXG4gICAgfVxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB0cnVlICYmIGRpci5leHApIHtcclxuICAgICAgICB2YWxpZGF0ZUJyb3dzZXJFeHByZXNzaW9uKGRpci5leHAsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgaWYgKGRpci5uYW1lID09PSAnaWYnKSB7XHJcbiAgICAgICAgY29uc3QgYnJhbmNoID0gY3JlYXRlSWZCcmFuY2gobm9kZSwgZGlyKTtcclxuICAgICAgICBjb25zdCBpZk5vZGUgPSB7XHJcbiAgICAgICAgICAgIHR5cGU6IDkgLyogSUYgKi8sXHJcbiAgICAgICAgICAgIGxvYzogbm9kZS5sb2MsXHJcbiAgICAgICAgICAgIGJyYW5jaGVzOiBbYnJhbmNoXVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29udGV4dC5yZXBsYWNlTm9kZShpZk5vZGUpO1xyXG4gICAgICAgIGlmIChwcm9jZXNzQ29kZWdlbikge1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvY2Vzc0NvZGVnZW4oaWZOb2RlLCBicmFuY2gsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIGxvY2F0ZSB0aGUgYWRqYWNlbnQgdi1pZlxyXG4gICAgICAgIGNvbnN0IHNpYmxpbmdzID0gY29udGV4dC5wYXJlbnQuY2hpbGRyZW47XHJcbiAgICAgICAgY29uc3QgY29tbWVudHMgPSBbXTtcclxuICAgICAgICBsZXQgaSA9IHNpYmxpbmdzLmluZGV4T2Yobm9kZSk7XHJcbiAgICAgICAgd2hpbGUgKGktLSA+PSAtMSkge1xyXG4gICAgICAgICAgICBjb25zdCBzaWJsaW5nID0gc2libGluZ3NbaV07XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgc2libGluZyAmJiBzaWJsaW5nLnR5cGUgPT09IDMgLyogQ09NTUVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5yZW1vdmVOb2RlKHNpYmxpbmcpO1xyXG4gICAgICAgICAgICAgICAgY29tbWVudHMudW5zaGlmdChzaWJsaW5nKTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzaWJsaW5nICYmXHJcbiAgICAgICAgICAgICAgICBzaWJsaW5nLnR5cGUgPT09IDIgLyogVEVYVCAqLyAmJlxyXG4gICAgICAgICAgICAgICAgIXNpYmxpbmcuY29udGVudC50cmltKCkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlbW92ZU5vZGUoc2libGluZyk7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc2libGluZyAmJiBzaWJsaW5nLnR5cGUgPT09IDkgLyogSUYgKi8pIHtcclxuICAgICAgICAgICAgICAgIC8vIG1vdmUgdGhlIG5vZGUgdG8gdGhlIGlmIG5vZGUncyBicmFuY2hlc1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5yZW1vdmVOb2RlKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBicmFuY2ggPSBjcmVhdGVJZkJyYW5jaChub2RlLCBkaXIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzLmxlbmd0aCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIC8vICMzNjE5IGlnbm9yZSBjb21tZW50cyBpZiB0aGUgdi1pZiBpcyBkaXJlY3QgY2hpbGQgb2YgPHRyYW5zaXRpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgIShjb250ZXh0LnBhcmVudCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnBhcmVudC50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNCdWlsdEluVHlwZShjb250ZXh0LnBhcmVudC50YWcsICd0cmFuc2l0aW9uJykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJhbmNoLmNoaWxkcmVuID0gWy4uLmNvbW1lbnRzLCAuLi5icmFuY2guY2hpbGRyZW5dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgdXNlciBpcyBmb3JjaW5nIHNhbWUga2V5IG9uIGRpZmZlcmVudCBicmFuY2hlc1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCAhdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGJyYW5jaC51c2VyS2V5O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2libGluZy5icmFuY2hlcy5mb3JFYWNoKCh7IHVzZXJLZXkgfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2FtZUtleSh1c2VyS2V5LCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMjggLyogWF9WX0lGX1NBTUVfS0VZICovLCBicmFuY2gudXNlcktleS5sb2MpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2libGluZy5icmFuY2hlcy5wdXNoKGJyYW5jaCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvbkV4aXQgPSBwcm9jZXNzQ29kZWdlbiAmJiBwcm9jZXNzQ29kZWdlbihzaWJsaW5nLCBicmFuY2gsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBicmFuY2ggd2FzIHJlbW92ZWQsIGl0IHdpbGwgbm90IGJlIHRyYXZlcnNlZC5cclxuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0byB0cmF2ZXJzZSBoZXJlLlxyXG4gICAgICAgICAgICAgICAgdHJhdmVyc2VOb2RlKGJyYW5jaCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAvLyBjYWxsIG9uIGV4aXRcclxuICAgICAgICAgICAgICAgIGlmIChvbkV4aXQpXHJcbiAgICAgICAgICAgICAgICAgICAgb25FeGl0KCk7XHJcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgdG8gcmVzZXQgY3VycmVudE5vZGUgYWZ0ZXIgdHJhdmVyc2FsIHRvIGluZGljYXRlIHRoaXNcclxuICAgICAgICAgICAgICAgIC8vIG5vZGUgaGFzIGJlZW4gcmVtb3ZlZC5cclxuICAgICAgICAgICAgICAgIGNvbnRleHQuY3VycmVudE5vZGUgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMjkgLyogWF9WX0VMU0VfTk9fQURKQUNFTlRfSUYgKi8sIG5vZGUubG9jKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUlmQnJhbmNoKG5vZGUsIGRpcikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAxMCAvKiBJRl9CUkFOQ0ggKi8sXHJcbiAgICAgICAgbG9jOiBub2RlLmxvYyxcclxuICAgICAgICBjb25kaXRpb246IGRpci5uYW1lID09PSAnZWxzZScgPyB1bmRlZmluZWQgOiBkaXIuZXhwLFxyXG4gICAgICAgIGNoaWxkcmVuOiBub2RlLnRhZ1R5cGUgPT09IDMgLyogVEVNUExBVEUgKi8gJiYgIWZpbmREaXIobm9kZSwgJ2ZvcicpXHJcbiAgICAgICAgICAgID8gbm9kZS5jaGlsZHJlblxyXG4gICAgICAgICAgICA6IFtub2RlXSxcclxuICAgICAgICB1c2VyS2V5OiBmaW5kUHJvcChub2RlLCBga2V5YClcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQ29kZWdlbk5vZGVGb3JCcmFuY2goYnJhbmNoLCBrZXlJbmRleCwgY29udGV4dCkge1xyXG4gICAgaWYgKGJyYW5jaC5jb25kaXRpb24pIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlQ29uZGl0aW9uYWxFeHByZXNzaW9uKGJyYW5jaC5jb25kaXRpb24sIGNyZWF0ZUNoaWxkcmVuQ29kZWdlbk5vZGUoYnJhbmNoLCBrZXlJbmRleCwgY29udGV4dCksIFxyXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0byBwYXNzIGluIGFzQmxvY2s6IHRydWUgc28gdGhhdCB0aGUgY29tbWVudCBub2RlIGNhbGxcclxuICAgICAgICAvLyBjbG9zZXMgdGhlIGN1cnJlbnQgYmxvY2suXHJcbiAgICAgICAgY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoQ1JFQVRFX0NPTU1FTlQpLCBbXHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/ICdcInYtaWZcIicgOiAnXCJcIicsXHJcbiAgICAgICAgICAgICd0cnVlJ1xyXG4gICAgICAgIF0pKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVDaGlsZHJlbkNvZGVnZW5Ob2RlKGJyYW5jaCwga2V5SW5kZXgsIGNvbnRleHQpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuQ29kZWdlbk5vZGUoYnJhbmNoLCBrZXlJbmRleCwgY29udGV4dCkge1xyXG4gICAgY29uc3QgeyBoZWxwZXIsIHJlbW92ZUhlbHBlciB9ID0gY29udGV4dDtcclxuICAgIGNvbnN0IGtleVByb3BlcnR5ID0gY3JlYXRlT2JqZWN0UHJvcGVydHkoYGtleWAsIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYCR7a2V5SW5kZXh9YCwgZmFsc2UsIGxvY1N0dWIsIDIgLyogQ0FOX0hPSVNUICovKSk7XHJcbiAgICBjb25zdCB7IGNoaWxkcmVuIH0gPSBicmFuY2g7XHJcbiAgICBjb25zdCBmaXJzdENoaWxkID0gY2hpbGRyZW5bMF07XHJcbiAgICBjb25zdCBuZWVkRnJhZ21lbnRXcmFwcGVyID0gY2hpbGRyZW4ubGVuZ3RoICE9PSAxIHx8IGZpcnN0Q2hpbGQudHlwZSAhPT0gMSAvKiBFTEVNRU5UICovO1xyXG4gICAgaWYgKG5lZWRGcmFnbWVudFdyYXBwZXIpIHtcclxuICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGZpcnN0Q2hpbGQudHlwZSA9PT0gMTEgLyogRk9SICovKSB7XHJcbiAgICAgICAgICAgIC8vIG9wdGltaXplIGF3YXkgbmVzdGVkIGZyYWdtZW50cyB3aGVuIGNoaWxkIGlzIGEgRm9yTm9kZVxyXG4gICAgICAgICAgICBjb25zdCB2bm9kZUNhbGwgPSBmaXJzdENoaWxkLmNvZGVnZW5Ob2RlO1xyXG4gICAgICAgICAgICBpbmplY3RQcm9wKHZub2RlQ2FsbCwga2V5UHJvcGVydHksIGNvbnRleHQpO1xyXG4gICAgICAgICAgICByZXR1cm4gdm5vZGVDYWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IHBhdGNoRmxhZyA9IDY0IC8qIFNUQUJMRV9GUkFHTUVOVCAqLztcclxuICAgICAgICAgICAgbGV0IHBhdGNoRmxhZ1RleHQgPSBQYXRjaEZsYWdOYW1lc1s2NCAvKiBTVEFCTEVfRlJBR01FTlQgKi9dO1xyXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgZnJhZ21lbnQgYWN0dWFsbHkgY29udGFpbnMgYSBzaW5nbGUgdmFsaWQgY2hpbGQgd2l0aFxyXG4gICAgICAgICAgICAvLyB0aGUgcmVzdCBiZWluZyBjb21tZW50c1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5maWx0ZXIoYyA9PiBjLnR5cGUgIT09IDMgLyogQ09NTUVOVCAqLykubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRjaEZsYWcgfD0gMjA0OCAvKiBERVZfUk9PVF9GUkFHTUVOVCAqLztcclxuICAgICAgICAgICAgICAgIHBhdGNoRmxhZ1RleHQgKz0gYCwgJHtQYXRjaEZsYWdOYW1lc1syMDQ4IC8qIERFVl9ST09UX0ZSQUdNRU5UICovXX1gO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZUNhbGwoY29udGV4dCwgaGVscGVyKEZSQUdNRU5UKSwgY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihba2V5UHJvcGVydHldKSwgY2hpbGRyZW4sIHBhdGNoRmxhZyArICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgIC8qICR7cGF0Y2hGbGFnVGV4dH0gKi9gIDogYGApLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdHJ1ZSwgZmFsc2UsIGJyYW5jaC5sb2MpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHZub2RlQ2FsbCA9IGZpcnN0Q2hpbGRcclxuICAgICAgICAgICAgLmNvZGVnZW5Ob2RlO1xyXG4gICAgICAgIC8vIENoYW5nZSBjcmVhdGVWTm9kZSB0byBjcmVhdGVCbG9jay5cclxuICAgICAgICBpZiAodm5vZGVDYWxsLnR5cGUgPT09IDEzIC8qIFZOT0RFX0NBTEwgKi8gJiYgIXZub2RlQ2FsbC5pc0Jsb2NrKSB7XHJcbiAgICAgICAgICAgIHJlbW92ZUhlbHBlcihDUkVBVEVfVk5PREUpO1xyXG4gICAgICAgICAgICB2bm9kZUNhbGwuaXNCbG9jayA9IHRydWU7XHJcbiAgICAgICAgICAgIGhlbHBlcihPUEVOX0JMT0NLKTtcclxuICAgICAgICAgICAgaGVscGVyKENSRUFURV9CTE9DSyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGluamVjdCBicmFuY2gga2V5XHJcbiAgICAgICAgaW5qZWN0UHJvcCh2bm9kZUNhbGwsIGtleVByb3BlcnR5LCBjb250ZXh0KTtcclxuICAgICAgICByZXR1cm4gdm5vZGVDYWxsO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzU2FtZUtleShhLCBiKSB7XHJcbiAgICBpZiAoIWEgfHwgYS50eXBlICE9PSBiLnR5cGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoYS50eXBlID09PSA2IC8qIEFUVFJJQlVURSAqLykge1xyXG4gICAgICAgIGlmIChhLnZhbHVlLmNvbnRlbnQgIT09IGIudmFsdWUuY29udGVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gZGlyZWN0aXZlXHJcbiAgICAgICAgY29uc3QgZXhwID0gYS5leHA7XHJcbiAgICAgICAgY29uc3QgYnJhbmNoRXhwID0gYi5leHA7XHJcbiAgICAgICAgaWYgKGV4cC50eXBlICE9PSBicmFuY2hFeHAudHlwZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChleHAudHlwZSAhPT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLyB8fFxyXG4gICAgICAgICAgICAoZXhwLmlzU3RhdGljICE9PSBicmFuY2hFeHAuaXNTdGF0aWMgfHxcclxuICAgICAgICAgICAgICAgIGV4cC5jb250ZW50ICE9PSBicmFuY2hFeHAuY29udGVudCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIGdldFBhcmVudENvbmRpdGlvbihub2RlKSB7XHJcbiAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IDE5IC8qIEpTX0NPTkRJVElPTkFMX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUuYWx0ZXJuYXRlLnR5cGUgPT09IDE5IC8qIEpTX0NPTkRJVElPTkFMX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmFsdGVybmF0ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMjAgLyogSlNfQ0FDSEVfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgICAgICBub2RlID0gbm9kZS52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY29uc3QgdHJhbnNmb3JtRm9yID0gY3JlYXRlU3RydWN0dXJhbERpcmVjdGl2ZVRyYW5zZm9ybSgnZm9yJywgKG5vZGUsIGRpciwgY29udGV4dCkgPT4ge1xyXG4gICAgY29uc3QgeyBoZWxwZXIsIHJlbW92ZUhlbHBlciB9ID0gY29udGV4dDtcclxuICAgIHJldHVybiBwcm9jZXNzRm9yKG5vZGUsIGRpciwgY29udGV4dCwgZm9yTm9kZSA9PiB7XHJcbiAgICAgICAgLy8gY3JlYXRlIHRoZSBsb29wIHJlbmRlciBmdW5jdGlvbiBleHByZXNzaW9uIG5vdywgYW5kIGFkZCB0aGVcclxuICAgICAgICAvLyBpdGVyYXRvciBvbiBleGl0IGFmdGVyIGFsbCBjaGlsZHJlbiBoYXZlIGJlZW4gdHJhdmVyc2VkXHJcbiAgICAgICAgY29uc3QgcmVuZGVyRXhwID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oaGVscGVyKFJFTkRFUl9MSVNUKSwgW1xyXG4gICAgICAgICAgICBmb3JOb2RlLnNvdXJjZVxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIGNvbnN0IGtleVByb3AgPSBmaW5kUHJvcChub2RlLCBga2V5YCk7XHJcbiAgICAgICAgY29uc3Qga2V5UHJvcGVydHkgPSBrZXlQcm9wXHJcbiAgICAgICAgICAgID8gY3JlYXRlT2JqZWN0UHJvcGVydHkoYGtleWAsIGtleVByb3AudHlwZSA9PT0gNiAvKiBBVFRSSUJVVEUgKi9cclxuICAgICAgICAgICAgICAgID8gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihrZXlQcm9wLnZhbHVlLmNvbnRlbnQsIHRydWUpXHJcbiAgICAgICAgICAgICAgICA6IGtleVByb3AuZXhwKVxyXG4gICAgICAgICAgICA6IG51bGw7XHJcbiAgICAgICAgY29uc3QgaXNTdGFibGVGcmFnbWVudCA9IGZvck5vZGUuc291cmNlLnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8gJiZcclxuICAgICAgICAgICAgZm9yTm9kZS5zb3VyY2UuY29uc3RUeXBlID4gMCAvKiBOT1RfQ09OU1RBTlQgKi87XHJcbiAgICAgICAgY29uc3QgZnJhZ21lbnRGbGFnID0gaXNTdGFibGVGcmFnbWVudFxyXG4gICAgICAgICAgICA/IDY0IC8qIFNUQUJMRV9GUkFHTUVOVCAqL1xyXG4gICAgICAgICAgICA6IGtleVByb3BcclxuICAgICAgICAgICAgICAgID8gMTI4IC8qIEtFWUVEX0ZSQUdNRU5UICovXHJcbiAgICAgICAgICAgICAgICA6IDI1NiAvKiBVTktFWUVEX0ZSQUdNRU5UICovO1xyXG4gICAgICAgIGZvck5vZGUuY29kZWdlbk5vZGUgPSBjcmVhdGVWTm9kZUNhbGwoY29udGV4dCwgaGVscGVyKEZSQUdNRU5UKSwgdW5kZWZpbmVkLCByZW5kZXJFeHAsIGZyYWdtZW50RmxhZyArXHJcbiAgICAgICAgICAgICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgIC8qICR7UGF0Y2hGbGFnTmFtZXNbZnJhZ21lbnRGbGFnXX0gKi9gIDogYGApLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdHJ1ZSAvKiBpc0Jsb2NrICovLCAhaXNTdGFibGVGcmFnbWVudCAvKiBkaXNhYmxlVHJhY2tpbmcgKi8sIG5vZGUubG9jKTtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBmaW5pc2ggdGhlIGNvZGVnZW4gbm93IHRoYXQgYWxsIGNoaWxkcmVuIGhhdmUgYmVlbiB0cmF2ZXJzZWRcclxuICAgICAgICAgICAgbGV0IGNoaWxkQmxvY2s7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzVGVtcGxhdGUgPSBpc1RlbXBsYXRlTm9kZShub2RlKTtcclxuICAgICAgICAgICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gZm9yTm9kZTtcclxuICAgICAgICAgICAgLy8gY2hlY2sgPHRlbXBsYXRlIHYtZm9yPiBrZXkgcGxhY2VtZW50XHJcbiAgICAgICAgICAgIGlmICgoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8ICF0cnVlKSAmJiBpc1RlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuLnNvbWUoYyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGZpbmRQcm9wKGMsICdrZXknKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzIgLyogWF9WX0ZPUl9URU1QTEFURV9LRVlfUExBQ0VNRU5UICovLCBrZXkubG9jKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG5lZWRGcmFnbWVudFdyYXBwZXIgPSBjaGlsZHJlbi5sZW5ndGggIT09IDEgfHwgY2hpbGRyZW5bMF0udHlwZSAhPT0gMSAvKiBFTEVNRU5UICovO1xyXG4gICAgICAgICAgICBjb25zdCBzbG90T3V0bGV0ID0gaXNTbG90T3V0bGV0KG5vZGUpXHJcbiAgICAgICAgICAgICAgICA/IG5vZGVcclxuICAgICAgICAgICAgICAgIDogaXNUZW1wbGF0ZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXHJcbiAgICAgICAgICAgICAgICAgICAgaXNTbG90T3V0bGV0KG5vZGUuY2hpbGRyZW5bMF0pXHJcbiAgICAgICAgICAgICAgICAgICAgPyBub2RlLmNoaWxkcmVuWzBdIC8vIGFwaS1leHRyYWN0b3Igc29tZWhvdyBmYWlscyB0byBpbmZlciB0aGlzXHJcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgICAgICBpZiAoc2xvdE91dGxldCkge1xyXG4gICAgICAgICAgICAgICAgLy8gPHNsb3Qgdi1mb3I9XCIuLi5cIj4gb3IgPHRlbXBsYXRlIHYtZm9yPVwiLi4uXCI+PHNsb3QvPjwvdGVtcGxhdGU+XHJcbiAgICAgICAgICAgICAgICBjaGlsZEJsb2NrID0gc2xvdE91dGxldC5jb2RlZ2VuTm9kZTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1RlbXBsYXRlICYmIGtleVByb3BlcnR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gPHRlbXBsYXRlIHYtZm9yPVwiLi4uXCIgOmtleT1cIi4uLlwiPjxzbG90Lz48L3RlbXBsYXRlPlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gaW5qZWN0IHRoZSBrZXkgdG8gdGhlIHJlbmRlclNsb3QoKSBjYWxsLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBwcm9wcyBmb3IgcmVuZGVyU2xvdCBpcyBwYXNzZWQgYXMgdGhlIDNyZCBhcmd1bWVudC5cclxuICAgICAgICAgICAgICAgICAgICBpbmplY3RQcm9wKGNoaWxkQmxvY2ssIGtleVByb3BlcnR5LCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChuZWVkRnJhZ21lbnRXcmFwcGVyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyA8dGVtcGxhdGUgdi1mb3I9XCIuLi5cIj4gd2l0aCB0ZXh0IG9yIG11bHRpLWVsZW1lbnRzXHJcbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgZ2VuZXJhdGUgYSBmcmFnbWVudCBibG9jayBmb3IgZWFjaCBsb29wXHJcbiAgICAgICAgICAgICAgICBjaGlsZEJsb2NrID0gY3JlYXRlVk5vZGVDYWxsKGNvbnRleHQsIGhlbHBlcihGUkFHTUVOVCksIGtleVByb3BlcnR5ID8gY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihba2V5UHJvcGVydHldKSA6IHVuZGVmaW5lZCwgbm9kZS5jaGlsZHJlbiwgNjQgLyogU1RBQkxFX0ZSQUdNRU5UICovICtcclxuICAgICAgICAgICAgICAgICAgICAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYCAvKiAke1BhdGNoRmxhZ05hbWVzWzY0IC8qIFNUQUJMRV9GUkFHTUVOVCAqL119ICovYFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGBgKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gTm9ybWFsIGVsZW1lbnQgdi1mb3IuIERpcmVjdGx5IHVzZSB0aGUgY2hpbGQncyBjb2RlZ2VuTm9kZVxyXG4gICAgICAgICAgICAgICAgLy8gYnV0IG1hcmsgaXQgYXMgYSBibG9jay5cclxuICAgICAgICAgICAgICAgIGNoaWxkQmxvY2sgPSBjaGlsZHJlblswXVxyXG4gICAgICAgICAgICAgICAgICAgIC5jb2RlZ2VuTm9kZTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1RlbXBsYXRlICYmIGtleVByb3BlcnR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5qZWN0UHJvcChjaGlsZEJsb2NrLCBrZXlQcm9wZXJ0eSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRCbG9jay5pc0Jsb2NrICE9PSAhaXNTdGFibGVGcmFnbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZEJsb2NrLmlzQmxvY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3dpdGNoIGZyb20gYmxvY2sgdG8gdm5vZGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlSGVscGVyKE9QRU5fQkxPQ0spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVIZWxwZXIoQ1JFQVRFX0JMT0NLKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN3aXRjaCBmcm9tIHZub2RlIHRvIGJsb2NrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUhlbHBlcihDUkVBVEVfVk5PREUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNoaWxkQmxvY2suaXNCbG9jayA9ICFpc1N0YWJsZUZyYWdtZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkQmxvY2suaXNCbG9jaykge1xyXG4gICAgICAgICAgICAgICAgICAgIGhlbHBlcihPUEVOX0JMT0NLKTtcclxuICAgICAgICAgICAgICAgICAgICBoZWxwZXIoQ1JFQVRFX0JMT0NLKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGhlbHBlcihDUkVBVEVfVk5PREUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlbmRlckV4cC5hcmd1bWVudHMucHVzaChjcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24oY3JlYXRlRm9yTG9vcFBhcmFtcyhmb3JOb2RlLnBhcnNlUmVzdWx0KSwgY2hpbGRCbG9jaywgdHJ1ZSAvKiBmb3JjZSBuZXdsaW5lICovKSk7XHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG59KTtcclxuLy8gdGFyZ2V0LWFnbm9zdGljIHRyYW5zZm9ybSB1c2VkIGZvciBib3RoIENsaWVudCBhbmQgU1NSXHJcbmZ1bmN0aW9uIHByb2Nlc3NGb3Iobm9kZSwgZGlyLCBjb250ZXh0LCBwcm9jZXNzQ29kZWdlbikge1xyXG4gICAgaWYgKCFkaXIuZXhwKSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzAgLyogWF9WX0ZPUl9OT19FWFBSRVNTSU9OICovLCBkaXIubG9jKSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcGFyc2VSZXN1bHQgPSBwYXJzZUZvckV4cHJlc3Npb24oXHJcbiAgICAvLyBjYW4gb25seSBiZSBzaW1wbGUgZXhwcmVzc2lvbiBiZWNhdXNlIHZGb3IgdHJhbnNmb3JtIGlzIGFwcGxpZWRcclxuICAgIC8vIGJlZm9yZSBleHByZXNzaW9uIHRyYW5zZm9ybS5cclxuICAgIGRpci5leHAsIGNvbnRleHQpO1xyXG4gICAgaWYgKCFwYXJzZVJlc3VsdCkge1xyXG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDMxIC8qIFhfVl9GT1JfTUFMRk9STUVEX0VYUFJFU1NJT04gKi8sIGRpci5sb2MpKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IGFkZElkZW50aWZpZXJzLCByZW1vdmVJZGVudGlmaWVycywgc2NvcGVzIH0gPSBjb250ZXh0O1xyXG4gICAgY29uc3QgeyBzb3VyY2UsIHZhbHVlLCBrZXksIGluZGV4IH0gPSBwYXJzZVJlc3VsdDtcclxuICAgIGNvbnN0IGZvck5vZGUgPSB7XHJcbiAgICAgICAgdHlwZTogMTEgLyogRk9SICovLFxyXG4gICAgICAgIGxvYzogZGlyLmxvYyxcclxuICAgICAgICBzb3VyY2UsXHJcbiAgICAgICAgdmFsdWVBbGlhczogdmFsdWUsXHJcbiAgICAgICAga2V5QWxpYXM6IGtleSxcclxuICAgICAgICBvYmplY3RJbmRleEFsaWFzOiBpbmRleCxcclxuICAgICAgICBwYXJzZVJlc3VsdCxcclxuICAgICAgICBjaGlsZHJlbjogaXNUZW1wbGF0ZU5vZGUobm9kZSkgPyBub2RlLmNoaWxkcmVuIDogW25vZGVdXHJcbiAgICB9O1xyXG4gICAgY29udGV4dC5yZXBsYWNlTm9kZShmb3JOb2RlKTtcclxuICAgIC8vIGJvb2trZWVwaW5nXHJcbiAgICBzY29wZXMudkZvcisrO1xyXG4gICAgY29uc3Qgb25FeGl0ID0gcHJvY2Vzc0NvZGVnZW4gJiYgcHJvY2Vzc0NvZGVnZW4oZm9yTm9kZSk7XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIHNjb3Blcy52Rm9yLS07XHJcbiAgICAgICAgaWYgKG9uRXhpdClcclxuICAgICAgICAgICAgb25FeGl0KCk7XHJcbiAgICB9O1xyXG59XHJcbmNvbnN0IGZvckFsaWFzUkUgPSAvKFtcXHNcXFNdKj8pXFxzKyg/OmlufG9mKVxccysoW1xcc1xcU10qKS87XHJcbi8vIFRoaXMgcmVnZXggZG9lc24ndCBjb3ZlciB0aGUgY2FzZSBpZiBrZXkgb3IgaW5kZXggYWxpYXNlcyBoYXZlIGRlc3RydWN0dXJpbmcsXHJcbi8vIGJ1dCB0aG9zZSBkbyBub3QgbWFrZSBzZW5zZSBpbiB0aGUgZmlyc3QgcGxhY2UsIHNvIHRoaXMgd29ya3MgaW4gcHJhY3RpY2UuXHJcbmNvbnN0IGZvckl0ZXJhdG9yUkUgPSAvLChbXixcXH1cXF1dKikoPzosKFteLFxcfVxcXV0qKSk/JC87XHJcbmNvbnN0IHN0cmlwUGFyZW5zUkUgPSAvXlxcKHxcXCkkL2c7XHJcbmZ1bmN0aW9uIHBhcnNlRm9yRXhwcmVzc2lvbihpbnB1dCwgY29udGV4dCkge1xyXG4gICAgY29uc3QgbG9jID0gaW5wdXQubG9jO1xyXG4gICAgY29uc3QgZXhwID0gaW5wdXQuY29udGVudDtcclxuICAgIGNvbnN0IGluTWF0Y2ggPSBleHAubWF0Y2goZm9yQWxpYXNSRSk7XHJcbiAgICBpZiAoIWluTWF0Y2gpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgY29uc3QgWywgTEhTLCBSSFNdID0gaW5NYXRjaDtcclxuICAgIGNvbnN0IHJlc3VsdCA9IHtcclxuICAgICAgICBzb3VyY2U6IGNyZWF0ZUFsaWFzRXhwcmVzc2lvbihsb2MsIFJIUy50cmltKCksIGV4cC5pbmRleE9mKFJIUywgTEhTLmxlbmd0aCkpLFxyXG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXHJcbiAgICAgICAga2V5OiB1bmRlZmluZWQsXHJcbiAgICAgICAgaW5kZXg6IHVuZGVmaW5lZFxyXG4gICAgfTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgdHJ1ZSkge1xyXG4gICAgICAgIHZhbGlkYXRlQnJvd3NlckV4cHJlc3Npb24ocmVzdWx0LnNvdXJjZSwgY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICBsZXQgdmFsdWVDb250ZW50ID0gTEhTLnRyaW0oKVxyXG4gICAgICAgIC5yZXBsYWNlKHN0cmlwUGFyZW5zUkUsICcnKVxyXG4gICAgICAgIC50cmltKCk7XHJcbiAgICBjb25zdCB0cmltbWVkT2Zmc2V0ID0gTEhTLmluZGV4T2YodmFsdWVDb250ZW50KTtcclxuICAgIGNvbnN0IGl0ZXJhdG9yTWF0Y2ggPSB2YWx1ZUNvbnRlbnQubWF0Y2goZm9ySXRlcmF0b3JSRSk7XHJcbiAgICBpZiAoaXRlcmF0b3JNYXRjaCkge1xyXG4gICAgICAgIHZhbHVlQ29udGVudCA9IHZhbHVlQ29udGVudC5yZXBsYWNlKGZvckl0ZXJhdG9yUkUsICcnKS50cmltKCk7XHJcbiAgICAgICAgY29uc3Qga2V5Q29udGVudCA9IGl0ZXJhdG9yTWF0Y2hbMV0udHJpbSgpO1xyXG4gICAgICAgIGxldCBrZXlPZmZzZXQ7XHJcbiAgICAgICAgaWYgKGtleUNvbnRlbnQpIHtcclxuICAgICAgICAgICAga2V5T2Zmc2V0ID0gZXhwLmluZGV4T2Yoa2V5Q29udGVudCwgdHJpbW1lZE9mZnNldCArIHZhbHVlQ29udGVudC5sZW5ndGgpO1xyXG4gICAgICAgICAgICByZXN1bHQua2V5ID0gY3JlYXRlQWxpYXNFeHByZXNzaW9uKGxvYywga2V5Q29udGVudCwga2V5T2Zmc2V0KTtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZUJyb3dzZXJFeHByZXNzaW9uKHJlc3VsdC5rZXksIGNvbnRleHQsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpdGVyYXRvck1hdGNoWzJdKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4Q29udGVudCA9IGl0ZXJhdG9yTWF0Y2hbMl0udHJpbSgpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXhDb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuaW5kZXggPSBjcmVhdGVBbGlhc0V4cHJlc3Npb24obG9jLCBpbmRleENvbnRlbnQsIGV4cC5pbmRleE9mKGluZGV4Q29udGVudCwgcmVzdWx0LmtleVxyXG4gICAgICAgICAgICAgICAgICAgID8ga2V5T2Zmc2V0ICsga2V5Q29udGVudC5sZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICA6IHRyaW1tZWRPZmZzZXQgKyB2YWx1ZUNvbnRlbnQubGVuZ3RoKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUJyb3dzZXJFeHByZXNzaW9uKHJlc3VsdC5pbmRleCwgY29udGV4dCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAodmFsdWVDb250ZW50KSB7XHJcbiAgICAgICAgcmVzdWx0LnZhbHVlID0gY3JlYXRlQWxpYXNFeHByZXNzaW9uKGxvYywgdmFsdWVDb250ZW50LCB0cmltbWVkT2Zmc2V0KTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHRydWUpIHtcclxuICAgICAgICAgICAgdmFsaWRhdGVCcm93c2VyRXhwcmVzc2lvbihyZXN1bHQudmFsdWUsIGNvbnRleHQsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQWxpYXNFeHByZXNzaW9uKHJhbmdlLCBjb250ZW50LCBvZmZzZXQpIHtcclxuICAgIHJldHVybiBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGNvbnRlbnQsIGZhbHNlLCBnZXRJbm5lclJhbmdlKHJhbmdlLCBvZmZzZXQsIGNvbnRlbnQubGVuZ3RoKSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlRm9yTG9vcFBhcmFtcyh7IHZhbHVlLCBrZXksIGluZGV4IH0pIHtcclxuICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xyXG4gICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgcGFyYW1zLnB1c2godmFsdWUpO1xyXG4gICAgfVxyXG4gICAgaWYgKGtleSkge1xyXG4gICAgICAgIGlmICghdmFsdWUpIHtcclxuICAgICAgICAgICAgcGFyYW1zLnB1c2goY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgX2AsIGZhbHNlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhcmFtcy5wdXNoKGtleSk7XHJcbiAgICB9XHJcbiAgICBpZiAoaW5kZXgpIHtcclxuICAgICAgICBpZiAoIWtleSkge1xyXG4gICAgICAgICAgICBpZiAoIXZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGBfYCwgZmFsc2UpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwYXJhbXMucHVzaChjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGBfX2AsIGZhbHNlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhcmFtcy5wdXNoKGluZGV4KTtcclxuICAgIH1cclxuICAgIHJldHVybiBwYXJhbXM7XHJcbn1cblxuY29uc3QgZGVmYXVsdEZhbGxiYWNrID0gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgdW5kZWZpbmVkYCwgZmFsc2UpO1xyXG4vLyBBIE5vZGVUcmFuc2Zvcm0gdGhhdDpcclxuLy8gMS4gVHJhY2tzIHNjb3BlIGlkZW50aWZpZXJzIGZvciBzY29wZWQgc2xvdHMgc28gdGhhdCB0aGV5IGRvbid0IGdldCBwcmVmaXhlZFxyXG4vLyAgICBieSB0cmFuc2Zvcm1FeHByZXNzaW9uLiBUaGlzIGlzIG9ubHkgYXBwbGllZCBpbiBub24tYnJvd3NlciBidWlsZHMgd2l0aFxyXG4vLyAgICB7IHByZWZpeElkZW50aWZpZXJzOiB0cnVlIH0uXHJcbi8vIDIuIFRyYWNrIHYtc2xvdCBkZXB0aHMgc28gdGhhdCB3ZSBrbm93IGEgc2xvdCBpcyBpbnNpZGUgYW5vdGhlciBzbG90LlxyXG4vLyAgICBOb3RlIHRoZSBleGl0IGNhbGxiYWNrIGlzIGV4ZWN1dGVkIGJlZm9yZSBidWlsZFNsb3RzKCkgb24gdGhlIHNhbWUgbm9kZSxcclxuLy8gICAgc28gb25seSBuZXN0ZWQgc2xvdHMgc2VlIHBvc2l0aXZlIG51bWJlcnMuXHJcbmNvbnN0IHRyYWNrU2xvdFNjb3BlcyA9IChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBpZiAobm9kZS50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICAobm9kZS50YWdUeXBlID09PSAxIC8qIENPTVBPTkVOVCAqLyB8fFxyXG4gICAgICAgICAgICBub2RlLnRhZ1R5cGUgPT09IDMgLyogVEVNUExBVEUgKi8pKSB7XHJcbiAgICAgICAgLy8gV2UgYXJlIG9ubHkgY2hlY2tpbmcgbm9uLWVtcHR5IHYtc2xvdCBoZXJlXHJcbiAgICAgICAgLy8gc2luY2Ugd2Ugb25seSBjYXJlIGFib3V0IHNsb3RzIHRoYXQgaW50cm9kdWNlIHNjb3BlIHZhcmlhYmxlcy5cclxuICAgICAgICBjb25zdCB2U2xvdCA9IGZpbmREaXIobm9kZSwgJ3Nsb3QnKTtcclxuICAgICAgICBpZiAodlNsb3QpIHtcclxuICAgICAgICAgICAgdlNsb3QuZXhwO1xyXG4gICAgICAgICAgICBjb250ZXh0LnNjb3Blcy52U2xvdCsrO1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5zY29wZXMudlNsb3QtLTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbi8vIEEgTm9kZVRyYW5zZm9ybSB0aGF0IHRyYWNrcyBzY29wZSBpZGVudGlmaWVycyBmb3Igc2NvcGVkIHNsb3RzIHdpdGggdi1mb3IuXHJcbi8vIFRoaXMgdHJhbnNmb3JtIGlzIG9ubHkgYXBwbGllZCBpbiBub24tYnJvd3NlciBidWlsZHMgd2l0aCB7IHByZWZpeElkZW50aWZpZXJzOiB0cnVlIH1cclxuY29uc3QgdHJhY2tWRm9yU2xvdFNjb3BlcyA9IChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBsZXQgdkZvcjtcclxuICAgIGlmIChpc1RlbXBsYXRlTm9kZShub2RlKSAmJlxyXG4gICAgICAgIG5vZGUucHJvcHMuc29tZShpc1ZTbG90KSAmJlxyXG4gICAgICAgICh2Rm9yID0gZmluZERpcihub2RlLCAnZm9yJykpKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gKHZGb3IucGFyc2VSZXN1bHQgPSBwYXJzZUZvckV4cHJlc3Npb24odkZvci5leHAsIGNvbnRleHQpKTtcclxuICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdmFsdWUsIGtleSwgaW5kZXggfSA9IHJlc3VsdDtcclxuICAgICAgICAgICAgY29uc3QgeyBhZGRJZGVudGlmaWVycywgcmVtb3ZlSWRlbnRpZmllcnMgfSA9IGNvbnRleHQ7XHJcbiAgICAgICAgICAgIHZhbHVlICYmIGFkZElkZW50aWZpZXJzKHZhbHVlKTtcclxuICAgICAgICAgICAga2V5ICYmIGFkZElkZW50aWZpZXJzKGtleSk7XHJcbiAgICAgICAgICAgIGluZGV4ICYmIGFkZElkZW50aWZpZXJzKGluZGV4KTtcclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHZhbHVlICYmIHJlbW92ZUlkZW50aWZpZXJzKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGtleSAmJiByZW1vdmVJZGVudGlmaWVycyhrZXkpO1xyXG4gICAgICAgICAgICAgICAgaW5kZXggJiYgcmVtb3ZlSWRlbnRpZmllcnMoaW5kZXgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuY29uc3QgYnVpbGRDbGllbnRTbG90Rm4gPSAocHJvcHMsIGNoaWxkcmVuLCBsb2MpID0+IGNyZWF0ZUZ1bmN0aW9uRXhwcmVzc2lvbihwcm9wcywgY2hpbGRyZW4sIGZhbHNlIC8qIG5ld2xpbmUgKi8sIHRydWUgLyogaXNTbG90ICovLCBjaGlsZHJlbi5sZW5ndGggPyBjaGlsZHJlblswXS5sb2MgOiBsb2MpO1xyXG4vLyBJbnN0ZWFkIG9mIGJlaW5nIGEgRGlyZWN0aXZlVHJhbnNmb3JtLCB2LXNsb3QgcHJvY2Vzc2luZyBpcyBjYWxsZWQgZHVyaW5nXHJcbi8vIHRyYW5zZm9ybUVsZW1lbnQgdG8gYnVpbGQgdGhlIHNsb3RzIG9iamVjdCBmb3IgYSBjb21wb25lbnQuXHJcbmZ1bmN0aW9uIGJ1aWxkU2xvdHMobm9kZSwgY29udGV4dCwgYnVpbGRTbG90Rm4gPSBidWlsZENsaWVudFNsb3RGbikge1xyXG4gICAgY29udGV4dC5oZWxwZXIoV0lUSF9DVFgpO1xyXG4gICAgY29uc3QgeyBjaGlsZHJlbiwgbG9jIH0gPSBub2RlO1xyXG4gICAgY29uc3Qgc2xvdHNQcm9wZXJ0aWVzID0gW107XHJcbiAgICBjb25zdCBkeW5hbWljU2xvdHMgPSBbXTtcclxuICAgIC8vIElmIHRoZSBzbG90IGlzIGluc2lkZSBhIHYtZm9yIG9yIGFub3RoZXIgdi1zbG90LCBmb3JjZSBpdCB0byBiZSBkeW5hbWljXHJcbiAgICAvLyBzaW5jZSBpdCBsaWtlbHkgdXNlcyBhIHNjb3BlIHZhcmlhYmxlLlxyXG4gICAgbGV0IGhhc0R5bmFtaWNTbG90cyA9IGNvbnRleHQuc2NvcGVzLnZTbG90ID4gMCB8fCBjb250ZXh0LnNjb3Blcy52Rm9yID4gMDtcclxuICAgIC8vIDEuIENoZWNrIGZvciBzbG90IHdpdGggc2xvdFByb3BzIG9uIGNvbXBvbmVudCBpdHNlbGYuXHJcbiAgICAvLyAgICA8Q29tcCB2LXNsb3Q9XCJ7IHByb3AgfVwiLz5cclxuICAgIGNvbnN0IG9uQ29tcG9uZW50U2xvdCA9IGZpbmREaXIobm9kZSwgJ3Nsb3QnLCB0cnVlKTtcclxuICAgIGlmIChvbkNvbXBvbmVudFNsb3QpIHtcclxuICAgICAgICBjb25zdCB7IGFyZywgZXhwIH0gPSBvbkNvbXBvbmVudFNsb3Q7XHJcbiAgICAgICAgaWYgKGFyZyAmJiAhaXNTdGF0aWNFeHAoYXJnKSkge1xyXG4gICAgICAgICAgICBoYXNEeW5hbWljU2xvdHMgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzbG90c1Byb3BlcnRpZXMucHVzaChjcmVhdGVPYmplY3RQcm9wZXJ0eShhcmcgfHwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbignZGVmYXVsdCcsIHRydWUpLCBidWlsZFNsb3RGbihleHAsIGNoaWxkcmVuLCBsb2MpKSk7XHJcbiAgICB9XHJcbiAgICAvLyAyLiBJdGVyYXRlIHRocm91Z2ggY2hpbGRyZW4gYW5kIGNoZWNrIGZvciB0ZW1wbGF0ZSBzbG90c1xyXG4gICAgLy8gICAgPHRlbXBsYXRlIHYtc2xvdDpmb289XCJ7IHByb3AgfVwiPlxyXG4gICAgbGV0IGhhc1RlbXBsYXRlU2xvdHMgPSBmYWxzZTtcclxuICAgIGxldCBoYXNOYW1lZERlZmF1bHRTbG90ID0gZmFsc2U7XHJcbiAgICBjb25zdCBpbXBsaWNpdERlZmF1bHRDaGlsZHJlbiA9IFtdO1xyXG4gICAgY29uc3Qgc2VlblNsb3ROYW1lcyA9IG5ldyBTZXQoKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBzbG90RWxlbWVudCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgIGxldCBzbG90RGlyO1xyXG4gICAgICAgIGlmICghaXNUZW1wbGF0ZU5vZGUoc2xvdEVsZW1lbnQpIHx8XHJcbiAgICAgICAgICAgICEoc2xvdERpciA9IGZpbmREaXIoc2xvdEVsZW1lbnQsICdzbG90JywgdHJ1ZSkpKSB7XHJcbiAgICAgICAgICAgIC8vIG5vdCBhIDx0ZW1wbGF0ZSB2LXNsb3Q+LCBza2lwLlxyXG4gICAgICAgICAgICBpZiAoc2xvdEVsZW1lbnQudHlwZSAhPT0gMyAvKiBDT01NRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICBpbXBsaWNpdERlZmF1bHRDaGlsZHJlbi5wdXNoKHNsb3RFbGVtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9uQ29tcG9uZW50U2xvdCkge1xyXG4gICAgICAgICAgICAvLyBhbHJlYWR5IGhhcyBvbi1jb21wb25lbnQgc2xvdCAtIHRoaXMgaXMgaW5jb3JyZWN0IHVzYWdlLlxyXG4gICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzNiAvKiBYX1ZfU0xPVF9NSVhFRF9TTE9UX1VTQUdFICovLCBzbG90RGlyLmxvYykpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgaGFzVGVtcGxhdGVTbG90cyA9IHRydWU7XHJcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbjogc2xvdENoaWxkcmVuLCBsb2M6IHNsb3RMb2MgfSA9IHNsb3RFbGVtZW50O1xyXG4gICAgICAgIGNvbnN0IHsgYXJnOiBzbG90TmFtZSA9IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYGRlZmF1bHRgLCB0cnVlKSwgZXhwOiBzbG90UHJvcHMsIGxvYzogZGlyTG9jIH0gPSBzbG90RGlyO1xyXG4gICAgICAgIC8vIGNoZWNrIGlmIG5hbWUgaXMgZHluYW1pYy5cclxuICAgICAgICBsZXQgc3RhdGljU2xvdE5hbWU7XHJcbiAgICAgICAgaWYgKGlzU3RhdGljRXhwKHNsb3ROYW1lKSkge1xyXG4gICAgICAgICAgICBzdGF0aWNTbG90TmFtZSA9IHNsb3ROYW1lID8gc2xvdE5hbWUuY29udGVudCA6IGBkZWZhdWx0YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGhhc0R5bmFtaWNTbG90cyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNsb3RGdW5jdGlvbiA9IGJ1aWxkU2xvdEZuKHNsb3RQcm9wcywgc2xvdENoaWxkcmVuLCBzbG90TG9jKTtcclxuICAgICAgICAvLyBjaGVjayBpZiB0aGlzIHNsb3QgaXMgY29uZGl0aW9uYWwgKHYtaWYvdi1mb3IpXHJcbiAgICAgICAgbGV0IHZJZjtcclxuICAgICAgICBsZXQgdkVsc2U7XHJcbiAgICAgICAgbGV0IHZGb3I7XHJcbiAgICAgICAgaWYgKCh2SWYgPSBmaW5kRGlyKHNsb3RFbGVtZW50LCAnaWYnKSkpIHtcclxuICAgICAgICAgICAgaGFzRHluYW1pY1Nsb3RzID0gdHJ1ZTtcclxuICAgICAgICAgICAgZHluYW1pY1Nsb3RzLnB1c2goY3JlYXRlQ29uZGl0aW9uYWxFeHByZXNzaW9uKHZJZi5leHAsIGJ1aWxkRHluYW1pY1Nsb3Qoc2xvdE5hbWUsIHNsb3RGdW5jdGlvbiksIGRlZmF1bHRGYWxsYmFjaykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgodkVsc2UgPSBmaW5kRGlyKHNsb3RFbGVtZW50LCAvXmVsc2UoLWlmKT8kLywgdHJ1ZSAvKiBhbGxvd0VtcHR5ICovKSkpIHtcclxuICAgICAgICAgICAgLy8gZmluZCBhZGphY2VudCB2LWlmXHJcbiAgICAgICAgICAgIGxldCBqID0gaTtcclxuICAgICAgICAgICAgbGV0IHByZXY7XHJcbiAgICAgICAgICAgIHdoaWxlIChqLS0pIHtcclxuICAgICAgICAgICAgICAgIHByZXYgPSBjaGlsZHJlbltqXTtcclxuICAgICAgICAgICAgICAgIGlmIChwcmV2LnR5cGUgIT09IDMgLyogQ09NTUVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwcmV2ICYmIGlzVGVtcGxhdGVOb2RlKHByZXYpICYmIGZpbmREaXIocHJldiwgJ2lmJykpIHtcclxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBub2RlXHJcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICBpLS07XHJcbiAgICAgICAgICAgICAgICAvLyBhdHRhY2ggdGhpcyBzbG90IHRvIHByZXZpb3VzIGNvbmRpdGlvbmFsXHJcbiAgICAgICAgICAgICAgICBsZXQgY29uZGl0aW9uYWwgPSBkeW5hbWljU2xvdHNbZHluYW1pY1Nsb3RzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGNvbmRpdGlvbmFsLmFsdGVybmF0ZS50eXBlID09PSAxOSAvKiBKU19DT05ESVRJT05BTF9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uYWwgPSBjb25kaXRpb25hbC5hbHRlcm5hdGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25kaXRpb25hbC5hbHRlcm5hdGUgPSB2RWxzZS5leHBcclxuICAgICAgICAgICAgICAgICAgICA/IGNyZWF0ZUNvbmRpdGlvbmFsRXhwcmVzc2lvbih2RWxzZS5leHAsIGJ1aWxkRHluYW1pY1Nsb3Qoc2xvdE5hbWUsIHNsb3RGdW5jdGlvbiksIGRlZmF1bHRGYWxsYmFjaylcclxuICAgICAgICAgICAgICAgICAgICA6IGJ1aWxkRHluYW1pY1Nsb3Qoc2xvdE5hbWUsIHNsb3RGdW5jdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigyOSAvKiBYX1ZfRUxTRV9OT19BREpBQ0VOVF9JRiAqLywgdkVsc2UubG9jKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKHZGb3IgPSBmaW5kRGlyKHNsb3RFbGVtZW50LCAnZm9yJykpKSB7XHJcbiAgICAgICAgICAgIGhhc0R5bmFtaWNTbG90cyA9IHRydWU7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gdkZvci5wYXJzZVJlc3VsdCB8fFxyXG4gICAgICAgICAgICAgICAgcGFyc2VGb3JFeHByZXNzaW9uKHZGb3IuZXhwLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgaWYgKHBhcnNlUmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZW5kZXIgdGhlIGR5bmFtaWMgc2xvdHMgYXMgYW4gYXJyYXkgYW5kIGFkZCBpdCB0byB0aGUgY3JlYXRlU2xvdCgpXHJcbiAgICAgICAgICAgICAgICAvLyBhcmdzLiBUaGUgcnVudGltZSBrbm93cyBob3cgdG8gaGFuZGxlIGl0IGFwcHJvcHJpYXRlbHkuXHJcbiAgICAgICAgICAgICAgICBkeW5hbWljU2xvdHMucHVzaChjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihSRU5ERVJfTElTVCksIFtcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZVJlc3VsdC5zb3VyY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uKGNyZWF0ZUZvckxvb3BQYXJhbXMocGFyc2VSZXN1bHQpLCBidWlsZER5bmFtaWNTbG90KHNsb3ROYW1lLCBzbG90RnVuY3Rpb24pLCB0cnVlIC8qIGZvcmNlIG5ld2xpbmUgKi8pXHJcbiAgICAgICAgICAgICAgICBdKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzMSAvKiBYX1ZfRk9SX01BTEZPUk1FRF9FWFBSRVNTSU9OICovLCB2Rm9yLmxvYykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBjaGVjayBkdXBsaWNhdGUgc3RhdGljIG5hbWVzXHJcbiAgICAgICAgICAgIGlmIChzdGF0aWNTbG90TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlZW5TbG90TmFtZXMuaGFzKHN0YXRpY1Nsb3ROYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDM3IC8qIFhfVl9TTE9UX0RVUExJQ0FURV9TTE9UX05BTUVTICovLCBkaXJMb2MpKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNlZW5TbG90TmFtZXMuYWRkKHN0YXRpY1Nsb3ROYW1lKTtcclxuICAgICAgICAgICAgICAgIGlmIChzdGF0aWNTbG90TmFtZSA9PT0gJ2RlZmF1bHQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzTmFtZWREZWZhdWx0U2xvdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2xvdHNQcm9wZXJ0aWVzLnB1c2goY3JlYXRlT2JqZWN0UHJvcGVydHkoc2xvdE5hbWUsIHNsb3RGdW5jdGlvbikpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghb25Db21wb25lbnRTbG90KSB7XHJcbiAgICAgICAgY29uc3QgYnVpbGREZWZhdWx0U2xvdFByb3BlcnR5ID0gKHByb3BzLCBjaGlsZHJlbikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBmbiA9IGJ1aWxkU2xvdEZuKHByb3BzLCBjaGlsZHJlbiwgbG9jKTtcclxuICAgICAgICAgICAgaWYgKGNvbnRleHQuY29tcGF0Q29uZmlnKSB7XHJcbiAgICAgICAgICAgICAgICBmbi5pc05vblNjb3BlZFNsb3QgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVPYmplY3RQcm9wZXJ0eShgZGVmYXVsdGAsIGZuKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICghaGFzVGVtcGxhdGVTbG90cykge1xyXG4gICAgICAgICAgICAvLyBpbXBsaWNpdCBkZWZhdWx0IHNsb3QgKG9uIGNvbXBvbmVudClcclxuICAgICAgICAgICAgc2xvdHNQcm9wZXJ0aWVzLnB1c2goYnVpbGREZWZhdWx0U2xvdFByb3BlcnR5KHVuZGVmaW5lZCwgY2hpbGRyZW4pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaW1wbGljaXREZWZhdWx0Q2hpbGRyZW4ubGVuZ3RoICYmXHJcbiAgICAgICAgICAgIC8vICMzNzY2XHJcbiAgICAgICAgICAgIC8vIHdpdGggd2hpdGVzcGFjZTogJ3ByZXNlcnZlJywgd2hpdGVzcGFjZXMgYmV0d2VlbiBzbG90cyB3aWxsIGVuZCB1cCBpblxyXG4gICAgICAgICAgICAvLyBpbXBsaWNpdERlZmF1bHRDaGlsZHJlbi4gSWdub3JlIGlmIGFsbCBpbXBsaWNpdCBjaGlsZHJlbiBhcmUgd2hpdGVzcGFjZXMuXHJcbiAgICAgICAgICAgIGltcGxpY2l0RGVmYXVsdENoaWxkcmVuLnNvbWUobm9kZSA9PiBpc05vbldoaXRlc3BhY2VDb250ZW50KG5vZGUpKSkge1xyXG4gICAgICAgICAgICAvLyBpbXBsaWNpdCBkZWZhdWx0IHNsb3QgKG1peGVkIHdpdGggbmFtZWQgc2xvdHMpXHJcbiAgICAgICAgICAgIGlmIChoYXNOYW1lZERlZmF1bHRTbG90KSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzOCAvKiBYX1ZfU0xPVF9FWFRSQU5FT1VTX0RFRkFVTFRfU0xPVF9DSElMRFJFTiAqLywgaW1wbGljaXREZWZhdWx0Q2hpbGRyZW5bMF0ubG9jKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzbG90c1Byb3BlcnRpZXMucHVzaChidWlsZERlZmF1bHRTbG90UHJvcGVydHkodW5kZWZpbmVkLCBpbXBsaWNpdERlZmF1bHRDaGlsZHJlbikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3Qgc2xvdEZsYWcgPSBoYXNEeW5hbWljU2xvdHNcclxuICAgICAgICA/IDIgLyogRFlOQU1JQyAqL1xyXG4gICAgICAgIDogaGFzRm9yd2FyZGVkU2xvdHMobm9kZS5jaGlsZHJlbilcclxuICAgICAgICAgICAgPyAzIC8qIEZPUldBUkRFRCAqL1xyXG4gICAgICAgICAgICA6IDEgLyogU1RBQkxFICovO1xyXG4gICAgbGV0IHNsb3RzID0gY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihzbG90c1Byb3BlcnRpZXMuY29uY2F0KGNyZWF0ZU9iamVjdFByb3BlcnR5KGBfYCwgXHJcbiAgICAvLyAyID0gY29tcGlsZWQgYnV0IGR5bmFtaWMgPSBjYW4gc2tpcCBub3JtYWxpemF0aW9uLCBidXQgbXVzdCBydW4gZGlmZlxyXG4gICAgLy8gMSA9IGNvbXBpbGVkIGFuZCBzdGF0aWMgPSBjYW4gc2tpcCBub3JtYWxpemF0aW9uIEFORCBkaWZmIGFzIG9wdGltaXplZFxyXG4gICAgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihzbG90RmxhZyArICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgIC8qICR7c2xvdEZsYWdzVGV4dFtzbG90RmxhZ119ICovYCA6IGBgKSwgZmFsc2UpKSksIGxvYyk7XHJcbiAgICBpZiAoZHluYW1pY1Nsb3RzLmxlbmd0aCkge1xyXG4gICAgICAgIHNsb3RzID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoQ1JFQVRFX1NMT1RTKSwgW1xyXG4gICAgICAgICAgICBzbG90cyxcclxuICAgICAgICAgICAgY3JlYXRlQXJyYXlFeHByZXNzaW9uKGR5bmFtaWNTbG90cylcclxuICAgICAgICBdKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc2xvdHMsXHJcbiAgICAgICAgaGFzRHluYW1pY1Nsb3RzXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGJ1aWxkRHluYW1pY1Nsb3QobmFtZSwgZm4pIHtcclxuICAgIHJldHVybiBjcmVhdGVPYmplY3RFeHByZXNzaW9uKFtcclxuICAgICAgICBjcmVhdGVPYmplY3RQcm9wZXJ0eShgbmFtZWAsIG5hbWUpLFxyXG4gICAgICAgIGNyZWF0ZU9iamVjdFByb3BlcnR5KGBmbmAsIGZuKVxyXG4gICAgXSk7XHJcbn1cclxuZnVuY3Rpb24gaGFzRm9yd2FyZGVkU2xvdHMoY2hpbGRyZW4pIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgIHN3aXRjaCAoY2hpbGQudHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIDEgLyogRUxFTUVOVCAqLzpcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50YWdUeXBlID09PSAyIC8qIFNMT1QgKi8gfHxcclxuICAgICAgICAgICAgICAgICAgICAoY2hpbGQudGFnVHlwZSA9PT0gMCAvKiBFTEVNRU5UICovICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0ZvcndhcmRlZFNsb3RzKGNoaWxkLmNoaWxkcmVuKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDkgLyogSUYgKi86XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzRm9yd2FyZGVkU2xvdHMoY2hpbGQuYnJhbmNoZXMpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMTAgLyogSUZfQlJBTkNIICovOlxyXG4gICAgICAgICAgICBjYXNlIDExIC8qIEZPUiAqLzpcclxuICAgICAgICAgICAgICAgIGlmIChoYXNGb3J3YXJkZWRTbG90cyhjaGlsZC5jaGlsZHJlbikpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gaXNOb25XaGl0ZXNwYWNlQ29udGVudChub2RlKSB7XHJcbiAgICBpZiAobm9kZS50eXBlICE9PSAyIC8qIFRFWFQgKi8gJiYgbm9kZS50eXBlICE9PSAxMiAvKiBURVhUX0NBTEwgKi8pXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSAyIC8qIFRFWFQgKi9cclxuICAgICAgICA/ICEhbm9kZS5jb250ZW50LnRyaW0oKVxyXG4gICAgICAgIDogaXNOb25XaGl0ZXNwYWNlQ29udGVudChub2RlLmNvbnRlbnQpO1xyXG59XG5cbi8vIHNvbWUgZGlyZWN0aXZlIHRyYW5zZm9ybXMgKGUuZy4gdi1tb2RlbCkgbWF5IHJldHVybiBhIHN5bWJvbCBmb3IgcnVudGltZVxyXG4vLyBpbXBvcnQsIHdoaWNoIHNob3VsZCBiZSB1c2VkIGluc3RlYWQgb2YgYSByZXNvbHZlRGlyZWN0aXZlIGNhbGwuXHJcbmNvbnN0IGRpcmVjdGl2ZUltcG9ydE1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbi8vIGdlbmVyYXRlIGEgSmF2YVNjcmlwdCBBU1QgZm9yIHRoaXMgZWxlbWVudCdzIGNvZGVnZW5cclxuY29uc3QgdHJhbnNmb3JtRWxlbWVudCA9IChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICAvLyBwZXJmb3JtIHRoZSB3b3JrIG9uIGV4aXQsIGFmdGVyIGFsbCBjaGlsZCBleHByZXNzaW9ucyBoYXZlIGJlZW5cclxuICAgIC8vIHByb2Nlc3NlZCBhbmQgbWVyZ2VkLlxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHBvc3RUcmFuc2Zvcm1FbGVtZW50KCkge1xyXG4gICAgICAgIG5vZGUgPSBjb250ZXh0LmN1cnJlbnROb2RlO1xyXG4gICAgICAgIGlmICghKG5vZGUudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovICYmXHJcbiAgICAgICAgICAgIChub2RlLnRhZ1R5cGUgPT09IDAgLyogRUxFTUVOVCAqLyB8fFxyXG4gICAgICAgICAgICAgICAgbm9kZS50YWdUeXBlID09PSAxIC8qIENPTVBPTkVOVCAqLykpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyB0YWcsIHByb3BzIH0gPSBub2RlO1xyXG4gICAgICAgIGNvbnN0IGlzQ29tcG9uZW50ID0gbm9kZS50YWdUeXBlID09PSAxIC8qIENPTVBPTkVOVCAqLztcclxuICAgICAgICAvLyBUaGUgZ29hbCBvZiB0aGUgdHJhbnNmb3JtIGlzIHRvIGNyZWF0ZSBhIGNvZGVnZW5Ob2RlIGltcGxlbWVudGluZyB0aGVcclxuICAgICAgICAvLyBWTm9kZUNhbGwgaW50ZXJmYWNlLlxyXG4gICAgICAgIGxldCB2bm9kZVRhZyA9IGlzQ29tcG9uZW50XHJcbiAgICAgICAgICAgID8gcmVzb2x2ZUNvbXBvbmVudFR5cGUobm9kZSwgY29udGV4dClcclxuICAgICAgICAgICAgOiBgXCIke3RhZ31cImA7XHJcbiAgICAgICAgY29uc3QgaXNEeW5hbWljQ29tcG9uZW50ID0gaXNPYmplY3Qodm5vZGVUYWcpICYmIHZub2RlVGFnLmNhbGxlZSA9PT0gUkVTT0xWRV9EWU5BTUlDX0NPTVBPTkVOVDtcclxuICAgICAgICBsZXQgdm5vZGVQcm9wcztcclxuICAgICAgICBsZXQgdm5vZGVDaGlsZHJlbjtcclxuICAgICAgICBsZXQgdm5vZGVQYXRjaEZsYWc7XHJcbiAgICAgICAgbGV0IHBhdGNoRmxhZyA9IDA7XHJcbiAgICAgICAgbGV0IHZub2RlRHluYW1pY1Byb3BzO1xyXG4gICAgICAgIGxldCBkeW5hbWljUHJvcE5hbWVzO1xyXG4gICAgICAgIGxldCB2bm9kZURpcmVjdGl2ZXM7XHJcbiAgICAgICAgbGV0IHNob3VsZFVzZUJsb2NrID0gXHJcbiAgICAgICAgLy8gZHluYW1pYyBjb21wb25lbnQgbWF5IHJlc29sdmUgdG8gcGxhaW4gZWxlbWVudHNcclxuICAgICAgICBpc0R5bmFtaWNDb21wb25lbnQgfHxcclxuICAgICAgICAgICAgdm5vZGVUYWcgPT09IFRFTEVQT1JUIHx8XHJcbiAgICAgICAgICAgIHZub2RlVGFnID09PSBTVVNQRU5TRSB8fFxyXG4gICAgICAgICAgICAoIWlzQ29tcG9uZW50ICYmXHJcbiAgICAgICAgICAgICAgICAvLyA8c3ZnPiBhbmQgPGZvcmVpZ25PYmplY3Q+IG11c3QgYmUgZm9yY2VkIGludG8gYmxvY2tzIHNvIHRoYXQgYmxvY2tcclxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZXMgaW5zaWRlIGdldCBwcm9wZXIgaXNTVkcgZmxhZyBhdCBydW50aW1lLiAoIzYzOSwgIzY0MylcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGVjaG5pY2FsbHkgd2ViLXNwZWNpZmljLCBidXQgc3BsaXR0aW5nIHRoZSBsb2dpYyBvdXQgb2YgY29yZVxyXG4gICAgICAgICAgICAgICAgLy8gbGVhZHMgdG8gdG9vIG11Y2ggdW5uZWNlc3NhcnkgY29tcGxleGl0eS5cclxuICAgICAgICAgICAgICAgICh0YWcgPT09ICdzdmcnIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgdGFnID09PSAnZm9yZWlnbk9iamVjdCcgfHxcclxuICAgICAgICAgICAgICAgICAgICAvLyAjOTM4OiBlbGVtZW50cyB3aXRoIGR5bmFtaWMga2V5cyBzaG91bGQgYmUgZm9yY2VkIGludG8gYmxvY2tzXHJcbiAgICAgICAgICAgICAgICAgICAgZmluZFByb3Aobm9kZSwgJ2tleScsIHRydWUpKSk7XHJcbiAgICAgICAgLy8gcHJvcHNcclxuICAgICAgICBpZiAocHJvcHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcm9wc0J1aWxkUmVzdWx0ID0gYnVpbGRQcm9wcyhub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgdm5vZGVQcm9wcyA9IHByb3BzQnVpbGRSZXN1bHQucHJvcHM7XHJcbiAgICAgICAgICAgIHBhdGNoRmxhZyA9IHByb3BzQnVpbGRSZXN1bHQucGF0Y2hGbGFnO1xyXG4gICAgICAgICAgICBkeW5hbWljUHJvcE5hbWVzID0gcHJvcHNCdWlsZFJlc3VsdC5keW5hbWljUHJvcE5hbWVzO1xyXG4gICAgICAgICAgICBjb25zdCBkaXJlY3RpdmVzID0gcHJvcHNCdWlsZFJlc3VsdC5kaXJlY3RpdmVzO1xyXG4gICAgICAgICAgICB2bm9kZURpcmVjdGl2ZXMgPVxyXG4gICAgICAgICAgICAgICAgZGlyZWN0aXZlcyAmJiBkaXJlY3RpdmVzLmxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgID8gY3JlYXRlQXJyYXlFeHByZXNzaW9uKGRpcmVjdGl2ZXMubWFwKGRpciA9PiBidWlsZERpcmVjdGl2ZUFyZ3MoZGlyLCBjb250ZXh0KSkpXHJcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNoaWxkcmVuXHJcbiAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBpZiAodm5vZGVUYWcgPT09IEtFRVBfQUxJVkUpIHtcclxuICAgICAgICAgICAgICAgIC8vIEFsdGhvdWdoIGEgYnVpbHQtaW4gY29tcG9uZW50LCB3ZSBjb21waWxlIEtlZXBBbGl2ZSB3aXRoIHJhdyBjaGlsZHJlblxyXG4gICAgICAgICAgICAgICAgLy8gaW5zdGVhZCBvZiBzbG90IGZ1bmN0aW9ucyBzbyB0aGF0IGl0IGNhbiBiZSB1c2VkIGluc2lkZSBUcmFuc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAvLyBvciBvdGhlciBUcmFuc2l0aW9uLXdyYXBwaW5nIEhPQ3MuXHJcbiAgICAgICAgICAgICAgICAvLyBUbyBlbnN1cmUgY29ycmVjdCB1cGRhdGVzIHdpdGggYmxvY2sgb3B0aW1pemF0aW9ucywgd2UgbmVlZCB0bzpcclxuICAgICAgICAgICAgICAgIC8vIDEuIEZvcmNlIGtlZXAtYWxpdmUgaW50byBhIGJsb2NrLiBUaGlzIGF2b2lkcyBpdHMgY2hpbGRyZW4gYmVpbmdcclxuICAgICAgICAgICAgICAgIC8vICAgIGNvbGxlY3RlZCBieSBhIHBhcmVudCBibG9jay5cclxuICAgICAgICAgICAgICAgIHNob3VsZFVzZUJsb2NrID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIC8vIDIuIEZvcmNlIGtlZXAtYWxpdmUgdG8gYWx3YXlzIGJlIHVwZGF0ZWQsIHNpbmNlIGl0IHVzZXMgcmF3IGNoaWxkcmVuLlxyXG4gICAgICAgICAgICAgICAgcGF0Y2hGbGFnIHw9IDEwMjQgLyogRFlOQU1JQ19TTE9UUyAqLztcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNDQgLyogWF9LRUVQX0FMSVZFX0lOVkFMSURfQ0hJTERSRU4gKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IG5vZGUuY2hpbGRyZW5bMF0ubG9jLnN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IG5vZGUuY2hpbGRyZW5bbm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxXS5sb2MuZW5kLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6ICcnXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZEJ1aWxkQXNTbG90cyA9IGlzQ29tcG9uZW50ICYmXHJcbiAgICAgICAgICAgICAgICAvLyBUZWxlcG9ydCBpcyBub3QgYSByZWFsIGNvbXBvbmVudCBhbmQgaGFzIGRlZGljYXRlZCBydW50aW1lIGhhbmRsaW5nXHJcbiAgICAgICAgICAgICAgICB2bm9kZVRhZyAhPT0gVEVMRVBPUlQgJiZcclxuICAgICAgICAgICAgICAgIC8vIGV4cGxhaW5lZCBhYm92ZS5cclxuICAgICAgICAgICAgICAgIHZub2RlVGFnICE9PSBLRUVQX0FMSVZFO1xyXG4gICAgICAgICAgICBpZiAoc2hvdWxkQnVpbGRBc1Nsb3RzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNsb3RzLCBoYXNEeW5hbWljU2xvdHMgfSA9IGJ1aWxkU2xvdHMobm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICB2bm9kZUNoaWxkcmVuID0gc2xvdHM7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzRHluYW1pY1Nsb3RzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hGbGFnIHw9IDEwMjQgLyogRFlOQU1JQ19TTE9UUyAqLztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiB2bm9kZVRhZyAhPT0gVEVMRVBPUlQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlblswXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBjaGlsZC50eXBlO1xyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGR5bmFtaWMgdGV4dCBjaGlsZHJlblxyXG4gICAgICAgICAgICAgICAgY29uc3QgaGFzRHluYW1pY1RleHRDaGlsZCA9IHR5cGUgPT09IDUgLyogSU5URVJQT0xBVElPTiAqLyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPT09IDggLyogQ09NUE9VTkRfRVhQUkVTU0lPTiAqLztcclxuICAgICAgICAgICAgICAgIGlmIChoYXNEeW5hbWljVGV4dENoaWxkICYmXHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0Q29uc3RhbnRUeXBlKGNoaWxkLCBjb250ZXh0KSA9PT0gMCAvKiBOT1RfQ09OU1RBTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRjaEZsYWcgfD0gMSAvKiBURVhUICovO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gcGFzcyBkaXJlY3RseSBpZiB0aGUgb25seSBjaGlsZCBpcyBhIHRleHQgbm9kZVxyXG4gICAgICAgICAgICAgICAgLy8gKHBsYWluIC8gaW50ZXJwb2xhdGlvbiAvIGV4cHJlc3Npb24pXHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzRHluYW1pY1RleHRDaGlsZCB8fCB0eXBlID09PSAyIC8qIFRFWFQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICB2bm9kZUNoaWxkcmVuID0gY2hpbGQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2bm9kZUNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZub2RlQ2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHBhdGNoRmxhZyAmIGR5bmFtaWNQcm9wTmFtZXNcclxuICAgICAgICBpZiAocGF0Y2hGbGFnICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwYXRjaEZsYWcgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lhbCBmbGFncyAobmVnYXRpdmUgYW5kIG11dHVhbGx5IGV4Y2x1c2l2ZSlcclxuICAgICAgICAgICAgICAgICAgICB2bm9kZVBhdGNoRmxhZyA9IHBhdGNoRmxhZyArIGAgLyogJHtQYXRjaEZsYWdOYW1lc1twYXRjaEZsYWddfSAqL2A7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBiaXR3aXNlIGZsYWdzXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmxhZ05hbWVzID0gT2JqZWN0LmtleXMoUGF0Y2hGbGFnTmFtZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoTnVtYmVyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKG4gPT4gbiA+IDAgJiYgcGF0Y2hGbGFnICYgbilcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChuID0+IFBhdGNoRmxhZ05hbWVzW25dKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuam9pbihgLCBgKTtcclxuICAgICAgICAgICAgICAgICAgICB2bm9kZVBhdGNoRmxhZyA9IHBhdGNoRmxhZyArIGAgLyogJHtmbGFnTmFtZXN9ICovYDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZub2RlUGF0Y2hGbGFnID0gU3RyaW5nKHBhdGNoRmxhZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGR5bmFtaWNQcm9wTmFtZXMgJiYgZHluYW1pY1Byb3BOYW1lcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHZub2RlRHluYW1pY1Byb3BzID0gc3RyaW5naWZ5RHluYW1pY1Byb3BOYW1lcyhkeW5hbWljUHJvcE5hbWVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBub2RlLmNvZGVnZW5Ob2RlID0gY3JlYXRlVk5vZGVDYWxsKGNvbnRleHQsIHZub2RlVGFnLCB2bm9kZVByb3BzLCB2bm9kZUNoaWxkcmVuLCB2bm9kZVBhdGNoRmxhZywgdm5vZGVEeW5hbWljUHJvcHMsIHZub2RlRGlyZWN0aXZlcywgISFzaG91bGRVc2VCbG9jaywgZmFsc2UgLyogZGlzYWJsZVRyYWNraW5nICovLCBub2RlLmxvYyk7XHJcbiAgICB9O1xyXG59O1xyXG5mdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50VHlwZShub2RlLCBjb250ZXh0LCBzc3IgPSBmYWxzZSkge1xyXG4gICAgbGV0IHsgdGFnIH0gPSBub2RlO1xyXG4gICAgLy8gMS4gZHluYW1pYyBjb21wb25lbnRcclxuICAgIGNvbnN0IGlzRXhwbGljaXREeW5hbWljID0gaXNDb21wb25lbnRUYWcodGFnKTtcclxuICAgIGNvbnN0IGlzUHJvcCA9IGZpbmRQcm9wKG5vZGUsICdpcycpIHx8ICghaXNFeHBsaWNpdER5bmFtaWMgJiYgZmluZERpcihub2RlLCAnaXMnKSk7XHJcbiAgICBpZiAoaXNQcm9wKSB7XHJcbiAgICAgICAgaWYgKCFpc0V4cGxpY2l0RHluYW1pYyAmJiBpc1Byb3AudHlwZSA9PT0gNiAvKiBBVFRSSUJVVEUgKi8pIHtcclxuICAgICAgICAgICAgLy8gPGJ1dHRvbiBpcz1cInZ1ZTp4eHhcIj5cclxuICAgICAgICAgICAgLy8gaWYgbm90IDxjb21wb25lbnQ+LCBvbmx5IGlzIHZhbHVlIHRoYXQgc3RhcnRzIHdpdGggXCJ2dWU6XCIgd2lsbCBiZVxyXG4gICAgICAgICAgICAvLyB0cmVhdGVkIGFzIGNvbXBvbmVudCBieSB0aGUgcGFyc2UgcGhhc2UgYW5kIHJlYWNoIGhlcmUsIHVubGVzcyBpdCdzXHJcbiAgICAgICAgICAgIC8vIGNvbXBhdCBtb2RlIHdoZXJlIGFsbCBpcyB2YWx1ZXMgYXJlIGNvbnNpZGVyZWQgY29tcG9uZW50c1xyXG4gICAgICAgICAgICB0YWcgPSBpc1Byb3AudmFsdWUuY29udGVudC5yZXBsYWNlKC9ednVlOi8sICcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4cCA9IGlzUHJvcC50eXBlID09PSA2IC8qIEFUVFJJQlVURSAqL1xyXG4gICAgICAgICAgICAgICAgPyBpc1Byb3AudmFsdWUgJiYgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihpc1Byb3AudmFsdWUuY29udGVudCwgdHJ1ZSlcclxuICAgICAgICAgICAgICAgIDogaXNQcm9wLmV4cDtcclxuICAgICAgICAgICAgaWYgKGV4cCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKFJFU09MVkVfRFlOQU1JQ19DT01QT05FTlQpLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgZXhwXHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIDIuIGJ1aWx0LWluIGNvbXBvbmVudHMgKFRlbGVwb3J0LCBUcmFuc2l0aW9uLCBLZWVwQWxpdmUsIFN1c3BlbnNlLi4uKVxyXG4gICAgY29uc3QgYnVpbHRJbiA9IGlzQ29yZUNvbXBvbmVudCh0YWcpIHx8IGNvbnRleHQuaXNCdWlsdEluQ29tcG9uZW50KHRhZyk7XHJcbiAgICBpZiAoYnVpbHRJbikge1xyXG4gICAgICAgIC8vIGJ1aWx0LWlucyBhcmUgc2ltcGx5IGZhbGx0aHJvdWdocyAvIGhhdmUgc3BlY2lhbCBoYW5kbGluZyBkdXJpbmcgc3NyXHJcbiAgICAgICAgLy8gc28gd2UgZG9uJ3QgbmVlZCB0byBpbXBvcnQgdGhlaXIgcnVudGltZSBlcXVpdmFsZW50c1xyXG4gICAgICAgIGlmICghc3NyKVxyXG4gICAgICAgICAgICBjb250ZXh0LmhlbHBlcihidWlsdEluKTtcclxuICAgICAgICByZXR1cm4gYnVpbHRJbjtcclxuICAgIH1cclxuICAgIC8vIDUuIHVzZXIgY29tcG9uZW50IChyZXNvbHZlKVxyXG4gICAgY29udGV4dC5oZWxwZXIoUkVTT0xWRV9DT01QT05FTlQpO1xyXG4gICAgY29udGV4dC5jb21wb25lbnRzLmFkZCh0YWcpO1xyXG4gICAgcmV0dXJuIHRvVmFsaWRBc3NldElkKHRhZywgYGNvbXBvbmVudGApO1xyXG59XHJcbmZ1bmN0aW9uIGJ1aWxkUHJvcHMobm9kZSwgY29udGV4dCwgcHJvcHMgPSBub2RlLnByb3BzLCBzc3IgPSBmYWxzZSkge1xyXG4gICAgY29uc3QgeyB0YWcsIGxvYzogZWxlbWVudExvYyB9ID0gbm9kZTtcclxuICAgIGNvbnN0IGlzQ29tcG9uZW50ID0gbm9kZS50YWdUeXBlID09PSAxIC8qIENPTVBPTkVOVCAqLztcclxuICAgIGxldCBwcm9wZXJ0aWVzID0gW107XHJcbiAgICBjb25zdCBtZXJnZUFyZ3MgPSBbXTtcclxuICAgIGNvbnN0IHJ1bnRpbWVEaXJlY3RpdmVzID0gW107XHJcbiAgICAvLyBwYXRjaEZsYWcgYW5hbHlzaXNcclxuICAgIGxldCBwYXRjaEZsYWcgPSAwO1xyXG4gICAgbGV0IGhhc1JlZiA9IGZhbHNlO1xyXG4gICAgbGV0IGhhc0NsYXNzQmluZGluZyA9IGZhbHNlO1xyXG4gICAgbGV0IGhhc1N0eWxlQmluZGluZyA9IGZhbHNlO1xyXG4gICAgbGV0IGhhc0h5ZHJhdGlvbkV2ZW50QmluZGluZyA9IGZhbHNlO1xyXG4gICAgbGV0IGhhc0R5bmFtaWNLZXlzID0gZmFsc2U7XHJcbiAgICBsZXQgaGFzVm5vZGVIb29rID0gZmFsc2U7XHJcbiAgICBjb25zdCBkeW5hbWljUHJvcE5hbWVzID0gW107XHJcbiAgICBjb25zdCBhbmFseXplUGF0Y2hGbGFnID0gKHsga2V5LCB2YWx1ZSB9KSA9PiB7XHJcbiAgICAgICAgaWYgKGlzU3RhdGljRXhwKGtleSkpIHtcclxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGtleS5jb250ZW50O1xyXG4gICAgICAgICAgICBjb25zdCBpc0V2ZW50SGFuZGxlciA9IGlzT24obmFtZSk7XHJcbiAgICAgICAgICAgIGlmICghaXNDb21wb25lbnQgJiZcclxuICAgICAgICAgICAgICAgIGlzRXZlbnRIYW5kbGVyICYmXHJcbiAgICAgICAgICAgICAgICAvLyBvbWl0IHRoZSBmbGFnIGZvciBjbGljayBoYW5kbGVycyBiZWNhdXNlIGh5ZHJhdGlvbiBnaXZlcyBjbGlja1xyXG4gICAgICAgICAgICAgICAgLy8gZGVkaWNhdGVkIGZhc3QgcGF0aC5cclxuICAgICAgICAgICAgICAgIG5hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ29uY2xpY2snICYmXHJcbiAgICAgICAgICAgICAgICAvLyBvbWl0IHYtbW9kZWwgaGFuZGxlcnNcclxuICAgICAgICAgICAgICAgIG5hbWUgIT09ICdvblVwZGF0ZTptb2RlbFZhbHVlJyAmJlxyXG4gICAgICAgICAgICAgICAgLy8gb21pdCBvblZub2RlWFhYIGhvb2tzXHJcbiAgICAgICAgICAgICAgICAhaXNSZXNlcnZlZFByb3AobmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIGhhc0h5ZHJhdGlvbkV2ZW50QmluZGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzRXZlbnRIYW5kbGVyICYmIGlzUmVzZXJ2ZWRQcm9wKG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBoYXNWbm9kZUhvb2sgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09PSAyMCAvKiBKU19DQUNIRV9FWFBSRVNTSU9OICovIHx8XHJcbiAgICAgICAgICAgICAgICAoKHZhbHVlLnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8gfHxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS50eXBlID09PSA4IC8qIENPTVBPVU5EX0VYUFJFU1NJT04gKi8pICYmXHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0Q29uc3RhbnRUeXBlKHZhbHVlLCBjb250ZXh0KSA+IDApKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBza2lwIGlmIHRoZSBwcm9wIGlzIGEgY2FjaGVkIGhhbmRsZXIgb3IgaGFzIGNvbnN0YW50IHZhbHVlXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdyZWYnKSB7XHJcbiAgICAgICAgICAgICAgICBoYXNSZWYgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdjbGFzcycgJiYgIWlzQ29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICBoYXNDbGFzc0JpbmRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdzdHlsZScgJiYgIWlzQ29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICBoYXNTdHlsZUJpbmRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgIT09ICdrZXknICYmICFkeW5hbWljUHJvcE5hbWVzLmluY2x1ZGVzKG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBkeW5hbWljUHJvcE5hbWVzLnB1c2gobmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGhhc0R5bmFtaWNLZXlzID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIC8vIHN0YXRpYyBhdHRyaWJ1dGVcclxuICAgICAgICBjb25zdCBwcm9wID0gcHJvcHNbaV07XHJcbiAgICAgICAgaWYgKHByb3AudHlwZSA9PT0gNiAvKiBBVFRSSUJVVEUgKi8pIHtcclxuICAgICAgICAgICAgY29uc3QgeyBsb2MsIG5hbWUsIHZhbHVlIH0gPSBwcm9wO1xyXG4gICAgICAgICAgICBsZXQgaXNTdGF0aWMgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ3JlZicpIHtcclxuICAgICAgICAgICAgICAgIGhhc1JlZiA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gc2tpcCBpcyBvbiA8Y29tcG9uZW50Piwgb3IgaXM9XCJ2dWU6eHh4XCJcclxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdpcycgJiZcclxuICAgICAgICAgICAgICAgIChpc0NvbXBvbmVudFRhZyh0YWcpIHx8ICh2YWx1ZSAmJiB2YWx1ZS5jb250ZW50LnN0YXJ0c1dpdGgoJ3Z1ZTonKSkpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2goY3JlYXRlT2JqZWN0UHJvcGVydHkoY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihuYW1lLCB0cnVlLCBnZXRJbm5lclJhbmdlKGxvYywgMCwgbmFtZS5sZW5ndGgpKSwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbih2YWx1ZSA/IHZhbHVlLmNvbnRlbnQgOiAnJywgaXNTdGF0aWMsIHZhbHVlID8gdmFsdWUubG9jIDogbG9jKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gZGlyZWN0aXZlc1xyXG4gICAgICAgICAgICBjb25zdCB7IG5hbWUsIGFyZywgZXhwLCBsb2MgfSA9IHByb3A7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzVkJpbmQgPSBuYW1lID09PSAnYmluZCc7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzVk9uID0gbmFtZSA9PT0gJ29uJztcclxuICAgICAgICAgICAgLy8gc2tpcCB2LXNsb3QgLSBpdCBpcyBoYW5kbGVkIGJ5IGl0cyBkZWRpY2F0ZWQgdHJhbnNmb3JtLlxyXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ3Nsb3QnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQ29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzkgLyogWF9WX1NMT1RfTUlTUExBQ0VEICovLCBsb2MpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHNraXAgdi1vbmNlIC0gaXQgaXMgaGFuZGxlZCBieSBpdHMgZGVkaWNhdGVkIHRyYW5zZm9ybS5cclxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdvbmNlJykge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gc2tpcCB2LWlzIGFuZCA6aXMgb24gPGNvbXBvbmVudD5cclxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdpcycgfHxcclxuICAgICAgICAgICAgICAgIChpc1ZCaW5kICYmIGlzQ29tcG9uZW50VGFnKHRhZykgJiYgaXNCaW5kS2V5KGFyZywgJ2lzJykpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBza2lwIHYtb24gaW4gU1NSIGNvbXBpbGF0aW9uXHJcbiAgICAgICAgICAgIGlmIChpc1ZPbiAmJiBzc3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZSBmb3Igdi1iaW5kIGFuZCB2LW9uIHdpdGggbm8gYXJndW1lbnRcclxuICAgICAgICAgICAgaWYgKCFhcmcgJiYgKGlzVkJpbmQgfHwgaXNWT24pKSB7XHJcbiAgICAgICAgICAgICAgICBoYXNEeW5hbWljS2V5cyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXhwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlQXJncy5wdXNoKGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oZGVkdXBlUHJvcGVydGllcyhwcm9wZXJ0aWVzKSwgZWxlbWVudExvYykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ZCaW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDIueCB2LWJpbmQgb2JqZWN0IG9yZGVyIGNvbXBhdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc092ZXJyaWRhYmxlS2V5cyA9IG1lcmdlQXJncy5zb21lKGFyZyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmcudHlwZSA9PT0gMTUgLyogSlNfT0JKRUNUX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmcucHJvcGVydGllcy5zb21lKCh7IGtleSB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleS50eXBlICE9PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFrZXkuaXNTdGF0aWMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoa2V5LmNvbnRlbnQgIT09ICdjbGFzcycgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5LmNvbnRlbnQgIT09ICdzdHlsZScgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWlzT24oa2V5LmNvbnRlbnQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZHluYW1pYyBleHByZXNzaW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNPdmVycmlkYWJsZUtleXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tDb21wYXRFbmFibGVkKFwiQ09NUElMRVJfVl9CSU5EX09CSkVDVF9PUkRFUlwiIC8qIENPTVBJTEVSX1ZfQklORF9PQkpFQ1RfT1JERVIgKi8sIGNvbnRleHQsIGxvYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ29tcGF0RW5hYmxlZChcIkNPTVBJTEVSX1ZfQklORF9PQkpFQ1RfT1JERVJcIiAvKiBDT01QSUxFUl9WX0JJTkRfT0JKRUNUX09SREVSICovLCBjb250ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlQXJncy51bnNoaWZ0KGV4cCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2VBcmdzLnB1c2goZXhwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHYtb249XCJvYmpcIiAtPiB0b0hhbmRsZXJzKG9iailcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2VBcmdzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogMTQgLyogSlNfQ0FMTF9FWFBSRVNTSU9OICovLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGVlOiBjb250ZXh0LmhlbHBlcihUT19IQU5ETEVSUyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtleHBdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKGlzVkJpbmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyAzMyAvKiBYX1ZfQklORF9OT19FWFBSRVNTSU9OICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogMzQgLyogWF9WX09OX05PX0VYUFJFU1NJT04gKi8sIGxvYykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZGlyZWN0aXZlVHJhbnNmb3JtID0gY29udGV4dC5kaXJlY3RpdmVUcmFuc2Zvcm1zW25hbWVdO1xyXG4gICAgICAgICAgICBpZiAoZGlyZWN0aXZlVHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBoYXMgYnVpbHQtaW4gZGlyZWN0aXZlIHRyYW5zZm9ybS5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcHJvcHMsIG5lZWRSdW50aW1lIH0gPSBkaXJlY3RpdmVUcmFuc2Zvcm0ocHJvcCwgbm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAhc3NyICYmIHByb3BzLmZvckVhY2goYW5hbHl6ZVBhdGNoRmxhZyk7XHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2goLi4ucHJvcHMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5lZWRSdW50aW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcnVudGltZURpcmVjdGl2ZXMucHVzaChwcm9wKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTeW1ib2wobmVlZFJ1bnRpbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGl2ZUltcG9ydE1hcC5zZXQocHJvcCwgbmVlZFJ1bnRpbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIG5vIGJ1aWx0LWluIHRyYW5zZm9ybSwgdGhpcyBpcyBhIHVzZXIgY3VzdG9tIGRpcmVjdGl2ZS5cclxuICAgICAgICAgICAgICAgIHJ1bnRpbWVEaXJlY3RpdmVzLnB1c2gocHJvcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByb3AudHlwZSA9PT0gNiAvKiBBVFRSSUJVVEUgKi8gJiZcclxuICAgICAgICAgICAgcHJvcC5uYW1lID09PSAncmVmJyAmJlxyXG4gICAgICAgICAgICBjb250ZXh0LnNjb3Blcy52Rm9yID4gMCAmJlxyXG4gICAgICAgICAgICBjaGVja0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9WX0ZPUl9SRUZcIiAvKiBDT01QSUxFUl9WX0ZPUl9SRUYgKi8sIGNvbnRleHQsIHByb3AubG9jKSkge1xyXG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2goY3JlYXRlT2JqZWN0UHJvcGVydHkoY3JlYXRlU2ltcGxlRXhwcmVzc2lvbigncmVmSW5Gb3InLCB0cnVlKSwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbigndHJ1ZScsIGZhbHNlKSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGxldCBwcm9wc0V4cHJlc3Npb24gPSB1bmRlZmluZWQ7XHJcbiAgICAvLyBoYXMgdi1iaW5kPVwib2JqZWN0XCIgb3Igdi1vbj1cIm9iamVjdFwiLCB3cmFwIHdpdGggbWVyZ2VQcm9wc1xyXG4gICAgaWYgKG1lcmdlQXJncy5sZW5ndGgpIHtcclxuICAgICAgICBpZiAocHJvcGVydGllcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgbWVyZ2VBcmdzLnB1c2goY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihkZWR1cGVQcm9wZXJ0aWVzKHByb3BlcnRpZXMpLCBlbGVtZW50TG9jKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtZXJnZUFyZ3MubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICBwcm9wc0V4cHJlc3Npb24gPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihNRVJHRV9QUk9QUyksIG1lcmdlQXJncywgZWxlbWVudExvYyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBzaW5nbGUgdi1iaW5kIHdpdGggbm90aGluZyBlbHNlIC0gbm8gbmVlZCBmb3IgYSBtZXJnZVByb3BzIGNhbGxcclxuICAgICAgICAgICAgcHJvcHNFeHByZXNzaW9uID0gbWVyZ2VBcmdzWzBdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHByb3BlcnRpZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgcHJvcHNFeHByZXNzaW9uID0gY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihkZWR1cGVQcm9wZXJ0aWVzKHByb3BlcnRpZXMpLCBlbGVtZW50TG9jKTtcclxuICAgIH1cclxuICAgIC8vIHBhdGNoRmxhZyBhbmFseXNpc1xyXG4gICAgaWYgKGhhc0R5bmFtaWNLZXlzKSB7XHJcbiAgICAgICAgcGF0Y2hGbGFnIHw9IDE2IC8qIEZVTExfUFJPUFMgKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoaGFzQ2xhc3NCaW5kaW5nKSB7XHJcbiAgICAgICAgICAgIHBhdGNoRmxhZyB8PSAyIC8qIENMQVNTICovO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaGFzU3R5bGVCaW5kaW5nKSB7XHJcbiAgICAgICAgICAgIHBhdGNoRmxhZyB8PSA0IC8qIFNUWUxFICovO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZHluYW1pY1Byb3BOYW1lcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcGF0Y2hGbGFnIHw9IDggLyogUFJPUFMgKi87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChoYXNIeWRyYXRpb25FdmVudEJpbmRpbmcpIHtcclxuICAgICAgICAgICAgcGF0Y2hGbGFnIHw9IDMyIC8qIEhZRFJBVEVfRVZFTlRTICovO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICgocGF0Y2hGbGFnID09PSAwIHx8IHBhdGNoRmxhZyA9PT0gMzIgLyogSFlEUkFURV9FVkVOVFMgKi8pICYmXHJcbiAgICAgICAgKGhhc1JlZiB8fCBoYXNWbm9kZUhvb2sgfHwgcnVudGltZURpcmVjdGl2ZXMubGVuZ3RoID4gMCkpIHtcclxuICAgICAgICBwYXRjaEZsYWcgfD0gNTEyIC8qIE5FRURfUEFUQ0ggKi87XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHByb3BzOiBwcm9wc0V4cHJlc3Npb24sXHJcbiAgICAgICAgZGlyZWN0aXZlczogcnVudGltZURpcmVjdGl2ZXMsXHJcbiAgICAgICAgcGF0Y2hGbGFnLFxyXG4gICAgICAgIGR5bmFtaWNQcm9wTmFtZXNcclxuICAgIH07XHJcbn1cclxuLy8gRGVkdXBlIHByb3BzIGluIGFuIG9iamVjdCBsaXRlcmFsLlxyXG4vLyBMaXRlcmFsIGR1cGxpY2F0ZWQgYXR0cmlidXRlcyB3b3VsZCBoYXZlIGJlZW4gd2FybmVkIGR1cmluZyB0aGUgcGFyc2UgcGhhc2UsXHJcbi8vIGhvd2V2ZXIsIGl0J3MgcG9zc2libGUgdG8gZW5jb3VudGVyIGR1cGxpY2F0ZWQgYG9uWFhYYCBoYW5kbGVycyB3aXRoIGRpZmZlcmVudFxyXG4vLyBtb2RpZmllcnMuIFdlIGFsc28gbmVlZCB0byBtZXJnZSBzdGF0aWMgYW5kIGR5bmFtaWMgY2xhc3MgLyBzdHlsZSBhdHRyaWJ1dGVzLlxyXG4vLyAtIG9uWFhYIGhhbmRsZXJzIC8gc3R5bGU6IG1lcmdlIGludG8gYXJyYXlcclxuLy8gLSBjbGFzczogbWVyZ2UgaW50byBzaW5nbGUgZXhwcmVzc2lvbiB3aXRoIGNvbmNhdGVuYXRpb25cclxuZnVuY3Rpb24gZGVkdXBlUHJvcGVydGllcyhwcm9wZXJ0aWVzKSB7XHJcbiAgICBjb25zdCBrbm93blByb3BzID0gbmV3IE1hcCgpO1xyXG4gICAgY29uc3QgZGVkdXBlZCA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgcHJvcCA9IHByb3BlcnRpZXNbaV07XHJcbiAgICAgICAgLy8gZHluYW1pYyBrZXlzIGFyZSBhbHdheXMgYWxsb3dlZFxyXG4gICAgICAgIGlmIChwcm9wLmtleS50eXBlID09PSA4IC8qIENPTVBPVU5EX0VYUFJFU1NJT04gKi8gfHwgIXByb3Aua2V5LmlzU3RhdGljKSB7XHJcbiAgICAgICAgICAgIGRlZHVwZWQucHVzaChwcm9wKTtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG5hbWUgPSBwcm9wLmtleS5jb250ZW50O1xyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0ga25vd25Qcm9wcy5nZXQobmFtZSk7XHJcbiAgICAgICAgaWYgKGV4aXN0aW5nKSB7XHJcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnc3R5bGUnIHx8IG5hbWUgPT09ICdjbGFzcycgfHwgbmFtZS5zdGFydHNXaXRoKCdvbicpKSB7XHJcbiAgICAgICAgICAgICAgICBtZXJnZUFzQXJyYXkoZXhpc3RpbmcsIHByb3ApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgZHVwbGljYXRlLCBzaG91bGQgaGF2ZSBlbWl0dGVkIGVycm9yIGR1cmluZyBwYXJzZVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAga25vd25Qcm9wcy5zZXQobmFtZSwgcHJvcCk7XHJcbiAgICAgICAgICAgIGRlZHVwZWQucHVzaChwcm9wKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGVkdXBlZDtcclxufVxyXG5mdW5jdGlvbiBtZXJnZUFzQXJyYXkoZXhpc3RpbmcsIGluY29taW5nKSB7XHJcbiAgICBpZiAoZXhpc3RpbmcudmFsdWUudHlwZSA9PT0gMTcgLyogSlNfQVJSQVlfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgIGV4aXN0aW5nLnZhbHVlLmVsZW1lbnRzLnB1c2goaW5jb21pbmcudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZXhpc3RpbmcudmFsdWUgPSBjcmVhdGVBcnJheUV4cHJlc3Npb24oW2V4aXN0aW5nLnZhbHVlLCBpbmNvbWluZy52YWx1ZV0sIGV4aXN0aW5nLmxvYyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gYnVpbGREaXJlY3RpdmVBcmdzKGRpciwgY29udGV4dCkge1xyXG4gICAgY29uc3QgZGlyQXJncyA9IFtdO1xyXG4gICAgY29uc3QgcnVudGltZSA9IGRpcmVjdGl2ZUltcG9ydE1hcC5nZXQoZGlyKTtcclxuICAgIGlmIChydW50aW1lKSB7XHJcbiAgICAgICAgLy8gYnVpbHQtaW4gZGlyZWN0aXZlIHdpdGggcnVudGltZVxyXG4gICAgICAgIGRpckFyZ3MucHVzaChjb250ZXh0LmhlbHBlclN0cmluZyhydW50aW1lKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIGluamVjdCBzdGF0ZW1lbnQgZm9yIHJlc29sdmluZyBkaXJlY3RpdmVcclxuICAgICAgICAgICAgY29udGV4dC5oZWxwZXIoUkVTT0xWRV9ESVJFQ1RJVkUpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmRpcmVjdGl2ZXMuYWRkKGRpci5uYW1lKTtcclxuICAgICAgICAgICAgZGlyQXJncy5wdXNoKHRvVmFsaWRBc3NldElkKGRpci5uYW1lLCBgZGlyZWN0aXZlYCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IHsgbG9jIH0gPSBkaXI7XHJcbiAgICBpZiAoZGlyLmV4cClcclxuICAgICAgICBkaXJBcmdzLnB1c2goZGlyLmV4cCk7XHJcbiAgICBpZiAoZGlyLmFyZykge1xyXG4gICAgICAgIGlmICghZGlyLmV4cCkge1xyXG4gICAgICAgICAgICBkaXJBcmdzLnB1c2goYHZvaWQgMGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkaXJBcmdzLnB1c2goZGlyLmFyZyk7XHJcbiAgICB9XHJcbiAgICBpZiAoT2JqZWN0LmtleXMoZGlyLm1vZGlmaWVycykubGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKCFkaXIuYXJnKSB7XHJcbiAgICAgICAgICAgIGlmICghZGlyLmV4cCkge1xyXG4gICAgICAgICAgICAgICAgZGlyQXJncy5wdXNoKGB2b2lkIDBgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkaXJBcmdzLnB1c2goYHZvaWQgMGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0cnVlRXhwcmVzc2lvbiA9IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYHRydWVgLCBmYWxzZSwgbG9jKTtcclxuICAgICAgICBkaXJBcmdzLnB1c2goY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihkaXIubW9kaWZpZXJzLm1hcChtb2RpZmllciA9PiBjcmVhdGVPYmplY3RQcm9wZXJ0eShtb2RpZmllciwgdHJ1ZUV4cHJlc3Npb24pKSwgbG9jKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3JlYXRlQXJyYXlFeHByZXNzaW9uKGRpckFyZ3MsIGRpci5sb2MpO1xyXG59XHJcbmZ1bmN0aW9uIHN0cmluZ2lmeUR5bmFtaWNQcm9wTmFtZXMocHJvcHMpIHtcclxuICAgIGxldCBwcm9wc05hbWVzU3RyaW5nID0gYFtgO1xyXG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBwcm9wcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBwcm9wc05hbWVzU3RyaW5nICs9IEpTT04uc3RyaW5naWZ5KHByb3BzW2ldKTtcclxuICAgICAgICBpZiAoaSA8IGwgLSAxKVxyXG4gICAgICAgICAgICBwcm9wc05hbWVzU3RyaW5nICs9ICcsICc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJvcHNOYW1lc1N0cmluZyArIGBdYDtcclxufVxyXG5mdW5jdGlvbiBpc0NvbXBvbmVudFRhZyh0YWcpIHtcclxuICAgIHJldHVybiB0YWdbMF0udG9Mb3dlckNhc2UoKSArIHRhZy5zbGljZSgxKSA9PT0gJ2NvbXBvbmVudCc7XHJcbn1cblxuKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICA/IE9iamVjdC5mcmVlemUoe30pXHJcbiAgICA6IHt9O1xyXG4ocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBPYmplY3QuZnJlZXplKFtdKSA6IFtdO1xyXG5jb25zdCBjYWNoZVN0cmluZ0Z1bmN0aW9uID0gKGZuKSA9PiB7XHJcbiAgICBjb25zdCBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICByZXR1cm4gKChzdHIpID0+IHtcclxuICAgICAgICBjb25zdCBoaXQgPSBjYWNoZVtzdHJdO1xyXG4gICAgICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKTtcclxuICAgIH0pO1xyXG59O1xyXG5jb25zdCBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IGNhbWVsaXplID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiB7XHJcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgKF8sIGMpID0+IChjID8gYy50b1VwcGVyQ2FzZSgpIDogJycpKTtcclxufSk7XG5cbmNvbnN0IHRyYW5zZm9ybVNsb3RPdXRsZXQgPSAobm9kZSwgY29udGV4dCkgPT4ge1xyXG4gICAgaWYgKGlzU2xvdE91dGxldChub2RlKSkge1xyXG4gICAgICAgIGNvbnN0IHsgY2hpbGRyZW4sIGxvYyB9ID0gbm9kZTtcclxuICAgICAgICBjb25zdCB7IHNsb3ROYW1lLCBzbG90UHJvcHMgfSA9IHByb2Nlc3NTbG90T3V0bGV0KG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgIGNvbnN0IHNsb3RBcmdzID0gW1xyXG4gICAgICAgICAgICBjb250ZXh0LnByZWZpeElkZW50aWZpZXJzID8gYF9jdHguJHNsb3RzYCA6IGAkc2xvdHNgLFxyXG4gICAgICAgICAgICBzbG90TmFtZVxyXG4gICAgICAgIF07XHJcbiAgICAgICAgaWYgKHNsb3RQcm9wcykge1xyXG4gICAgICAgICAgICBzbG90QXJncy5wdXNoKHNsb3RQcm9wcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKCFzbG90UHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIHNsb3RBcmdzLnB1c2goYHt9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2xvdEFyZ3MucHVzaChjcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24oW10sIGNoaWxkcmVuLCBmYWxzZSwgZmFsc2UsIGxvYykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29udGV4dC5zY29wZUlkICYmICFjb250ZXh0LnNsb3R0ZWQpIHtcclxuICAgICAgICAgICAgaWYgKCFzbG90UHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIHNsb3RBcmdzLnB1c2goYHt9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHNsb3RBcmdzLnB1c2goYHVuZGVmaW5lZGApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNsb3RBcmdzLnB1c2goYHRydWVgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbm9kZS5jb2RlZ2VuTm9kZSA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKFJFTkRFUl9TTE9UKSwgc2xvdEFyZ3MsIGxvYyk7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIHByb2Nlc3NTbG90T3V0bGV0KG5vZGUsIGNvbnRleHQpIHtcclxuICAgIGxldCBzbG90TmFtZSA9IGBcImRlZmF1bHRcImA7XHJcbiAgICBsZXQgc2xvdFByb3BzID0gdW5kZWZpbmVkO1xyXG4gICAgY29uc3Qgbm9uTmFtZVByb3BzID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUucHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBwID0gbm9kZS5wcm9wc1tpXTtcclxuICAgICAgICBpZiAocC50eXBlID09PSA2IC8qIEFUVFJJQlVURSAqLykge1xyXG4gICAgICAgICAgICBpZiAocC52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHAubmFtZSA9PT0gJ25hbWUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2xvdE5hbWUgPSBKU09OLnN0cmluZ2lmeShwLnZhbHVlLmNvbnRlbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcC5uYW1lID0gY2FtZWxpemUocC5uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBub25OYW1lUHJvcHMucHVzaChwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHAubmFtZSA9PT0gJ2JpbmQnICYmIGlzQmluZEtleShwLmFyZywgJ25hbWUnKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHAuZXhwKVxyXG4gICAgICAgICAgICAgICAgICAgIHNsb3ROYW1lID0gcC5leHA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocC5uYW1lID09PSAnYmluZCcgJiYgcC5hcmcgJiYgaXNTdGF0aWNFeHAocC5hcmcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcC5hcmcuY29udGVudCA9IGNhbWVsaXplKHAuYXJnLmNvbnRlbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbm9uTmFtZVByb3BzLnB1c2gocCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAobm9uTmFtZVByb3BzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb25zdCB7IHByb3BzLCBkaXJlY3RpdmVzIH0gPSBidWlsZFByb3BzKG5vZGUsIGNvbnRleHQsIG5vbk5hbWVQcm9wcyk7XHJcbiAgICAgICAgc2xvdFByb3BzID0gcHJvcHM7XHJcbiAgICAgICAgaWYgKGRpcmVjdGl2ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDM1IC8qIFhfVl9TTE9UX1VORVhQRUNURURfRElSRUNUSVZFX09OX1NMT1RfT1VUTEVUICovLCBkaXJlY3RpdmVzWzBdLmxvYykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc2xvdE5hbWUsXHJcbiAgICAgICAgc2xvdFByb3BzXHJcbiAgICB9O1xyXG59XG5cbmNvbnN0IGZuRXhwUkUgPSAvXlxccyooW1xcdyRfXSt8XFwoW14pXSo/XFwpKVxccyo9PnxeXFxzKmZ1bmN0aW9uKD86XFxzK1tcXHckXSspP1xccypcXCgvO1xyXG5jb25zdCB0cmFuc2Zvcm1PbiA9IChkaXIsIG5vZGUsIGNvbnRleHQsIGF1Z21lbnRvcikgPT4ge1xyXG4gICAgY29uc3QgeyBsb2MsIG1vZGlmaWVycywgYXJnIH0gPSBkaXI7XHJcbiAgICBpZiAoIWRpci5leHAgJiYgIW1vZGlmaWVycy5sZW5ndGgpIHtcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzNCAvKiBYX1ZfT05fTk9fRVhQUkVTU0lPTiAqLywgbG9jKSk7XHJcbiAgICB9XHJcbiAgICBsZXQgZXZlbnROYW1lO1xyXG4gICAgaWYgKGFyZy50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgaWYgKGFyZy5pc1N0YXRpYykge1xyXG4gICAgICAgICAgICBjb25zdCByYXdOYW1lID0gYXJnLmNvbnRlbnQ7XHJcbiAgICAgICAgICAgIC8vIGZvciBhbGwgZXZlbnQgbGlzdGVuZXJzLCBhdXRvIGNvbnZlcnQgaXQgdG8gY2FtZWxDYXNlLiBTZWUgaXNzdWUgIzIyNDlcclxuICAgICAgICAgICAgZXZlbnROYW1lID0gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbih0b0hhbmRsZXJLZXkoY2FtZWxpemUkMShyYXdOYW1lKSksIHRydWUsIGFyZy5sb2MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gIzIzODhcclxuICAgICAgICAgICAgZXZlbnROYW1lID0gY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFtcclxuICAgICAgICAgICAgICAgIGAke2NvbnRleHQuaGVscGVyU3RyaW5nKFRPX0hBTkRMRVJfS0VZKX0oYCxcclxuICAgICAgICAgICAgICAgIGFyZyxcclxuICAgICAgICAgICAgICAgIGApYFxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBhbHJlYWR5IGEgY29tcG91bmQgZXhwcmVzc2lvbi5cclxuICAgICAgICBldmVudE5hbWUgPSBhcmc7XHJcbiAgICAgICAgZXZlbnROYW1lLmNoaWxkcmVuLnVuc2hpZnQoYCR7Y29udGV4dC5oZWxwZXJTdHJpbmcoVE9fSEFORExFUl9LRVkpfShgKTtcclxuICAgICAgICBldmVudE5hbWUuY2hpbGRyZW4ucHVzaChgKWApO1xyXG4gICAgfVxyXG4gICAgLy8gaGFuZGxlciBwcm9jZXNzaW5nXHJcbiAgICBsZXQgZXhwID0gZGlyLmV4cDtcclxuICAgIGlmIChleHAgJiYgIWV4cC5jb250ZW50LnRyaW0oKSkge1xyXG4gICAgICAgIGV4cCA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGxldCBzaG91bGRDYWNoZSA9IGNvbnRleHQuY2FjaGVIYW5kbGVycyAmJiAhZXhwO1xyXG4gICAgaWYgKGV4cCkge1xyXG4gICAgICAgIGNvbnN0IGlzTWVtYmVyRXhwID0gaXNNZW1iZXJFeHByZXNzaW9uKGV4cC5jb250ZW50KTtcclxuICAgICAgICBjb25zdCBpc0lubGluZVN0YXRlbWVudCA9ICEoaXNNZW1iZXJFeHAgfHwgZm5FeHBSRS50ZXN0KGV4cC5jb250ZW50KSk7XHJcbiAgICAgICAgY29uc3QgaGFzTXVsdGlwbGVTdGF0ZW1lbnRzID0gZXhwLmNvbnRlbnQuaW5jbHVkZXMoYDtgKTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHRydWUpIHtcclxuICAgICAgICAgICAgdmFsaWRhdGVCcm93c2VyRXhwcmVzc2lvbihleHAsIGNvbnRleHQsIGZhbHNlLCBoYXNNdWx0aXBsZVN0YXRlbWVudHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNJbmxpbmVTdGF0ZW1lbnQgfHwgKHNob3VsZENhY2hlICYmIGlzTWVtYmVyRXhwKSkge1xyXG4gICAgICAgICAgICAvLyB3cmFwIGlubGluZSBzdGF0ZW1lbnQgaW4gYSBmdW5jdGlvbiBleHByZXNzaW9uXHJcbiAgICAgICAgICAgIGV4cCA9IGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihbXHJcbiAgICAgICAgICAgICAgICBgJHtpc0lubGluZVN0YXRlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgID8gYCRldmVudGBcclxuICAgICAgICAgICAgICAgICAgICA6IGAke2BgfSguLi5hcmdzKWB9ID0+ICR7aGFzTXVsdGlwbGVTdGF0ZW1lbnRzID8gYHtgIDogYChgfWAsXHJcbiAgICAgICAgICAgICAgICBleHAsXHJcbiAgICAgICAgICAgICAgICBoYXNNdWx0aXBsZVN0YXRlbWVudHMgPyBgfWAgOiBgKWBcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbGV0IHJldCA9IHtcclxuICAgICAgICBwcm9wczogW1xyXG4gICAgICAgICAgICBjcmVhdGVPYmplY3RQcm9wZXJ0eShldmVudE5hbWUsIGV4cCB8fCBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGAoKSA9PiB7fWAsIGZhbHNlLCBsb2MpKVxyXG4gICAgICAgIF1cclxuICAgIH07XHJcbiAgICAvLyBhcHBseSBleHRlbmRlZCBjb21waWxlciBhdWdtZW50b3JcclxuICAgIGlmIChhdWdtZW50b3IpIHtcclxuICAgICAgICByZXQgPSBhdWdtZW50b3IocmV0KTtcclxuICAgIH1cclxuICAgIGlmIChzaG91bGRDYWNoZSkge1xyXG4gICAgICAgIC8vIGNhY2hlIGhhbmRsZXJzIHNvIHRoYXQgaXQncyBhbHdheXMgdGhlIHNhbWUgaGFuZGxlciBiZWluZyBwYXNzZWQgZG93bi5cclxuICAgICAgICAvLyB0aGlzIGF2b2lkcyB1bm5lY2Vzc2FyeSByZS1yZW5kZXJzIHdoZW4gdXNlcnMgdXNlIGlubGluZSBoYW5kbGVycyBvblxyXG4gICAgICAgIC8vIGNvbXBvbmVudHMuXHJcbiAgICAgICAgcmV0LnByb3BzWzBdLnZhbHVlID0gY29udGV4dC5jYWNoZShyZXQucHJvcHNbMF0udmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldDtcclxufTtcblxuLy8gdi1iaW5kIHdpdGhvdXQgYXJnIGlzIGhhbmRsZWQgZGlyZWN0bHkgaW4gLi90cmFuc2Zvcm1FbGVtZW50cy50cyBkdWUgdG8gaXQgYWZmZWN0aW5nXHJcbi8vIGNvZGVnZW4gZm9yIHRoZSBlbnRpcmUgcHJvcHMgb2JqZWN0LiBUaGlzIHRyYW5zZm9ybSBoZXJlIGlzIG9ubHkgZm9yIHYtYmluZFxyXG4vLyAqd2l0aCogYXJncy5cclxuY29uc3QgdHJhbnNmb3JtQmluZCA9IChkaXIsIF9ub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBjb25zdCB7IGV4cCwgbW9kaWZpZXJzLCBsb2MgfSA9IGRpcjtcclxuICAgIGNvbnN0IGFyZyA9IGRpci5hcmc7XHJcbiAgICBpZiAoYXJnLnR5cGUgIT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICBhcmcuY2hpbGRyZW4udW5zaGlmdChgKGApO1xyXG4gICAgICAgIGFyZy5jaGlsZHJlbi5wdXNoKGApIHx8IFwiXCJgKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCFhcmcuaXNTdGF0aWMpIHtcclxuICAgICAgICBhcmcuY29udGVudCA9IGAke2FyZy5jb250ZW50fSB8fCBcIlwiYDtcclxuICAgIH1cclxuICAgIC8vIC5wcm9wIGlzIG5vIGxvbmdlciBuZWNlc3NhcnkgZHVlIHRvIG5ldyBwYXRjaCBiZWhhdmlvclxyXG4gICAgLy8gLnN5bmMgaXMgcmVwbGFjZWQgYnkgdi1tb2RlbDphcmdcclxuICAgIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoJ2NhbWVsJykpIHtcclxuICAgICAgICBpZiAoYXJnLnR5cGUgPT09IDQgLyogU0lNUExFX0VYUFJFU1NJT04gKi8pIHtcclxuICAgICAgICAgICAgaWYgKGFyZy5pc1N0YXRpYykge1xyXG4gICAgICAgICAgICAgICAgYXJnLmNvbnRlbnQgPSBjYW1lbGl6ZSQxKGFyZy5jb250ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFyZy5jb250ZW50ID0gYCR7Y29udGV4dC5oZWxwZXJTdHJpbmcoQ0FNRUxJWkUpfSgke2FyZy5jb250ZW50fSlgO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhcmcuY2hpbGRyZW4udW5zaGlmdChgJHtjb250ZXh0LmhlbHBlclN0cmluZyhDQU1FTElaRSl9KGApO1xyXG4gICAgICAgICAgICBhcmcuY2hpbGRyZW4ucHVzaChgKWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghZXhwIHx8XHJcbiAgICAgICAgKGV4cC50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovICYmICFleHAuY29udGVudC50cmltKCkpKSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzMgLyogWF9WX0JJTkRfTk9fRVhQUkVTU0lPTiAqLywgbG9jKSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcHJvcHM6IFtjcmVhdGVPYmplY3RQcm9wZXJ0eShhcmcsIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oJycsIHRydWUsIGxvYykpXVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHByb3BzOiBbY3JlYXRlT2JqZWN0UHJvcGVydHkoYXJnLCBleHApXVxyXG4gICAgfTtcclxufTtcblxuLy8gTWVyZ2UgYWRqYWNlbnQgdGV4dCBub2RlcyBhbmQgZXhwcmVzc2lvbnMgaW50byBhIHNpbmdsZSBleHByZXNzaW9uXHJcbi8vIGUuZy4gPGRpdj5hYmMge3sgZCB9fSB7eyBlIH19PC9kaXY+IHNob3VsZCBoYXZlIGEgc2luZ2xlIGV4cHJlc3Npb24gbm9kZSBhcyBjaGlsZC5cclxuY29uc3QgdHJhbnNmb3JtVGV4dCA9IChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBpZiAobm9kZS50eXBlID09PSAwIC8qIFJPT1QgKi8gfHxcclxuICAgICAgICBub2RlLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyB8fFxyXG4gICAgICAgIG5vZGUudHlwZSA9PT0gMTEgLyogRk9SICovIHx8XHJcbiAgICAgICAgbm9kZS50eXBlID09PSAxMCAvKiBJRl9CUkFOQ0ggKi8pIHtcclxuICAgICAgICAvLyBwZXJmb3JtIHRoZSB0cmFuc2Zvcm0gb24gbm9kZSBleGl0IHNvIHRoYXQgYWxsIGV4cHJlc3Npb25zIGhhdmUgYWxyZWFkeVxyXG4gICAgICAgIC8vIGJlZW4gcHJvY2Vzc2VkLlxyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcclxuICAgICAgICAgICAgbGV0IGN1cnJlbnRDb250YWluZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGxldCBoYXNUZXh0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNUZXh0KGNoaWxkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc1RleHQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBjaGlsZHJlbltqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVGV4dChuZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50Q29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbnRhaW5lciA9IGNoaWxkcmVuW2ldID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiA4IC8qIENPTVBPVU5EX0VYUFJFU1NJT04gKi8sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYzogY2hpbGQubG9jLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW2NoaWxkXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGUgaW50byBjdXJyZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29udGFpbmVyLmNoaWxkcmVuLnB1c2goYCArIGAsIG5leHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGosIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgai0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbnRhaW5lciA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaGFzVGV4dCB8fFxyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBhIHBsYWluIGVsZW1lbnQgd2l0aCBhIHNpbmdsZSB0ZXh0IGNoaWxkLCBsZWF2ZSBpdFxyXG4gICAgICAgICAgICAgICAgLy8gYXMtaXMgc2luY2UgdGhlIHJ1bnRpbWUgaGFzIGRlZGljYXRlZCBmYXN0IHBhdGggZm9yIHRoaXMgYnkgZGlyZWN0bHlcclxuICAgICAgICAgICAgICAgIC8vIHNldHRpbmcgdGV4dENvbnRlbnQgb2YgdGhlIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICAvLyBmb3IgY29tcG9uZW50IHJvb3QgaXQncyBhbHdheXMgbm9ybWFsaXplZCBhbnl3YXkuXHJcbiAgICAgICAgICAgICAgICAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKG5vZGUudHlwZSA9PT0gMCAvKiBST09UICovIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChub2RlLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS50YWdUeXBlID09PSAwIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICMzNzU2XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjdXN0b20gZGlyZWN0aXZlcyBjYW4gcG90ZW50aWFsbHkgYWRkIERPTSBlbGVtZW50cyBhcmJpdHJhcmlseSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gYXZvaWQgc2V0dGluZyB0ZXh0Q29udGVudCBvZiB0aGUgZWxlbWVudCBhdCBydW50aW1lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0byBhdm9pZCBhY2NpZGVudGFsbHkgb3ZlcndyaXRpbmcgdGhlIERPTSBlbGVtZW50cyBhZGRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnkgdGhlIHVzZXIgdGhyb3VnaCBjdXN0b20gZGlyZWN0aXZlcy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFub2RlLnByb3BzLmZpbmQocCA9PiBwLnR5cGUgPT09IDcgLyogRElSRUNUSVZFICovICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWNvbnRleHQuZGlyZWN0aXZlVHJhbnNmb3Jtc1twLm5hbWVdKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gY29tcGF0IG1vZGUsIDx0ZW1wbGF0ZT4gdGFncyB3aXRoIG5vIHNwZWNpYWwgZGlyZWN0aXZlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2lsbCBiZSByZW5kZXJlZCBhcyBhIGZyYWdtZW50IHNvIGl0cyBjaGlsZHJlbiBtdXN0IGJlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0ZWQgaW50byB2bm9kZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhKG5vZGUudGFnID09PSAndGVtcGxhdGUnKSkpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHByZS1jb252ZXJ0IHRleHQgbm9kZXMgaW50byBjcmVhdGVUZXh0Vk5vZGUodGV4dCkgY2FsbHMgdG8gYXZvaWRcclxuICAgICAgICAgICAgLy8gcnVudGltZSBub3JtYWxpemF0aW9uLlxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzVGV4dChjaGlsZCkgfHwgY2hpbGQudHlwZSA9PT0gOCAvKiBDT01QT1VORF9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbEFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGVUZXh0Vk5vZGUgZGVmYXVsdHMgdG8gc2luZ2xlIHdoaXRlc3BhY2UsIHNvIGlmIGl0IGlzIGFcclxuICAgICAgICAgICAgICAgICAgICAvLyBzaW5nbGUgc3BhY2UgdGhlIGNvZGUgY291bGQgYmUgYW4gZW1wdHkgY2FsbCB0byBzYXZlIGJ5dGVzLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlICE9PSAyIC8qIFRFWFQgKi8gfHwgY2hpbGQuY29udGVudCAhPT0gJyAnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxBcmdzLnB1c2goY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBtYXJrIGR5bmFtaWMgdGV4dCB3aXRoIGZsYWcgc28gaXQgZ2V0cyBwYXRjaGVkIGluc2lkZSBhIGJsb2NrXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250ZXh0LnNzciAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRDb25zdGFudFR5cGUoY2hpbGQsIGNvbnRleHQpID09PSAwIC8qIE5PVF9DT05TVEFOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsQXJncy5wdXNoKDEgLyogVEVYVCAqLyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYCAvKiAke1BhdGNoRmxhZ05hbWVzWzEgLyogVEVYVCAqL119ICovYCA6IGBgKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2ldID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAxMiAvKiBURVhUX0NBTEwgKi8sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNoaWxkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2M6IGNoaWxkLmxvYyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZWdlbk5vZGU6IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKENSRUFURV9URVhUKSwgY2FsbEFyZ3MpXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn07XG5cbmNvbnN0IHNlZW4gPSBuZXcgV2Vha1NldCgpO1xyXG5jb25zdCB0cmFuc2Zvcm1PbmNlID0gKG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGlmIChub2RlLnR5cGUgPT09IDEgLyogRUxFTUVOVCAqLyAmJiBmaW5kRGlyKG5vZGUsICdvbmNlJywgdHJ1ZSkpIHtcclxuICAgICAgICBpZiAoc2Vlbi5oYXMobm9kZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZWVuLmFkZChub2RlKTtcclxuICAgICAgICBjb250ZXh0LmhlbHBlcihTRVRfQkxPQ0tfVFJBQ0tJTkcpO1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1ciA9IGNvbnRleHQuY3VycmVudE5vZGU7XHJcbiAgICAgICAgICAgIGlmIChjdXIuY29kZWdlbk5vZGUpIHtcclxuICAgICAgICAgICAgICAgIGN1ci5jb2RlZ2VuTm9kZSA9IGNvbnRleHQuY2FjaGUoY3VyLmNvZGVnZW5Ob2RlLCB0cnVlIC8qIGlzVk5vZGUgKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufTtcblxuY29uc3QgdHJhbnNmb3JtTW9kZWwgPSAoZGlyLCBub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBjb25zdCB7IGV4cCwgYXJnIH0gPSBkaXI7XHJcbiAgICBpZiAoIWV4cCkge1xyXG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDQwIC8qIFhfVl9NT0RFTF9OT19FWFBSRVNTSU9OICovLCBkaXIubG9jKSk7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRyYW5zZm9ybVByb3BzKCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCByYXdFeHAgPSBleHAubG9jLnNvdXJjZTtcclxuICAgIGNvbnN0IGV4cFN0cmluZyA9IGV4cC50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovID8gZXhwLmNvbnRlbnQgOiByYXdFeHA7XHJcbiAgICAvLyBpbSBTRkMgPHNjcmlwdCBzZXR1cD4gaW5saW5lIG1vZGUsIHRoZSBleHAgbWF5IGhhdmUgYmVlbiB0cmFuc2Zvcm1lZCBpbnRvXHJcbiAgICAvLyBfdW5yZWYoZXhwKVxyXG4gICAgY29udGV4dC5iaW5kaW5nTWV0YWRhdGFbcmF3RXhwXTtcclxuICAgIGNvbnN0IG1heWJlUmVmID0gIXRydWUgICAgLyogU0VUVVBfQ09OU1QgKi87XHJcbiAgICBpZiAoIWlzTWVtYmVyRXhwcmVzc2lvbihleHBTdHJpbmcpICYmICFtYXliZVJlZikge1xyXG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDQxIC8qIFhfVl9NT0RFTF9NQUxGT1JNRURfRVhQUkVTU0lPTiAqLywgZXhwLmxvYykpO1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVUcmFuc2Zvcm1Qcm9wcygpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcHJvcE5hbWUgPSBhcmcgPyBhcmcgOiBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKCdtb2RlbFZhbHVlJywgdHJ1ZSk7XHJcbiAgICBjb25zdCBldmVudE5hbWUgPSBhcmdcclxuICAgICAgICA/IGlzU3RhdGljRXhwKGFyZylcclxuICAgICAgICAgICAgPyBgb25VcGRhdGU6JHthcmcuY29udGVudH1gXHJcbiAgICAgICAgICAgIDogY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFsnXCJvblVwZGF0ZTpcIiArICcsIGFyZ10pXHJcbiAgICAgICAgOiBgb25VcGRhdGU6bW9kZWxWYWx1ZWA7XHJcbiAgICBsZXQgYXNzaWdubWVudEV4cDtcclxuICAgIGNvbnN0IGV2ZW50QXJnID0gY29udGV4dC5pc1RTID8gYCgkZXZlbnQ6IGFueSlgIDogYCRldmVudGA7XHJcbiAgICB7XHJcbiAgICAgICAgYXNzaWdubWVudEV4cCA9IGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihbXHJcbiAgICAgICAgICAgIGAke2V2ZW50QXJnfSA9PiAoYCxcclxuICAgICAgICAgICAgZXhwLFxyXG4gICAgICAgICAgICBgID0gJGV2ZW50KWBcclxuICAgICAgICBdKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHByb3BzID0gW1xyXG4gICAgICAgIC8vIG1vZGVsVmFsdWU6IGZvb1xyXG4gICAgICAgIGNyZWF0ZU9iamVjdFByb3BlcnR5KHByb3BOYW1lLCBkaXIuZXhwKSxcclxuICAgICAgICAvLyBcIm9uVXBkYXRlOm1vZGVsVmFsdWVcIjogJGV2ZW50ID0+IChmb28gPSAkZXZlbnQpXHJcbiAgICAgICAgY3JlYXRlT2JqZWN0UHJvcGVydHkoZXZlbnROYW1lLCBhc3NpZ25tZW50RXhwKVxyXG4gICAgXTtcclxuICAgIC8vIG1vZGVsTW9kaWZpZXJzOiB7IGZvbzogdHJ1ZSwgXCJiYXItYmF6XCI6IHRydWUgfVxyXG4gICAgaWYgKGRpci5tb2RpZmllcnMubGVuZ3RoICYmIG5vZGUudGFnVHlwZSA9PT0gMSAvKiBDT01QT05FTlQgKi8pIHtcclxuICAgICAgICBjb25zdCBtb2RpZmllcnMgPSBkaXIubW9kaWZpZXJzXHJcbiAgICAgICAgICAgIC5tYXAobSA9PiAoaXNTaW1wbGVJZGVudGlmaWVyKG0pID8gbSA6IEpTT04uc3RyaW5naWZ5KG0pKSArIGA6IHRydWVgKVxyXG4gICAgICAgICAgICAuam9pbihgLCBgKTtcclxuICAgICAgICBjb25zdCBtb2RpZmllcnNLZXkgPSBhcmdcclxuICAgICAgICAgICAgPyBpc1N0YXRpY0V4cChhcmcpXHJcbiAgICAgICAgICAgICAgICA/IGAke2FyZy5jb250ZW50fU1vZGlmaWVyc2BcclxuICAgICAgICAgICAgICAgIDogY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFthcmcsICcgKyBcIk1vZGlmaWVyc1wiJ10pXHJcbiAgICAgICAgICAgIDogYG1vZGVsTW9kaWZpZXJzYDtcclxuICAgICAgICBwcm9wcy5wdXNoKGNyZWF0ZU9iamVjdFByb3BlcnR5KG1vZGlmaWVyc0tleSwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgeyAke21vZGlmaWVyc30gfWAsIGZhbHNlLCBkaXIubG9jLCAyIC8qIENBTl9IT0lTVCAqLykpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjcmVhdGVUcmFuc2Zvcm1Qcm9wcyhwcm9wcyk7XHJcbn07XHJcbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zZm9ybVByb3BzKHByb3BzID0gW10pIHtcclxuICAgIHJldHVybiB7IHByb3BzIH07XHJcbn1cblxuY29uc3QgdmFsaWREaXZpc2lvbkNoYXJSRSA9IC9bXFx3KS4rXFwtXyRcXF1dLztcclxuY29uc3QgdHJhbnNmb3JtRmlsdGVyID0gKG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGlmICghaXNDb21wYXRFbmFibGVkKFwiQ09NUElMRVJfRklMVEVSXCIgLyogQ09NUElMRVJfRklMVEVSUyAqLywgY29udGV4dCkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAobm9kZS50eXBlID09PSA1IC8qIElOVEVSUE9MQVRJT04gKi8pIHtcclxuICAgICAgICAvLyBmaWx0ZXIgcmV3cml0ZSBpcyBhcHBsaWVkIGJlZm9yZSBleHByZXNzaW9uIHRyYW5zZm9ybSBzbyBvbmx5XHJcbiAgICAgICAgLy8gc2ltcGxlIGV4cHJlc3Npb25zIGFyZSBwb3NzaWJsZSBhdCB0aGlzIHN0YWdlXHJcbiAgICAgICAgcmV3cml0ZUZpbHRlcihub2RlLmNvbnRlbnQsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMSAvKiBFTEVNRU5UICovKSB7XHJcbiAgICAgICAgbm9kZS5wcm9wcy5mb3JFYWNoKChwcm9wKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChwcm9wLnR5cGUgPT09IDcgLyogRElSRUNUSVZFICovICYmXHJcbiAgICAgICAgICAgICAgICBwcm9wLm5hbWUgIT09ICdmb3InICYmXHJcbiAgICAgICAgICAgICAgICBwcm9wLmV4cCkge1xyXG4gICAgICAgICAgICAgICAgcmV3cml0ZUZpbHRlcihwcm9wLmV4cCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gcmV3cml0ZUZpbHRlcihub2RlLCBjb250ZXh0KSB7XHJcbiAgICBpZiAobm9kZS50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovKSB7XHJcbiAgICAgICAgcGFyc2VGaWx0ZXIobm9kZSwgY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoaWxkICE9PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gNCAvKiBTSU1QTEVfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgICAgICAgICAgcGFyc2VGaWx0ZXIoY2hpbGQsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkLnR5cGUgPT09IDggLyogQ09NUE9VTkRfRVhQUkVTU0lPTiAqLykge1xyXG4gICAgICAgICAgICAgICAgcmV3cml0ZUZpbHRlcihub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGlsZC50eXBlID09PSA1IC8qIElOVEVSUE9MQVRJT04gKi8pIHtcclxuICAgICAgICAgICAgICAgIHJld3JpdGVGaWx0ZXIoY2hpbGQuY29udGVudCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VGaWx0ZXIobm9kZSwgY29udGV4dCkge1xyXG4gICAgY29uc3QgZXhwID0gbm9kZS5jb250ZW50O1xyXG4gICAgbGV0IGluU2luZ2xlID0gZmFsc2U7XHJcbiAgICBsZXQgaW5Eb3VibGUgPSBmYWxzZTtcclxuICAgIGxldCBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7XHJcbiAgICBsZXQgaW5SZWdleCA9IGZhbHNlO1xyXG4gICAgbGV0IGN1cmx5ID0gMDtcclxuICAgIGxldCBzcXVhcmUgPSAwO1xyXG4gICAgbGV0IHBhcmVuID0gMDtcclxuICAgIGxldCBsYXN0RmlsdGVySW5kZXggPSAwO1xyXG4gICAgbGV0IGMsIHByZXYsIGksIGV4cHJlc3Npb24sIGZpbHRlcnMgPSBbXTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBleHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBwcmV2ID0gYztcclxuICAgICAgICBjID0gZXhwLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgaWYgKGluU2luZ2xlKSB7XHJcbiAgICAgICAgICAgIGlmIChjID09PSAweDI3ICYmIHByZXYgIT09IDB4NWMpXHJcbiAgICAgICAgICAgICAgICBpblNpbmdsZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpbkRvdWJsZSkge1xyXG4gICAgICAgICAgICBpZiAoYyA9PT0gMHgyMiAmJiBwcmV2ICE9PSAweDVjKVxyXG4gICAgICAgICAgICAgICAgaW5Eb3VibGUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaW5UZW1wbGF0ZVN0cmluZykge1xyXG4gICAgICAgICAgICBpZiAoYyA9PT0gMHg2MCAmJiBwcmV2ICE9PSAweDVjKVxyXG4gICAgICAgICAgICAgICAgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpblJlZ2V4KSB7XHJcbiAgICAgICAgICAgIGlmIChjID09PSAweDJmICYmIHByZXYgIT09IDB4NWMpXHJcbiAgICAgICAgICAgICAgICBpblJlZ2V4ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGMgPT09IDB4N2MgJiYgLy8gcGlwZVxyXG4gICAgICAgICAgICBleHAuY2hhckNvZGVBdChpICsgMSkgIT09IDB4N2MgJiZcclxuICAgICAgICAgICAgZXhwLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdjICYmXHJcbiAgICAgICAgICAgICFjdXJseSAmJlxyXG4gICAgICAgICAgICAhc3F1YXJlICYmXHJcbiAgICAgICAgICAgICFwYXJlbikge1xyXG4gICAgICAgICAgICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBmaXJzdCBmaWx0ZXIsIGVuZCBvZiBleHByZXNzaW9uXHJcbiAgICAgICAgICAgICAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcclxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcHVzaEZpbHRlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGMpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMHgyMjpcclxuICAgICAgICAgICAgICAgICAgICBpbkRvdWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIFwiXHJcbiAgICAgICAgICAgICAgICBjYXNlIDB4Mjc6XHJcbiAgICAgICAgICAgICAgICAgICAgaW5TaW5nbGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyAnXHJcbiAgICAgICAgICAgICAgICBjYXNlIDB4NjA6XHJcbiAgICAgICAgICAgICAgICAgICAgaW5UZW1wbGF0ZVN0cmluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIGBcclxuICAgICAgICAgICAgICAgIGNhc2UgMHgyODpcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbisrO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyAoXHJcbiAgICAgICAgICAgICAgICBjYXNlIDB4Mjk6XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW4tLTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gKVxyXG4gICAgICAgICAgICAgICAgY2FzZSAweDViOlxyXG4gICAgICAgICAgICAgICAgICAgIHNxdWFyZSsrO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBbXHJcbiAgICAgICAgICAgICAgICBjYXNlIDB4NWQ6XHJcbiAgICAgICAgICAgICAgICAgICAgc3F1YXJlLS07XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIF1cclxuICAgICAgICAgICAgICAgIGNhc2UgMHg3YjpcclxuICAgICAgICAgICAgICAgICAgICBjdXJseSsrO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDB4N2Q6XHJcbiAgICAgICAgICAgICAgICAgICAgY3VybHktLTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjID09PSAweDJmKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAvXHJcbiAgICAgICAgICAgICAgICBsZXQgaiA9IGkgLSAxO1xyXG4gICAgICAgICAgICAgICAgbGV0IHA7XHJcbiAgICAgICAgICAgICAgICAvLyBmaW5kIGZpcnN0IG5vbi13aGl0ZXNwYWNlIHByZXYgY2hhclxyXG4gICAgICAgICAgICAgICAgZm9yICg7IGogPj0gMDsgai0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcCA9IGV4cC5jaGFyQXQoaik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHAgIT09ICcgJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIXAgfHwgIXZhbGlkRGl2aXNpb25DaGFyUkUudGVzdChwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluUmVnZXggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobGFzdEZpbHRlckluZGV4ICE9PSAwKSB7XHJcbiAgICAgICAgcHVzaEZpbHRlcigpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcHVzaEZpbHRlcigpIHtcclxuICAgICAgICBmaWx0ZXJzLnB1c2goZXhwLnNsaWNlKGxhc3RGaWx0ZXJJbmRleCwgaSkudHJpbSgpKTtcclxuICAgICAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcclxuICAgIH1cclxuICAgIGlmIChmaWx0ZXJzLmxlbmd0aCkge1xyXG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICB3YXJuRGVwcmVjYXRpb24oXCJDT01QSUxFUl9GSUxURVJcIiAvKiBDT01QSUxFUl9GSUxURVJTICovLCBjb250ZXh0LCBub2RlLmxvYyk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZXhwcmVzc2lvbiA9IHdyYXBGaWx0ZXIoZXhwcmVzc2lvbiwgZmlsdGVyc1tpXSwgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5vZGUuY29udGVudCA9IGV4cHJlc3Npb247XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gd3JhcEZpbHRlcihleHAsIGZpbHRlciwgY29udGV4dCkge1xyXG4gICAgY29udGV4dC5oZWxwZXIoUkVTT0xWRV9GSUxURVIpO1xyXG4gICAgY29uc3QgaSA9IGZpbHRlci5pbmRleE9mKCcoJyk7XHJcbiAgICBpZiAoaSA8IDApIHtcclxuICAgICAgICBjb250ZXh0LmZpbHRlcnMuYWRkKGZpbHRlcik7XHJcbiAgICAgICAgcmV0dXJuIGAke3RvVmFsaWRBc3NldElkKGZpbHRlciwgJ2ZpbHRlcicpfSgke2V4cH0pYDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSBmaWx0ZXIuc2xpY2UoMCwgaSk7XHJcbiAgICAgICAgY29uc3QgYXJncyA9IGZpbHRlci5zbGljZShpICsgMSk7XHJcbiAgICAgICAgY29udGV4dC5maWx0ZXJzLmFkZChuYW1lKTtcclxuICAgICAgICByZXR1cm4gYCR7dG9WYWxpZEFzc2V0SWQobmFtZSwgJ2ZpbHRlcicpfSgke2V4cH0ke2FyZ3MgIT09ICcpJyA/ICcsJyArIGFyZ3MgOiBhcmdzfWA7XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gZ2V0QmFzZVRyYW5zZm9ybVByZXNldChwcmVmaXhJZGVudGlmaWVycykge1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICBbXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybU9uY2UsXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybUlmLFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm1Gb3IsXHJcbiAgICAgICAgICAgIC4uLihbdHJhbnNmb3JtRmlsdGVyXSApLFxyXG4gICAgICAgICAgICAuLi4oKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgICAgICAgICAgICAgPyBbdHJhbnNmb3JtRXhwcmVzc2lvbl1cclxuICAgICAgICAgICAgICAgICAgICA6IFtdKSxcclxuICAgICAgICAgICAgdHJhbnNmb3JtU2xvdE91dGxldCxcclxuICAgICAgICAgICAgdHJhbnNmb3JtRWxlbWVudCxcclxuICAgICAgICAgICAgdHJhY2tTbG90U2NvcGVzLFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm1UZXh0XHJcbiAgICAgICAgXSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG9uOiB0cmFuc2Zvcm1PbixcclxuICAgICAgICAgICAgYmluZDogdHJhbnNmb3JtQmluZCxcclxuICAgICAgICAgICAgbW9kZWw6IHRyYW5zZm9ybU1vZGVsXHJcbiAgICAgICAgfVxyXG4gICAgXTtcclxufVxyXG4vLyB3ZSBuYW1lIGl0IGBiYXNlQ29tcGlsZWAgc28gdGhhdCBoaWdoZXIgb3JkZXIgY29tcGlsZXJzIGxpa2VcclxuLy8gQHZ1ZS9jb21waWxlci1kb20gY2FuIGV4cG9ydCBgY29tcGlsZWAgd2hpbGUgcmUtZXhwb3J0aW5nIGV2ZXJ5dGhpbmcgZWxzZS5cclxuZnVuY3Rpb24gYmFzZUNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgY29uc3Qgb25FcnJvciA9IG9wdGlvbnMub25FcnJvciB8fCBkZWZhdWx0T25FcnJvcjtcclxuICAgIGNvbnN0IGlzTW9kdWxlTW9kZSA9IG9wdGlvbnMubW9kZSA9PT0gJ21vZHVsZSc7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIHtcclxuICAgICAgICBpZiAob3B0aW9ucy5wcmVmaXhJZGVudGlmaWVycyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBvbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNDUgLyogWF9QUkVGSVhfSURfTk9UX1NVUFBPUlRFRCAqLykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc01vZHVsZU1vZGUpIHtcclxuICAgICAgICAgICAgb25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDQ2IC8qIFhfTU9EVUxFX01PREVfTk9UX1NVUFBPUlRFRCAqLykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IHByZWZpeElkZW50aWZpZXJzID0gIXRydWUgO1xyXG4gICAgaWYgKG9wdGlvbnMuY2FjaGVIYW5kbGVycykge1xyXG4gICAgICAgIG9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcig0NyAvKiBYX0NBQ0hFX0hBTkRMRVJfTk9UX1NVUFBPUlRFRCAqLykpO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdGlvbnMuc2NvcGVJZCAmJiAhaXNNb2R1bGVNb2RlKSB7XHJcbiAgICAgICAgb25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDQ4IC8qIFhfU0NPUEVfSURfTk9UX1NVUFBPUlRFRCAqLykpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYXN0ID0gaXNTdHJpbmcodGVtcGxhdGUpID8gYmFzZVBhcnNlKHRlbXBsYXRlLCBvcHRpb25zKSA6IHRlbXBsYXRlO1xyXG4gICAgY29uc3QgW25vZGVUcmFuc2Zvcm1zLCBkaXJlY3RpdmVUcmFuc2Zvcm1zXSA9IGdldEJhc2VUcmFuc2Zvcm1QcmVzZXQoKTtcclxuICAgIHRyYW5zZm9ybShhc3QsIGV4dGVuZCh7fSwgb3B0aW9ucywge1xyXG4gICAgICAgIHByZWZpeElkZW50aWZpZXJzLFxyXG4gICAgICAgIG5vZGVUcmFuc2Zvcm1zOiBbXHJcbiAgICAgICAgICAgIC4uLm5vZGVUcmFuc2Zvcm1zLFxyXG4gICAgICAgICAgICAuLi4ob3B0aW9ucy5ub2RlVHJhbnNmb3JtcyB8fCBbXSkgLy8gdXNlciB0cmFuc2Zvcm1zXHJcbiAgICAgICAgXSxcclxuICAgICAgICBkaXJlY3RpdmVUcmFuc2Zvcm1zOiBleHRlbmQoe30sIGRpcmVjdGl2ZVRyYW5zZm9ybXMsIG9wdGlvbnMuZGlyZWN0aXZlVHJhbnNmb3JtcyB8fCB7fSAvLyB1c2VyIHRyYW5zZm9ybXNcclxuICAgICAgICApXHJcbiAgICB9KSk7XHJcbiAgICByZXR1cm4gZ2VuZXJhdGUoYXN0LCBleHRlbmQoe30sIG9wdGlvbnMsIHtcclxuICAgICAgICBwcmVmaXhJZGVudGlmaWVyc1xyXG4gICAgfSkpO1xyXG59XG5cbmNvbnN0IG5vb3BEaXJlY3RpdmVUcmFuc2Zvcm0gPSAoKSA9PiAoeyBwcm9wczogW10gfSk7XG5cbmV4cG9ydCB7IEJBU0VfVFJBTlNJVElPTiwgQ0FNRUxJWkUsIENBUElUQUxJWkUsIENSRUFURV9CTE9DSywgQ1JFQVRFX0NPTU1FTlQsIENSRUFURV9TTE9UUywgQ1JFQVRFX1NUQVRJQywgQ1JFQVRFX1RFWFQsIENSRUFURV9WTk9ERSwgRlJBR01FTlQsIElTX1JFRiwgS0VFUF9BTElWRSwgTUVSR0VfUFJPUFMsIE9QRU5fQkxPQ0ssIFBPUF9TQ09QRV9JRCwgUFVTSF9TQ09QRV9JRCwgUkVOREVSX0xJU1QsIFJFTkRFUl9TTE9ULCBSRVNPTFZFX0NPTVBPTkVOVCwgUkVTT0xWRV9ESVJFQ1RJVkUsIFJFU09MVkVfRFlOQU1JQ19DT01QT05FTlQsIFJFU09MVkVfRklMVEVSLCBTRVRfQkxPQ0tfVFJBQ0tJTkcsIFNVU1BFTlNFLCBURUxFUE9SVCwgVE9fRElTUExBWV9TVFJJTkcsIFRPX0hBTkRMRVJTLCBUT19IQU5ETEVSX0tFWSwgVU5SRUYsIFdJVEhfQ1RYLCBXSVRIX0RJUkVDVElWRVMsIFdJVEhfU0NPUEVfSUQsIGFkdmFuY2VQb3NpdGlvbldpdGhDbG9uZSwgYWR2YW5jZVBvc2l0aW9uV2l0aE11dGF0aW9uLCBhc3NlcnQsIGJhc2VDb21waWxlLCBiYXNlUGFyc2UsIGJ1aWxkUHJvcHMsIGJ1aWxkU2xvdHMsIGNoZWNrQ29tcGF0RW5hYmxlZCwgY3JlYXRlQXJyYXlFeHByZXNzaW9uLCBjcmVhdGVBc3NpZ25tZW50RXhwcmVzc2lvbiwgY3JlYXRlQmxvY2tTdGF0ZW1lbnQsIGNyZWF0ZUNhY2hlRXhwcmVzc2lvbiwgY3JlYXRlQ2FsbEV4cHJlc3Npb24sIGNyZWF0ZUNvbXBpbGVyRXJyb3IsIGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbiwgY3JlYXRlQ29uZGl0aW9uYWxFeHByZXNzaW9uLCBjcmVhdGVGb3JMb29wUGFyYW1zLCBjcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24sIGNyZWF0ZUlmU3RhdGVtZW50LCBjcmVhdGVJbnRlcnBvbGF0aW9uLCBjcmVhdGVPYmplY3RFeHByZXNzaW9uLCBjcmVhdGVPYmplY3RQcm9wZXJ0eSwgY3JlYXRlUmV0dXJuU3RhdGVtZW50LCBjcmVhdGVSb290LCBjcmVhdGVTZXF1ZW5jZUV4cHJlc3Npb24sIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24sIGNyZWF0ZVN0cnVjdHVyYWxEaXJlY3RpdmVUcmFuc2Zvcm0sIGNyZWF0ZVRlbXBsYXRlTGl0ZXJhbCwgY3JlYXRlVHJhbnNmb3JtQ29udGV4dCwgY3JlYXRlVk5vZGVDYWxsLCBmaW5kRGlyLCBmaW5kUHJvcCwgZ2VuZXJhdGUsIGdldEJhc2VUcmFuc2Zvcm1QcmVzZXQsIGdldElubmVyUmFuZ2UsIGhhc0R5bmFtaWNLZXlWQmluZCwgaGFzU2NvcGVSZWYsIGhlbHBlck5hbWVNYXAsIGluamVjdFByb3AsIGlzQmluZEtleSwgaXNCdWlsdEluVHlwZSwgaXNDb3JlQ29tcG9uZW50LCBpc01lbWJlckV4cHJlc3Npb24sIGlzU2ltcGxlSWRlbnRpZmllciwgaXNTbG90T3V0bGV0LCBpc1N0YXRpY0V4cCwgaXNUZW1wbGF0ZU5vZGUsIGlzVGV4dCwgaXNWU2xvdCwgbG9jU3R1Yiwgbm9vcERpcmVjdGl2ZVRyYW5zZm9ybSwgcHJvY2Vzc0V4cHJlc3Npb24sIHByb2Nlc3NGb3IsIHByb2Nlc3NJZiwgcHJvY2Vzc1Nsb3RPdXRsZXQsIHJlZ2lzdGVyUnVudGltZUhlbHBlcnMsIHJlc29sdmVDb21wb25lbnRUeXBlLCB0b1ZhbGlkQXNzZXRJZCwgdHJhY2tTbG90U2NvcGVzLCB0cmFja1ZGb3JTbG90U2NvcGVzLCB0cmFuc2Zvcm0sIHRyYW5zZm9ybUJpbmQsIHRyYW5zZm9ybUVsZW1lbnQsIHRyYW5zZm9ybUV4cHJlc3Npb24sIHRyYW5zZm9ybU1vZGVsLCB0cmFuc2Zvcm1PbiwgdHJhdmVyc2VOb2RlLCB3YXJuRGVwcmVjYXRpb24gfTtcbiIsImltcG9ydCB7IHJlZ2lzdGVyUnVudGltZUhlbHBlcnMsIGlzQnVpbHRJblR5cGUsIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24sIGNyZWF0ZUNvbXBpbGVyRXJyb3IsIGNyZWF0ZU9iamVjdFByb3BlcnR5LCBjcmVhdGVDYWxsRXhwcmVzc2lvbiwgVE9fRElTUExBWV9TVFJJTkcsIHRyYW5zZm9ybU1vZGVsIGFzIHRyYW5zZm9ybU1vZGVsJDEsIGZpbmRQcm9wLCBoYXNEeW5hbWljS2V5VkJpbmQsIHRyYW5zZm9ybU9uIGFzIHRyYW5zZm9ybU9uJDEsIGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbiwgaXNTdGF0aWNFeHAsIGNoZWNrQ29tcGF0RW5hYmxlZCwgbm9vcERpcmVjdGl2ZVRyYW5zZm9ybSwgYmFzZUNvbXBpbGUsIGJhc2VQYXJzZSB9IGZyb20gJ0B2dWUvY29tcGlsZXItY29yZSc7XG5leHBvcnQgKiBmcm9tICdAdnVlL2NvbXBpbGVyLWNvcmUnO1xuaW1wb3J0IHsgaXNWb2lkVGFnLCBpc0hUTUxUYWcsIGlzU1ZHVGFnLCBtYWtlTWFwLCBwYXJzZVN0cmluZ1N0eWxlLCBjYXBpdGFsaXplLCBleHRlbmQgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5cbmNvbnN0IFZfTU9ERUxfUkFESU8gPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHZNb2RlbFJhZGlvYCA6IGBgKTtcclxuY29uc3QgVl9NT0RFTF9DSEVDS0JPWCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdk1vZGVsQ2hlY2tib3hgIDogYGApO1xyXG5jb25zdCBWX01PREVMX1RFWFQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHZNb2RlbFRleHRgIDogYGApO1xyXG5jb25zdCBWX01PREVMX1NFTEVDVCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdk1vZGVsU2VsZWN0YCA6IGBgKTtcclxuY29uc3QgVl9NT0RFTF9EWU5BTUlDID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB2TW9kZWxEeW5hbWljYCA6IGBgKTtcclxuY29uc3QgVl9PTl9XSVRIX01PRElGSUVSUyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdk9uTW9kaWZpZXJzR3VhcmRgIDogYGApO1xyXG5jb25zdCBWX09OX1dJVEhfS0VZUyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdk9uS2V5c0d1YXJkYCA6IGBgKTtcclxuY29uc3QgVl9TSE9XID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB2U2hvd2AgOiBgYCk7XHJcbmNvbnN0IFRSQU5TSVRJT04gPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYFRyYW5zaXRpb25gIDogYGApO1xyXG5jb25zdCBUUkFOU0lUSU9OX0dST1VQID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBUcmFuc2l0aW9uR3JvdXBgIDogYGApO1xyXG5yZWdpc3RlclJ1bnRpbWVIZWxwZXJzKHtcclxuICAgIFtWX01PREVMX1JBRElPXTogYHZNb2RlbFJhZGlvYCxcclxuICAgIFtWX01PREVMX0NIRUNLQk9YXTogYHZNb2RlbENoZWNrYm94YCxcclxuICAgIFtWX01PREVMX1RFWFRdOiBgdk1vZGVsVGV4dGAsXHJcbiAgICBbVl9NT0RFTF9TRUxFQ1RdOiBgdk1vZGVsU2VsZWN0YCxcclxuICAgIFtWX01PREVMX0RZTkFNSUNdOiBgdk1vZGVsRHluYW1pY2AsXHJcbiAgICBbVl9PTl9XSVRIX01PRElGSUVSU106IGB3aXRoTW9kaWZpZXJzYCxcclxuICAgIFtWX09OX1dJVEhfS0VZU106IGB3aXRoS2V5c2AsXHJcbiAgICBbVl9TSE9XXTogYHZTaG93YCxcclxuICAgIFtUUkFOU0lUSU9OXTogYFRyYW5zaXRpb25gLFxyXG4gICAgW1RSQU5TSVRJT05fR1JPVVBdOiBgVHJhbnNpdGlvbkdyb3VwYFxyXG59KTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzICovXHJcbmxldCBkZWNvZGVyO1xyXG5mdW5jdGlvbiBkZWNvZGVIdG1sQnJvd3NlcihyYXcsIGFzQXR0ciA9IGZhbHNlKSB7XHJcbiAgICBpZiAoIWRlY29kZXIpIHtcclxuICAgICAgICBkZWNvZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICB9XHJcbiAgICBpZiAoYXNBdHRyKSB7XHJcbiAgICAgICAgZGVjb2Rlci5pbm5lckhUTUwgPSBgPGRpdiBmb289XCIke3Jhdy5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyl9XCI+YDtcclxuICAgICAgICByZXR1cm4gZGVjb2Rlci5jaGlsZHJlblswXS5nZXRBdHRyaWJ1dGUoJ2ZvbycpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZGVjb2Rlci5pbm5lckhUTUwgPSByYXc7XHJcbiAgICAgICAgcmV0dXJuIGRlY29kZXIudGV4dENvbnRlbnQ7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgaXNSYXdUZXh0Q29udGFpbmVyID0gLyojX19QVVJFX18qLyBtYWtlTWFwKCdzdHlsZSxpZnJhbWUsc2NyaXB0LG5vc2NyaXB0JywgdHJ1ZSk7XHJcbmNvbnN0IHBhcnNlck9wdGlvbnMgPSB7XHJcbiAgICBpc1ZvaWRUYWcsXHJcbiAgICBpc05hdGl2ZVRhZzogdGFnID0+IGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHVGFnKHRhZyksXHJcbiAgICBpc1ByZVRhZzogdGFnID0+IHRhZyA9PT0gJ3ByZScsXHJcbiAgICBkZWNvZGVFbnRpdGllczogZGVjb2RlSHRtbEJyb3dzZXIgLFxyXG4gICAgaXNCdWlsdEluQ29tcG9uZW50OiAodGFnKSA9PiB7XHJcbiAgICAgICAgaWYgKGlzQnVpbHRJblR5cGUodGFnLCBgVHJhbnNpdGlvbmApKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBUUkFOU0lUSU9OO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc0J1aWx0SW5UeXBlKHRhZywgYFRyYW5zaXRpb25Hcm91cGApKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBUUkFOU0lUSU9OX0dST1VQO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9wYXJzaW5nLmh0bWwjdHJlZS1jb25zdHJ1Y3Rpb24tZGlzcGF0Y2hlclxyXG4gICAgZ2V0TmFtZXNwYWNlKHRhZywgcGFyZW50KSB7XHJcbiAgICAgICAgbGV0IG5zID0gcGFyZW50ID8gcGFyZW50Lm5zIDogMCAvKiBIVE1MICovO1xyXG4gICAgICAgIGlmIChwYXJlbnQgJiYgbnMgPT09IDIgLyogTUFUSF9NTCAqLykge1xyXG4gICAgICAgICAgICBpZiAocGFyZW50LnRhZyA9PT0gJ2Fubm90YXRpb24teG1sJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRhZyA9PT0gJ3N2ZycpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBTVkcgKi87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50LnByb3BzLnNvbWUoYSA9PiBhLnR5cGUgPT09IDYgLyogQVRUUklCVVRFICovICYmXHJcbiAgICAgICAgICAgICAgICAgICAgYS5uYW1lID09PSAnZW5jb2RpbmcnICYmXHJcbiAgICAgICAgICAgICAgICAgICAgYS52YWx1ZSAhPSBudWxsICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKGEudmFsdWUuY29udGVudCA9PT0gJ3RleHQvaHRtbCcgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYS52YWx1ZS5jb250ZW50ID09PSAnYXBwbGljYXRpb24veGh0bWwreG1sJykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbnMgPSAwIC8qIEhUTUwgKi87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoL15tKD86W2lvbnNdfHRleHQpJC8udGVzdChwYXJlbnQudGFnKSAmJlxyXG4gICAgICAgICAgICAgICAgdGFnICE9PSAnbWdseXBoJyAmJlxyXG4gICAgICAgICAgICAgICAgdGFnICE9PSAnbWFsaWdubWFyaycpIHtcclxuICAgICAgICAgICAgICAgIG5zID0gMCAvKiBIVE1MICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBhcmVudCAmJiBucyA9PT0gMSAvKiBTVkcgKi8pIHtcclxuICAgICAgICAgICAgaWYgKHBhcmVudC50YWcgPT09ICdmb3JlaWduT2JqZWN0JyB8fFxyXG4gICAgICAgICAgICAgICAgcGFyZW50LnRhZyA9PT0gJ2Rlc2MnIHx8XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQudGFnID09PSAndGl0bGUnKSB7XHJcbiAgICAgICAgICAgICAgICBucyA9IDAgLyogSFRNTCAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobnMgPT09IDAgLyogSFRNTCAqLykge1xyXG4gICAgICAgICAgICBpZiAodGFnID09PSAnc3ZnJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU1ZHICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0YWcgPT09ICdtYXRoJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDIgLyogTUFUSF9NTCAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnM7XHJcbiAgICB9LFxyXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvcGFyc2luZy5odG1sI3BhcnNpbmctaHRtbC1mcmFnbWVudHNcclxuICAgIGdldFRleHRNb2RlKHsgdGFnLCBucyB9KSB7XHJcbiAgICAgICAgaWYgKG5zID09PSAwIC8qIEhUTUwgKi8pIHtcclxuICAgICAgICAgICAgaWYgKHRhZyA9PT0gJ3RleHRhcmVhJyB8fCB0YWcgPT09ICd0aXRsZScpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFJDREFUQSAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNSYXdUZXh0Q29udGFpbmVyKHRhZykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAyIC8qIFJBV1RFWFQgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDAgLyogREFUQSAqLztcclxuICAgIH1cclxufTtcblxuLy8gUGFyc2UgaW5saW5lIENTUyBzdHJpbmdzIGZvciBzdGF0aWMgc3R5bGUgYXR0cmlidXRlcyBpbnRvIGFuIG9iamVjdC5cclxuLy8gVGhpcyBpcyBhIE5vZGVUcmFuc2Zvcm0gc2luY2UgaXQgd29ya3Mgb24gdGhlIHN0YXRpYyBgc3R5bGVgIGF0dHJpYnV0ZSBhbmRcclxuLy8gY29udmVydHMgaXQgaW50byBhIGR5bmFtaWMgZXF1aXZhbGVudDpcclxuLy8gc3R5bGU9XCJjb2xvcjogcmVkXCIgLT4gOnN0eWxlPSd7IFwiY29sb3JcIjogXCJyZWRcIiB9J1xyXG4vLyBJdCBpcyB0aGVuIHByb2Nlc3NlZCBieSBgdHJhbnNmb3JtRWxlbWVudGAgYW5kIGluY2x1ZGVkIGluIHRoZSBnZW5lcmF0ZWRcclxuLy8gcHJvcHMuXHJcbmNvbnN0IHRyYW5zZm9ybVN0eWxlID0gbm9kZSA9PiB7XHJcbiAgICBpZiAobm9kZS50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8pIHtcclxuICAgICAgICBub2RlLnByb3BzLmZvckVhY2goKHAsIGkpID0+IHtcclxuICAgICAgICAgICAgaWYgKHAudHlwZSA9PT0gNiAvKiBBVFRSSUJVVEUgKi8gJiYgcC5uYW1lID09PSAnc3R5bGUnICYmIHAudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIC8vIHJlcGxhY2UgcCB3aXRoIGFuIGV4cHJlc3Npb24gbm9kZVxyXG4gICAgICAgICAgICAgICAgbm9kZS5wcm9wc1tpXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiA3IC8qIERJUkVDVElWRSAqLyxcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBgYmluZGAsXHJcbiAgICAgICAgICAgICAgICAgICAgYXJnOiBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGBzdHlsZWAsIHRydWUsIHAubG9jKSxcclxuICAgICAgICAgICAgICAgICAgICBleHA6IHBhcnNlSW5saW5lQ1NTKHAudmFsdWUuY29udGVudCwgcC5sb2MpLFxyXG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVyczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgbG9jOiBwLmxvY1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBwYXJzZUlubGluZUNTUyA9IChjc3NUZXh0LCBsb2MpID0+IHtcclxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBwYXJzZVN0cmluZ1N0eWxlKGNzc1RleHQpO1xyXG4gICAgcmV0dXJuIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oSlNPTi5zdHJpbmdpZnkobm9ybWFsaXplZCksIGZhbHNlLCBsb2MsIDMgLyogQ0FOX1NUUklOR0lGWSAqLyk7XHJcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoY29kZSwgbG9jKSB7XHJcbiAgICByZXR1cm4gY3JlYXRlQ29tcGlsZXJFcnJvcihjb2RlLCBsb2MsIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCAhdHJ1ZSA/IERPTUVycm9yTWVzc2FnZXMgOiB1bmRlZmluZWQpO1xyXG59XHJcbmNvbnN0IERPTUVycm9yTWVzc2FnZXMgPSB7XHJcbiAgICBbNDkgLyogWF9WX0hUTUxfTk9fRVhQUkVTU0lPTiAqL106IGB2LWh0bWwgaXMgbWlzc2luZyBleHByZXNzaW9uLmAsXHJcbiAgICBbNTAgLyogWF9WX0hUTUxfV0lUSF9DSElMRFJFTiAqL106IGB2LWh0bWwgd2lsbCBvdmVycmlkZSBlbGVtZW50IGNoaWxkcmVuLmAsXHJcbiAgICBbNTEgLyogWF9WX1RFWFRfTk9fRVhQUkVTU0lPTiAqL106IGB2LXRleHQgaXMgbWlzc2luZyBleHByZXNzaW9uLmAsXHJcbiAgICBbNTIgLyogWF9WX1RFWFRfV0lUSF9DSElMRFJFTiAqL106IGB2LXRleHQgd2lsbCBvdmVycmlkZSBlbGVtZW50IGNoaWxkcmVuLmAsXHJcbiAgICBbNTMgLyogWF9WX01PREVMX09OX0lOVkFMSURfRUxFTUVOVCAqL106IGB2LW1vZGVsIGNhbiBvbmx5IGJlIHVzZWQgb24gPGlucHV0PiwgPHRleHRhcmVhPiBhbmQgPHNlbGVjdD4gZWxlbWVudHMuYCxcclxuICAgIFs1NCAvKiBYX1ZfTU9ERUxfQVJHX09OX0VMRU1FTlQgKi9dOiBgdi1tb2RlbCBhcmd1bWVudCBpcyBub3Qgc3VwcG9ydGVkIG9uIHBsYWluIGVsZW1lbnRzLmAsXHJcbiAgICBbNTUgLyogWF9WX01PREVMX09OX0ZJTEVfSU5QVVRfRUxFTUVOVCAqL106IGB2LW1vZGVsIGNhbm5vdCBiZSB1c2VkIG9uIGZpbGUgaW5wdXRzIHNpbmNlIHRoZXkgYXJlIHJlYWQtb25seS4gVXNlIGEgdi1vbjpjaGFuZ2UgbGlzdGVuZXIgaW5zdGVhZC5gLFxyXG4gICAgWzU2IC8qIFhfVl9NT0RFTF9VTk5FQ0VTU0FSWV9WQUxVRSAqL106IGBVbm5lY2Vzc2FyeSB2YWx1ZSBiaW5kaW5nIHVzZWQgYWxvbmdzaWRlIHYtbW9kZWwuIEl0IHdpbGwgaW50ZXJmZXJlIHdpdGggdi1tb2RlbCdzIGJlaGF2aW9yLmAsXHJcbiAgICBbNTcgLyogWF9WX1NIT1dfTk9fRVhQUkVTU0lPTiAqL106IGB2LXNob3cgaXMgbWlzc2luZyBleHByZXNzaW9uLmAsXHJcbiAgICBbNTggLyogWF9UUkFOU0lUSU9OX0lOVkFMSURfQ0hJTERSRU4gKi9dOiBgPFRyYW5zaXRpb24+IGV4cGVjdHMgZXhhY3RseSBvbmUgY2hpbGQgZWxlbWVudCBvciBjb21wb25lbnQuYCxcclxuICAgIFs1OSAvKiBYX0lHTk9SRURfU0lERV9FRkZFQ1RfVEFHICovXTogYFRhZ3Mgd2l0aCBzaWRlIGVmZmVjdCAoPHNjcmlwdD4gYW5kIDxzdHlsZT4pIGFyZSBpZ25vcmVkIGluIGNsaWVudCBjb21wb25lbnQgdGVtcGxhdGVzLmBcclxufTtcblxuY29uc3QgdHJhbnNmb3JtVkh0bWwgPSAoZGlyLCBub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBjb25zdCB7IGV4cCwgbG9jIH0gPSBkaXI7XHJcbiAgICBpZiAoIWV4cCkge1xyXG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVET01Db21waWxlckVycm9yKDQ5IC8qIFhfVl9IVE1MX05PX0VYUFJFU1NJT04gKi8sIGxvYykpO1xyXG4gICAgfVxyXG4gICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTAgLyogWF9WX0hUTUxfV0lUSF9DSElMRFJFTiAqLywgbG9jKSk7XHJcbiAgICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggPSAwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBwcm9wczogW1xyXG4gICAgICAgICAgICBjcmVhdGVPYmplY3RQcm9wZXJ0eShjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGBpbm5lckhUTUxgLCB0cnVlLCBsb2MpLCBleHAgfHwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbignJywgdHJ1ZSkpXHJcbiAgICAgICAgXVxyXG4gICAgfTtcclxufTtcblxuY29uc3QgdHJhbnNmb3JtVlRleHQgPSAoZGlyLCBub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBjb25zdCB7IGV4cCwgbG9jIH0gPSBkaXI7XHJcbiAgICBpZiAoIWV4cCkge1xyXG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVET01Db21waWxlckVycm9yKDUxIC8qIFhfVl9URVhUX05PX0VYUFJFU1NJT04gKi8sIGxvYykpO1xyXG4gICAgfVxyXG4gICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTIgLyogWF9WX1RFWFRfV0lUSF9DSElMRFJFTiAqLywgbG9jKSk7XHJcbiAgICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggPSAwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBwcm9wczogW1xyXG4gICAgICAgICAgICBjcmVhdGVPYmplY3RQcm9wZXJ0eShjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGB0ZXh0Q29udGVudGAsIHRydWUpLCBleHBcclxuICAgICAgICAgICAgICAgID8gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXJTdHJpbmcoVE9fRElTUExBWV9TVFJJTkcpLCBbZXhwXSwgbG9jKVxyXG4gICAgICAgICAgICAgICAgOiBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKCcnLCB0cnVlKSlcclxuICAgICAgICBdXHJcbiAgICB9O1xyXG59O1xuXG5jb25zdCB0cmFuc2Zvcm1Nb2RlbCA9IChkaXIsIG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGNvbnN0IGJhc2VSZXN1bHQgPSB0cmFuc2Zvcm1Nb2RlbCQxKGRpciwgbm9kZSwgY29udGV4dCk7XHJcbiAgICAvLyBiYXNlIHRyYW5zZm9ybSBoYXMgZXJyb3JzIE9SIGNvbXBvbmVudCB2LW1vZGVsIChvbmx5IG5lZWQgcHJvcHMpXHJcbiAgICBpZiAoIWJhc2VSZXN1bHQucHJvcHMubGVuZ3RoIHx8IG5vZGUudGFnVHlwZSA9PT0gMSAvKiBDT01QT05FTlQgKi8pIHtcclxuICAgICAgICByZXR1cm4gYmFzZVJlc3VsdDtcclxuICAgIH1cclxuICAgIGlmIChkaXIuYXJnKSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTQgLyogWF9WX01PREVMX0FSR19PTl9FTEVNRU5UICovLCBkaXIuYXJnLmxvYykpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY2hlY2tEdXBsaWNhdGVkVmFsdWUoKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBmaW5kUHJvcChub2RlLCAndmFsdWUnKTtcclxuICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTYgLyogWF9WX01PREVMX1VOTkVDRVNTQVJZX1ZBTFVFICovLCB2YWx1ZS5sb2MpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IHRhZyB9ID0gbm9kZTtcclxuICAgIGNvbnN0IGlzQ3VzdG9tRWxlbWVudCA9IGNvbnRleHQuaXNDdXN0b21FbGVtZW50KHRhZyk7XHJcbiAgICBpZiAodGFnID09PSAnaW5wdXQnIHx8XHJcbiAgICAgICAgdGFnID09PSAndGV4dGFyZWEnIHx8XHJcbiAgICAgICAgdGFnID09PSAnc2VsZWN0JyB8fFxyXG4gICAgICAgIGlzQ3VzdG9tRWxlbWVudCkge1xyXG4gICAgICAgIGxldCBkaXJlY3RpdmVUb1VzZSA9IFZfTU9ERUxfVEVYVDtcclxuICAgICAgICBsZXQgaXNJbnZhbGlkVHlwZSA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0YWcgPT09ICdpbnB1dCcgfHwgaXNDdXN0b21FbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBmaW5kUHJvcChub2RlLCBgdHlwZWApO1xyXG4gICAgICAgICAgICBpZiAodHlwZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUudHlwZSA9PT0gNyAvKiBESVJFQ1RJVkUgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyA6dHlwZT1cImZvb1wiXHJcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlVG9Vc2UgPSBWX01PREVMX0RZTkFNSUM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlLnZhbHVlLmNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncmFkaW8nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlVG9Vc2UgPSBWX01PREVMX1JBRElPO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NoZWNrYm94JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGl2ZVRvVXNlID0gVl9NT0RFTF9DSEVDS0JPWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmaWxlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzSW52YWxpZFR5cGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTUgLyogWF9WX01PREVMX09OX0ZJTEVfSU5QVVRfRUxFTUVOVCAqLywgZGlyLmxvYykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0ZXh0IHR5cGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjaGVja0R1cGxpY2F0ZWRWYWx1ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc0R5bmFtaWNLZXlWQmluZChub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gZWxlbWVudCBoYXMgYmluZGluZ3Mgd2l0aCBkeW5hbWljIGtleXMsIHdoaWNoIGNhbiBwb3NzaWJseSBjb250YWluXHJcbiAgICAgICAgICAgICAgICAvLyBcInR5cGVcIi5cclxuICAgICAgICAgICAgICAgIGRpcmVjdGl2ZVRvVXNlID0gVl9NT0RFTF9EWU5BTUlDO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gdGV4dCB0eXBlXHJcbiAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgY2hlY2tEdXBsaWNhdGVkVmFsdWUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0YWcgPT09ICdzZWxlY3QnKSB7XHJcbiAgICAgICAgICAgIGRpcmVjdGl2ZVRvVXNlID0gVl9NT0RFTF9TRUxFQ1Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB0ZXh0YXJlYVxyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgY2hlY2tEdXBsaWNhdGVkVmFsdWUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaW5qZWN0IHJ1bnRpbWUgZGlyZWN0aXZlXHJcbiAgICAgICAgLy8gYnkgcmV0dXJuaW5nIHRoZSBoZWxwZXIgc3ltYm9sIHZpYSBuZWVkUnVudGltZVxyXG4gICAgICAgIC8vIHRoZSBpbXBvcnQgd2lsbCByZXBsYWNlZCBhIHJlc29sdmVEaXJlY3RpdmUgY2FsbC5cclxuICAgICAgICBpZiAoIWlzSW52YWxpZFR5cGUpIHtcclxuICAgICAgICAgICAgYmFzZVJlc3VsdC5uZWVkUnVudGltZSA9IGNvbnRleHQuaGVscGVyKGRpcmVjdGl2ZVRvVXNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlRE9NQ29tcGlsZXJFcnJvcig1MyAvKiBYX1ZfTU9ERUxfT05fSU5WQUxJRF9FTEVNRU5UICovLCBkaXIubG9jKSk7XHJcbiAgICB9XHJcbiAgICAvLyBuYXRpdmUgdm1vZGVsIGRvZXNuJ3QgbmVlZCB0aGUgYG1vZGVsVmFsdWVgIHByb3BzIHNpbmNlIHRoZXkgYXJlIGFsc29cclxuICAgIC8vIHBhc3NlZCB0byB0aGUgcnVudGltZSBhcyBgYmluZGluZy52YWx1ZWAuIHJlbW92aW5nIGl0IHJlZHVjZXMgY29kZSBzaXplLlxyXG4gICAgYmFzZVJlc3VsdC5wcm9wcyA9IGJhc2VSZXN1bHQucHJvcHMuZmlsdGVyKHAgPT4gIShwLmtleS50eXBlID09PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovICYmXHJcbiAgICAgICAgcC5rZXkuY29udGVudCA9PT0gJ21vZGVsVmFsdWUnKSk7XHJcbiAgICByZXR1cm4gYmFzZVJlc3VsdDtcclxufTtcblxuY29uc3QgaXNFdmVudE9wdGlvbk1vZGlmaWVyID0gLyojX19QVVJFX18qLyBtYWtlTWFwKGBwYXNzaXZlLG9uY2UsY2FwdHVyZWApO1xyXG5jb25zdCBpc05vbktleU1vZGlmaWVyID0gLyojX19QVVJFX18qLyBtYWtlTWFwKFxyXG4vLyBldmVudCBwcm9wYWdhdGlvbiBtYW5hZ2VtZW50XHJcbmBzdG9wLHByZXZlbnQsc2VsZixgICtcclxuICAgIC8vIHN5c3RlbSBtb2RpZmllcnMgKyBleGFjdFxyXG4gICAgYGN0cmwsc2hpZnQsYWx0LG1ldGEsZXhhY3QsYCArXHJcbiAgICAvLyBtb3VzZVxyXG4gICAgYG1pZGRsZWApO1xyXG4vLyBsZWZ0ICYgcmlnaHQgY291bGQgYmUgbW91c2Ugb3Iga2V5IG1vZGlmaWVycyBiYXNlZCBvbiBldmVudCB0eXBlXHJcbmNvbnN0IG1heWJlS2V5TW9kaWZpZXIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoJ2xlZnQscmlnaHQnKTtcclxuY29uc3QgaXNLZXlib2FyZEV2ZW50ID0gLyojX19QVVJFX18qLyBtYWtlTWFwKGBvbmtleXVwLG9ua2V5ZG93bixvbmtleXByZXNzYCwgdHJ1ZSk7XHJcbmNvbnN0IHJlc29sdmVNb2RpZmllcnMgPSAoa2V5LCBtb2RpZmllcnMsIGNvbnRleHQsIGxvYykgPT4ge1xyXG4gICAgY29uc3Qga2V5TW9kaWZpZXJzID0gW107XHJcbiAgICBjb25zdCBub25LZXlNb2RpZmllcnMgPSBbXTtcclxuICAgIGNvbnN0IGV2ZW50T3B0aW9uTW9kaWZpZXJzID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZGlmaWVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IG1vZGlmaWVyID0gbW9kaWZpZXJzW2ldO1xyXG4gICAgICAgIGlmIChtb2RpZmllciA9PT0gJ25hdGl2ZScgJiZcclxuICAgICAgICAgICAgY2hlY2tDb21wYXRFbmFibGVkKFwiQ09NUElMRVJfVl9PTl9OQVRJVkVcIiAvKiBDT01QSUxFUl9WX09OX05BVElWRSAqLywgY29udGV4dCwgbG9jKSkge1xyXG4gICAgICAgICAgICBldmVudE9wdGlvbk1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNFdmVudE9wdGlvbk1vZGlmaWVyKG1vZGlmaWVyKSkge1xyXG4gICAgICAgICAgICAvLyBldmVudE9wdGlvbk1vZGlmaWVyczogbW9kaWZpZXJzIGZvciBhZGRFdmVudExpc3RlbmVyKCkgb3B0aW9ucyxcclxuICAgICAgICAgICAgLy8gZS5nLiAucGFzc2l2ZSAmIC5jYXB0dXJlXHJcbiAgICAgICAgICAgIGV2ZW50T3B0aW9uTW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gcnVudGltZU1vZGlmaWVyczogbW9kaWZpZXJzIHRoYXQgbmVlZHMgcnVudGltZSBndWFyZHNcclxuICAgICAgICAgICAgaWYgKG1heWJlS2V5TW9kaWZpZXIobW9kaWZpZXIpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNTdGF0aWNFeHAoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0tleWJvYXJkRXZlbnQoa2V5LmNvbnRlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleU1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vbktleU1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXlNb2RpZmllcnMucHVzaChtb2RpZmllcik7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9uS2V5TW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTm9uS2V5TW9kaWZpZXIobW9kaWZpZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9uS2V5TW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5TW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBrZXlNb2RpZmllcnMsXHJcbiAgICAgICAgbm9uS2V5TW9kaWZpZXJzLFxyXG4gICAgICAgIGV2ZW50T3B0aW9uTW9kaWZpZXJzXHJcbiAgICB9O1xyXG59O1xyXG5jb25zdCB0cmFuc2Zvcm1DbGljayA9IChrZXksIGV2ZW50KSA9PiB7XHJcbiAgICBjb25zdCBpc1N0YXRpY0NsaWNrID0gaXNTdGF0aWNFeHAoa2V5KSAmJiBrZXkuY29udGVudC50b0xvd2VyQ2FzZSgpID09PSAnb25jbGljayc7XHJcbiAgICByZXR1cm4gaXNTdGF0aWNDbGlja1xyXG4gICAgICAgID8gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihldmVudCwgdHJ1ZSlcclxuICAgICAgICA6IGtleS50eXBlICE9PSA0IC8qIFNJTVBMRV9FWFBSRVNTSU9OICovXHJcbiAgICAgICAgICAgID8gY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFtcclxuICAgICAgICAgICAgICAgIGAoYCxcclxuICAgICAgICAgICAgICAgIGtleSxcclxuICAgICAgICAgICAgICAgIGApID09PSBcIm9uQ2xpY2tcIiA/IFwiJHtldmVudH1cIiA6IChgLFxyXG4gICAgICAgICAgICAgICAga2V5LFxyXG4gICAgICAgICAgICAgICAgYClgXHJcbiAgICAgICAgICAgIF0pXHJcbiAgICAgICAgICAgIDoga2V5O1xyXG59O1xyXG5jb25zdCB0cmFuc2Zvcm1PbiA9IChkaXIsIG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIHJldHVybiB0cmFuc2Zvcm1PbiQxKGRpciwgbm9kZSwgY29udGV4dCwgYmFzZVJlc3VsdCA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBtb2RpZmllcnMgfSA9IGRpcjtcclxuICAgICAgICBpZiAoIW1vZGlmaWVycy5sZW5ndGgpXHJcbiAgICAgICAgICAgIHJldHVybiBiYXNlUmVzdWx0O1xyXG4gICAgICAgIGxldCB7IGtleSwgdmFsdWU6IGhhbmRsZXJFeHAgfSA9IGJhc2VSZXN1bHQucHJvcHNbMF07XHJcbiAgICAgICAgY29uc3QgeyBrZXlNb2RpZmllcnMsIG5vbktleU1vZGlmaWVycywgZXZlbnRPcHRpb25Nb2RpZmllcnMgfSA9IHJlc29sdmVNb2RpZmllcnMoa2V5LCBtb2RpZmllcnMsIGNvbnRleHQsIGRpci5sb2MpO1xyXG4gICAgICAgIC8vIG5vcm1hbGl6ZSBjbGljay5yaWdodCBhbmQgY2xpY2subWlkZGxlIHNpbmNlIHRoZXkgZG9uJ3QgYWN0dWFsbHkgZmlyZVxyXG4gICAgICAgIGlmIChub25LZXlNb2RpZmllcnMuaW5jbHVkZXMoJ3JpZ2h0JykpIHtcclxuICAgICAgICAgICAga2V5ID0gdHJhbnNmb3JtQ2xpY2soa2V5LCBgb25Db250ZXh0bWVudWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobm9uS2V5TW9kaWZpZXJzLmluY2x1ZGVzKCdtaWRkbGUnKSkge1xyXG4gICAgICAgICAgICBrZXkgPSB0cmFuc2Zvcm1DbGljayhrZXksIGBvbk1vdXNldXBgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5vbktleU1vZGlmaWVycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaGFuZGxlckV4cCA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKFZfT05fV0lUSF9NT0RJRklFUlMpLCBbXHJcbiAgICAgICAgICAgICAgICBoYW5kbGVyRXhwLFxyXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkobm9uS2V5TW9kaWZpZXJzKVxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGtleU1vZGlmaWVycy5sZW5ndGggJiZcclxuICAgICAgICAgICAgLy8gaWYgZXZlbnQgbmFtZSBpcyBkeW5hbWljLCBhbHdheXMgd3JhcCB3aXRoIGtleXMgZ3VhcmRcclxuICAgICAgICAgICAgKCFpc1N0YXRpY0V4cChrZXkpIHx8IGlzS2V5Ym9hcmRFdmVudChrZXkuY29udGVudCkpKSB7XHJcbiAgICAgICAgICAgIGhhbmRsZXJFeHAgPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihWX09OX1dJVEhfS0VZUyksIFtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXJFeHAsXHJcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShrZXlNb2RpZmllcnMpXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXZlbnRPcHRpb25Nb2RpZmllcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVyUG9zdGZpeCA9IGV2ZW50T3B0aW9uTW9kaWZpZXJzLm1hcChjYXBpdGFsaXplKS5qb2luKCcnKTtcclxuICAgICAgICAgICAga2V5ID0gaXNTdGF0aWNFeHAoa2V5KVxyXG4gICAgICAgICAgICAgICAgPyBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGAke2tleS5jb250ZW50fSR7bW9kaWZpZXJQb3N0Zml4fWAsIHRydWUpXHJcbiAgICAgICAgICAgICAgICA6IGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihbYChgLCBrZXksIGApICsgXCIke21vZGlmaWVyUG9zdGZpeH1cImBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcHJvcHM6IFtjcmVhdGVPYmplY3RQcm9wZXJ0eShrZXksIGhhbmRsZXJFeHApXVxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxufTtcblxuY29uc3QgdHJhbnNmb3JtU2hvdyA9IChkaXIsIG5vZGUsIGNvbnRleHQpID0+IHtcclxuICAgIGNvbnN0IHsgZXhwLCBsb2MgfSA9IGRpcjtcclxuICAgIGlmICghZXhwKSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTcgLyogWF9WX1NIT1dfTk9fRVhQUkVTU0lPTiAqLywgbG9jKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHByb3BzOiBbXSxcclxuICAgICAgICBuZWVkUnVudGltZTogY29udGV4dC5oZWxwZXIoVl9TSE9XKVxyXG4gICAgfTtcclxufTtcblxuY29uc3Qgd2FyblRyYW5zaXRpb25DaGlsZHJlbiA9IChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBpZiAobm9kZS50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICBub2RlLnRhZ1R5cGUgPT09IDEgLyogQ09NUE9ORU5UICovKSB7XHJcbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gY29udGV4dC5pc0J1aWx0SW5Db21wb25lbnQobm9kZS50YWcpO1xyXG4gICAgICAgIGlmIChjb21wb25lbnQgPT09IFRSQU5TSVRJT04pIHtcclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCAmJiBoYXNNdWx0aXBsZUNoaWxkcmVuKG5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTggLyogWF9UUkFOU0lUSU9OX0lOVkFMSURfQ0hJTERSRU4gKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IG5vZGUuY2hpbGRyZW5bMF0ubG9jLnN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IG5vZGUuY2hpbGRyZW5bbm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxXS5sb2MuZW5kLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6ICcnXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gaGFzTXVsdGlwbGVDaGlsZHJlbihub2RlKSB7XHJcbiAgICAvLyAjMTM1MiBmaWx0ZXIgb3V0IHBvdGVudGlhbCBjb21tZW50IG5vZGVzLlxyXG4gICAgY29uc3QgY2hpbGRyZW4gPSAobm9kZS5jaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4uZmlsdGVyKGMgPT4gYy50eXBlICE9PSAzIC8qIENPTU1FTlQgKi8pKTtcclxuICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5bMF07XHJcbiAgICByZXR1cm4gKGNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fFxyXG4gICAgICAgIGNoaWxkLnR5cGUgPT09IDExIC8qIEZPUiAqLyB8fFxyXG4gICAgICAgIChjaGlsZC50eXBlID09PSA5IC8qIElGICovICYmIGNoaWxkLmJyYW5jaGVzLnNvbWUoaGFzTXVsdGlwbGVDaGlsZHJlbikpKTtcclxufVxuXG5jb25zdCBpZ25vcmVTaWRlRWZmZWN0VGFncyA9IChub2RlLCBjb250ZXh0KSA9PiB7XHJcbiAgICBpZiAobm9kZS50eXBlID09PSAxIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICBub2RlLnRhZ1R5cGUgPT09IDAgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgIChub2RlLnRhZyA9PT0gJ3NjcmlwdCcgfHwgbm9kZS50YWcgPT09ICdzdHlsZScpKSB7XHJcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTkgLyogWF9JR05PUkVEX1NJREVfRUZGRUNUX1RBRyAqLywgbm9kZS5sb2MpKTtcclxuICAgICAgICBjb250ZXh0LnJlbW92ZU5vZGUoKTtcclxuICAgIH1cclxufTtcblxuY29uc3QgRE9NTm9kZVRyYW5zZm9ybXMgPSBbXHJcbiAgICB0cmFuc2Zvcm1TdHlsZSxcclxuICAgIC4uLigocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBbd2FyblRyYW5zaXRpb25DaGlsZHJlbl0gOiBbXSlcclxuXTtcclxuY29uc3QgRE9NRGlyZWN0aXZlVHJhbnNmb3JtcyA9IHtcclxuICAgIGNsb2FrOiBub29wRGlyZWN0aXZlVHJhbnNmb3JtLFxyXG4gICAgaHRtbDogdHJhbnNmb3JtVkh0bWwsXHJcbiAgICB0ZXh0OiB0cmFuc2Zvcm1WVGV4dCxcclxuICAgIG1vZGVsOiB0cmFuc2Zvcm1Nb2RlbCxcclxuICAgIG9uOiB0cmFuc2Zvcm1PbixcclxuICAgIHNob3c6IHRyYW5zZm9ybVNob3dcclxufTtcclxuZnVuY3Rpb24gY29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICByZXR1cm4gYmFzZUNvbXBpbGUodGVtcGxhdGUsIGV4dGVuZCh7fSwgcGFyc2VyT3B0aW9ucywgb3B0aW9ucywge1xyXG4gICAgICAgIG5vZGVUcmFuc2Zvcm1zOiBbXHJcbiAgICAgICAgICAgIC8vIGlnbm9yZSA8c2NyaXB0PiBhbmQgPHRhZz5cclxuICAgICAgICAgICAgLy8gdGhpcyBpcyBub3QgcHV0IGluc2lkZSBET01Ob2RlVHJhbnNmb3JtcyBiZWNhdXNlIHRoYXQgbGlzdCBpcyB1c2VkXHJcbiAgICAgICAgICAgIC8vIGJ5IGNvbXBpbGVyLXNzciB0byBnZW5lcmF0ZSB2bm9kZSBmYWxsYmFjayBicmFuY2hlc1xyXG4gICAgICAgICAgICBpZ25vcmVTaWRlRWZmZWN0VGFncyxcclxuICAgICAgICAgICAgLi4uRE9NTm9kZVRyYW5zZm9ybXMsXHJcbiAgICAgICAgICAgIC4uLihvcHRpb25zLm5vZGVUcmFuc2Zvcm1zIHx8IFtdKVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgZGlyZWN0aXZlVHJhbnNmb3JtczogZXh0ZW5kKHt9LCBET01EaXJlY3RpdmVUcmFuc2Zvcm1zLCBvcHRpb25zLmRpcmVjdGl2ZVRyYW5zZm9ybXMgfHwge30pLFxyXG4gICAgICAgIHRyYW5zZm9ybUhvaXN0OiBudWxsIFxyXG4gICAgfSkpO1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlKHRlbXBsYXRlLCBvcHRpb25zID0ge30pIHtcclxuICAgIHJldHVybiBiYXNlUGFyc2UodGVtcGxhdGUsIGV4dGVuZCh7fSwgcGFyc2VyT3B0aW9ucywgb3B0aW9ucykpO1xyXG59XG5cbmV4cG9ydCB7IERPTURpcmVjdGl2ZVRyYW5zZm9ybXMsIERPTU5vZGVUcmFuc2Zvcm1zLCBUUkFOU0lUSU9OLCBUUkFOU0lUSU9OX0dST1VQLCBWX01PREVMX0NIRUNLQk9YLCBWX01PREVMX0RZTkFNSUMsIFZfTU9ERUxfUkFESU8sIFZfTU9ERUxfU0VMRUNULCBWX01PREVMX1RFWFQsIFZfT05fV0lUSF9LRVlTLCBWX09OX1dJVEhfTU9ESUZJRVJTLCBWX1NIT1csIGNvbXBpbGUsIGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IsIHBhcnNlLCBwYXJzZXJPcHRpb25zLCB0cmFuc2Zvcm1TdHlsZSB9O1xuIiwiaW1wb3J0IHsgRU1QVFlfT0JKLCBpc0FycmF5LCBpc01hcCwgaXNJbnRlZ2VyS2V5LCBpc1N5bWJvbCwgZXh0ZW5kLCBoYXNPd24sIGlzT2JqZWN0LCBoYXNDaGFuZ2VkLCBtYWtlTWFwLCBjYXBpdGFsaXplLCB0b1Jhd1R5cGUsIGRlZiwgaXNGdW5jdGlvbiwgTk9PUCB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxuY29uc3QgdGFyZ2V0TWFwID0gbmV3IFdlYWtNYXAoKTtcclxuY29uc3QgZWZmZWN0U3RhY2sgPSBbXTtcclxubGV0IGFjdGl2ZUVmZmVjdDtcclxuY29uc3QgSVRFUkFURV9LRVkgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ2l0ZXJhdGUnIDogJycpO1xyXG5jb25zdCBNQVBfS0VZX0lURVJBVEVfS0VZID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/ICdNYXAga2V5IGl0ZXJhdGUnIDogJycpO1xyXG5mdW5jdGlvbiBpc0VmZmVjdChmbikge1xyXG4gICAgcmV0dXJuIGZuICYmIGZuLl9pc0VmZmVjdCA9PT0gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBlZmZlY3QoZm4sIG9wdGlvbnMgPSBFTVBUWV9PQkopIHtcclxuICAgIGlmIChpc0VmZmVjdChmbikpIHtcclxuICAgICAgICBmbiA9IGZuLnJhdztcclxuICAgIH1cclxuICAgIGNvbnN0IGVmZmVjdCA9IGNyZWF0ZVJlYWN0aXZlRWZmZWN0KGZuLCBvcHRpb25zKTtcclxuICAgIGlmICghb3B0aW9ucy5sYXp5KSB7XHJcbiAgICAgICAgZWZmZWN0KCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZWZmZWN0O1xyXG59XHJcbmZ1bmN0aW9uIHN0b3AoZWZmZWN0KSB7XHJcbiAgICBpZiAoZWZmZWN0LmFjdGl2ZSkge1xyXG4gICAgICAgIGNsZWFudXAoZWZmZWN0KTtcclxuICAgICAgICBpZiAoZWZmZWN0Lm9wdGlvbnMub25TdG9wKSB7XHJcbiAgICAgICAgICAgIGVmZmVjdC5vcHRpb25zLm9uU3RvcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlZmZlY3QuYWN0aXZlID0gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxubGV0IHVpZCA9IDA7XHJcbmZ1bmN0aW9uIGNyZWF0ZVJlYWN0aXZlRWZmZWN0KGZuLCBvcHRpb25zKSB7XHJcbiAgICBjb25zdCBlZmZlY3QgPSBmdW5jdGlvbiByZWFjdGl2ZUVmZmVjdCgpIHtcclxuICAgICAgICBpZiAoIWVmZmVjdC5hY3RpdmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghZWZmZWN0U3RhY2suaW5jbHVkZXMoZWZmZWN0KSkge1xyXG4gICAgICAgICAgICBjbGVhbnVwKGVmZmVjdCk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBlbmFibGVUcmFja2luZygpO1xyXG4gICAgICAgICAgICAgICAgZWZmZWN0U3RhY2sucHVzaChlZmZlY3QpO1xyXG4gICAgICAgICAgICAgICAgYWN0aXZlRWZmZWN0ID0gZWZmZWN0O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICBlZmZlY3RTdGFjay5wb3AoKTtcclxuICAgICAgICAgICAgICAgIHJlc2V0VHJhY2tpbmcoKTtcclxuICAgICAgICAgICAgICAgIGFjdGl2ZUVmZmVjdCA9IGVmZmVjdFN0YWNrW2VmZmVjdFN0YWNrLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGVmZmVjdC5pZCA9IHVpZCsrO1xyXG4gICAgZWZmZWN0LmFsbG93UmVjdXJzZSA9ICEhb3B0aW9ucy5hbGxvd1JlY3Vyc2U7XHJcbiAgICBlZmZlY3QuX2lzRWZmZWN0ID0gdHJ1ZTtcclxuICAgIGVmZmVjdC5hY3RpdmUgPSB0cnVlO1xyXG4gICAgZWZmZWN0LnJhdyA9IGZuO1xyXG4gICAgZWZmZWN0LmRlcHMgPSBbXTtcclxuICAgIGVmZmVjdC5vcHRpb25zID0gb3B0aW9ucztcclxuICAgIHJldHVybiBlZmZlY3Q7XHJcbn1cclxuZnVuY3Rpb24gY2xlYW51cChlZmZlY3QpIHtcclxuICAgIGNvbnN0IHsgZGVwcyB9ID0gZWZmZWN0O1xyXG4gICAgaWYgKGRlcHMubGVuZ3RoKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXBzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGRlcHNbaV0uZGVsZXRlKGVmZmVjdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlcHMubGVuZ3RoID0gMDtcclxuICAgIH1cclxufVxyXG5sZXQgc2hvdWxkVHJhY2sgPSB0cnVlO1xyXG5jb25zdCB0cmFja1N0YWNrID0gW107XHJcbmZ1bmN0aW9uIHBhdXNlVHJhY2tpbmcoKSB7XHJcbiAgICB0cmFja1N0YWNrLnB1c2goc2hvdWxkVHJhY2spO1xyXG4gICAgc2hvdWxkVHJhY2sgPSBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBlbmFibGVUcmFja2luZygpIHtcclxuICAgIHRyYWNrU3RhY2sucHVzaChzaG91bGRUcmFjayk7XHJcbiAgICBzaG91bGRUcmFjayA9IHRydWU7XHJcbn1cclxuZnVuY3Rpb24gcmVzZXRUcmFja2luZygpIHtcclxuICAgIGNvbnN0IGxhc3QgPSB0cmFja1N0YWNrLnBvcCgpO1xyXG4gICAgc2hvdWxkVHJhY2sgPSBsYXN0ID09PSB1bmRlZmluZWQgPyB0cnVlIDogbGFzdDtcclxufVxyXG5mdW5jdGlvbiB0cmFjayh0YXJnZXQsIHR5cGUsIGtleSkge1xyXG4gICAgaWYgKCFzaG91bGRUcmFjayB8fCBhY3RpdmVFZmZlY3QgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGxldCBkZXBzTWFwID0gdGFyZ2V0TWFwLmdldCh0YXJnZXQpO1xyXG4gICAgaWYgKCFkZXBzTWFwKSB7XHJcbiAgICAgICAgdGFyZ2V0TWFwLnNldCh0YXJnZXQsIChkZXBzTWFwID0gbmV3IE1hcCgpKSk7XHJcbiAgICB9XHJcbiAgICBsZXQgZGVwID0gZGVwc01hcC5nZXQoa2V5KTtcclxuICAgIGlmICghZGVwKSB7XHJcbiAgICAgICAgZGVwc01hcC5zZXQoa2V5LCAoZGVwID0gbmV3IFNldCgpKSk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWRlcC5oYXMoYWN0aXZlRWZmZWN0KSkge1xyXG4gICAgICAgIGRlcC5hZGQoYWN0aXZlRWZmZWN0KTtcclxuICAgICAgICBhY3RpdmVFZmZlY3QuZGVwcy5wdXNoKGRlcCk7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBhY3RpdmVFZmZlY3Qub3B0aW9ucy5vblRyYWNrKSB7XHJcbiAgICAgICAgICAgIGFjdGl2ZUVmZmVjdC5vcHRpb25zLm9uVHJhY2soe1xyXG4gICAgICAgICAgICAgICAgZWZmZWN0OiBhY3RpdmVFZmZlY3QsXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQsXHJcbiAgICAgICAgICAgICAgICB0eXBlLFxyXG4gICAgICAgICAgICAgICAga2V5XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0cmlnZ2VyKHRhcmdldCwgdHlwZSwga2V5LCBuZXdWYWx1ZSwgb2xkVmFsdWUsIG9sZFRhcmdldCkge1xyXG4gICAgY29uc3QgZGVwc01hcCA9IHRhcmdldE1hcC5nZXQodGFyZ2V0KTtcclxuICAgIGlmICghZGVwc01hcCkge1xyXG4gICAgICAgIC8vIG5ldmVyIGJlZW4gdHJhY2tlZFxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IGVmZmVjdHMgPSBuZXcgU2V0KCk7XHJcbiAgICBjb25zdCBhZGQgPSAoZWZmZWN0c1RvQWRkKSA9PiB7XHJcbiAgICAgICAgaWYgKGVmZmVjdHNUb0FkZCkge1xyXG4gICAgICAgICAgICBlZmZlY3RzVG9BZGQuZm9yRWFjaChlZmZlY3QgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVmZmVjdCAhPT0gYWN0aXZlRWZmZWN0IHx8IGVmZmVjdC5hbGxvd1JlY3Vyc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBlZmZlY3RzLmFkZChlZmZlY3QpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgaWYgKHR5cGUgPT09IFwiY2xlYXJcIiAvKiBDTEVBUiAqLykge1xyXG4gICAgICAgIC8vIGNvbGxlY3Rpb24gYmVpbmcgY2xlYXJlZFxyXG4gICAgICAgIC8vIHRyaWdnZXIgYWxsIGVmZmVjdHMgZm9yIHRhcmdldFxyXG4gICAgICAgIGRlcHNNYXAuZm9yRWFjaChhZGQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoa2V5ID09PSAnbGVuZ3RoJyAmJiBpc0FycmF5KHRhcmdldCkpIHtcclxuICAgICAgICBkZXBzTWFwLmZvckVhY2goKGRlcCwga2V5KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdsZW5ndGgnIHx8IGtleSA+PSBuZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgYWRkKGRlcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIHNjaGVkdWxlIHJ1bnMgZm9yIFNFVCB8IEFERCB8IERFTEVURVxyXG4gICAgICAgIGlmIChrZXkgIT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBhZGQoZGVwc01hcC5nZXQoa2V5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFsc28gcnVuIGZvciBpdGVyYXRpb24ga2V5IG9uIEFERCB8IERFTEVURSB8IE1hcC5TRVRcclxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBcImFkZFwiIC8qIEFERCAqLzpcclxuICAgICAgICAgICAgICAgIGlmICghaXNBcnJheSh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTWFwKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkKGRlcHNNYXAuZ2V0KE1BUF9LRVlfSVRFUkFURV9LRVkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0ludGVnZXJLZXkoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5ldyBpbmRleCBhZGRlZCB0byBhcnJheSAtPiBsZW5ndGggY2hhbmdlc1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZChkZXBzTWFwLmdldCgnbGVuZ3RoJykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJkZWxldGVcIiAvKiBERUxFVEUgKi86XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQXJyYXkodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZChkZXBzTWFwLmdldChJVEVSQVRFX0tFWSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc01hcCh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZChkZXBzTWFwLmdldChNQVBfS0VZX0lURVJBVEVfS0VZKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJzZXRcIiAvKiBTRVQgKi86XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNNYXAodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZChkZXBzTWFwLmdldChJVEVSQVRFX0tFWSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgcnVuID0gKGVmZmVjdCkgPT4ge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgZWZmZWN0Lm9wdGlvbnMub25UcmlnZ2VyKSB7XHJcbiAgICAgICAgICAgIGVmZmVjdC5vcHRpb25zLm9uVHJpZ2dlcih7XHJcbiAgICAgICAgICAgICAgICBlZmZlY3QsXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQsXHJcbiAgICAgICAgICAgICAgICBrZXksXHJcbiAgICAgICAgICAgICAgICB0eXBlLFxyXG4gICAgICAgICAgICAgICAgbmV3VmFsdWUsXHJcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZSxcclxuICAgICAgICAgICAgICAgIG9sZFRhcmdldFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVmZmVjdC5vcHRpb25zLnNjaGVkdWxlcikge1xyXG4gICAgICAgICAgICBlZmZlY3Qub3B0aW9ucy5zY2hlZHVsZXIoZWZmZWN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVmZmVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBlZmZlY3RzLmZvckVhY2gocnVuKTtcclxufVxuXG5jb25zdCBpc05vblRyYWNrYWJsZUtleXMgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoYF9fcHJvdG9fXyxfX3ZfaXNSZWYsX19pc1Z1ZWApO1xyXG5jb25zdCBidWlsdEluU3ltYm9scyA9IG5ldyBTZXQoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoU3ltYm9sKVxyXG4gICAgLm1hcChrZXkgPT4gU3ltYm9sW2tleV0pXHJcbiAgICAuZmlsdGVyKGlzU3ltYm9sKSk7XHJcbmNvbnN0IGdldCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlR2V0dGVyKCk7XHJcbmNvbnN0IHNoYWxsb3dHZXQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZUdldHRlcihmYWxzZSwgdHJ1ZSk7XHJcbmNvbnN0IHJlYWRvbmx5R2V0ID0gLyojX19QVVJFX18qLyBjcmVhdGVHZXR0ZXIodHJ1ZSk7XHJcbmNvbnN0IHNoYWxsb3dSZWFkb25seUdldCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlR2V0dGVyKHRydWUsIHRydWUpO1xyXG5jb25zdCBhcnJheUluc3RydW1lbnRhdGlvbnMgPSB7fTtcclxuWydpbmNsdWRlcycsICdpbmRleE9mJywgJ2xhc3RJbmRleE9mJ10uZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgY29uc3QgbWV0aG9kID0gQXJyYXkucHJvdG90eXBlW2tleV07XHJcbiAgICBhcnJheUluc3RydW1lbnRhdGlvbnNba2V5XSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XHJcbiAgICAgICAgY29uc3QgYXJyID0gdG9SYXcodGhpcyk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICB0cmFjayhhcnIsIFwiZ2V0XCIgLyogR0VUICovLCBpICsgJycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB3ZSBydW4gdGhlIG1ldGhvZCB1c2luZyB0aGUgb3JpZ2luYWwgYXJncyBmaXJzdCAod2hpY2ggbWF5IGJlIHJlYWN0aXZlKVxyXG4gICAgICAgIGNvbnN0IHJlcyA9IG1ldGhvZC5hcHBseShhcnIsIGFyZ3MpO1xyXG4gICAgICAgIGlmIChyZXMgPT09IC0xIHx8IHJlcyA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgLy8gaWYgdGhhdCBkaWRuJ3Qgd29yaywgcnVuIGl0IGFnYWluIHVzaW5nIHJhdyB2YWx1ZXMuXHJcbiAgICAgICAgICAgIHJldHVybiBtZXRob2QuYXBwbHkoYXJyLCBhcmdzLm1hcCh0b1JhdykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59KTtcclxuWydwdXNoJywgJ3BvcCcsICdzaGlmdCcsICd1bnNoaWZ0JywgJ3NwbGljZSddLmZvckVhY2goa2V5ID0+IHtcclxuICAgIGNvbnN0IG1ldGhvZCA9IEFycmF5LnByb3RvdHlwZVtrZXldO1xyXG4gICAgYXJyYXlJbnN0cnVtZW50YXRpb25zW2tleV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgIHBhdXNlVHJhY2tpbmcoKTtcclxuICAgICAgICBjb25zdCByZXMgPSBtZXRob2QuYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICAgICAgcmVzZXRUcmFja2luZygpO1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9O1xyXG59KTtcclxuZnVuY3Rpb24gY3JlYXRlR2V0dGVyKGlzUmVhZG9ubHkgPSBmYWxzZSwgc2hhbGxvdyA9IGZhbHNlKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcikge1xyXG4gICAgICAgIGlmIChrZXkgPT09IFwiX192X2lzUmVhY3RpdmVcIiAvKiBJU19SRUFDVElWRSAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gIWlzUmVhZG9ubHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFkb25seVwiIC8qIElTX1JFQURPTkxZICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc1JlYWRvbmx5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiX192X3Jhd1wiIC8qIFJBVyAqLyAmJlxyXG4gICAgICAgICAgICByZWNlaXZlciA9PT1cclxuICAgICAgICAgICAgICAgIChpc1JlYWRvbmx5XHJcbiAgICAgICAgICAgICAgICAgICAgPyBzaGFsbG93XHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2hhbGxvd1JlYWRvbmx5TWFwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcmVhZG9ubHlNYXBcclxuICAgICAgICAgICAgICAgICAgICA6IHNoYWxsb3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzaGFsbG93UmVhY3RpdmVNYXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiByZWFjdGl2ZU1hcCkuZ2V0KHRhcmdldCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0SXNBcnJheSA9IGlzQXJyYXkodGFyZ2V0KTtcclxuICAgICAgICBpZiAoIWlzUmVhZG9ubHkgJiYgdGFyZ2V0SXNBcnJheSAmJiBoYXNPd24oYXJyYXlJbnN0cnVtZW50YXRpb25zLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldChhcnJheUluc3RydW1lbnRhdGlvbnMsIGtleSwgcmVjZWl2ZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXMgPSBSZWZsZWN0LmdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpO1xyXG4gICAgICAgIGlmIChpc1N5bWJvbChrZXkpID8gYnVpbHRJblN5bWJvbHMuaGFzKGtleSkgOiBpc05vblRyYWNrYWJsZUtleXMoa2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzUmVhZG9ubHkpIHtcclxuICAgICAgICAgICAgdHJhY2sodGFyZ2V0LCBcImdldFwiIC8qIEdFVCAqLywga2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNoYWxsb3cpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzUmVmKHJlcykpIHtcclxuICAgICAgICAgICAgLy8gcmVmIHVud3JhcHBpbmcgLSBkb2VzIG5vdCBhcHBseSBmb3IgQXJyYXkgKyBpbnRlZ2VyIGtleS5cclxuICAgICAgICAgICAgY29uc3Qgc2hvdWxkVW53cmFwID0gIXRhcmdldElzQXJyYXkgfHwgIWlzSW50ZWdlcktleShrZXkpO1xyXG4gICAgICAgICAgICByZXR1cm4gc2hvdWxkVW53cmFwID8gcmVzLnZhbHVlIDogcmVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNPYmplY3QocmVzKSkge1xyXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHJldHVybmVkIHZhbHVlIGludG8gYSBwcm94eSBhcyB3ZWxsLiB3ZSBkbyB0aGUgaXNPYmplY3QgY2hlY2tcclxuICAgICAgICAgICAgLy8gaGVyZSB0byBhdm9pZCBpbnZhbGlkIHZhbHVlIHdhcm5pbmcuIEFsc28gbmVlZCB0byBsYXp5IGFjY2VzcyByZWFkb25seVxyXG4gICAgICAgICAgICAvLyBhbmQgcmVhY3RpdmUgaGVyZSB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmN5LlxyXG4gICAgICAgICAgICByZXR1cm4gaXNSZWFkb25seSA/IHJlYWRvbmx5KHJlcykgOiByZWFjdGl2ZShyZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfTtcclxufVxyXG5jb25zdCBzZXQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZVNldHRlcigpO1xyXG5jb25zdCBzaGFsbG93U2V0ID0gLyojX19QVVJFX18qLyBjcmVhdGVTZXR0ZXIodHJ1ZSk7XHJcbmZ1bmN0aW9uIGNyZWF0ZVNldHRlcihzaGFsbG93ID0gZmFsc2UpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiBzZXQodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcikge1xyXG4gICAgICAgIGxldCBvbGRWYWx1ZSA9IHRhcmdldFtrZXldO1xyXG4gICAgICAgIGlmICghc2hhbGxvdykge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcclxuICAgICAgICAgICAgb2xkVmFsdWUgPSB0b1JhdyhvbGRWYWx1ZSk7XHJcbiAgICAgICAgICAgIGlmICghaXNBcnJheSh0YXJnZXQpICYmIGlzUmVmKG9sZFZhbHVlKSAmJiAhaXNSZWYodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZS52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaGFkS2V5ID0gaXNBcnJheSh0YXJnZXQpICYmIGlzSW50ZWdlcktleShrZXkpXHJcbiAgICAgICAgICAgID8gTnVtYmVyKGtleSkgPCB0YXJnZXQubGVuZ3RoXHJcbiAgICAgICAgICAgIDogaGFzT3duKHRhcmdldCwga2V5KTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LnNldCh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKTtcclxuICAgICAgICAvLyBkb24ndCB0cmlnZ2VyIGlmIHRhcmdldCBpcyBzb21ldGhpbmcgdXAgaW4gdGhlIHByb3RvdHlwZSBjaGFpbiBvZiBvcmlnaW5hbFxyXG4gICAgICAgIGlmICh0YXJnZXQgPT09IHRvUmF3KHJlY2VpdmVyKSkge1xyXG4gICAgICAgICAgICBpZiAoIWhhZEtleSkge1xyXG4gICAgICAgICAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiYWRkXCIgLyogQUREICovLCBrZXksIHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChoYXNDaGFuZ2VkKHZhbHVlLCBvbGRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcInNldFwiIC8qIFNFVCAqLywga2V5LCB2YWx1ZSwgb2xkVmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KSB7XHJcbiAgICBjb25zdCBoYWRLZXkgPSBoYXNPd24odGFyZ2V0LCBrZXkpO1xyXG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0YXJnZXRba2V5XTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpO1xyXG4gICAgaWYgKHJlc3VsdCAmJiBoYWRLZXkpIHtcclxuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJkZWxldGVcIiAvKiBERUxFVEUgKi8sIGtleSwgdW5kZWZpbmVkLCBvbGRWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIGhhcyh0YXJnZXQsIGtleSkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5oYXModGFyZ2V0LCBrZXkpO1xyXG4gICAgaWYgKCFpc1N5bWJvbChrZXkpIHx8ICFidWlsdEluU3ltYm9scy5oYXMoa2V5KSkge1xyXG4gICAgICAgIHRyYWNrKHRhcmdldCwgXCJoYXNcIiAvKiBIQVMgKi8sIGtleSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIG93bktleXModGFyZ2V0KSB7XHJcbiAgICB0cmFjayh0YXJnZXQsIFwiaXRlcmF0ZVwiIC8qIElURVJBVEUgKi8sIGlzQXJyYXkodGFyZ2V0KSA/ICdsZW5ndGgnIDogSVRFUkFURV9LRVkpO1xyXG4gICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpO1xyXG59XHJcbmNvbnN0IG11dGFibGVIYW5kbGVycyA9IHtcclxuICAgIGdldCxcclxuICAgIHNldCxcclxuICAgIGRlbGV0ZVByb3BlcnR5LFxyXG4gICAgaGFzLFxyXG4gICAgb3duS2V5c1xyXG59O1xyXG5jb25zdCByZWFkb25seUhhbmRsZXJzID0ge1xyXG4gICAgZ2V0OiByZWFkb25seUdldCxcclxuICAgIHNldCh0YXJnZXQsIGtleSkge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBTZXQgb3BlcmF0aW9uIG9uIGtleSBcIiR7U3RyaW5nKGtleSl9XCIgZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCwgdGFyZ2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9LFxyXG4gICAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgRGVsZXRlIG9wZXJhdGlvbiBvbiBrZXkgXCIke1N0cmluZyhrZXkpfVwiIGZhaWxlZDogdGFyZ2V0IGlzIHJlYWRvbmx5LmAsIHRhcmdldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBzaGFsbG93UmVhY3RpdmVIYW5kbGVycyA9IGV4dGVuZCh7fSwgbXV0YWJsZUhhbmRsZXJzLCB7XHJcbiAgICBnZXQ6IHNoYWxsb3dHZXQsXHJcbiAgICBzZXQ6IHNoYWxsb3dTZXRcclxufSk7XHJcbi8vIFByb3BzIGhhbmRsZXJzIGFyZSBzcGVjaWFsIGluIHRoZSBzZW5zZSB0aGF0IGl0IHNob3VsZCBub3QgdW53cmFwIHRvcC1sZXZlbFxyXG4vLyByZWZzIChpbiBvcmRlciB0byBhbGxvdyByZWZzIHRvIGJlIGV4cGxpY2l0bHkgcGFzc2VkIGRvd24pLCBidXQgc2hvdWxkXHJcbi8vIHJldGFpbiB0aGUgcmVhY3Rpdml0eSBvZiB0aGUgbm9ybWFsIHJlYWRvbmx5IG9iamVjdC5cclxuY29uc3Qgc2hhbGxvd1JlYWRvbmx5SGFuZGxlcnMgPSBleHRlbmQoe30sIHJlYWRvbmx5SGFuZGxlcnMsIHtcclxuICAgIGdldDogc2hhbGxvd1JlYWRvbmx5R2V0XHJcbn0pO1xuXG5jb25zdCB0b1JlYWN0aXZlID0gKHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgPyByZWFjdGl2ZSh2YWx1ZSkgOiB2YWx1ZTtcclxuY29uc3QgdG9SZWFkb25seSA9ICh2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpID8gcmVhZG9ubHkodmFsdWUpIDogdmFsdWU7XHJcbmNvbnN0IHRvU2hhbGxvdyA9ICh2YWx1ZSkgPT4gdmFsdWU7XHJcbmNvbnN0IGdldFByb3RvID0gKHYpID0+IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2Yodik7XHJcbmZ1bmN0aW9uIGdldCQxKHRhcmdldCwga2V5LCBpc1JlYWRvbmx5ID0gZmFsc2UsIGlzU2hhbGxvdyA9IGZhbHNlKSB7XHJcbiAgICAvLyAjMTc3MjogcmVhZG9ubHkocmVhY3RpdmUoTWFwKSkgc2hvdWxkIHJldHVybiByZWFkb25seSArIHJlYWN0aXZlIHZlcnNpb25cclxuICAgIC8vIG9mIHRoZSB2YWx1ZVxyXG4gICAgdGFyZ2V0ID0gdGFyZ2V0W1wiX192X3Jhd1wiIC8qIFJBVyAqL107XHJcbiAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xyXG4gICAgY29uc3QgcmF3S2V5ID0gdG9SYXcoa2V5KTtcclxuICAgIGlmIChrZXkgIT09IHJhd0tleSkge1xyXG4gICAgICAgICFpc1JlYWRvbmx5ICYmIHRyYWNrKHJhd1RhcmdldCwgXCJnZXRcIiAvKiBHRVQgKi8sIGtleSk7XHJcbiAgICB9XHJcbiAgICAhaXNSZWFkb25seSAmJiB0cmFjayhyYXdUYXJnZXQsIFwiZ2V0XCIgLyogR0VUICovLCByYXdLZXkpO1xyXG4gICAgY29uc3QgeyBoYXMgfSA9IGdldFByb3RvKHJhd1RhcmdldCk7XHJcbiAgICBjb25zdCB3cmFwID0gaXNTaGFsbG93ID8gdG9TaGFsbG93IDogaXNSZWFkb25seSA/IHRvUmVhZG9ubHkgOiB0b1JlYWN0aXZlO1xyXG4gICAgaWYgKGhhcy5jYWxsKHJhd1RhcmdldCwga2V5KSkge1xyXG4gICAgICAgIHJldHVybiB3cmFwKHRhcmdldC5nZXQoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChoYXMuY2FsbChyYXdUYXJnZXQsIHJhd0tleSkpIHtcclxuICAgICAgICByZXR1cm4gd3JhcCh0YXJnZXQuZ2V0KHJhd0tleSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodGFyZ2V0ICE9PSByYXdUYXJnZXQpIHtcclxuICAgICAgICAvLyAjMzYwMiByZWFkb25seShyZWFjdGl2ZShNYXApKVxyXG4gICAgICAgIC8vIGVuc3VyZSB0aGF0IHRoZSBuZXN0ZWQgcmVhY3RpdmUgYE1hcGAgY2FuIGRvIHRyYWNraW5nIGZvciBpdHNlbGZcclxuICAgICAgICB0YXJnZXQuZ2V0KGtleSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaGFzJDEoa2V5LCBpc1JlYWRvbmx5ID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IHRhcmdldCA9IHRoaXNbXCJfX3ZfcmF3XCIgLyogUkFXICovXTtcclxuICAgIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XHJcbiAgICBjb25zdCByYXdLZXkgPSB0b1JhdyhrZXkpO1xyXG4gICAgaWYgKGtleSAhPT0gcmF3S2V5KSB7XHJcbiAgICAgICAgIWlzUmVhZG9ubHkgJiYgdHJhY2socmF3VGFyZ2V0LCBcImhhc1wiIC8qIEhBUyAqLywga2V5KTtcclxuICAgIH1cclxuICAgICFpc1JlYWRvbmx5ICYmIHRyYWNrKHJhd1RhcmdldCwgXCJoYXNcIiAvKiBIQVMgKi8sIHJhd0tleSk7XHJcbiAgICByZXR1cm4ga2V5ID09PSByYXdLZXlcclxuICAgICAgICA/IHRhcmdldC5oYXMoa2V5KVxyXG4gICAgICAgIDogdGFyZ2V0LmhhcyhrZXkpIHx8IHRhcmdldC5oYXMocmF3S2V5KTtcclxufVxyXG5mdW5jdGlvbiBzaXplKHRhcmdldCwgaXNSZWFkb25seSA9IGZhbHNlKSB7XHJcbiAgICB0YXJnZXQgPSB0YXJnZXRbXCJfX3ZfcmF3XCIgLyogUkFXICovXTtcclxuICAgICFpc1JlYWRvbmx5ICYmIHRyYWNrKHRvUmF3KHRhcmdldCksIFwiaXRlcmF0ZVwiIC8qIElURVJBVEUgKi8sIElURVJBVEVfS0VZKTtcclxuICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsICdzaXplJywgdGFyZ2V0KTtcclxufVxyXG5mdW5jdGlvbiBhZGQodmFsdWUpIHtcclxuICAgIHZhbHVlID0gdG9SYXcodmFsdWUpO1xyXG4gICAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XHJcbiAgICBjb25zdCBwcm90byA9IGdldFByb3RvKHRhcmdldCk7XHJcbiAgICBjb25zdCBoYWRLZXkgPSBwcm90by5oYXMuY2FsbCh0YXJnZXQsIHZhbHVlKTtcclxuICAgIGlmICghaGFkS2V5KSB7XHJcbiAgICAgICAgdGFyZ2V0LmFkZCh2YWx1ZSk7XHJcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiYWRkXCIgLyogQUREICovLCB2YWx1ZSwgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuZnVuY3Rpb24gc2V0JDEoa2V5LCB2YWx1ZSkge1xyXG4gICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XHJcbiAgICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcclxuICAgIGNvbnN0IHsgaGFzLCBnZXQgfSA9IGdldFByb3RvKHRhcmdldCk7XHJcbiAgICBsZXQgaGFkS2V5ID0gaGFzLmNhbGwodGFyZ2V0LCBrZXkpO1xyXG4gICAgaWYgKCFoYWRLZXkpIHtcclxuICAgICAgICBrZXkgPSB0b1JhdyhrZXkpO1xyXG4gICAgICAgIGhhZEtleSA9IGhhcy5jYWxsKHRhcmdldCwga2V5KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGNoZWNrSWRlbnRpdHlLZXlzKHRhcmdldCwgaGFzLCBrZXkpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb2xkVmFsdWUgPSBnZXQuY2FsbCh0YXJnZXQsIGtleSk7XHJcbiAgICB0YXJnZXQuc2V0KGtleSwgdmFsdWUpO1xyXG4gICAgaWYgKCFoYWRLZXkpIHtcclxuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJhZGRcIiAvKiBBREQgKi8sIGtleSwgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaGFzQ2hhbmdlZCh2YWx1ZSwgb2xkVmFsdWUpKSB7XHJcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwic2V0XCIgLyogU0VUICovLCBrZXksIHZhbHVlLCBvbGRWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5mdW5jdGlvbiBkZWxldGVFbnRyeShrZXkpIHtcclxuICAgIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xyXG4gICAgY29uc3QgeyBoYXMsIGdldCB9ID0gZ2V0UHJvdG8odGFyZ2V0KTtcclxuICAgIGxldCBoYWRLZXkgPSBoYXMuY2FsbCh0YXJnZXQsIGtleSk7XHJcbiAgICBpZiAoIWhhZEtleSkge1xyXG4gICAgICAgIGtleSA9IHRvUmF3KGtleSk7XHJcbiAgICAgICAgaGFkS2V5ID0gaGFzLmNhbGwodGFyZ2V0LCBrZXkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMsIGtleSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBvbGRWYWx1ZSA9IGdldCA/IGdldC5jYWxsKHRhcmdldCwga2V5KSA6IHVuZGVmaW5lZDtcclxuICAgIC8vIGZvcndhcmQgdGhlIG9wZXJhdGlvbiBiZWZvcmUgcXVldWVpbmcgcmVhY3Rpb25zXHJcbiAgICBjb25zdCByZXN1bHQgPSB0YXJnZXQuZGVsZXRlKGtleSk7XHJcbiAgICBpZiAoaGFkS2V5KSB7XHJcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiZGVsZXRlXCIgLyogREVMRVRFICovLCBrZXksIHVuZGVmaW5lZCwgb2xkVmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBjbGVhcigpIHtcclxuICAgIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xyXG4gICAgY29uc3QgaGFkSXRlbXMgPSB0YXJnZXQuc2l6ZSAhPT0gMDtcclxuICAgIGNvbnN0IG9sZFRhcmdldCA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgICAgID8gaXNNYXAodGFyZ2V0KVxyXG4gICAgICAgICAgICA/IG5ldyBNYXAodGFyZ2V0KVxyXG4gICAgICAgICAgICA6IG5ldyBTZXQodGFyZ2V0KVxyXG4gICAgICAgIDogdW5kZWZpbmVkO1xyXG4gICAgLy8gZm9yd2FyZCB0aGUgb3BlcmF0aW9uIGJlZm9yZSBxdWV1ZWluZyByZWFjdGlvbnNcclxuICAgIGNvbnN0IHJlc3VsdCA9IHRhcmdldC5jbGVhcigpO1xyXG4gICAgaWYgKGhhZEl0ZW1zKSB7XHJcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiY2xlYXJcIiAvKiBDTEVBUiAqLywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG9sZFRhcmdldCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUZvckVhY2goaXNSZWFkb25seSwgaXNTaGFsbG93KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZykge1xyXG4gICAgICAgIGNvbnN0IG9ic2VydmVkID0gdGhpcztcclxuICAgICAgICBjb25zdCB0YXJnZXQgPSBvYnNlcnZlZFtcIl9fdl9yYXdcIiAvKiBSQVcgKi9dO1xyXG4gICAgICAgIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XHJcbiAgICAgICAgY29uc3Qgd3JhcCA9IGlzU2hhbGxvdyA/IHRvU2hhbGxvdyA6IGlzUmVhZG9ubHkgPyB0b1JlYWRvbmx5IDogdG9SZWFjdGl2ZTtcclxuICAgICAgICAhaXNSZWFkb25seSAmJiB0cmFjayhyYXdUYXJnZXQsIFwiaXRlcmF0ZVwiIC8qIElURVJBVEUgKi8sIElURVJBVEVfS0VZKTtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0LmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcclxuICAgICAgICAgICAgLy8gaW1wb3J0YW50OiBtYWtlIHN1cmUgdGhlIGNhbGxiYWNrIGlzXHJcbiAgICAgICAgICAgIC8vIDEuIGludm9rZWQgd2l0aCB0aGUgcmVhY3RpdmUgbWFwIGFzIGB0aGlzYCBhbmQgM3JkIGFyZ1xyXG4gICAgICAgICAgICAvLyAyLiB0aGUgdmFsdWUgcmVjZWl2ZWQgc2hvdWxkIGJlIGEgY29ycmVzcG9uZGluZyByZWFjdGl2ZS9yZWFkb25seS5cclxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgd3JhcCh2YWx1ZSksIHdyYXAoa2V5KSwgb2JzZXJ2ZWQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIGlzUmVhZG9ubHksIGlzU2hhbGxvdykge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpc1tcIl9fdl9yYXdcIiAvKiBSQVcgKi9dO1xyXG4gICAgICAgIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0SXNNYXAgPSBpc01hcChyYXdUYXJnZXQpO1xyXG4gICAgICAgIGNvbnN0IGlzUGFpciA9IG1ldGhvZCA9PT0gJ2VudHJpZXMnIHx8IChtZXRob2QgPT09IFN5bWJvbC5pdGVyYXRvciAmJiB0YXJnZXRJc01hcCk7XHJcbiAgICAgICAgY29uc3QgaXNLZXlPbmx5ID0gbWV0aG9kID09PSAna2V5cycgJiYgdGFyZ2V0SXNNYXA7XHJcbiAgICAgICAgY29uc3QgaW5uZXJJdGVyYXRvciA9IHRhcmdldFttZXRob2RdKC4uLmFyZ3MpO1xyXG4gICAgICAgIGNvbnN0IHdyYXAgPSBpc1NoYWxsb3cgPyB0b1NoYWxsb3cgOiBpc1JlYWRvbmx5ID8gdG9SZWFkb25seSA6IHRvUmVhY3RpdmU7XHJcbiAgICAgICAgIWlzUmVhZG9ubHkgJiZcclxuICAgICAgICAgICAgdHJhY2socmF3VGFyZ2V0LCBcIml0ZXJhdGVcIiAvKiBJVEVSQVRFICovLCBpc0tleU9ubHkgPyBNQVBfS0VZX0lURVJBVEVfS0VZIDogSVRFUkFURV9LRVkpO1xyXG4gICAgICAgIC8vIHJldHVybiBhIHdyYXBwZWQgaXRlcmF0b3Igd2hpY2ggcmV0dXJucyBvYnNlcnZlZCB2ZXJzaW9ucyBvZiB0aGVcclxuICAgICAgICAvLyB2YWx1ZXMgZW1pdHRlZCBmcm9tIHRoZSByZWFsIGl0ZXJhdG9yXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLy8gaXRlcmF0b3IgcHJvdG9jb2xcclxuICAgICAgICAgICAgbmV4dCgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGlubmVySXRlcmF0b3IubmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbmVcclxuICAgICAgICAgICAgICAgICAgICA/IHsgdmFsdWUsIGRvbmUgfVxyXG4gICAgICAgICAgICAgICAgICAgIDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaXNQYWlyID8gW3dyYXAodmFsdWVbMF0pLCB3cmFwKHZhbHVlWzFdKV0gOiB3cmFwKHZhbHVlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8vIGl0ZXJhYmxlIHByb3RvY29sXHJcbiAgICAgICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVSZWFkb25seU1ldGhvZCh0eXBlKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGFyZ3NbMF0gPyBgb24ga2V5IFwiJHthcmdzWzBdfVwiIGAgOiBgYDtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGAke2NhcGl0YWxpemUodHlwZSl9IG9wZXJhdGlvbiAke2tleX1mYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLCB0b1Jhdyh0aGlzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0eXBlID09PSBcImRlbGV0ZVwiIC8qIERFTEVURSAqLyA/IGZhbHNlIDogdGhpcztcclxuICAgIH07XHJcbn1cclxuY29uc3QgbXV0YWJsZUluc3RydW1lbnRhdGlvbnMgPSB7XHJcbiAgICBnZXQoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIGdldCQxKHRoaXMsIGtleSk7XHJcbiAgICB9LFxyXG4gICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHNpemUodGhpcyk7XHJcbiAgICB9LFxyXG4gICAgaGFzOiBoYXMkMSxcclxuICAgIGFkZCxcclxuICAgIHNldDogc2V0JDEsXHJcbiAgICBkZWxldGU6IGRlbGV0ZUVudHJ5LFxyXG4gICAgY2xlYXIsXHJcbiAgICBmb3JFYWNoOiBjcmVhdGVGb3JFYWNoKGZhbHNlLCBmYWxzZSlcclxufTtcclxuY29uc3Qgc2hhbGxvd0luc3RydW1lbnRhdGlvbnMgPSB7XHJcbiAgICBnZXQoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIGdldCQxKHRoaXMsIGtleSwgZmFsc2UsIHRydWUpO1xyXG4gICAgfSxcclxuICAgIGdldCBzaXplKCkge1xyXG4gICAgICAgIHJldHVybiBzaXplKHRoaXMpO1xyXG4gICAgfSxcclxuICAgIGhhczogaGFzJDEsXHJcbiAgICBhZGQsXHJcbiAgICBzZXQ6IHNldCQxLFxyXG4gICAgZGVsZXRlOiBkZWxldGVFbnRyeSxcclxuICAgIGNsZWFyLFxyXG4gICAgZm9yRWFjaDogY3JlYXRlRm9yRWFjaChmYWxzZSwgdHJ1ZSlcclxufTtcclxuY29uc3QgcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zID0ge1xyXG4gICAgZ2V0KGtleSkge1xyXG4gICAgICAgIHJldHVybiBnZXQkMSh0aGlzLCBrZXksIHRydWUpO1xyXG4gICAgfSxcclxuICAgIGdldCBzaXplKCkge1xyXG4gICAgICAgIHJldHVybiBzaXplKHRoaXMsIHRydWUpO1xyXG4gICAgfSxcclxuICAgIGhhcyhrZXkpIHtcclxuICAgICAgICByZXR1cm4gaGFzJDEuY2FsbCh0aGlzLCBrZXksIHRydWUpO1xyXG4gICAgfSxcclxuICAgIGFkZDogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJhZGRcIiAvKiBBREQgKi8pLFxyXG4gICAgc2V0OiBjcmVhdGVSZWFkb25seU1ldGhvZChcInNldFwiIC8qIFNFVCAqLyksXHJcbiAgICBkZWxldGU6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiZGVsZXRlXCIgLyogREVMRVRFICovKSxcclxuICAgIGNsZWFyOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImNsZWFyXCIgLyogQ0xFQVIgKi8pLFxyXG4gICAgZm9yRWFjaDogY3JlYXRlRm9yRWFjaCh0cnVlLCBmYWxzZSlcclxufTtcclxuY29uc3Qgc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9ucyA9IHtcclxuICAgIGdldChrZXkpIHtcclxuICAgICAgICByZXR1cm4gZ2V0JDEodGhpcywga2V5LCB0cnVlLCB0cnVlKTtcclxuICAgIH0sXHJcbiAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gc2l6ZSh0aGlzLCB0cnVlKTtcclxuICAgIH0sXHJcbiAgICBoYXMoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIGhhcyQxLmNhbGwodGhpcywga2V5LCB0cnVlKTtcclxuICAgIH0sXHJcbiAgICBhZGQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiYWRkXCIgLyogQUREICovKSxcclxuICAgIHNldDogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJzZXRcIiAvKiBTRVQgKi8pLFxyXG4gICAgZGVsZXRlOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImRlbGV0ZVwiIC8qIERFTEVURSAqLyksXHJcbiAgICBjbGVhcjogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJjbGVhclwiIC8qIENMRUFSICovKSxcclxuICAgIGZvckVhY2g6IGNyZWF0ZUZvckVhY2godHJ1ZSwgdHJ1ZSlcclxufTtcclxuY29uc3QgaXRlcmF0b3JNZXRob2RzID0gWydrZXlzJywgJ3ZhbHVlcycsICdlbnRyaWVzJywgU3ltYm9sLml0ZXJhdG9yXTtcclxuaXRlcmF0b3JNZXRob2RzLmZvckVhY2gobWV0aG9kID0+IHtcclxuICAgIG11dGFibGVJbnN0cnVtZW50YXRpb25zW21ldGhvZF0gPSBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIGZhbHNlLCBmYWxzZSk7XHJcbiAgICByZWFkb25seUluc3RydW1lbnRhdGlvbnNbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgc2hhbGxvd0luc3RydW1lbnRhdGlvbnNbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgZmFsc2UsIHRydWUpO1xyXG4gICAgc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9uc1ttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCB0cnVlLCB0cnVlKTtcclxufSk7XHJcbmZ1bmN0aW9uIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihpc1JlYWRvbmx5LCBzaGFsbG93KSB7XHJcbiAgICBjb25zdCBpbnN0cnVtZW50YXRpb25zID0gc2hhbGxvd1xyXG4gICAgICAgID8gaXNSZWFkb25seVxyXG4gICAgICAgICAgICA/IHNoYWxsb3dSZWFkb25seUluc3RydW1lbnRhdGlvbnNcclxuICAgICAgICAgICAgOiBzaGFsbG93SW5zdHJ1bWVudGF0aW9uc1xyXG4gICAgICAgIDogaXNSZWFkb25seVxyXG4gICAgICAgICAgICA/IHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9uc1xyXG4gICAgICAgICAgICA6IG11dGFibGVJbnN0cnVtZW50YXRpb25zO1xyXG4gICAgcmV0dXJuICh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpID0+IHtcclxuICAgICAgICBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWN0aXZlXCIgLyogSVNfUkVBQ1RJVkUgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuICFpc1JlYWRvbmx5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiX192X2lzUmVhZG9ubHlcIiAvKiBJU19SRUFET05MWSAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNSZWFkb25seTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9yYXdcIiAvKiBSQVcgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KGhhc093bihpbnN0cnVtZW50YXRpb25zLCBrZXkpICYmIGtleSBpbiB0YXJnZXRcclxuICAgICAgICAgICAgPyBpbnN0cnVtZW50YXRpb25zXHJcbiAgICAgICAgICAgIDogdGFyZ2V0LCBrZXksIHJlY2VpdmVyKTtcclxuICAgIH07XHJcbn1cclxuY29uc3QgbXV0YWJsZUNvbGxlY3Rpb25IYW5kbGVycyA9IHtcclxuICAgIGdldDogY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKGZhbHNlLCBmYWxzZSlcclxufTtcclxuY29uc3Qgc2hhbGxvd0NvbGxlY3Rpb25IYW5kbGVycyA9IHtcclxuICAgIGdldDogY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKGZhbHNlLCB0cnVlKVxyXG59O1xyXG5jb25zdCByZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycyA9IHtcclxuICAgIGdldDogY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKHRydWUsIGZhbHNlKVxyXG59O1xyXG5jb25zdCBzaGFsbG93UmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XHJcbiAgICBnZXQ6IGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcih0cnVlLCB0cnVlKVxyXG59O1xyXG5mdW5jdGlvbiBjaGVja0lkZW50aXR5S2V5cyh0YXJnZXQsIGhhcywga2V5KSB7XHJcbiAgICBjb25zdCByYXdLZXkgPSB0b1JhdyhrZXkpO1xyXG4gICAgaWYgKHJhd0tleSAhPT0ga2V5ICYmIGhhcy5jYWxsKHRhcmdldCwgcmF3S2V5KSkge1xyXG4gICAgICAgIGNvbnN0IHR5cGUgPSB0b1Jhd1R5cGUodGFyZ2V0KTtcclxuICAgICAgICBjb25zb2xlLndhcm4oYFJlYWN0aXZlICR7dHlwZX0gY29udGFpbnMgYm90aCB0aGUgcmF3IGFuZCByZWFjdGl2ZSBgICtcclxuICAgICAgICAgICAgYHZlcnNpb25zIG9mIHRoZSBzYW1lIG9iamVjdCR7dHlwZSA9PT0gYE1hcGAgPyBgIGFzIGtleXNgIDogYGB9LCBgICtcclxuICAgICAgICAgICAgYHdoaWNoIGNhbiBsZWFkIHRvIGluY29uc2lzdGVuY2llcy4gYCArXHJcbiAgICAgICAgICAgIGBBdm9pZCBkaWZmZXJlbnRpYXRpbmcgYmV0d2VlbiB0aGUgcmF3IGFuZCByZWFjdGl2ZSB2ZXJzaW9ucyBgICtcclxuICAgICAgICAgICAgYG9mIGFuIG9iamVjdCBhbmQgb25seSB1c2UgdGhlIHJlYWN0aXZlIHZlcnNpb24gaWYgcG9zc2libGUuYCk7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgcmVhY3RpdmVNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG5jb25zdCBzaGFsbG93UmVhY3RpdmVNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG5jb25zdCByZWFkb25seU1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbmNvbnN0IHNoYWxsb3dSZWFkb25seU1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbmZ1bmN0aW9uIHRhcmdldFR5cGVNYXAocmF3VHlwZSkge1xyXG4gICAgc3dpdGNoIChyYXdUeXBlKSB7XHJcbiAgICAgICAgY2FzZSAnT2JqZWN0JzpcclxuICAgICAgICBjYXNlICdBcnJheSc6XHJcbiAgICAgICAgICAgIHJldHVybiAxIC8qIENPTU1PTiAqLztcclxuICAgICAgICBjYXNlICdNYXAnOlxyXG4gICAgICAgIGNhc2UgJ1NldCc6XHJcbiAgICAgICAgY2FzZSAnV2Vha01hcCc6XHJcbiAgICAgICAgY2FzZSAnV2Vha1NldCc6XHJcbiAgICAgICAgICAgIHJldHVybiAyIC8qIENPTExFQ1RJT04gKi87XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIDAgLyogSU5WQUxJRCAqLztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRUYXJnZXRUeXBlKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWVbXCJfX3Zfc2tpcFwiIC8qIFNLSVAgKi9dIHx8ICFPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKVxyXG4gICAgICAgID8gMCAvKiBJTlZBTElEICovXHJcbiAgICAgICAgOiB0YXJnZXRUeXBlTWFwKHRvUmF3VHlwZSh2YWx1ZSkpO1xyXG59XHJcbmZ1bmN0aW9uIHJlYWN0aXZlKHRhcmdldCkge1xyXG4gICAgLy8gaWYgdHJ5aW5nIHRvIG9ic2VydmUgYSByZWFkb25seSBwcm94eSwgcmV0dXJuIHRoZSByZWFkb25seSB2ZXJzaW9uLlxyXG4gICAgaWYgKHRhcmdldCAmJiB0YXJnZXRbXCJfX3ZfaXNSZWFkb25seVwiIC8qIElTX1JFQURPTkxZICovXSkge1xyXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QodGFyZ2V0LCBmYWxzZSwgbXV0YWJsZUhhbmRsZXJzLCBtdXRhYmxlQ29sbGVjdGlvbkhhbmRsZXJzLCByZWFjdGl2ZU1hcCk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybiBhIHNoYWxsb3dseS1yZWFjdGl2ZSBjb3B5IG9mIHRoZSBvcmlnaW5hbCBvYmplY3QsIHdoZXJlIG9ubHkgdGhlIHJvb3RcclxuICogbGV2ZWwgcHJvcGVydGllcyBhcmUgcmVhY3RpdmUuIEl0IGFsc28gZG9lcyBub3QgYXV0by11bndyYXAgcmVmcyAoZXZlbiBhdCB0aGVcclxuICogcm9vdCBsZXZlbCkuXHJcbiAqL1xyXG5mdW5jdGlvbiBzaGFsbG93UmVhY3RpdmUodGFyZ2V0KSB7XHJcbiAgICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QodGFyZ2V0LCBmYWxzZSwgc2hhbGxvd1JlYWN0aXZlSGFuZGxlcnMsIHNoYWxsb3dDb2xsZWN0aW9uSGFuZGxlcnMsIHNoYWxsb3dSZWFjdGl2ZU1hcCk7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSByZWFkb25seSBjb3B5IG9mIHRoZSBvcmlnaW5hbCBvYmplY3QuIE5vdGUgdGhlIHJldHVybmVkIGNvcHkgaXMgbm90XHJcbiAqIG1hZGUgcmVhY3RpdmUsIGJ1dCBgcmVhZG9ubHlgIGNhbiBiZSBjYWxsZWQgb24gYW4gYWxyZWFkeSByZWFjdGl2ZSBvYmplY3QuXHJcbiAqL1xyXG5mdW5jdGlvbiByZWFkb25seSh0YXJnZXQpIHtcclxuICAgIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdCh0YXJnZXQsIHRydWUsIHJlYWRvbmx5SGFuZGxlcnMsIHJlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzLCByZWFkb25seU1hcCk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSByZWFjdGl2ZS1jb3B5IG9mIHRoZSBvcmlnaW5hbCBvYmplY3QsIHdoZXJlIG9ubHkgdGhlIHJvb3QgbGV2ZWxcclxuICogcHJvcGVydGllcyBhcmUgcmVhZG9ubHksIGFuZCBkb2VzIE5PVCB1bndyYXAgcmVmcyBub3IgcmVjdXJzaXZlbHkgY29udmVydFxyXG4gKiByZXR1cm5lZCBwcm9wZXJ0aWVzLlxyXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGNyZWF0aW5nIHRoZSBwcm9wcyBwcm94eSBvYmplY3QgZm9yIHN0YXRlZnVsIGNvbXBvbmVudHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBzaGFsbG93UmVhZG9ubHkodGFyZ2V0KSB7XHJcbiAgICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QodGFyZ2V0LCB0cnVlLCBzaGFsbG93UmVhZG9ubHlIYW5kbGVycywgc2hhbGxvd1JlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzLCBzaGFsbG93UmVhZG9ubHlNYXApO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgaXNSZWFkb25seSwgYmFzZUhhbmRsZXJzLCBjb2xsZWN0aW9uSGFuZGxlcnMsIHByb3h5TWFwKSB7XHJcbiAgICBpZiAoIWlzT2JqZWN0KHRhcmdldCkpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgdmFsdWUgY2Fubm90IGJlIG1hZGUgcmVhY3RpdmU6ICR7U3RyaW5nKHRhcmdldCl9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICAvLyB0YXJnZXQgaXMgYWxyZWFkeSBhIFByb3h5LCByZXR1cm4gaXQuXHJcbiAgICAvLyBleGNlcHRpb246IGNhbGxpbmcgcmVhZG9ubHkoKSBvbiBhIHJlYWN0aXZlIG9iamVjdFxyXG4gICAgaWYgKHRhcmdldFtcIl9fdl9yYXdcIiAvKiBSQVcgKi9dICYmXHJcbiAgICAgICAgIShpc1JlYWRvbmx5ICYmIHRhcmdldFtcIl9fdl9pc1JlYWN0aXZlXCIgLyogSVNfUkVBQ1RJVkUgKi9dKSkge1xyXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICAvLyB0YXJnZXQgYWxyZWFkeSBoYXMgY29ycmVzcG9uZGluZyBQcm94eVxyXG4gICAgY29uc3QgZXhpc3RpbmdQcm94eSA9IHByb3h5TWFwLmdldCh0YXJnZXQpO1xyXG4gICAgaWYgKGV4aXN0aW5nUHJveHkpIHtcclxuICAgICAgICByZXR1cm4gZXhpc3RpbmdQcm94eTtcclxuICAgIH1cclxuICAgIC8vIG9ubHkgYSB3aGl0ZWxpc3Qgb2YgdmFsdWUgdHlwZXMgY2FuIGJlIG9ic2VydmVkLlxyXG4gICAgY29uc3QgdGFyZ2V0VHlwZSA9IGdldFRhcmdldFR5cGUodGFyZ2V0KTtcclxuICAgIGlmICh0YXJnZXRUeXBlID09PSAwIC8qIElOVkFMSUQgKi8pIHtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkodGFyZ2V0LCB0YXJnZXRUeXBlID09PSAyIC8qIENPTExFQ1RJT04gKi8gPyBjb2xsZWN0aW9uSGFuZGxlcnMgOiBiYXNlSGFuZGxlcnMpO1xyXG4gICAgcHJveHlNYXAuc2V0KHRhcmdldCwgcHJveHkpO1xyXG4gICAgcmV0dXJuIHByb3h5O1xyXG59XHJcbmZ1bmN0aW9uIGlzUmVhY3RpdmUodmFsdWUpIHtcclxuICAgIGlmIChpc1JlYWRvbmx5KHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiBpc1JlYWN0aXZlKHZhbHVlW1wiX192X3Jhd1wiIC8qIFJBVyAqL10pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlW1wiX192X2lzUmVhY3RpdmVcIiAvKiBJU19SRUFDVElWRSAqL10pO1xyXG59XHJcbmZ1bmN0aW9uIGlzUmVhZG9ubHkodmFsdWUpIHtcclxuICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZVtcIl9fdl9pc1JlYWRvbmx5XCIgLyogSVNfUkVBRE9OTFkgKi9dKTtcclxufVxyXG5mdW5jdGlvbiBpc1Byb3h5KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gaXNSZWFjdGl2ZSh2YWx1ZSkgfHwgaXNSZWFkb25seSh2YWx1ZSk7XHJcbn1cclxuZnVuY3Rpb24gdG9SYXcob2JzZXJ2ZWQpIHtcclxuICAgIHJldHVybiAoKG9ic2VydmVkICYmIHRvUmF3KG9ic2VydmVkW1wiX192X3Jhd1wiIC8qIFJBVyAqL10pKSB8fCBvYnNlcnZlZCk7XHJcbn1cclxuZnVuY3Rpb24gbWFya1Jhdyh2YWx1ZSkge1xyXG4gICAgZGVmKHZhbHVlLCBcIl9fdl9za2lwXCIgLyogU0tJUCAqLywgdHJ1ZSk7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cblxuY29uc3QgY29udmVydCA9ICh2YWwpID0+IGlzT2JqZWN0KHZhbCkgPyByZWFjdGl2ZSh2YWwpIDogdmFsO1xyXG5mdW5jdGlvbiBpc1JlZihyKSB7XHJcbiAgICByZXR1cm4gQm9vbGVhbihyICYmIHIuX192X2lzUmVmID09PSB0cnVlKTtcclxufVxyXG5mdW5jdGlvbiByZWYodmFsdWUpIHtcclxuICAgIHJldHVybiBjcmVhdGVSZWYodmFsdWUpO1xyXG59XHJcbmZ1bmN0aW9uIHNoYWxsb3dSZWYodmFsdWUpIHtcclxuICAgIHJldHVybiBjcmVhdGVSZWYodmFsdWUsIHRydWUpO1xyXG59XHJcbmNsYXNzIFJlZkltcGwge1xyXG4gICAgY29uc3RydWN0b3IoX3Jhd1ZhbHVlLCBfc2hhbGxvdyA9IGZhbHNlKSB7XHJcbiAgICAgICAgdGhpcy5fcmF3VmFsdWUgPSBfcmF3VmFsdWU7XHJcbiAgICAgICAgdGhpcy5fc2hhbGxvdyA9IF9zaGFsbG93O1xyXG4gICAgICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl92YWx1ZSA9IF9zaGFsbG93ID8gX3Jhd1ZhbHVlIDogY29udmVydChfcmF3VmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHZhbHVlKCkge1xyXG4gICAgICAgIHRyYWNrKHRvUmF3KHRoaXMpLCBcImdldFwiIC8qIEdFVCAqLywgJ3ZhbHVlJyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xyXG4gICAgfVxyXG4gICAgc2V0IHZhbHVlKG5ld1ZhbCkge1xyXG4gICAgICAgIGlmIChoYXNDaGFuZ2VkKHRvUmF3KG5ld1ZhbCksIHRoaXMuX3Jhd1ZhbHVlKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9yYXdWYWx1ZSA9IG5ld1ZhbDtcclxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB0aGlzLl9zaGFsbG93ID8gbmV3VmFsIDogY29udmVydChuZXdWYWwpO1xyXG4gICAgICAgICAgICB0cmlnZ2VyKHRvUmF3KHRoaXMpLCBcInNldFwiIC8qIFNFVCAqLywgJ3ZhbHVlJywgbmV3VmFsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUmVmKHJhd1ZhbHVlLCBzaGFsbG93ID0gZmFsc2UpIHtcclxuICAgIGlmIChpc1JlZihyYXdWYWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gcmF3VmFsdWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFJlZkltcGwocmF3VmFsdWUsIHNoYWxsb3cpO1xyXG59XHJcbmZ1bmN0aW9uIHRyaWdnZXJSZWYocmVmKSB7XHJcbiAgICB0cmlnZ2VyKHRvUmF3KHJlZiksIFwic2V0XCIgLyogU0VUICovLCAndmFsdWUnLCAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyByZWYudmFsdWUgOiB2b2lkIDApO1xyXG59XHJcbmZ1bmN0aW9uIHVucmVmKHJlZikge1xyXG4gICAgcmV0dXJuIGlzUmVmKHJlZikgPyByZWYudmFsdWUgOiByZWY7XHJcbn1cclxuY29uc3Qgc2hhbGxvd1Vud3JhcEhhbmRsZXJzID0ge1xyXG4gICAgZ2V0OiAodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSA9PiB1bnJlZihSZWZsZWN0LmdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpKSxcclxuICAgIHNldDogKHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpID0+IHtcclxuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHRhcmdldFtrZXldO1xyXG4gICAgICAgIGlmIChpc1JlZihvbGRWYWx1ZSkgJiYgIWlzUmVmKHZhbHVlKSkge1xyXG4gICAgICAgICAgICBvbGRWYWx1ZS52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LnNldCh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIHByb3h5UmVmcyhvYmplY3RXaXRoUmVmcykge1xyXG4gICAgcmV0dXJuIGlzUmVhY3RpdmUob2JqZWN0V2l0aFJlZnMpXHJcbiAgICAgICAgPyBvYmplY3RXaXRoUmVmc1xyXG4gICAgICAgIDogbmV3IFByb3h5KG9iamVjdFdpdGhSZWZzLCBzaGFsbG93VW53cmFwSGFuZGxlcnMpO1xyXG59XHJcbmNsYXNzIEN1c3RvbVJlZkltcGwge1xyXG4gICAgY29uc3RydWN0b3IoZmFjdG9yeSkge1xyXG4gICAgICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcclxuICAgICAgICBjb25zdCB7IGdldCwgc2V0IH0gPSBmYWN0b3J5KCgpID0+IHRyYWNrKHRoaXMsIFwiZ2V0XCIgLyogR0VUICovLCAndmFsdWUnKSwgKCkgPT4gdHJpZ2dlcih0aGlzLCBcInNldFwiIC8qIFNFVCAqLywgJ3ZhbHVlJykpO1xyXG4gICAgICAgIHRoaXMuX2dldCA9IGdldDtcclxuICAgICAgICB0aGlzLl9zZXQgPSBzZXQ7XHJcbiAgICB9XHJcbiAgICBnZXQgdmFsdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldCgpO1xyXG4gICAgfVxyXG4gICAgc2V0IHZhbHVlKG5ld1ZhbCkge1xyXG4gICAgICAgIHRoaXMuX3NldChuZXdWYWwpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGN1c3RvbVJlZihmYWN0b3J5KSB7XHJcbiAgICByZXR1cm4gbmV3IEN1c3RvbVJlZkltcGwoZmFjdG9yeSk7XHJcbn1cclxuZnVuY3Rpb24gdG9SZWZzKG9iamVjdCkge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNQcm94eShvYmplY3QpKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGB0b1JlZnMoKSBleHBlY3RzIGEgcmVhY3RpdmUgb2JqZWN0IGJ1dCByZWNlaXZlZCBhIHBsYWluIG9uZS5gKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHJldCA9IGlzQXJyYXkob2JqZWN0KSA/IG5ldyBBcnJheShvYmplY3QubGVuZ3RoKSA6IHt9O1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XHJcbiAgICAgICAgcmV0W2tleV0gPSB0b1JlZihvYmplY3QsIGtleSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XHJcbmNsYXNzIE9iamVjdFJlZkltcGwge1xyXG4gICAgY29uc3RydWN0b3IoX29iamVjdCwgX2tleSkge1xyXG4gICAgICAgIHRoaXMuX29iamVjdCA9IF9vYmplY3Q7XHJcbiAgICAgICAgdGhpcy5fa2V5ID0gX2tleTtcclxuICAgICAgICB0aGlzLl9fdl9pc1JlZiA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBnZXQgdmFsdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX29iamVjdFt0aGlzLl9rZXldO1xyXG4gICAgfVxyXG4gICAgc2V0IHZhbHVlKG5ld1ZhbCkge1xyXG4gICAgICAgIHRoaXMuX29iamVjdFt0aGlzLl9rZXldID0gbmV3VmFsO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRvUmVmKG9iamVjdCwga2V5KSB7XHJcbiAgICByZXR1cm4gaXNSZWYob2JqZWN0W2tleV0pXHJcbiAgICAgICAgPyBvYmplY3Rba2V5XVxyXG4gICAgICAgIDogbmV3IE9iamVjdFJlZkltcGwob2JqZWN0LCBrZXkpO1xyXG59XG5cbmNsYXNzIENvbXB1dGVkUmVmSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihnZXR0ZXIsIF9zZXR0ZXIsIGlzUmVhZG9ubHkpIHtcclxuICAgICAgICB0aGlzLl9zZXR0ZXIgPSBfc2V0dGVyO1xyXG4gICAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9fdl9pc1JlZiA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5lZmZlY3QgPSBlZmZlY3QoZ2V0dGVyLCB7XHJcbiAgICAgICAgICAgIGxhenk6IHRydWUsXHJcbiAgICAgICAgICAgIHNjaGVkdWxlcjogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9kaXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyKHRvUmF3KHRoaXMpLCBcInNldFwiIC8qIFNFVCAqLywgJ3ZhbHVlJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzW1wiX192X2lzUmVhZG9ubHlcIiAvKiBJU19SRUFET05MWSAqL10gPSBpc1JlYWRvbmx5O1xyXG4gICAgfVxyXG4gICAgZ2V0IHZhbHVlKCkge1xyXG4gICAgICAgIC8vIHRoZSBjb21wdXRlZCByZWYgbWF5IGdldCB3cmFwcGVkIGJ5IG90aGVyIHByb3hpZXMgZS5nLiByZWFkb25seSgpICMzMzc2XHJcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRvUmF3KHRoaXMpO1xyXG4gICAgICAgIGlmIChzZWxmLl9kaXJ0eSkge1xyXG4gICAgICAgICAgICBzZWxmLl92YWx1ZSA9IHRoaXMuZWZmZWN0KCk7XHJcbiAgICAgICAgICAgIHNlbGYuX2RpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyYWNrKHNlbGYsIFwiZ2V0XCIgLyogR0VUICovLCAndmFsdWUnKTtcclxuICAgICAgICByZXR1cm4gc2VsZi5fdmFsdWU7XHJcbiAgICB9XHJcbiAgICBzZXQgdmFsdWUobmV3VmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9zZXR0ZXIobmV3VmFsdWUpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNvbXB1dGVkKGdldHRlck9yT3B0aW9ucykge1xyXG4gICAgbGV0IGdldHRlcjtcclxuICAgIGxldCBzZXR0ZXI7XHJcbiAgICBpZiAoaXNGdW5jdGlvbihnZXR0ZXJPck9wdGlvbnMpKSB7XHJcbiAgICAgICAgZ2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zO1xyXG4gICAgICAgIHNldHRlciA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgICAgICAgICA/ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignV3JpdGUgb3BlcmF0aW9uIGZhaWxlZDogY29tcHV0ZWQgdmFsdWUgaXMgcmVhZG9ubHknKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA6IE5PT1A7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBnZXR0ZXIgPSBnZXR0ZXJPck9wdGlvbnMuZ2V0O1xyXG4gICAgICAgIHNldHRlciA9IGdldHRlck9yT3B0aW9ucy5zZXQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IENvbXB1dGVkUmVmSW1wbChnZXR0ZXIsIHNldHRlciwgaXNGdW5jdGlvbihnZXR0ZXJPck9wdGlvbnMpIHx8ICFnZXR0ZXJPck9wdGlvbnMuc2V0KTtcclxufVxuXG5leHBvcnQgeyBJVEVSQVRFX0tFWSwgY29tcHV0ZWQsIGN1c3RvbVJlZiwgZWZmZWN0LCBlbmFibGVUcmFja2luZywgaXNQcm94eSwgaXNSZWFjdGl2ZSwgaXNSZWFkb25seSwgaXNSZWYsIG1hcmtSYXcsIHBhdXNlVHJhY2tpbmcsIHByb3h5UmVmcywgcmVhY3RpdmUsIHJlYWRvbmx5LCByZWYsIHJlc2V0VHJhY2tpbmcsIHNoYWxsb3dSZWFjdGl2ZSwgc2hhbGxvd1JlYWRvbmx5LCBzaGFsbG93UmVmLCBzdG9wLCB0b1JhdywgdG9SZWYsIHRvUmVmcywgdHJhY2ssIHRyaWdnZXIsIHRyaWdnZXJSZWYsIHVucmVmIH07XG4iLCJpbXBvcnQgeyBwYXVzZVRyYWNraW5nLCByZXNldFRyYWNraW5nLCBpc1JlZiwgdG9SYXcsIGlzUmVhY3RpdmUsIGVmZmVjdCwgc3RvcCwgcmVmLCByZWFjdGl2ZSwgcHJveHlSZWZzLCB0b1JlZiwgc2hhbGxvd1JlYWN0aXZlLCB0cmlnZ2VyLCBpc1Byb3h5LCBzaGFsbG93UmVhZG9ubHksIHRyYWNrLCBjb21wdXRlZCBhcyBjb21wdXRlZCQxLCBpc1JlYWRvbmx5IH0gZnJvbSAnQHZ1ZS9yZWFjdGl2aXR5JztcbmV4cG9ydCB7IGN1c3RvbVJlZiwgaXNQcm94eSwgaXNSZWFjdGl2ZSwgaXNSZWFkb25seSwgaXNSZWYsIG1hcmtSYXcsIHByb3h5UmVmcywgcmVhY3RpdmUsIHJlYWRvbmx5LCByZWYsIHNoYWxsb3dSZWFjdGl2ZSwgc2hhbGxvd1JlYWRvbmx5LCBzaGFsbG93UmVmLCB0b1JhdywgdG9SZWYsIHRvUmVmcywgdHJpZ2dlclJlZiwgdW5yZWYgfSBmcm9tICdAdnVlL3JlYWN0aXZpdHknO1xuaW1wb3J0IHsgaXNTdHJpbmcsIGlzRnVuY3Rpb24sIGlzUHJvbWlzZSwgaXNBcnJheSwgZXh0ZW5kLCBoYXNPd24sIEVNUFRZX09CSiwgdG9IYW5kbGVyS2V5LCB0b051bWJlciwgaHlwaGVuYXRlLCBjYW1lbGl6ZSwgaXNPbiwgaXNNb2RlbExpc3RlbmVyLCByZW1vdmUsIE5PT1AsIGhhc0NoYW5nZWQsIGlzT2JqZWN0LCBpc1NldCwgaXNNYXAsIGlzUGxhaW5PYmplY3QsIGludm9rZUFycmF5Rm5zLCBkZWYsIGlzUmVzZXJ2ZWRQcm9wLCBFTVBUWV9BUlIsIGNhcGl0YWxpemUsIHRvUmF3VHlwZSwgbWFrZU1hcCwgTk8sIGdldEdsb2JhbFRoaXMsIG5vcm1hbGl6ZUNsYXNzLCBub3JtYWxpemVTdHlsZSwgaXNHbG9iYWxseVdoaXRlbGlzdGVkIH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuZXhwb3J0IHsgY2FtZWxpemUsIGNhcGl0YWxpemUsIHRvRGlzcGxheVN0cmluZywgdG9IYW5kbGVyS2V5IH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuXG5jb25zdCBzdGFjayA9IFtdO1xyXG5mdW5jdGlvbiBwdXNoV2FybmluZ0NvbnRleHQodm5vZGUpIHtcclxuICAgIHN0YWNrLnB1c2godm5vZGUpO1xyXG59XHJcbmZ1bmN0aW9uIHBvcFdhcm5pbmdDb250ZXh0KCkge1xyXG4gICAgc3RhY2sucG9wKCk7XHJcbn1cclxuZnVuY3Rpb24gd2Fybihtc2csIC4uLmFyZ3MpIHtcclxuICAgIC8vIGF2b2lkIHByb3BzIGZvcm1hdHRpbmcgb3Igd2FybiBoYW5kbGVyIHRyYWNraW5nIGRlcHMgdGhhdCBtaWdodCBiZSBtdXRhdGVkXHJcbiAgICAvLyBkdXJpbmcgcGF0Y2gsIGxlYWRpbmcgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxyXG4gICAgcGF1c2VUcmFja2luZygpO1xyXG4gICAgY29uc3QgaW5zdGFuY2UgPSBzdGFjay5sZW5ndGggPyBzdGFja1tzdGFjay5sZW5ndGggLSAxXS5jb21wb25lbnQgOiBudWxsO1xyXG4gICAgY29uc3QgYXBwV2FybkhhbmRsZXIgPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy53YXJuSGFuZGxlcjtcclxuICAgIGNvbnN0IHRyYWNlID0gZ2V0Q29tcG9uZW50VHJhY2UoKTtcclxuICAgIGlmIChhcHBXYXJuSGFuZGxlcikge1xyXG4gICAgICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhhcHBXYXJuSGFuZGxlciwgaW5zdGFuY2UsIDExIC8qIEFQUF9XQVJOX0hBTkRMRVIgKi8sIFtcclxuICAgICAgICAgICAgbXNnICsgYXJncy5qb2luKCcnKSxcclxuICAgICAgICAgICAgaW5zdGFuY2UgJiYgaW5zdGFuY2UucHJveHksXHJcbiAgICAgICAgICAgIHRyYWNlXHJcbiAgICAgICAgICAgICAgICAubWFwKCh7IHZub2RlIH0pID0+IGBhdCA8JHtmb3JtYXRDb21wb25lbnROYW1lKGluc3RhbmNlLCB2bm9kZS50eXBlKX0+YClcclxuICAgICAgICAgICAgICAgIC5qb2luKCdcXG4nKSxcclxuICAgICAgICAgICAgdHJhY2VcclxuICAgICAgICBdKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHdhcm5BcmdzID0gW2BbVnVlIHdhcm5dOiAke21zZ31gLCAuLi5hcmdzXTtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICBpZiAodHJhY2UubGVuZ3RoICYmXHJcbiAgICAgICAgICAgIC8vIGF2b2lkIHNwYW1taW5nIGNvbnNvbGUgZHVyaW5nIHRlc3RzXHJcbiAgICAgICAgICAgICFmYWxzZSkge1xyXG4gICAgICAgICAgICB3YXJuQXJncy5wdXNoKGBcXG5gLCAuLi5mb3JtYXRUcmFjZSh0cmFjZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zb2xlLndhcm4oLi4ud2FybkFyZ3MpO1xyXG4gICAgfVxyXG4gICAgcmVzZXRUcmFja2luZygpO1xyXG59XHJcbmZ1bmN0aW9uIGdldENvbXBvbmVudFRyYWNlKCkge1xyXG4gICAgbGV0IGN1cnJlbnRWTm9kZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xyXG4gICAgaWYgKCFjdXJyZW50Vk5vZGUpIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICAvLyB3ZSBjYW4ndCBqdXN0IHVzZSB0aGUgc3RhY2sgYmVjYXVzZSBpdCB3aWxsIGJlIGluY29tcGxldGUgZHVyaW5nIHVwZGF0ZXNcclxuICAgIC8vIHRoYXQgZGlkIG5vdCBzdGFydCBmcm9tIHRoZSByb290LiBSZS1jb25zdHJ1Y3QgdGhlIHBhcmVudCBjaGFpbiB1c2luZ1xyXG4gICAgLy8gaW5zdGFuY2UgcGFyZW50IHBvaW50ZXJzLlxyXG4gICAgY29uc3Qgbm9ybWFsaXplZFN0YWNrID0gW107XHJcbiAgICB3aGlsZSAoY3VycmVudFZOb2RlKSB7XHJcbiAgICAgICAgY29uc3QgbGFzdCA9IG5vcm1hbGl6ZWRTdGFja1swXTtcclxuICAgICAgICBpZiAobGFzdCAmJiBsYXN0LnZub2RlID09PSBjdXJyZW50Vk5vZGUpIHtcclxuICAgICAgICAgICAgbGFzdC5yZWN1cnNlQ291bnQrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRTdGFjay5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHZub2RlOiBjdXJyZW50Vk5vZGUsXHJcbiAgICAgICAgICAgICAgICByZWN1cnNlQ291bnQ6IDBcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBhcmVudEluc3RhbmNlID0gY3VycmVudFZOb2RlLmNvbXBvbmVudCAmJiBjdXJyZW50Vk5vZGUuY29tcG9uZW50LnBhcmVudDtcclxuICAgICAgICBjdXJyZW50Vk5vZGUgPSBwYXJlbnRJbnN0YW5jZSAmJiBwYXJlbnRJbnN0YW5jZS52bm9kZTtcclxuICAgIH1cclxuICAgIHJldHVybiBub3JtYWxpemVkU3RhY2s7XHJcbn1cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuZnVuY3Rpb24gZm9ybWF0VHJhY2UodHJhY2UpIHtcclxuICAgIGNvbnN0IGxvZ3MgPSBbXTtcclxuICAgIHRyYWNlLmZvckVhY2goKGVudHJ5LCBpKSA9PiB7XHJcbiAgICAgICAgbG9ncy5wdXNoKC4uLihpID09PSAwID8gW10gOiBbYFxcbmBdKSwgLi4uZm9ybWF0VHJhY2VFbnRyeShlbnRyeSkpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gbG9ncztcclxufVxyXG5mdW5jdGlvbiBmb3JtYXRUcmFjZUVudHJ5KHsgdm5vZGUsIHJlY3Vyc2VDb3VudCB9KSB7XHJcbiAgICBjb25zdCBwb3N0Zml4ID0gcmVjdXJzZUNvdW50ID4gMCA/IGAuLi4gKCR7cmVjdXJzZUNvdW50fSByZWN1cnNpdmUgY2FsbHMpYCA6IGBgO1xyXG4gICAgY29uc3QgaXNSb290ID0gdm5vZGUuY29tcG9uZW50ID8gdm5vZGUuY29tcG9uZW50LnBhcmVudCA9PSBudWxsIDogZmFsc2U7XHJcbiAgICBjb25zdCBvcGVuID0gYCBhdCA8JHtmb3JtYXRDb21wb25lbnROYW1lKHZub2RlLmNvbXBvbmVudCwgdm5vZGUudHlwZSwgaXNSb290KX1gO1xyXG4gICAgY29uc3QgY2xvc2UgPSBgPmAgKyBwb3N0Zml4O1xyXG4gICAgcmV0dXJuIHZub2RlLnByb3BzXHJcbiAgICAgICAgPyBbb3BlbiwgLi4uZm9ybWF0UHJvcHModm5vZGUucHJvcHMpLCBjbG9zZV1cclxuICAgICAgICA6IFtvcGVuICsgY2xvc2VdO1xyXG59XHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbmZ1bmN0aW9uIGZvcm1hdFByb3BzKHByb3BzKSB7XHJcbiAgICBjb25zdCByZXMgPSBbXTtcclxuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcyk7XHJcbiAgICBrZXlzLnNsaWNlKDAsIDMpLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICByZXMucHVzaCguLi5mb3JtYXRQcm9wKGtleSwgcHJvcHNba2V5XSkpO1xyXG4gICAgfSk7XHJcbiAgICBpZiAoa2V5cy5sZW5ndGggPiAzKSB7XHJcbiAgICAgICAgcmVzLnB1c2goYCAuLi5gKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuZnVuY3Rpb24gZm9ybWF0UHJvcChrZXksIHZhbHVlLCByYXcpIHtcclxuICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcclxuICAgICAgICB2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcclxuICAgICAgICByZXR1cm4gcmF3ID8gdmFsdWUgOiBbYCR7a2V5fT0ke3ZhbHVlfWBdO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fFxyXG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8XHJcbiAgICAgICAgdmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiByYXcgPyB2YWx1ZSA6IFtgJHtrZXl9PSR7dmFsdWV9YF07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1JlZih2YWx1ZSkpIHtcclxuICAgICAgICB2YWx1ZSA9IGZvcm1hdFByb3Aoa2V5LCB0b1Jhdyh2YWx1ZS52YWx1ZSksIHRydWUpO1xyXG4gICAgICAgIHJldHVybiByYXcgPyB2YWx1ZSA6IFtgJHtrZXl9PVJlZjxgLCB2YWx1ZSwgYD5gXTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIFtgJHtrZXl9PWZuJHt2YWx1ZS5uYW1lID8gYDwke3ZhbHVlLm5hbWV9PmAgOiBgYH1gXTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhbHVlID0gdG9SYXcodmFsdWUpO1xyXG4gICAgICAgIHJldHVybiByYXcgPyB2YWx1ZSA6IFtgJHtrZXl9PWAsIHZhbHVlXTtcclxuICAgIH1cclxufVxuXG5jb25zdCBFcnJvclR5cGVTdHJpbmdzID0ge1xyXG4gICAgW1wiYmNcIiAvKiBCRUZPUkVfQ1JFQVRFICovXTogJ2JlZm9yZUNyZWF0ZSBob29rJyxcclxuICAgIFtcImNcIiAvKiBDUkVBVEVEICovXTogJ2NyZWF0ZWQgaG9vaycsXHJcbiAgICBbXCJibVwiIC8qIEJFRk9SRV9NT1VOVCAqL106ICdiZWZvcmVNb3VudCBob29rJyxcclxuICAgIFtcIm1cIiAvKiBNT1VOVEVEICovXTogJ21vdW50ZWQgaG9vaycsXHJcbiAgICBbXCJidVwiIC8qIEJFRk9SRV9VUERBVEUgKi9dOiAnYmVmb3JlVXBkYXRlIGhvb2snLFxyXG4gICAgW1widVwiIC8qIFVQREFURUQgKi9dOiAndXBkYXRlZCcsXHJcbiAgICBbXCJidW1cIiAvKiBCRUZPUkVfVU5NT1VOVCAqL106ICdiZWZvcmVVbm1vdW50IGhvb2snLFxyXG4gICAgW1widW1cIiAvKiBVTk1PVU5URUQgKi9dOiAndW5tb3VudGVkIGhvb2snLFxyXG4gICAgW1wiYVwiIC8qIEFDVElWQVRFRCAqL106ICdhY3RpdmF0ZWQgaG9vaycsXHJcbiAgICBbXCJkYVwiIC8qIERFQUNUSVZBVEVEICovXTogJ2RlYWN0aXZhdGVkIGhvb2snLFxyXG4gICAgW1wiZWNcIiAvKiBFUlJPUl9DQVBUVVJFRCAqL106ICdlcnJvckNhcHR1cmVkIGhvb2snLFxyXG4gICAgW1wicnRjXCIgLyogUkVOREVSX1RSQUNLRUQgKi9dOiAncmVuZGVyVHJhY2tlZCBob29rJyxcclxuICAgIFtcInJ0Z1wiIC8qIFJFTkRFUl9UUklHR0VSRUQgKi9dOiAncmVuZGVyVHJpZ2dlcmVkIGhvb2snLFxyXG4gICAgWzAgLyogU0VUVVBfRlVOQ1RJT04gKi9dOiAnc2V0dXAgZnVuY3Rpb24nLFxyXG4gICAgWzEgLyogUkVOREVSX0ZVTkNUSU9OICovXTogJ3JlbmRlciBmdW5jdGlvbicsXHJcbiAgICBbMiAvKiBXQVRDSF9HRVRURVIgKi9dOiAnd2F0Y2hlciBnZXR0ZXInLFxyXG4gICAgWzMgLyogV0FUQ0hfQ0FMTEJBQ0sgKi9dOiAnd2F0Y2hlciBjYWxsYmFjaycsXHJcbiAgICBbNCAvKiBXQVRDSF9DTEVBTlVQICovXTogJ3dhdGNoZXIgY2xlYW51cCBmdW5jdGlvbicsXHJcbiAgICBbNSAvKiBOQVRJVkVfRVZFTlRfSEFORExFUiAqL106ICduYXRpdmUgZXZlbnQgaGFuZGxlcicsXHJcbiAgICBbNiAvKiBDT01QT05FTlRfRVZFTlRfSEFORExFUiAqL106ICdjb21wb25lbnQgZXZlbnQgaGFuZGxlcicsXHJcbiAgICBbNyAvKiBWTk9ERV9IT09LICovXTogJ3Zub2RlIGhvb2snLFxyXG4gICAgWzggLyogRElSRUNUSVZFX0hPT0sgKi9dOiAnZGlyZWN0aXZlIGhvb2snLFxyXG4gICAgWzkgLyogVFJBTlNJVElPTl9IT09LICovXTogJ3RyYW5zaXRpb24gaG9vaycsXHJcbiAgICBbMTAgLyogQVBQX0VSUk9SX0hBTkRMRVIgKi9dOiAnYXBwIGVycm9ySGFuZGxlcicsXHJcbiAgICBbMTEgLyogQVBQX1dBUk5fSEFORExFUiAqL106ICdhcHAgd2FybkhhbmRsZXInLFxyXG4gICAgWzEyIC8qIEZVTkNUSU9OX1JFRiAqL106ICdyZWYgZnVuY3Rpb24nLFxyXG4gICAgWzEzIC8qIEFTWU5DX0NPTVBPTkVOVF9MT0FERVIgKi9dOiAnYXN5bmMgY29tcG9uZW50IGxvYWRlcicsXHJcbiAgICBbMTQgLyogU0NIRURVTEVSICovXTogJ3NjaGVkdWxlciBmbHVzaC4gVGhpcyBpcyBsaWtlbHkgYSBWdWUgaW50ZXJuYWxzIGJ1Zy4gJyArXHJcbiAgICAgICAgJ1BsZWFzZSBvcGVuIGFuIGlzc3VlIGF0IGh0dHBzOi8vbmV3LWlzc3VlLnZ1ZWpzLm9yZy8/cmVwbz12dWVqcy92dWUtbmV4dCdcclxufTtcclxuZnVuY3Rpb24gY2FsbFdpdGhFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgdHlwZSwgYXJncykge1xyXG4gICAgbGV0IHJlcztcclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmVzID0gYXJncyA/IGZuKC4uLmFyZ3MpIDogZm4oKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCB0eXBlKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuZnVuY3Rpb24gY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCB0eXBlLCBhcmdzKSB7XHJcbiAgICBpZiAoaXNGdW5jdGlvbihmbikpIHtcclxuICAgICAgICBjb25zdCByZXMgPSBjYWxsV2l0aEVycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCB0eXBlLCBhcmdzKTtcclxuICAgICAgICBpZiAocmVzICYmIGlzUHJvbWlzZShyZXMpKSB7XHJcbiAgICAgICAgICAgIHJlcy5jYXRjaChlcnIgPT4ge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgdHlwZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdmFsdWVzID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFsdWVzLnB1c2goY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoZm5baV0sIGluc3RhbmNlLCB0eXBlLCBhcmdzKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWVzO1xyXG59XHJcbmZ1bmN0aW9uIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIHR5cGUsIHRocm93SW5EZXYgPSB0cnVlKSB7XHJcbiAgICBjb25zdCBjb250ZXh0Vk5vZGUgPSBpbnN0YW5jZSA/IGluc3RhbmNlLnZub2RlIDogbnVsbDtcclxuICAgIGlmIChpbnN0YW5jZSkge1xyXG4gICAgICAgIGxldCBjdXIgPSBpbnN0YW5jZS5wYXJlbnQ7XHJcbiAgICAgICAgLy8gdGhlIGV4cG9zZWQgaW5zdGFuY2UgaXMgdGhlIHJlbmRlciBwcm94eSB0byBrZWVwIGl0IGNvbnNpc3RlbnQgd2l0aCAyLnhcclxuICAgICAgICBjb25zdCBleHBvc2VkSW5zdGFuY2UgPSBpbnN0YW5jZS5wcm94eTtcclxuICAgICAgICAvLyBpbiBwcm9kdWN0aW9uIHRoZSBob29rIHJlY2VpdmVzIG9ubHkgdGhlIGVycm9yIGNvZGVcclxuICAgICAgICBjb25zdCBlcnJvckluZm8gPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBFcnJvclR5cGVTdHJpbmdzW3R5cGVdIDogdHlwZTtcclxuICAgICAgICB3aGlsZSAoY3VyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yQ2FwdHVyZWRIb29rcyA9IGN1ci5lYztcclxuICAgICAgICAgICAgaWYgKGVycm9yQ2FwdHVyZWRIb29rcykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlcnJvckNhcHR1cmVkSG9va3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JDYXB0dXJlZEhvb2tzW2ldKGVyciwgZXhwb3NlZEluc3RhbmNlLCBlcnJvckluZm8pID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1ciA9IGN1ci5wYXJlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFwcC1sZXZlbCBoYW5kbGluZ1xyXG4gICAgICAgIGNvbnN0IGFwcEVycm9ySGFuZGxlciA9IGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLmVycm9ySGFuZGxlcjtcclxuICAgICAgICBpZiAoYXBwRXJyb3JIYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhhcHBFcnJvckhhbmRsZXIsIG51bGwsIDEwIC8qIEFQUF9FUlJPUl9IQU5ETEVSICovLCBbZXJyLCBleHBvc2VkSW5zdGFuY2UsIGVycm9ySW5mb10pO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbG9nRXJyb3IoZXJyLCB0eXBlLCBjb250ZXh0Vk5vZGUsIHRocm93SW5EZXYpO1xyXG59XHJcbmZ1bmN0aW9uIGxvZ0Vycm9yKGVyciwgdHlwZSwgY29udGV4dFZOb2RlLCB0aHJvd0luRGV2ID0gdHJ1ZSkge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGNvbnN0IGluZm8gPSBFcnJvclR5cGVTdHJpbmdzW3R5cGVdO1xyXG4gICAgICAgIGlmIChjb250ZXh0Vk5vZGUpIHtcclxuICAgICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KGNvbnRleHRWTm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdhcm4oYFVuaGFuZGxlZCBlcnJvciR7aW5mbyA/IGAgZHVyaW5nIGV4ZWN1dGlvbiBvZiAke2luZm99YCA6IGBgfWApO1xyXG4gICAgICAgIGlmIChjb250ZXh0Vk5vZGUpIHtcclxuICAgICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY3Jhc2ggaW4gZGV2IGJ5IGRlZmF1bHQgc28gaXQncyBtb3JlIG5vdGljZWFibGVcclxuICAgICAgICBpZiAodGhyb3dJbkRldikge1xyXG4gICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gcmVjb3ZlciBpbiBwcm9kIHRvIHJlZHVjZSB0aGUgaW1wYWN0IG9uIGVuZC11c2VyXHJcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xyXG4gICAgfVxyXG59XG5cbmxldCBpc0ZsdXNoaW5nID0gZmFsc2U7XHJcbmxldCBpc0ZsdXNoUGVuZGluZyA9IGZhbHNlO1xyXG5jb25zdCBxdWV1ZSA9IFtdO1xyXG5sZXQgZmx1c2hJbmRleCA9IDA7XHJcbmNvbnN0IHBlbmRpbmdQcmVGbHVzaENicyA9IFtdO1xyXG5sZXQgYWN0aXZlUHJlRmx1c2hDYnMgPSBudWxsO1xyXG5sZXQgcHJlRmx1c2hJbmRleCA9IDA7XHJcbmNvbnN0IHBlbmRpbmdQb3N0Rmx1c2hDYnMgPSBbXTtcclxubGV0IGFjdGl2ZVBvc3RGbHVzaENicyA9IG51bGw7XHJcbmxldCBwb3N0Rmx1c2hJbmRleCA9IDA7XHJcbmNvbnN0IHJlc29sdmVkUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xyXG5sZXQgY3VycmVudEZsdXNoUHJvbWlzZSA9IG51bGw7XHJcbmxldCBjdXJyZW50UHJlRmx1c2hQYXJlbnRKb2IgPSBudWxsO1xyXG5jb25zdCBSRUNVUlNJT05fTElNSVQgPSAxMDA7XHJcbmZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XHJcbiAgICBjb25zdCBwID0gY3VycmVudEZsdXNoUHJvbWlzZSB8fCByZXNvbHZlZFByb21pc2U7XHJcbiAgICByZXR1cm4gZm4gPyBwLnRoZW4odGhpcyA/IGZuLmJpbmQodGhpcykgOiBmbikgOiBwO1xyXG59XHJcbi8vICMyNzY4XHJcbi8vIFVzZSBiaW5hcnktc2VhcmNoIHRvIGZpbmQgYSBzdWl0YWJsZSBwb3NpdGlvbiBpbiB0aGUgcXVldWUsXHJcbi8vIHNvIHRoYXQgdGhlIHF1ZXVlIG1haW50YWlucyB0aGUgaW5jcmVhc2luZyBvcmRlciBvZiBqb2IncyBpZCxcclxuLy8gd2hpY2ggY2FuIHByZXZlbnQgdGhlIGpvYiBmcm9tIGJlaW5nIHNraXBwZWQgYW5kIGFsc28gY2FuIGF2b2lkIHJlcGVhdGVkIHBhdGNoaW5nLlxyXG5mdW5jdGlvbiBmaW5kSW5zZXJ0aW9uSW5kZXgoam9iKSB7XHJcbiAgICAvLyB0aGUgc3RhcnQgaW5kZXggc2hvdWxkIGJlIGBmbHVzaEluZGV4ICsgMWBcclxuICAgIGxldCBzdGFydCA9IGZsdXNoSW5kZXggKyAxO1xyXG4gICAgbGV0IGVuZCA9IHF1ZXVlLmxlbmd0aDtcclxuICAgIGNvbnN0IGpvYklkID0gZ2V0SWQoam9iKTtcclxuICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xyXG4gICAgICAgIGNvbnN0IG1pZGRsZSA9IChzdGFydCArIGVuZCkgPj4+IDE7XHJcbiAgICAgICAgY29uc3QgbWlkZGxlSm9iSWQgPSBnZXRJZChxdWV1ZVttaWRkbGVdKTtcclxuICAgICAgICBtaWRkbGVKb2JJZCA8IGpvYklkID8gKHN0YXJ0ID0gbWlkZGxlICsgMSkgOiAoZW5kID0gbWlkZGxlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzdGFydDtcclxufVxyXG5mdW5jdGlvbiBxdWV1ZUpvYihqb2IpIHtcclxuICAgIC8vIHRoZSBkZWR1cGUgc2VhcmNoIHVzZXMgdGhlIHN0YXJ0SW5kZXggYXJndW1lbnQgb2YgQXJyYXkuaW5jbHVkZXMoKVxyXG4gICAgLy8gYnkgZGVmYXVsdCB0aGUgc2VhcmNoIGluZGV4IGluY2x1ZGVzIHRoZSBjdXJyZW50IGpvYiB0aGF0IGlzIGJlaW5nIHJ1blxyXG4gICAgLy8gc28gaXQgY2Fubm90IHJlY3Vyc2l2ZWx5IHRyaWdnZXIgaXRzZWxmIGFnYWluLlxyXG4gICAgLy8gaWYgdGhlIGpvYiBpcyBhIHdhdGNoKCkgY2FsbGJhY2ssIHRoZSBzZWFyY2ggd2lsbCBzdGFydCB3aXRoIGEgKzEgaW5kZXggdG9cclxuICAgIC8vIGFsbG93IGl0IHJlY3Vyc2l2ZWx5IHRyaWdnZXIgaXRzZWxmIC0gaXQgaXMgdGhlIHVzZXIncyByZXNwb25zaWJpbGl0eSB0b1xyXG4gICAgLy8gZW5zdXJlIGl0IGRvZXNuJ3QgZW5kIHVwIGluIGFuIGluZmluaXRlIGxvb3AuXHJcbiAgICBpZiAoKCFxdWV1ZS5sZW5ndGggfHxcclxuICAgICAgICAhcXVldWUuaW5jbHVkZXMoam9iLCBpc0ZsdXNoaW5nICYmIGpvYi5hbGxvd1JlY3Vyc2UgPyBmbHVzaEluZGV4ICsgMSA6IGZsdXNoSW5kZXgpKSAmJlxyXG4gICAgICAgIGpvYiAhPT0gY3VycmVudFByZUZsdXNoUGFyZW50Sm9iKSB7XHJcbiAgICAgICAgY29uc3QgcG9zID0gZmluZEluc2VydGlvbkluZGV4KGpvYik7XHJcbiAgICAgICAgaWYgKHBvcyA+IC0xKSB7XHJcbiAgICAgICAgICAgIHF1ZXVlLnNwbGljZShwb3MsIDAsIGpvYik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGpvYik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHF1ZXVlRmx1c2goKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBxdWV1ZUZsdXNoKCkge1xyXG4gICAgaWYgKCFpc0ZsdXNoaW5nICYmICFpc0ZsdXNoUGVuZGluZykge1xyXG4gICAgICAgIGlzRmx1c2hQZW5kaW5nID0gdHJ1ZTtcclxuICAgICAgICBjdXJyZW50Rmx1c2hQcm9taXNlID0gcmVzb2x2ZWRQcm9taXNlLnRoZW4oZmx1c2hKb2JzKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpbnZhbGlkYXRlSm9iKGpvYikge1xyXG4gICAgY29uc3QgaSA9IHF1ZXVlLmluZGV4T2Yoam9iKTtcclxuICAgIGlmIChpID4gZmx1c2hJbmRleCkge1xyXG4gICAgICAgIHF1ZXVlLnNwbGljZShpLCAxKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBxdWV1ZUNiKGNiLCBhY3RpdmVRdWV1ZSwgcGVuZGluZ1F1ZXVlLCBpbmRleCkge1xyXG4gICAgaWYgKCFpc0FycmF5KGNiKSkge1xyXG4gICAgICAgIGlmICghYWN0aXZlUXVldWUgfHxcclxuICAgICAgICAgICAgIWFjdGl2ZVF1ZXVlLmluY2x1ZGVzKGNiLCBjYi5hbGxvd1JlY3Vyc2UgPyBpbmRleCArIDEgOiBpbmRleCkpIHtcclxuICAgICAgICAgICAgcGVuZGluZ1F1ZXVlLnB1c2goY2IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIGlmIGNiIGlzIGFuIGFycmF5LCBpdCBpcyBhIGNvbXBvbmVudCBsaWZlY3ljbGUgaG9vayB3aGljaCBjYW4gb25seSBiZVxyXG4gICAgICAgIC8vIHRyaWdnZXJlZCBieSBhIGpvYiwgd2hpY2ggaXMgYWxyZWFkeSBkZWR1cGVkIGluIHRoZSBtYWluIHF1ZXVlLCBzb1xyXG4gICAgICAgIC8vIHdlIGNhbiBza2lwIGR1cGxpY2F0ZSBjaGVjayBoZXJlIHRvIGltcHJvdmUgcGVyZlxyXG4gICAgICAgIHBlbmRpbmdRdWV1ZS5wdXNoKC4uLmNiKTtcclxuICAgIH1cclxuICAgIHF1ZXVlRmx1c2goKTtcclxufVxyXG5mdW5jdGlvbiBxdWV1ZVByZUZsdXNoQ2IoY2IpIHtcclxuICAgIHF1ZXVlQ2IoY2IsIGFjdGl2ZVByZUZsdXNoQ2JzLCBwZW5kaW5nUHJlRmx1c2hDYnMsIHByZUZsdXNoSW5kZXgpO1xyXG59XHJcbmZ1bmN0aW9uIHF1ZXVlUG9zdEZsdXNoQ2IoY2IpIHtcclxuICAgIHF1ZXVlQ2IoY2IsIGFjdGl2ZVBvc3RGbHVzaENicywgcGVuZGluZ1Bvc3RGbHVzaENicywgcG9zdEZsdXNoSW5kZXgpO1xyXG59XHJcbmZ1bmN0aW9uIGZsdXNoUHJlRmx1c2hDYnMoc2VlbiwgcGFyZW50Sm9iID0gbnVsbCkge1xyXG4gICAgaWYgKHBlbmRpbmdQcmVGbHVzaENicy5sZW5ndGgpIHtcclxuICAgICAgICBjdXJyZW50UHJlRmx1c2hQYXJlbnRKb2IgPSBwYXJlbnRKb2I7XHJcbiAgICAgICAgYWN0aXZlUHJlRmx1c2hDYnMgPSBbLi4ubmV3IFNldChwZW5kaW5nUHJlRmx1c2hDYnMpXTtcclxuICAgICAgICBwZW5kaW5nUHJlRmx1c2hDYnMubGVuZ3RoID0gMDtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHNlZW4gPSBzZWVuIHx8IG5ldyBNYXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChwcmVGbHVzaEluZGV4ID0gMDsgcHJlRmx1c2hJbmRleCA8IGFjdGl2ZVByZUZsdXNoQ2JzLmxlbmd0aDsgcHJlRmx1c2hJbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgIGNoZWNrUmVjdXJzaXZlVXBkYXRlcyhzZWVuLCBhY3RpdmVQcmVGbHVzaENic1twcmVGbHVzaEluZGV4XSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFjdGl2ZVByZUZsdXNoQ2JzW3ByZUZsdXNoSW5kZXhdKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFjdGl2ZVByZUZsdXNoQ2JzID0gbnVsbDtcclxuICAgICAgICBwcmVGbHVzaEluZGV4ID0gMDtcclxuICAgICAgICBjdXJyZW50UHJlRmx1c2hQYXJlbnRKb2IgPSBudWxsO1xyXG4gICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGZsdXNoIHVudGlsIGl0IGRyYWluc1xyXG4gICAgICAgIGZsdXNoUHJlRmx1c2hDYnMoc2VlbiwgcGFyZW50Sm9iKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBmbHVzaFBvc3RGbHVzaENicyhzZWVuKSB7XHJcbiAgICBpZiAocGVuZGluZ1Bvc3RGbHVzaENicy5sZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBkZWR1cGVkID0gWy4uLm5ldyBTZXQocGVuZGluZ1Bvc3RGbHVzaENicyldO1xyXG4gICAgICAgIHBlbmRpbmdQb3N0Rmx1c2hDYnMubGVuZ3RoID0gMDtcclxuICAgICAgICAvLyAjMTk0NyBhbHJlYWR5IGhhcyBhY3RpdmUgcXVldWUsIG5lc3RlZCBmbHVzaFBvc3RGbHVzaENicyBjYWxsXHJcbiAgICAgICAgaWYgKGFjdGl2ZVBvc3RGbHVzaENicykge1xyXG4gICAgICAgICAgICBhY3RpdmVQb3N0Rmx1c2hDYnMucHVzaCguLi5kZWR1cGVkKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhY3RpdmVQb3N0Rmx1c2hDYnMgPSBkZWR1cGVkO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgc2VlbiA9IHNlZW4gfHwgbmV3IE1hcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhY3RpdmVQb3N0Rmx1c2hDYnMuc29ydCgoYSwgYikgPT4gZ2V0SWQoYSkgLSBnZXRJZChiKSk7XHJcbiAgICAgICAgZm9yIChwb3N0Rmx1c2hJbmRleCA9IDA7IHBvc3RGbHVzaEluZGV4IDwgYWN0aXZlUG9zdEZsdXNoQ2JzLmxlbmd0aDsgcG9zdEZsdXNoSW5kZXgrKykge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICBjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMoc2VlbiwgYWN0aXZlUG9zdEZsdXNoQ2JzW3Bvc3RGbHVzaEluZGV4XSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFjdGl2ZVBvc3RGbHVzaENic1twb3N0Rmx1c2hJbmRleF0oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWN0aXZlUG9zdEZsdXNoQ2JzID0gbnVsbDtcclxuICAgICAgICBwb3N0Rmx1c2hJbmRleCA9IDA7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgZ2V0SWQgPSAoam9iKSA9PiBqb2IuaWQgPT0gbnVsbCA/IEluZmluaXR5IDogam9iLmlkO1xyXG5mdW5jdGlvbiBmbHVzaEpvYnMoc2Vlbikge1xyXG4gICAgaXNGbHVzaFBlbmRpbmcgPSBmYWxzZTtcclxuICAgIGlzRmx1c2hpbmcgPSB0cnVlO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHNlZW4gPSBzZWVuIHx8IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIGZsdXNoUHJlRmx1c2hDYnMoc2Vlbik7XHJcbiAgICAvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cclxuICAgIC8vIFRoaXMgZW5zdXJlcyB0aGF0OlxyXG4gICAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xyXG4gICAgLy8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkIHNvIGl0cyByZW5kZXIgZWZmZWN0IHdpbGwgaGF2ZSBzbWFsbGVyXHJcbiAgICAvLyAgICBwcmlvcml0eSBudW1iZXIpXHJcbiAgICAvLyAyLiBJZiBhIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQgZHVyaW5nIGEgcGFyZW50IGNvbXBvbmVudCdzIHVwZGF0ZSxcclxuICAgIC8vICAgIGl0cyB1cGRhdGUgY2FuIGJlIHNraXBwZWQuXHJcbiAgICBxdWV1ZS5zb3J0KChhLCBiKSA9PiBnZXRJZChhKSAtIGdldElkKGIpKTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgZm9yIChmbHVzaEluZGV4ID0gMDsgZmx1c2hJbmRleCA8IHF1ZXVlLmxlbmd0aDsgZmx1c2hJbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGpvYiA9IHF1ZXVlW2ZsdXNoSW5kZXhdO1xyXG4gICAgICAgICAgICBpZiAoam9iICYmIGpvYi5hY3RpdmUgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNoZWNrUmVjdXJzaXZlVXBkYXRlcyhzZWVuLCBqb2IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcoam9iLCBudWxsLCAxNCAvKiBTQ0hFRFVMRVIgKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgZmx1c2hJbmRleCA9IDA7XHJcbiAgICAgICAgcXVldWUubGVuZ3RoID0gMDtcclxuICAgICAgICBmbHVzaFBvc3RGbHVzaENicyhzZWVuKTtcclxuICAgICAgICBpc0ZsdXNoaW5nID0gZmFsc2U7XHJcbiAgICAgICAgY3VycmVudEZsdXNoUHJvbWlzZSA9IG51bGw7XHJcbiAgICAgICAgLy8gc29tZSBwb3N0Rmx1c2hDYiBxdWV1ZWQgam9icyFcclxuICAgICAgICAvLyBrZWVwIGZsdXNoaW5nIHVudGlsIGl0IGRyYWlucy5cclxuICAgICAgICBpZiAocXVldWUubGVuZ3RoIHx8XHJcbiAgICAgICAgICAgIHBlbmRpbmdQcmVGbHVzaENicy5sZW5ndGggfHxcclxuICAgICAgICAgICAgcGVuZGluZ1Bvc3RGbHVzaENicy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgZmx1c2hKb2JzKHNlZW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMoc2VlbiwgZm4pIHtcclxuICAgIGlmICghc2Vlbi5oYXMoZm4pKSB7XHJcbiAgICAgICAgc2Vlbi5zZXQoZm4sIDEpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgY291bnQgPSBzZWVuLmdldChmbik7XHJcbiAgICAgICAgaWYgKGNvdW50ID4gUkVDVVJTSU9OX0xJTUlUKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gZm4ub3duZXJJbnN0YW5jZTtcclxuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50TmFtZSA9IGluc3RhbmNlICYmIGdldENvbXBvbmVudE5hbWUoaW5zdGFuY2UudHlwZSk7XHJcbiAgICAgICAgICAgIHdhcm4oYE1heGltdW0gcmVjdXJzaXZlIHVwZGF0ZXMgZXhjZWVkZWQke2NvbXBvbmVudE5hbWUgPyBgIGluIGNvbXBvbmVudCA8JHtjb21wb25lbnROYW1lfT5gIDogYGB9LiBgICtcclxuICAgICAgICAgICAgICAgIGBUaGlzIG1lYW5zIHlvdSBoYXZlIGEgcmVhY3RpdmUgZWZmZWN0IHRoYXQgaXMgbXV0YXRpbmcgaXRzIG93biBgICtcclxuICAgICAgICAgICAgICAgIGBkZXBlbmRlbmNpZXMgYW5kIHRodXMgcmVjdXJzaXZlbHkgdHJpZ2dlcmluZyBpdHNlbGYuIFBvc3NpYmxlIHNvdXJjZXMgYCArXHJcbiAgICAgICAgICAgICAgICBgaW5jbHVkZSBjb21wb25lbnQgdGVtcGxhdGUsIHJlbmRlciBmdW5jdGlvbiwgdXBkYXRlZCBob29rIG9yIGAgK1xyXG4gICAgICAgICAgICAgICAgYHdhdGNoZXIgc291cmNlIGZ1bmN0aW9uLmApO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNlZW4uc2V0KGZuLCBjb3VudCArIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgKi9cclxubGV0IGlzSG1yVXBkYXRpbmcgPSBmYWxzZTtcclxuY29uc3QgaG1yRGlydHlDb21wb25lbnRzID0gbmV3IFNldCgpO1xyXG4vLyBFeHBvc2UgdGhlIEhNUiBydW50aW1lIG9uIHRoZSBnbG9iYWwgb2JqZWN0XHJcbi8vIFRoaXMgbWFrZXMgaXQgZW50aXJlbHkgdHJlZS1zaGFrYWJsZSB3aXRob3V0IHBvbGx1dGluZyB0aGUgZXhwb3J0cyBhbmQgbWFrZXNcclxuLy8gaXQgZWFzaWVyIHRvIGJlIHVzZWQgaW4gdG9vbGluZ3MgbGlrZSB2dWUtbG9hZGVyXHJcbi8vIE5vdGU6IGZvciBhIGNvbXBvbmVudCB0byBiZSBlbGlnaWJsZSBmb3IgSE1SIGl0IGFsc28gbmVlZHMgdGhlIF9faG1ySWQgb3B0aW9uXHJcbi8vIHRvIGJlIHNldCBzbyB0aGF0IGl0cyBpbnN0YW5jZXMgY2FuIGJlIHJlZ2lzdGVyZWQgLyByZW1vdmVkLlxyXG5pZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICBjb25zdCBnbG9iYWxPYmplY3QgPSB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgID8gZ2xvYmFsXHJcbiAgICAgICAgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICAgICAgPyBzZWxmXHJcbiAgICAgICAgICAgIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICAgICAgICAgID8gd2luZG93XHJcbiAgICAgICAgICAgICAgICA6IHt9O1xyXG4gICAgZ2xvYmFsT2JqZWN0Ll9fVlVFX0hNUl9SVU5USU1FX18gPSB7XHJcbiAgICAgICAgY3JlYXRlUmVjb3JkOiB0cnlXcmFwKGNyZWF0ZVJlY29yZCksXHJcbiAgICAgICAgcmVyZW5kZXI6IHRyeVdyYXAocmVyZW5kZXIpLFxyXG4gICAgICAgIHJlbG9hZDogdHJ5V3JhcChyZWxvYWQpXHJcbiAgICB9O1xyXG59XHJcbmNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcclxuZnVuY3Rpb24gcmVnaXN0ZXJITVIoaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IGlkID0gaW5zdGFuY2UudHlwZS5fX2htcklkO1xyXG4gICAgbGV0IHJlY29yZCA9IG1hcC5nZXQoaWQpO1xyXG4gICAgaWYgKCFyZWNvcmQpIHtcclxuICAgICAgICBjcmVhdGVSZWNvcmQoaWQsIGluc3RhbmNlLnR5cGUpO1xyXG4gICAgICAgIHJlY29yZCA9IG1hcC5nZXQoaWQpO1xyXG4gICAgfVxyXG4gICAgcmVjb3JkLmluc3RhbmNlcy5hZGQoaW5zdGFuY2UpO1xyXG59XHJcbmZ1bmN0aW9uIHVucmVnaXN0ZXJITVIoaW5zdGFuY2UpIHtcclxuICAgIG1hcC5nZXQoaW5zdGFuY2UudHlwZS5fX2htcklkKS5pbnN0YW5jZXMuZGVsZXRlKGluc3RhbmNlKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVSZWNvcmQoaWQsIGNvbXBvbmVudCkge1xyXG4gICAgaWYgKCFjb21wb25lbnQpIHtcclxuICAgICAgICB3YXJuKGBITVIgQVBJIHVzYWdlIGlzIG91dCBvZiBkYXRlLlxcbmAgK1xyXG4gICAgICAgICAgICBgUGxlYXNlIHVwZ3JhZGUgdnVlLWxvYWRlci92aXRlL3JvbGx1cC1wbHVnaW4tdnVlIG9yIG90aGVyIHJlbGV2YW50IGAgK1xyXG4gICAgICAgICAgICBgZGVwZW5kZW5jeSB0aGF0IGhhbmRsZXMgVnVlIFNGQyBjb21waWxhdGlvbi5gKTtcclxuICAgICAgICBjb21wb25lbnQgPSB7fTtcclxuICAgIH1cclxuICAgIGlmIChtYXAuaGFzKGlkKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIG1hcC5zZXQoaWQsIHtcclxuICAgICAgICBjb21wb25lbnQ6IGlzQ2xhc3NDb21wb25lbnQoY29tcG9uZW50KSA/IGNvbXBvbmVudC5fX3ZjY09wdHMgOiBjb21wb25lbnQsXHJcbiAgICAgICAgaW5zdGFuY2VzOiBuZXcgU2V0KClcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gcmVyZW5kZXIoaWQsIG5ld1JlbmRlcikge1xyXG4gICAgY29uc3QgcmVjb3JkID0gbWFwLmdldChpZCk7XHJcbiAgICBpZiAoIXJlY29yZClcclxuICAgICAgICByZXR1cm47XHJcbiAgICBpZiAobmV3UmVuZGVyKVxyXG4gICAgICAgIHJlY29yZC5jb21wb25lbnQucmVuZGVyID0gbmV3UmVuZGVyO1xyXG4gICAgLy8gQXJyYXkuZnJvbSBjcmVhdGVzIGEgc25hcHNob3Qgd2hpY2ggYXZvaWRzIHRoZSBzZXQgYmVpbmcgbXV0YXRlZCBkdXJpbmdcclxuICAgIC8vIHVwZGF0ZXNcclxuICAgIEFycmF5LmZyb20ocmVjb3JkLmluc3RhbmNlcykuZm9yRWFjaChpbnN0YW5jZSA9PiB7XHJcbiAgICAgICAgaWYgKG5ld1JlbmRlcikge1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5yZW5kZXIgPSBuZXdSZW5kZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluc3RhbmNlLnJlbmRlckNhY2hlID0gW107XHJcbiAgICAgICAgLy8gdGhpcyBmbGFnIGZvcmNlcyBjaGlsZCBjb21wb25lbnRzIHdpdGggc2xvdCBjb250ZW50IHRvIHVwZGF0ZVxyXG4gICAgICAgIGlzSG1yVXBkYXRpbmcgPSB0cnVlO1xyXG4gICAgICAgIGluc3RhbmNlLnVwZGF0ZSgpO1xyXG4gICAgICAgIGlzSG1yVXBkYXRpbmcgPSBmYWxzZTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHJlbG9hZChpZCwgbmV3Q29tcCkge1xyXG4gICAgY29uc3QgcmVjb3JkID0gbWFwLmdldChpZCk7XHJcbiAgICBpZiAoIXJlY29yZClcclxuICAgICAgICByZXR1cm47XHJcbiAgICAvLyBBcnJheS5mcm9tIGNyZWF0ZXMgYSBzbmFwc2hvdCB3aGljaCBhdm9pZHMgdGhlIHNldCBiZWluZyBtdXRhdGVkIGR1cmluZ1xyXG4gICAgLy8gdXBkYXRlc1xyXG4gICAgY29uc3QgeyBjb21wb25lbnQsIGluc3RhbmNlcyB9ID0gcmVjb3JkO1xyXG4gICAgaWYgKCFobXJEaXJ0eUNvbXBvbmVudHMuaGFzKGNvbXBvbmVudCkpIHtcclxuICAgICAgICAvLyAxLiBVcGRhdGUgZXhpc3RpbmcgY29tcCBkZWZpbml0aW9uIHRvIG1hdGNoIG5ldyBvbmVcclxuICAgICAgICBuZXdDb21wID0gaXNDbGFzc0NvbXBvbmVudChuZXdDb21wKSA/IG5ld0NvbXAuX192Y2NPcHRzIDogbmV3Q29tcDtcclxuICAgICAgICBleHRlbmQoY29tcG9uZW50LCBuZXdDb21wKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjb21wb25lbnQpIHtcclxuICAgICAgICAgICAgaWYgKGtleSAhPT0gJ19fZmlsZScgJiYgIShrZXkgaW4gbmV3Q29tcCkpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBjb21wb25lbnRba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyAyLiBNYXJrIGNvbXBvbmVudCBkaXJ0eS4gVGhpcyBmb3JjZXMgdGhlIHJlbmRlcmVyIHRvIHJlcGxhY2UgdGhlIGNvbXBvbmVudFxyXG4gICAgICAgIC8vIG9uIHBhdGNoLlxyXG4gICAgICAgIGhtckRpcnR5Q29tcG9uZW50cy5hZGQoY29tcG9uZW50KTtcclxuICAgICAgICAvLyAzLiBNYWtlIHN1cmUgdG8gdW5tYXJrIHRoZSBjb21wb25lbnQgYWZ0ZXIgdGhlIHJlbG9hZC5cclxuICAgICAgICBxdWV1ZVBvc3RGbHVzaENiKCgpID0+IHtcclxuICAgICAgICAgICAgaG1yRGlydHlDb21wb25lbnRzLmRlbGV0ZShjb21wb25lbnQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgQXJyYXkuZnJvbShpbnN0YW5jZXMpLmZvckVhY2goaW5zdGFuY2UgPT4ge1xyXG4gICAgICAgIGlmIChpbnN0YW5jZS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgLy8gNC4gRm9yY2UgdGhlIHBhcmVudCBpbnN0YW5jZSB0byByZS1yZW5kZXIuIFRoaXMgd2lsbCBjYXVzZSBhbGwgdXBkYXRlZFxyXG4gICAgICAgICAgICAvLyBjb21wb25lbnRzIHRvIGJlIHVubW91bnRlZCBhbmQgcmUtbW91bnRlZC4gUXVldWUgdGhlIHVwZGF0ZSBzbyB0aGF0IHdlXHJcbiAgICAgICAgICAgIC8vIGRvbid0IGVuZCB1cCBmb3JjaW5nIHRoZSBzYW1lIHBhcmVudCB0byByZS1yZW5kZXIgbXVsdGlwbGUgdGltZXMuXHJcbiAgICAgICAgICAgIHF1ZXVlSm9iKGluc3RhbmNlLnBhcmVudC51cGRhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpbnN0YW5jZS5hcHBDb250ZXh0LnJlbG9hZCkge1xyXG4gICAgICAgICAgICAvLyByb290IGluc3RhbmNlIG1vdW50ZWQgdmlhIGNyZWF0ZUFwcCgpIGhhcyBhIHJlbG9hZCBtZXRob2RcclxuICAgICAgICAgICAgaW5zdGFuY2UuYXBwQ29udGV4dC5yZWxvYWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgLy8gcm9vdCBpbnN0YW5jZSBpbnNpZGUgdHJlZSBjcmVhdGVkIHZpYSByYXcgcmVuZGVyKCkuIEZvcmNlIHJlbG9hZC5cclxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdbSE1SXSBSb290IG9yIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UgbW9kaWZpZWQuIEZ1bGwgcmVsb2FkIHJlcXVpcmVkLicpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHRyeVdyYXAoZm4pIHtcclxuICAgIHJldHVybiAoaWQsIGFyZykgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmbihpZCwgYXJnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBbSE1SXSBTb21ldGhpbmcgd2VudCB3cm9uZyBkdXJpbmcgVnVlIGNvbXBvbmVudCBob3QtcmVsb2FkLiBgICtcclxuICAgICAgICAgICAgICAgIGBGdWxsIHJlbG9hZCByZXF1aXJlZC5gKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XG5cbmxldCBkZXZ0b29scztcclxuZnVuY3Rpb24gc2V0RGV2dG9vbHNIb29rKGhvb2spIHtcclxuICAgIGRldnRvb2xzID0gaG9vaztcclxufVxyXG5mdW5jdGlvbiBkZXZ0b29sc0luaXRBcHAoYXBwLCB2ZXJzaW9uKSB7XHJcbiAgICAvLyBUT0RPIHF1ZXVlIGlmIGRldnRvb2xzIGlzIHVuZGVmaW5lZFxyXG4gICAgaWYgKCFkZXZ0b29scylcclxuICAgICAgICByZXR1cm47XHJcbiAgICBkZXZ0b29scy5lbWl0KFwiYXBwOmluaXRcIiAvKiBBUFBfSU5JVCAqLywgYXBwLCB2ZXJzaW9uLCB7XHJcbiAgICAgICAgRnJhZ21lbnQsXHJcbiAgICAgICAgVGV4dCxcclxuICAgICAgICBDb21tZW50OiBDb21tZW50JDEsXHJcbiAgICAgICAgU3RhdGljXHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBkZXZ0b29sc1VubW91bnRBcHAoYXBwKSB7XHJcbiAgICBpZiAoIWRldnRvb2xzKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIGRldnRvb2xzLmVtaXQoXCJhcHA6dW5tb3VudFwiIC8qIEFQUF9VTk1PVU5UICovLCBhcHApO1xyXG59XHJcbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50QWRkZWQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhcImNvbXBvbmVudDphZGRlZFwiIC8qIENPTVBPTkVOVF9BRERFRCAqLyk7XHJcbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50VXBkYXRlZCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKFwiY29tcG9uZW50OnVwZGF0ZWRcIiAvKiBDT01QT05FTlRfVVBEQVRFRCAqLyk7XHJcbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50UmVtb3ZlZCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKFwiY29tcG9uZW50OnJlbW92ZWRcIiAvKiBDT01QT05FTlRfUkVNT1ZFRCAqLyk7XHJcbmZ1bmN0aW9uIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhob29rKSB7XHJcbiAgICByZXR1cm4gKGNvbXBvbmVudCkgPT4ge1xyXG4gICAgICAgIGlmICghZGV2dG9vbHMpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBkZXZ0b29scy5lbWl0KGhvb2ssIGNvbXBvbmVudC5hcHBDb250ZXh0LmFwcCwgY29tcG9uZW50LnVpZCwgY29tcG9uZW50LnBhcmVudCA/IGNvbXBvbmVudC5wYXJlbnQudWlkIDogdW5kZWZpbmVkLCBjb21wb25lbnQpO1xyXG4gICAgfTtcclxufVxyXG5jb25zdCBkZXZ0b29sc1BlcmZTdGFydCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlRGV2dG9vbHNQZXJmb3JtYW5jZUhvb2soXCJwZXJmOnN0YXJ0XCIgLyogUEVSRk9STUFOQ0VfU1RBUlQgKi8pO1xyXG5jb25zdCBkZXZ0b29sc1BlcmZFbmQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZURldnRvb2xzUGVyZm9ybWFuY2VIb29rKFwicGVyZjplbmRcIiAvKiBQRVJGT1JNQU5DRV9FTkQgKi8pO1xyXG5mdW5jdGlvbiBjcmVhdGVEZXZ0b29sc1BlcmZvcm1hbmNlSG9vayhob29rKSB7XHJcbiAgICByZXR1cm4gKGNvbXBvbmVudCwgdHlwZSwgdGltZSkgPT4ge1xyXG4gICAgICAgIGlmICghZGV2dG9vbHMpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBkZXZ0b29scy5lbWl0KGhvb2ssIGNvbXBvbmVudC5hcHBDb250ZXh0LmFwcCwgY29tcG9uZW50LnVpZCwgY29tcG9uZW50LCB0eXBlLCB0aW1lKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZGV2dG9vbHNDb21wb25lbnRFbWl0KGNvbXBvbmVudCwgZXZlbnQsIHBhcmFtcykge1xyXG4gICAgaWYgKCFkZXZ0b29scylcclxuICAgICAgICByZXR1cm47XHJcbiAgICBkZXZ0b29scy5lbWl0KFwiY29tcG9uZW50OmVtaXRcIiAvKiBDT01QT05FTlRfRU1JVCAqLywgY29tcG9uZW50LmFwcENvbnRleHQuYXBwLCBjb21wb25lbnQsIGV2ZW50LCBwYXJhbXMpO1xyXG59XG5cbmNvbnN0IGRlcHJlY2F0aW9uRGF0YSA9IHtcclxuICAgIFtcIkdMT0JBTF9NT1VOVFwiIC8qIEdMT0JBTF9NT1VOVCAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgVGhlIGdsb2JhbCBhcHAgYm9vdHN0cmFwcGluZyBBUEkgaGFzIGNoYW5nZWQ6IHZtLiRtb3VudCgpIGFuZCB0aGUgXCJlbFwiIGAgK1xyXG4gICAgICAgICAgICBgb3B0aW9uIGhhdmUgYmVlbiByZW1vdmVkLiBVc2UgY3JlYXRlQXBwKFJvb3RDb21wb25lbnQpLm1vdW50KCkgaW5zdGVhZC5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vZ2xvYmFsLWFwaS5odG1sI21vdW50aW5nLWFwcC1pbnN0YW5jZWBcclxuICAgIH0sXHJcbiAgICBbXCJHTE9CQUxfTU9VTlRfQ09OVEFJTkVSXCIgLyogR0xPQkFMX01PVU5UX0NPTlRBSU5FUiAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgVnVlIGRldGVjdGVkIGRpcmVjdGl2ZXMgb24gdGhlIG1vdW50IGNvbnRhaW5lci4gYCArXHJcbiAgICAgICAgICAgIGBJbiBWdWUgMywgdGhlIGNvbnRhaW5lciBpcyBubyBsb25nZXIgY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSB0ZW1wbGF0ZSBgICtcclxuICAgICAgICAgICAgYGFuZCB3aWxsIG5vdCBiZSBwcm9jZXNzZWQvcmVwbGFjZWQuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL21vdW50LWNoYW5nZXMuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJHTE9CQUxfRVhURU5EXCIgLyogR0xPQkFMX0VYVEVORCAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgVnVlLmV4dGVuZCgpIGhhcyBiZWVuIHJlbW92ZWQgaW4gVnVlIDMuIGAgK1xyXG4gICAgICAgICAgICBgVXNlIGRlZmluZUNvbXBvbmVudCgpIGluc3RlYWQuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvYXBpL2dsb2JhbC1hcGkuaHRtbCNkZWZpbmVjb21wb25lbnRgXHJcbiAgICB9LFxyXG4gICAgW1wiR0xPQkFMX1BST1RPVFlQRVwiIC8qIEdMT0JBTF9QUk9UT1RZUEUgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYFZ1ZS5wcm90b3R5cGUgaXMgbm8gbG9uZ2VyIGF2YWlsYWJsZSBpbiBWdWUgMy4gYCArXHJcbiAgICAgICAgICAgIGBVc2UgYXBwLmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzIGluc3RlYWQuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL2dsb2JhbC1hcGkuaHRtbCN2dWUtcHJvdG90eXBlLXJlcGxhY2VkLWJ5LWNvbmZpZy1nbG9iYWxwcm9wZXJ0aWVzYFxyXG4gICAgfSxcclxuICAgIFtcIkdMT0JBTF9TRVRcIiAvKiBHTE9CQUxfU0VUICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGBWdWUuc2V0KCkgaGFzIGJlZW4gcmVtb3ZlZCBhcyBpdCBpcyBubyBsb25nZXIgbmVlZGVkIGluIFZ1ZSAzLiBgICtcclxuICAgICAgICAgICAgYFNpbXBseSB1c2UgbmF0aXZlIEphdmFTY3JpcHQgbXV0YXRpb25zLmBcclxuICAgIH0sXHJcbiAgICBbXCJHTE9CQUxfREVMRVRFXCIgLyogR0xPQkFMX0RFTEVURSAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgVnVlLmRlbGV0ZSgpIGhhcyBiZWVuIHJlbW92ZWQgYXMgaXQgaXMgbm8gbG9uZ2VyIG5lZWRlZCBpbiBWdWUgMy4gYCArXHJcbiAgICAgICAgICAgIGBTaW1wbHkgdXNlIG5hdGl2ZSBKYXZhU2NyaXB0IG11dGF0aW9ucy5gXHJcbiAgICB9LFxyXG4gICAgW1wiR0xPQkFMX09CU0VSVkFCTEVcIiAvKiBHTE9CQUxfT0JTRVJWQUJMRSAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgVnVlLm9ic2VydmFibGUoKSBoYXMgYmVlbiByZW1vdmVkLiBgICtcclxuICAgICAgICAgICAgYFVzZSBcXGBpbXBvcnQgeyByZWFjdGl2ZSB9IGZyb20gXCJ2dWVcIlxcYCBmcm9tIENvbXBvc2l0aW9uIEFQSSBpbnN0ZWFkLmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMudnVlanMub3JnL2FwaS9iYXNpYy1yZWFjdGl2aXR5Lmh0bWxgXHJcbiAgICB9LFxyXG4gICAgW1wiR0xPQkFMX1BSSVZBVEVfVVRJTFwiIC8qIEdMT0JBTF9QUklWQVRFX1VUSUwgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYFZ1ZS51dGlsIGhhcyBiZWVuIHJlbW92ZWQuIFBsZWFzZSByZWZhY3RvciB0byBhdm9pZCBpdHMgdXNhZ2UgYCArXHJcbiAgICAgICAgICAgIGBzaW5jZSBpdCB3YXMgYW4gaW50ZXJuYWwgQVBJIGV2ZW4gaW4gVnVlIDIuYFxyXG4gICAgfSxcclxuICAgIFtcIkNPTkZJR19TSUxFTlRcIiAvKiBDT05GSUdfU0lMRU5UICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGBjb25maWcuc2lsZW50IGhhcyBiZWVuIHJlbW92ZWQgYmVjYXVzZSBpdCBpcyBub3QgZ29vZCBwcmFjdGljZSB0byBgICtcclxuICAgICAgICAgICAgYGludGVudGlvbmFsbHkgc3VwcHJlc3Mgd2FybmluZ3MuIFlvdSBjYW4gdXNlIHlvdXIgYnJvd3NlciBjb25zb2xlJ3MgYCArXHJcbiAgICAgICAgICAgIGBmaWx0ZXIgZmVhdHVyZXMgdG8gZm9jdXMgb24gcmVsZXZhbnQgbWVzc2FnZXMuYFxyXG4gICAgfSxcclxuICAgIFtcIkNPTkZJR19ERVZUT09MU1wiIC8qIENPTkZJR19ERVZUT09MUyAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgY29uZmlnLmRldnRvb2xzIGhhcyBiZWVuIHJlbW92ZWQuIFRvIGVuYWJsZSBkZXZ0b29scyBmb3IgYCArXHJcbiAgICAgICAgICAgIGBwcm9kdWN0aW9uLCBjb25maWd1cmUgdGhlIF9fVlVFX1BST0RfREVWVE9PTFNfXyBjb21waWxlLXRpbWUgZmxhZy5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlLW5leHQvdHJlZS9tYXN0ZXIvcGFja2FnZXMvdnVlI2J1bmRsZXItYnVpbGQtZmVhdHVyZS1mbGFnc2BcclxuICAgIH0sXHJcbiAgICBbXCJDT05GSUdfS0VZX0NPREVTXCIgLyogQ09ORklHX0tFWV9DT0RFUyAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgY29uZmlnLmtleUNvZGVzIGhhcyBiZWVuIHJlbW92ZWQuIGAgK1xyXG4gICAgICAgICAgICBgSW4gVnVlIDMsIHlvdSBjYW4gZGlyZWN0bHkgdXNlIHRoZSBrZWJhYi1jYXNlIGtleSBuYW1lcyBhcyB2LW9uIG1vZGlmaWVycy5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24va2V5Y29kZS1tb2RpZmllcnMuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJDT05GSUdfUFJPRFVDVElPTl9USVBcIiAvKiBDT05GSUdfUFJPRFVDVElPTl9USVAgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYGNvbmZpZy5wcm9kdWN0aW9uVGlwIGhhcyBiZWVuIHJlbW92ZWQuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL2dsb2JhbC1hcGkuaHRtbCNjb25maWctcHJvZHVjdGlvbnRpcC1yZW1vdmVkYFxyXG4gICAgfSxcclxuICAgIFtcIkNPTkZJR19JR05PUkVEX0VMRU1FTlRTXCIgLyogQ09ORklHX0lHTk9SRURfRUxFTUVOVFMgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogKCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgbXNnID0gYGNvbmZpZy5pZ25vcmVkRWxlbWVudHMgaGFzIGJlZW4gcmVtb3ZlZC5gO1xyXG4gICAgICAgICAgICBpZiAoaXNSdW50aW1lT25seSgpKSB7XHJcbiAgICAgICAgICAgICAgICBtc2cgKz0gYCBQYXNzIHRoZSBcImlzQ3VzdG9tRWxlbWVudFwiIG9wdGlvbiB0byBAdnVlL2NvbXBpbGVyLWRvbSBpbnN0ZWFkLmA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtc2cgKz0gYCBVc2UgY29uZmlnLmlzQ3VzdG9tRWxlbWVudCBpbnN0ZWFkLmA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1zZztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vZ2xvYmFsLWFwaS5odG1sI2NvbmZpZy1pZ25vcmVkZWxlbWVudHMtaXMtbm93LWNvbmZpZy1pc2N1c3RvbWVsZW1lbnRgXHJcbiAgICB9LFxyXG4gICAgW1wiQ09ORklHX1dISVRFU1BBQ0VcIiAvKiBDT05GSUdfV0hJVEVTUEFDRSAqL106IHtcclxuICAgICAgICAvLyB0aGlzIHdhcm5pbmcgaXMgb25seSByZWxldmFudCBpbiB0aGUgZnVsbCBidWlsZCB3aGVuIHVzaW5nIHJ1bnRpbWVcclxuICAgICAgICAvLyBjb21waWxhdGlvbiwgc28gaXQncyBwdXQgaW4gdGhlIHJ1bnRpbWUgY29tcGF0Q29uZmlnIGxpc3QuXHJcbiAgICAgICAgbWVzc2FnZTogYFZ1ZSAzIGNvbXBpbGVyJ3Mgd2hpdGVzcGFjZSBvcHRpb24gd2lsbCBkZWZhdWx0IHRvIFwiY29uZGVuc2VcIiBpbnN0ZWFkIG9mIGAgK1xyXG4gICAgICAgICAgICBgXCJwcmVzZXJ2ZVwiLiBUbyBzdXBwcmVzcyB0aGlzIHdhcm5pbmcsIHByb3ZpZGUgYW4gZXhwbGljaXQgdmFsdWUgZm9yIGAgK1xyXG4gICAgICAgICAgICBgXFxgY29uZmlnLmNvbXBpbGVyT3B0aW9ucy53aGl0ZXNwYWNlXFxgLmBcclxuICAgIH0sXHJcbiAgICBbXCJDT05GSUdfT1BUSU9OX01FUkdFX1NUUkFUU1wiIC8qIENPTkZJR19PUFRJT05fTUVSR0VfU1RSQVRTICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGBjb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzIG5vIGxvbmdlciBleHBvc2VzIGludGVybmFsIHN0cmF0ZWdpZXMuIGAgK1xyXG4gICAgICAgICAgICBgVXNlIGN1c3RvbSBtZXJnZSBmdW5jdGlvbnMgaW5zdGVhZC5gXHJcbiAgICB9LFxyXG4gICAgW1wiSU5TVEFOQ0VfU0VUXCIgLyogSU5TVEFOQ0VfU0VUICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGB2bS4kc2V0KCkgaGFzIGJlZW4gcmVtb3ZlZCBhcyBpdCBpcyBubyBsb25nZXIgbmVlZGVkIGluIFZ1ZSAzLiBgICtcclxuICAgICAgICAgICAgYFNpbXBseSB1c2UgbmF0aXZlIEphdmFTY3JpcHQgbXV0YXRpb25zLmBcclxuICAgIH0sXHJcbiAgICBbXCJJTlNUQU5DRV9ERUxFVEVcIiAvKiBJTlNUQU5DRV9ERUxFVEUgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYHZtLiRkZWxldGUoKSBoYXMgYmVlbiByZW1vdmVkIGFzIGl0IGlzIG5vIGxvbmdlciBuZWVkZWQgaW4gVnVlIDMuIGAgK1xyXG4gICAgICAgICAgICBgU2ltcGx5IHVzZSBuYXRpdmUgSmF2YVNjcmlwdCBtdXRhdGlvbnMuYFxyXG4gICAgfSxcclxuICAgIFtcIklOU1RBTkNFX0RFU1RST1lcIiAvKiBJTlNUQU5DRV9ERVNUUk9ZICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGB2bS4kZGVzdHJveSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBhcHAudW5tb3VudCgpIGluc3RlYWQuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvYXBpL2FwcGxpY2F0aW9uLWFwaS5odG1sI3VubW91bnRgXHJcbiAgICB9LFxyXG4gICAgW1wiSU5TVEFOQ0VfRVZFTlRfRU1JVFRFUlwiIC8qIElOU1RBTkNFX0VWRU5UX0VNSVRURVIgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYHZtLiRvbi8kb25jZS8kb2ZmKCkgaGF2ZSBiZWVuIHJlbW92ZWQuIGAgK1xyXG4gICAgICAgICAgICBgVXNlIGFuIGV4dGVybmFsIGV2ZW50IGVtaXR0ZXIgbGlicmFyeSBpbnN0ZWFkLmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMudnVlanMub3JnL2d1aWRlL21pZ3JhdGlvbi9ldmVudHMtYXBpLmh0bWxgXHJcbiAgICB9LFxyXG4gICAgW1wiSU5TVEFOQ0VfRVZFTlRfSE9PS1NcIiAvKiBJTlNUQU5DRV9FVkVOVF9IT09LUyAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBldmVudCA9PiBgXCIke2V2ZW50fVwiIGxpZmVjeWNsZSBldmVudHMgYXJlIG5vIGxvbmdlciBzdXBwb3J0ZWQuIEZyb20gdGVtcGxhdGVzLCBgICtcclxuICAgICAgICAgICAgYHVzZSB0aGUgXCJ2bm9kZVwiIHByZWZpeCBpbnN0ZWFkIG9mIFwiaG9vazpcIi4gRm9yIGV4YW1wbGUsIEAke2V2ZW50fSBgICtcclxuICAgICAgICAgICAgYHNob3VsZCBiZSBjaGFuZ2VkIHRvIEB2bm9kZS0ke2V2ZW50LnNsaWNlKDUpfS4gYCArXHJcbiAgICAgICAgICAgIGBGcm9tIEphdmFTY3JpcHQsIHVzZSBDb21wb3NpdGlvbiBBUEkgdG8gZHluYW1pY2FsbHkgcmVnaXN0ZXIgbGlmZWN5Y2xlIGAgK1xyXG4gICAgICAgICAgICBgaG9va3MuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL3Zub2RlLWxpZmVjeWNsZS1ldmVudHMuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJJTlNUQU5DRV9DSElMRFJFTlwiIC8qIElOU1RBTkNFX0NISUxEUkVOICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGB2bS4kY2hpbGRyZW4gaGFzIGJlZW4gcmVtb3ZlZC4gQ29uc2lkZXIgcmVmYWN0b3JpbmcgeW91ciBsb2dpYyBgICtcclxuICAgICAgICAgICAgYHRvIGF2b2lkIHJlbHlpbmcgb24gZGlyZWN0IGFjY2VzcyB0byBjaGlsZCBjb21wb25lbnRzLmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMudnVlanMub3JnL2d1aWRlL21pZ3JhdGlvbi9jaGlsZHJlbi5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIklOU1RBTkNFX0xJU1RFTkVSU1wiIC8qIElOU1RBTkNFX0xJU1RFTkVSUyAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgdm0uJGxpc3RlbmVycyBoYXMgYmVlbiByZW1vdmVkLiBJbiBWdWUgMywgcGFyZW50IHYtb24gbGlzdGVuZXJzIGFyZSBgICtcclxuICAgICAgICAgICAgYGluY2x1ZGVkIGluIHZtLiRhdHRycyBhbmQgaXQgaXMgbm8gbG9uZ2VyIG5lY2Vzc2FyeSB0byBzZXBhcmF0ZWx5IHVzZSBgICtcclxuICAgICAgICAgICAgYHYtb249XCIkbGlzdGVuZXJzXCIgaWYgeW91IGFyZSBhbHJlYWR5IHVzaW5nIHYtYmluZD1cIiRhdHRyc1wiLiBgICtcclxuICAgICAgICAgICAgYChOb3RlOiB0aGUgVnVlIDMgYmVoYXZpb3Igb25seSBhcHBsaWVzIGlmIHRoaXMgY29tcGF0IGNvbmZpZyBpcyBkaXNhYmxlZClgLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vbGlzdGVuZXJzLXJlbW92ZWQuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJJTlNUQU5DRV9TQ09QRURfU0xPVFNcIiAvKiBJTlNUQU5DRV9TQ09QRURfU0xPVFMgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYHZtLiRzY29wZWRTbG90cyBoYXMgYmVlbiByZW1vdmVkLiBVc2Ugdm0uJHNsb3RzIGluc3RlYWQuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL3Nsb3RzLXVuaWZpY2F0aW9uLmh0bWxgXHJcbiAgICB9LFxyXG4gICAgW1wiSU5TVEFOQ0VfQVRUUlNfQ0xBU1NfU1RZTEVcIiAvKiBJTlNUQU5DRV9BVFRSU19DTEFTU19TVFlMRSAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBjb21wb25lbnROYW1lID0+IGBDb21wb25lbnQgPCR7Y29tcG9uZW50TmFtZSB8fFxyXG4gICAgICAgICAgICAnQW5vbnltb3VzJ30+IGhhcyBcXGBpbmhlcml0QXR0cnM6IGZhbHNlXFxgIGJ1dCBpcyBgICtcclxuICAgICAgICAgICAgYHJlbHlpbmcgb24gY2xhc3Mvc3R5bGUgZmFsbHRocm91Z2ggZnJvbSBwYXJlbnQuIEluIFZ1ZSAzLCBjbGFzcy9zdHlsZSBgICtcclxuICAgICAgICAgICAgYGFyZSBub3cgaW5jbHVkZWQgaW4gJGF0dHJzIGFuZCB3aWxsIG5vIGxvbmdlciBmYWxsdGhyb3VnaCB3aGVuIGAgK1xyXG4gICAgICAgICAgICBgaW5oZXJpdEF0dHJzIGlzIGZhbHNlLiBJZiB5b3UgYXJlIGFscmVhZHkgdXNpbmcgdi1iaW5kPVwiJGF0dHJzXCIgb24gYCArXHJcbiAgICAgICAgICAgIGBjb21wb25lbnQgcm9vdCBpdCBzaG91bGQgcmVuZGVyIHRoZSBzYW1lIGVuZCByZXN1bHQuIGAgK1xyXG4gICAgICAgICAgICBgSWYgeW91IGFyZSBiaW5kaW5nICRhdHRycyB0byBhIG5vbi1yb290IGVsZW1lbnQgYW5kIGV4cGVjdGluZyBgICtcclxuICAgICAgICAgICAgYGNsYXNzL3N0eWxlIHRvIGZhbGx0aHJvdWdoIG9uIHJvb3QsIHlvdSB3aWxsIG5lZWQgdG8gbm93IG1hbnVhbGx5IGJpbmQgYCArXHJcbiAgICAgICAgICAgIGB0aGVtIG9uIHJvb3QgdmlhIDpjbGFzcz1cIiRhdHRycy5jbGFzc1wiLmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMudnVlanMub3JnL2d1aWRlL21pZ3JhdGlvbi9hdHRycy1pbmNsdWRlcy1jbGFzcy1zdHlsZS5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIk9QVElPTlNfREFUQV9GTlwiIC8qIE9QVElPTlNfREFUQV9GTiAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgVGhlIFwiZGF0YVwiIG9wdGlvbiBjYW4gbm8gbG9uZ2VyIGJlIGEgcGxhaW4gb2JqZWN0LiBgICtcclxuICAgICAgICAgICAgYEFsd2F5cyB1c2UgYSBmdW5jdGlvbi5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vZGF0YS1vcHRpb24uaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJPUFRJT05TX0RBVEFfTUVSR0VcIiAvKiBPUFRJT05TX0RBVEFfTUVSR0UgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogKGtleSkgPT4gYERldGVjdGVkIGNvbmZsaWN0aW5nIGtleSBcIiR7a2V5fVwiIHdoZW4gbWVyZ2luZyBkYXRhIG9wdGlvbiB2YWx1ZXMuIGAgK1xyXG4gICAgICAgICAgICBgSW4gVnVlIDMsIGRhdGEga2V5cyBhcmUgbWVyZ2VkIHNoYWxsb3dseSBhbmQgd2lsbCBvdmVycmlkZSBvbmUgYW5vdGhlci5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vZGF0YS1vcHRpb24uaHRtbCNtaXhpbi1tZXJnZS1iZWhhdmlvci1jaGFuZ2VgXHJcbiAgICB9LFxyXG4gICAgW1wiT1BUSU9OU19CRUZPUkVfREVTVFJPWVwiIC8qIE9QVElPTlNfQkVGT1JFX0RFU1RST1kgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYFxcYGJlZm9yZURlc3Ryb3lcXGAgaGFzIGJlZW4gcmVuYW1lZCB0byBcXGBiZWZvcmVVbm1vdW50XFxgLmBcclxuICAgIH0sXHJcbiAgICBbXCJPUFRJT05TX0RFU1RST1lFRFwiIC8qIE9QVElPTlNfREVTVFJPWUVEICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGBcXGBkZXN0cm95ZWRcXGAgaGFzIGJlZW4gcmVuYW1lZCB0byBcXGB1bm1vdW50ZWRcXGAuYFxyXG4gICAgfSxcclxuICAgIFtcIldBVENIX0FSUkFZXCIgLyogV0FUQ0hfQVJSQVkgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYFwid2F0Y2hcIiBvcHRpb24gb3Igdm0uJHdhdGNoIG9uIGFuIGFycmF5IHZhbHVlIHdpbGwgbm8gbG9uZ2VyIGAgK1xyXG4gICAgICAgICAgICBgdHJpZ2dlciBvbiBhcnJheSBtdXRhdGlvbiB1bmxlc3MgdGhlIFwiZGVlcFwiIG9wdGlvbiBpcyBzcGVjaWZpZWQuIGAgK1xyXG4gICAgICAgICAgICBgSWYgY3VycmVudCB1c2FnZSBpcyBpbnRlbmRlZCwgeW91IGNhbiBkaXNhYmxlIHRoZSBjb21wYXQgYmVoYXZpb3IgYW5kIGAgK1xyXG4gICAgICAgICAgICBgc3VwcHJlc3MgdGhpcyB3YXJuaW5nIHdpdGg6YCArXHJcbiAgICAgICAgICAgIGBcXG5cXG4gIGNvbmZpZ3VyZUNvbXBhdCh7ICR7XCJXQVRDSF9BUlJBWVwiIC8qIFdBVENIX0FSUkFZICovfTogZmFsc2UgfSlcXG5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vd2F0Y2guaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJQUk9QU19ERUZBVUxUX1RISVNcIiAvKiBQUk9QU19ERUZBVUxUX1RISVMgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogKGtleSkgPT4gYHByb3BzIGRlZmF1bHQgdmFsdWUgZnVuY3Rpb24gbm8gbG9uZ2VyIGhhcyBhY2Nlc3MgdG8gXCJ0aGlzXCIuIFRoZSBjb21wYXQgYCArXHJcbiAgICAgICAgICAgIGBidWlsZCBvbmx5IG9mZmVycyBhY2Nlc3MgdG8gdGhpcy4kb3B0aW9ucy5gICtcclxuICAgICAgICAgICAgYChmb3VuZCBpbiBwcm9wIFwiJHtrZXl9XCIpYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL3Byb3BzLWRlZmF1bHQtdGhpcy5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIkNVU1RPTV9ESVJcIiAvKiBDVVNUT01fRElSICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IChsZWdhY3lIb29rLCBuZXdIb29rKSA9PiBgQ3VzdG9tIGRpcmVjdGl2ZSBob29rIFwiJHtsZWdhY3lIb29rfVwiIGhhcyBiZWVuIHJlbW92ZWQuIGAgK1xyXG4gICAgICAgICAgICBgVXNlIFwiJHtuZXdIb29rfVwiIGluc3RlYWQuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL2N1c3RvbS1kaXJlY3RpdmVzLmh0bWxgXHJcbiAgICB9LFxyXG4gICAgW1wiVl9GT1JfUkVGXCIgLyogVl9GT1JfUkVGICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGBSZWYgdXNhZ2Ugb24gdi1mb3Igbm8gbG9uZ2VyIGNyZWF0ZXMgYXJyYXkgcmVmIHZhbHVlcyBpbiBWdWUgMy4gYCArXHJcbiAgICAgICAgICAgIGBDb25zaWRlciB1c2luZyBmdW5jdGlvbiByZWZzIG9yIHJlZmFjdG9yIHRvIGF2b2lkIHJlZiB1c2FnZSBhbHRvZ2V0aGVyLmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMudnVlanMub3JnL2d1aWRlL21pZ3JhdGlvbi9hcnJheS1yZWZzLmh0bWxgXHJcbiAgICB9LFxyXG4gICAgW1wiVl9PTl9LRVlDT0RFX01PRElGSUVSXCIgLyogVl9PTl9LRVlDT0RFX01PRElGSUVSICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGBVc2luZyBrZXlDb2RlIGFzIHYtb24gbW9kaWZpZXIgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gYCArXHJcbiAgICAgICAgICAgIGBVc2Uga2ViYWItY2FzZSBrZXkgbmFtZSBtb2RpZmllcnMgaW5zdGVhZC5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24va2V5Y29kZS1tb2RpZmllcnMuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJBVFRSX0ZBTFNFX1ZBTFVFXCIgLyogQVRUUl9GQUxTRV9WQUxVRSAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiAobmFtZSkgPT4gYEF0dHJpYnV0ZSBcIiR7bmFtZX1cIiB3aXRoIHYtYmluZCB2YWx1ZSBcXGBmYWxzZVxcYCB3aWxsIHJlbmRlciBgICtcclxuICAgICAgICAgICAgYCR7bmFtZX09XCJmYWxzZVwiIGluc3RlYWQgb2YgcmVtb3ZpbmcgaXQgaW4gVnVlIDMuIFRvIHJlbW92ZSB0aGUgYXR0cmlidXRlLCBgICtcclxuICAgICAgICAgICAgYHVzZSBcXGBudWxsXFxgIG9yIFxcYHVuZGVmaW5lZFxcYCBpbnN0ZWFkLiBJZiB0aGUgdXNhZ2UgaXMgaW50ZW5kZWQsIGAgK1xyXG4gICAgICAgICAgICBgeW91IGNhbiBkaXNhYmxlIHRoZSBjb21wYXQgYmVoYXZpb3IgYW5kIHN1cHByZXNzIHRoaXMgd2FybmluZyB3aXRoOmAgK1xyXG4gICAgICAgICAgICBgXFxuXFxuICBjb25maWd1cmVDb21wYXQoeyAke1wiQVRUUl9GQUxTRV9WQUxVRVwiIC8qIEFUVFJfRkFMU0VfVkFMVUUgKi99OiBmYWxzZSB9KVxcbmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMudnVlanMub3JnL2d1aWRlL21pZ3JhdGlvbi9hdHRyaWJ1dGUtY29lcmNpb24uaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJBVFRSX0VOVU1FUkFURURfQ09FUkNJT05cIiAvKiBBVFRSX0VOVU1FUkFURURfQ09FUkNJT04gKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogKG5hbWUsIHZhbHVlLCBjb2VyY2VkKSA9PiBgRW51bWVyYXRlZCBhdHRyaWJ1dGUgXCIke25hbWV9XCIgd2l0aCB2LWJpbmQgdmFsdWUgXFxgJHt2YWx1ZX1cXGAgd2lsbCBgICtcclxuICAgICAgICAgICAgYCR7dmFsdWUgPT09IG51bGwgPyBgYmUgcmVtb3ZlZGAgOiBgcmVuZGVyIHRoZSB2YWx1ZSBhcy1pc2B9IGluc3RlYWQgb2YgY29lcmNpbmcgdGhlIHZhbHVlIHRvIFwiJHtjb2VyY2VkfVwiIGluIFZ1ZSAzLiBgICtcclxuICAgICAgICAgICAgYEFsd2F5cyB1c2UgZXhwbGljaXQgXCJ0cnVlXCIgb3IgXCJmYWxzZVwiIHZhbHVlcyBmb3IgZW51bWVyYXRlZCBhdHRyaWJ1dGVzLiBgICtcclxuICAgICAgICAgICAgYElmIHRoZSB1c2FnZSBpcyBpbnRlbmRlZCwgYCArXHJcbiAgICAgICAgICAgIGB5b3UgY2FuIGRpc2FibGUgdGhlIGNvbXBhdCBiZWhhdmlvciBhbmQgc3VwcHJlc3MgdGhpcyB3YXJuaW5nIHdpdGg6YCArXHJcbiAgICAgICAgICAgIGBcXG5cXG4gIGNvbmZpZ3VyZUNvbXBhdCh7ICR7XCJBVFRSX0VOVU1FUkFURURfQ09FUkNJT05cIiAvKiBBVFRSX0VOVU1FUkFURURfQ09FUkNJT04gKi99OiBmYWxzZSB9KVxcbmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMudnVlanMub3JnL2d1aWRlL21pZ3JhdGlvbi9hdHRyaWJ1dGUtY29lcmNpb24uaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJUUkFOU0lUSU9OX0NMQVNTRVNcIiAvKiBUUkFOU0lUSU9OX0NMQVNTRVMgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYGAgLy8gdGhpcyBmZWF0dXJlIGNhbm5vdCBiZSBydW50aW1lLWRldGVjdGVkXHJcbiAgICB9LFxyXG4gICAgW1wiVFJBTlNJVElPTl9HUk9VUF9ST09UXCIgLyogVFJBTlNJVElPTl9HUk9VUF9ST09UICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGA8VHJhbnNpdGlvbkdyb3VwPiBubyBsb25nZXIgcmVuZGVycyBhIHJvb3QgPHNwYW4+IGVsZW1lbnQgYnkgYCArXHJcbiAgICAgICAgICAgIGBkZWZhdWx0IGlmIG5vIFwidGFnXCIgcHJvcCBpcyBzcGVjaWZpZWQuIElmIHlvdSBkbyBub3QgcmVseSBvbiB0aGUgc3BhbiBgICtcclxuICAgICAgICAgICAgYGZvciBzdHlsaW5nLCB5b3UgY2FuIGRpc2FibGUgdGhlIGNvbXBhdCBiZWhhdmlvciBhbmQgc3VwcHJlc3MgdGhpcyBgICtcclxuICAgICAgICAgICAgYHdhcm5pbmcgd2l0aDpgICtcclxuICAgICAgICAgICAgYFxcblxcbiAgY29uZmlndXJlQ29tcGF0KHsgJHtcIlRSQU5TSVRJT05fR1JPVVBfUk9PVFwiIC8qIFRSQU5TSVRJT05fR1JPVVBfUk9PVCAqL306IGZhbHNlIH0pXFxuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL3RyYW5zaXRpb24tZ3JvdXAuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJDT01QT05FTlRfQVNZTkNcIiAvKiBDT01QT05FTlRfQVNZTkMgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogKGNvbXApID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY29tcCk7XHJcbiAgICAgICAgICAgIHJldHVybiAoYEFzeW5jIGNvbXBvbmVudCR7bmFtZSA/IGAgPCR7bmFtZX0+YCA6IGBzYH0gc2hvdWxkIGJlIGV4cGxpY2l0bHkgY3JlYXRlZCB2aWEgXFxgZGVmaW5lQXN5bmNDb21wb25lbnQoKVxcYCBgICtcclxuICAgICAgICAgICAgICAgIGBpbiBWdWUgMy4gUGxhaW4gZnVuY3Rpb25zIHdpbGwgYmUgdHJlYXRlZCBhcyBmdW5jdGlvbmFsIGNvbXBvbmVudHMgaW4gYCArXHJcbiAgICAgICAgICAgICAgICBgbm9uLWNvbXBhdCBidWlsZC4gSWYgeW91IGhhdmUgYWxyZWFkeSBtaWdyYXRlZCBhbGwgYXN5bmMgY29tcG9uZW50IGAgK1xyXG4gICAgICAgICAgICAgICAgYHVzYWdlIGFuZCBpbnRlbmQgdG8gdXNlIHBsYWluIGZ1bmN0aW9ucyBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnRzLCBgICtcclxuICAgICAgICAgICAgICAgIGB5b3UgY2FuIGRpc2FibGUgdGhlIGNvbXBhdCBiZWhhdmlvciBhbmQgc3VwcHJlc3MgdGhpcyBgICtcclxuICAgICAgICAgICAgICAgIGB3YXJuaW5nIHdpdGg6YCArXHJcbiAgICAgICAgICAgICAgICBgXFxuXFxuICBjb25maWd1cmVDb21wYXQoeyAke1wiQ09NUE9ORU5UX0FTWU5DXCIgLyogQ09NUE9ORU5UX0FTWU5DICovfTogZmFsc2UgfSlcXG5gKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vYXN5bmMtY29tcG9uZW50cy5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIkNPTVBPTkVOVF9GVU5DVElPTkFMXCIgLyogQ09NUE9ORU5UX0ZVTkNUSU9OQUwgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogKGNvbXApID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY29tcCk7XHJcbiAgICAgICAgICAgIHJldHVybiAoYEZ1bmN0aW9uYWwgY29tcG9uZW50JHtuYW1lID8gYCA8JHtuYW1lfT5gIDogYHNgfSBzaG91bGQgYmUgZGVmaW5lZCBhcyBhIHBsYWluIGZ1bmN0aW9uIGluIFZ1ZSAzLiBUaGUgXCJmdW5jdGlvbmFsXCIgYCArXHJcbiAgICAgICAgICAgICAgICBgb3B0aW9uIGhhcyBiZWVuIHJlbW92ZWQuIE5PVEU6IEJlZm9yZSBtaWdyYXRpbmcgdG8gdXNlIHBsYWluIGAgK1xyXG4gICAgICAgICAgICAgICAgYGZ1bmN0aW9ucyBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnRzLCBmaXJzdCBtYWtlIHN1cmUgdGhhdCBhbGwgYXN5bmMgYCArXHJcbiAgICAgICAgICAgICAgICBgY29tcG9uZW50cyB1c2FnZSBoYXZlIGJlZW4gbWlncmF0ZWQgYW5kIGl0cyBjb21wYXQgYmVoYXZpb3IgaGFzIGAgK1xyXG4gICAgICAgICAgICAgICAgYGJlZW4gZGlzYWJsZWQuYCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL2Z1bmN0aW9uYWwtY29tcG9uZW50cy5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIkNPTVBPTkVOVF9WX01PREVMXCIgLyogQ09NUE9ORU5UX1ZfTU9ERUwgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogKGNvbXApID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY29uZmlnTXNnID0gYG9wdC1pbiB0byBgICtcclxuICAgICAgICAgICAgICAgIGBWdWUgMyBiZWhhdmlvciBvbiBhIHBlci1jb21wb25lbnQgYmFzaXMgd2l0aCBcXGBjb21wYXRDb25maWc6IHsgJHtcIkNPTVBPTkVOVF9WX01PREVMXCIgLyogQ09NUE9ORU5UX1ZfTU9ERUwgKi99OiBmYWxzZSB9XFxgLmA7XHJcbiAgICAgICAgICAgIGlmIChjb21wLnByb3BzICYmIGlzQXJyYXkoY29tcC5wcm9wcylcclxuICAgICAgICAgICAgICAgID8gY29tcC5wcm9wcy5pbmNsdWRlcygnbW9kZWxWYWx1ZScpXHJcbiAgICAgICAgICAgICAgICA6IGhhc093bihjb21wLnByb3BzLCAnbW9kZWxWYWx1ZScpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKGBDb21wb25lbnQgZGVsY2FyZXMgXCJtb2RlbFZhbHVlXCIgcHJvcCwgd2hpY2ggaXMgVnVlIDMgdXNhZ2UsIGJ1dCBgICtcclxuICAgICAgICAgICAgICAgICAgICBgaXMgcnVubmluZyB1bmRlciBWdWUgMiBjb21wYXQgdi1tb2RlbCBiZWhhdmlvci4gWW91IGNhbiAke2NvbmZpZ01zZ31gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gKGB2LW1vZGVsIHVzYWdlIG9uIGNvbXBvbmVudCBoYXMgY2hhbmdlZCBpbiBWdWUgMy4gQ29tcG9uZW50IHRoYXQgZXhwZWN0cyBgICtcclxuICAgICAgICAgICAgICAgIGB0byB3b3JrIHdpdGggdi1tb2RlbCBzaG91bGQgbm93IHVzZSB0aGUgXCJtb2RlbFZhbHVlXCIgcHJvcCBhbmQgZW1pdCB0aGUgYCArXHJcbiAgICAgICAgICAgICAgICBgXCJ1cGRhdGU6bW9kZWxWYWx1ZVwiIGV2ZW50LiBZb3UgY2FuIHVwZGF0ZSB0aGUgdXNhZ2UgYW5kIHRoZW4gJHtjb25maWdNc2d9YCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uL3YtbW9kZWwuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJSRU5ERVJfRlVOQ1RJT05cIiAvKiBSRU5ERVJfRlVOQ1RJT04gKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYFZ1ZSAzJ3MgcmVuZGVyIGZ1bmN0aW9uIEFQSSBoYXMgY2hhbmdlZC4gYCArXHJcbiAgICAgICAgICAgIGBZb3UgY2FuIG9wdC1pbiB0byB0aGUgbmV3IEFQSSB3aXRoOmAgK1xyXG4gICAgICAgICAgICBgXFxuXFxuICBjb25maWd1cmVDb21wYXQoeyAke1wiUkVOREVSX0ZVTkNUSU9OXCIgLyogUkVOREVSX0ZVTkNUSU9OICovfTogZmFsc2UgfSlcXG5gICtcclxuICAgICAgICAgICAgYFxcbiAgKFRoaXMgY2FuIGFsc28gYmUgZG9uZSBwZXItY29tcG9uZW50IHZpYSB0aGUgXCJjb21wYXRDb25maWdcIiBvcHRpb24uKWAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMudnVlanMub3JnL2d1aWRlL21pZ3JhdGlvbi9yZW5kZXItZnVuY3Rpb24tYXBpLmh0bWxgXHJcbiAgICB9LFxyXG4gICAgW1wiRklMVEVSU1wiIC8qIEZJTFRFUlMgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYGZpbHRlcnMgaGF2ZSBiZWVuIHJlbW92ZWQgaW4gVnVlIDMuIGAgK1xyXG4gICAgICAgICAgICBgVGhlIFwifFwiIHN5bWJvbCB3aWxsIGJlIHRyZWF0ZWQgYXMgbmF0aXZlIEphdmFTY3JpcHQgYml0d2lzZSBPUiBvcGVyYXRvci4gYCArXHJcbiAgICAgICAgICAgIGBVc2UgbWV0aG9kIGNhbGxzIG9yIGNvbXB1dGVkIHByb3BlcnRpZXMgaW5zdGVhZC5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vZmlsdGVycy5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIlBSSVZBVEVfQVBJU1wiIC8qIFBSSVZBVEVfQVBJUyAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBuYW1lID0+IGBcIiR7bmFtZX1cIiBpcyBhIFZ1ZSAyIHByaXZhdGUgQVBJIHRoYXQgbm8gbG9uZ2VyIGV4aXN0cyBpbiBWdWUgMy4gYCArXHJcbiAgICAgICAgICAgIGBJZiB5b3UgYXJlIHNlZWluZyB0aGlzIHdhcm5pbmcgb25seSBkdWUgdG8gYSBkZXBlbmRlbmN5LCB5b3UgY2FuIGAgK1xyXG4gICAgICAgICAgICBgc3VwcHJlc3MgdGhpcyB3YXJuaW5nIHZpYSB7IFBSSVZBVEVfQVBJUzogJ3N1cHJlc3Mtd2FybmluZycgfS5gXHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IGluc3RhbmNlV2FybmVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuY29uc3Qgd2FybkNvdW50ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuZnVuY3Rpb24gd2FybkRlcHJlY2F0aW9uKGtleSwgaW5zdGFuY2UsIC4uLmFyZ3MpIHtcclxuICAgIGlmICghKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaW5zdGFuY2UgPSBpbnN0YW5jZSB8fCBnZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgIC8vIGNoZWNrIHVzZXIgY29uZmlnXHJcbiAgICBjb25zdCBjb25maWcgPSBnZXRDb21wYXRDb25maWdGb3JLZXkoa2V5LCBpbnN0YW5jZSk7XHJcbiAgICBpZiAoY29uZmlnID09PSAnc3VwcHJlc3Mtd2FybmluZycpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBkdXBLZXkgPSBrZXkgKyBhcmdzLmpvaW4oJycpO1xyXG4gICAgbGV0IGNvbXBJZCA9IGluc3RhbmNlICYmIGZvcm1hdENvbXBvbmVudE5hbWUoaW5zdGFuY2UsIGluc3RhbmNlLnR5cGUpO1xyXG4gICAgaWYgKGNvbXBJZCA9PT0gJ0Fub255bW91cycgJiYgaW5zdGFuY2UpIHtcclxuICAgICAgICBjb21wSWQgPSBpbnN0YW5jZS51aWQ7XHJcbiAgICB9XHJcbiAgICAvLyBza2lwIGlmIHRoZSBzYW1lIHdhcm5pbmcgaXMgZW1pdHRlZCBmb3IgdGhlIHNhbWUgY29tcG9uZW50IHR5cGVcclxuICAgIGNvbnN0IGNvbXBvbmVudER1cEtleSA9IGR1cEtleSArIGNvbXBJZDtcclxuICAgIGlmIChjb21wb25lbnREdXBLZXkgaW4gaW5zdGFuY2VXYXJuZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpbnN0YW5jZVdhcm5lZFtjb21wb25lbnREdXBLZXldID0gdHJ1ZTtcclxuICAgIC8vIHNhbWUgd2FybmluZywgYnV0IGRpZmZlcmVudCBjb21wb25lbnQuIHNraXAgdGhlIGxvbmcgbWVzc2FnZSBhbmQganVzdFxyXG4gICAgLy8gbG9nIHRoZSBrZXkgYW5kIGNvdW50LlxyXG4gICAgaWYgKGR1cEtleSBpbiB3YXJuQ291bnQpIHtcclxuICAgICAgICB3YXJuKGAoZGVwcmVjYXRpb24gJHtrZXl9KSAoJHsrK3dhcm5Db3VudFtkdXBLZXldICsgMX0pYCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgd2FybkNvdW50W2R1cEtleV0gPSAwO1xyXG4gICAgY29uc3QgeyBtZXNzYWdlLCBsaW5rIH0gPSBkZXByZWNhdGlvbkRhdGFba2V5XTtcclxuICAgIHdhcm4oYChkZXByZWNhdGlvbiAke2tleX0pICR7dHlwZW9mIG1lc3NhZ2UgPT09ICdmdW5jdGlvbicgPyBtZXNzYWdlKC4uLmFyZ3MpIDogbWVzc2FnZX0ke2xpbmsgPyBgXFxuICBEZXRhaWxzOiAke2xpbmt9YCA6IGBgfWApO1xyXG4gICAgaWYgKCFpc0NvbXBhdEVuYWJsZWQoa2V5LCBpbnN0YW5jZSwgdHJ1ZSkpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKGBeIFRoZSBhYm92ZSBkZXByZWNhdGlvbidzIGNvbXBhdCBiZWhhdmlvciBpcyBkaXNhYmxlZCBhbmQgd2lsbCBsaWtlbHkgYCArXHJcbiAgICAgICAgICAgIGBsZWFkIHRvIHJ1bnRpbWUgZXJyb3JzLmApO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGdsb2JhbENvbXBhdENvbmZpZyA9IHtcclxuICAgIE1PREU6IDJcclxufTtcclxuZnVuY3Rpb24gZ2V0Q29tcGF0Q29uZmlnRm9yS2V5KGtleSwgaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IGluc3RhbmNlQ29uZmlnID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UudHlwZS5jb21wYXRDb25maWc7XHJcbiAgICBpZiAoaW5zdGFuY2VDb25maWcgJiYga2V5IGluIGluc3RhbmNlQ29uZmlnKSB7XHJcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlQ29uZmlnW2tleV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZ2xvYmFsQ29tcGF0Q29uZmlnW2tleV07XHJcbn1cclxuZnVuY3Rpb24gaXNDb21wYXRFbmFibGVkKGtleSwgaW5zdGFuY2UsIGVuYWJsZUZvckJ1aWx0SW4gPSBmYWxzZSkge1xyXG4gICAgLy8gc2tpcCBjb21wYXQgZm9yIGJ1aWx0LWluIGNvbXBvbmVudHNcclxuICAgIGlmICghZW5hYmxlRm9yQnVpbHRJbiAmJiBpbnN0YW5jZSAmJiBpbnN0YW5jZS50eXBlLl9faXNCdWlsdEluKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmF3TW9kZSA9IGdldENvbXBhdENvbmZpZ0ZvcktleSgnTU9ERScsIGluc3RhbmNlKSB8fCAyO1xyXG4gICAgY29uc3QgdmFsID0gZ2V0Q29tcGF0Q29uZmlnRm9yS2V5KGtleSwgaW5zdGFuY2UpO1xyXG4gICAgY29uc3QgbW9kZSA9IGlzRnVuY3Rpb24ocmF3TW9kZSlcclxuICAgICAgICA/IHJhd01vZGUoaW5zdGFuY2UgJiYgaW5zdGFuY2UudHlwZSlcclxuICAgICAgICA6IHJhd01vZGU7XHJcbiAgICBpZiAobW9kZSA9PT0gMikge1xyXG4gICAgICAgIHJldHVybiB2YWwgIT09IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbCA9PT0gdHJ1ZSB8fCB2YWwgPT09ICdzdXBwcmVzcy13YXJuaW5nJztcclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiBlbWl0KGluc3RhbmNlLCBldmVudCwgLi4ucmF3QXJncykge1xyXG4gICAgY29uc3QgcHJvcHMgPSBpbnN0YW5jZS52bm9kZS5wcm9wcyB8fCBFTVBUWV9PQko7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgY29uc3QgeyBlbWl0c09wdGlvbnMsIHByb3BzT3B0aW9uczogW3Byb3BzT3B0aW9uc10gfSA9IGluc3RhbmNlO1xyXG4gICAgICAgIGlmIChlbWl0c09wdGlvbnMpIHtcclxuICAgICAgICAgICAgaWYgKCEoZXZlbnQgaW4gZW1pdHNPcHRpb25zKSAmJlxyXG4gICAgICAgICAgICAgICAgIShmYWxzZSApKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXByb3BzT3B0aW9ucyB8fCAhKHRvSGFuZGxlcktleShldmVudCkgaW4gcHJvcHNPcHRpb25zKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYENvbXBvbmVudCBlbWl0dGVkIGV2ZW50IFwiJHtldmVudH1cIiBidXQgaXQgaXMgbmVpdGhlciBkZWNsYXJlZCBpbiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYHRoZSBlbWl0cyBvcHRpb24gbm9yIGFzIGFuIFwiJHt0b0hhbmRsZXJLZXkoZXZlbnQpfVwiIHByb3AuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSBlbWl0c09wdGlvbnNbZXZlbnRdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsaWRhdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzVmFsaWQgPSB2YWxpZGF0b3IoLi4ucmF3QXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYEludmFsaWQgZXZlbnQgYXJndW1lbnRzOiBldmVudCB2YWxpZGF0aW9uIGZhaWxlZCBmb3IgZXZlbnQgXCIke2V2ZW50fVwiLmApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGxldCBhcmdzID0gcmF3QXJncztcclxuICAgIGNvbnN0IGlzTW9kZWxMaXN0ZW5lciA9IGV2ZW50LnN0YXJ0c1dpdGgoJ3VwZGF0ZTonKTtcclxuICAgIC8vIGZvciB2LW1vZGVsIHVwZGF0ZTp4eHggZXZlbnRzLCBhcHBseSBtb2RpZmllcnMgb24gYXJnc1xyXG4gICAgY29uc3QgbW9kZWxBcmcgPSBpc01vZGVsTGlzdGVuZXIgJiYgZXZlbnQuc2xpY2UoNyk7XHJcbiAgICBpZiAobW9kZWxBcmcgJiYgbW9kZWxBcmcgaW4gcHJvcHMpIHtcclxuICAgICAgICBjb25zdCBtb2RpZmllcnNLZXkgPSBgJHttb2RlbEFyZyA9PT0gJ21vZGVsVmFsdWUnID8gJ21vZGVsJyA6IG1vZGVsQXJnfU1vZGlmaWVyc2A7XHJcbiAgICAgICAgY29uc3QgeyBudW1iZXIsIHRyaW0gfSA9IHByb3BzW21vZGlmaWVyc0tleV0gfHwgRU1QVFlfT0JKO1xyXG4gICAgICAgIGlmICh0cmltKSB7XHJcbiAgICAgICAgICAgIGFyZ3MgPSByYXdBcmdzLm1hcChhID0+IGEudHJpbSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobnVtYmVyKSB7XHJcbiAgICAgICAgICAgIGFyZ3MgPSByYXdBcmdzLm1hcCh0b051bWJlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICBkZXZ0b29sc0NvbXBvbmVudEVtaXQoaW5zdGFuY2UsIGV2ZW50LCBhcmdzKTtcclxuICAgIH1cclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBjb25zdCBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgaWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCAmJiBwcm9wc1t0b0hhbmRsZXJLZXkobG93ZXJDYXNlRXZlbnQpXSkge1xyXG4gICAgICAgICAgICB3YXJuKGBFdmVudCBcIiR7bG93ZXJDYXNlRXZlbnR9XCIgaXMgZW1pdHRlZCBpbiBjb21wb25lbnQgYCArXHJcbiAgICAgICAgICAgICAgICBgJHtmb3JtYXRDb21wb25lbnROYW1lKGluc3RhbmNlLCBpbnN0YW5jZS50eXBlKX0gYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFwiJHtldmVudH1cIi4gYCArXHJcbiAgICAgICAgICAgICAgICBgTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2UgYCArXHJcbiAgICAgICAgICAgICAgICBgdi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIGAgK1xyXG4gICAgICAgICAgICAgICAgYFlvdSBzaG91bGQgcHJvYmFibHkgdXNlIFwiJHtoeXBoZW5hdGUoZXZlbnQpfVwiIGluc3RlYWQgb2YgXCIke2V2ZW50fVwiLmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGxldCBoYW5kbGVyTmFtZTtcclxuICAgIGxldCBoYW5kbGVyID0gcHJvcHNbKGhhbmRsZXJOYW1lID0gdG9IYW5kbGVyS2V5KGV2ZW50KSldIHx8XHJcbiAgICAgICAgLy8gYWxzbyB0cnkgY2FtZWxDYXNlIGV2ZW50IGhhbmRsZXIgKCMyMjQ5KVxyXG4gICAgICAgIHByb3BzWyhoYW5kbGVyTmFtZSA9IHRvSGFuZGxlcktleShjYW1lbGl6ZShldmVudCkpKV07XHJcbiAgICAvLyBmb3Igdi1tb2RlbCB1cGRhdGU6eHh4IGV2ZW50cywgYWxzbyB0cmlnZ2VyIGtlYmFiLWNhc2UgZXF1aXZhbGVudFxyXG4gICAgLy8gZm9yIHByb3BzIHBhc3NlZCB2aWEga2ViYWItY2FzZVxyXG4gICAgaWYgKCFoYW5kbGVyICYmIGlzTW9kZWxMaXN0ZW5lcikge1xyXG4gICAgICAgIGhhbmRsZXIgPSBwcm9wc1soaGFuZGxlck5hbWUgPSB0b0hhbmRsZXJLZXkoaHlwaGVuYXRlKGV2ZW50KSkpXTtcclxuICAgIH1cclxuICAgIGlmIChoYW5kbGVyKSB7XHJcbiAgICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaGFuZGxlciwgaW5zdGFuY2UsIDYgLyogQ09NUE9ORU5UX0VWRU5UX0hBTkRMRVIgKi8sIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb25jZUhhbmRsZXIgPSBwcm9wc1toYW5kbGVyTmFtZSArIGBPbmNlYF07XHJcbiAgICBpZiAob25jZUhhbmRsZXIpIHtcclxuICAgICAgICBpZiAoIWluc3RhbmNlLmVtaXR0ZWQpIHtcclxuICAgICAgICAgICAgKGluc3RhbmNlLmVtaXR0ZWQgPSB7fSlbaGFuZGxlck5hbWVdID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaW5zdGFuY2UuZW1pdHRlZFtoYW5kbGVyTmFtZV0pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhvbmNlSGFuZGxlciwgaW5zdGFuY2UsIDYgLyogQ09NUE9ORU5UX0VWRU5UX0hBTkRMRVIgKi8sIGFyZ3MpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUVtaXRzT3B0aW9ucyhjb21wLCBhcHBDb250ZXh0LCBhc01peGluID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IGNhY2hlID0gYXBwQ29udGV4dC5lbWl0c0NhY2hlO1xyXG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGNvbXApO1xyXG4gICAgaWYgKGNhY2hlZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcclxuICAgIH1cclxuICAgIGNvbnN0IHJhdyA9IGNvbXAuZW1pdHM7XHJcbiAgICBsZXQgbm9ybWFsaXplZCA9IHt9O1xyXG4gICAgLy8gYXBwbHkgbWl4aW4vZXh0ZW5kcyBwcm9wc1xyXG4gICAgbGV0IGhhc0V4dGVuZHMgPSBmYWxzZTtcclxuICAgIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fICYmICFpc0Z1bmN0aW9uKGNvbXApKSB7XHJcbiAgICAgICAgY29uc3QgZXh0ZW5kRW1pdHMgPSAocmF3KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRGcm9tRXh0ZW5kID0gbm9ybWFsaXplRW1pdHNPcHRpb25zKHJhdywgYXBwQ29udGV4dCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkRnJvbUV4dGVuZCkge1xyXG4gICAgICAgICAgICAgICAgaGFzRXh0ZW5kcyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBleHRlbmQobm9ybWFsaXplZCwgbm9ybWFsaXplZEZyb21FeHRlbmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoIWFzTWl4aW4gJiYgYXBwQ29udGV4dC5taXhpbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGFwcENvbnRleHQubWl4aW5zLmZvckVhY2goZXh0ZW5kRW1pdHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29tcC5leHRlbmRzKSB7XHJcbiAgICAgICAgICAgIGV4dGVuZEVtaXRzKGNvbXAuZXh0ZW5kcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb21wLm1peGlucykge1xyXG4gICAgICAgICAgICBjb21wLm1peGlucy5mb3JFYWNoKGV4dGVuZEVtaXRzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIXJhdyAmJiAhaGFzRXh0ZW5kcykge1xyXG4gICAgICAgIGNhY2hlLnNldChjb21wLCBudWxsKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGlmIChpc0FycmF5KHJhdykpIHtcclxuICAgICAgICByYXcuZm9yRWFjaChrZXkgPT4gKG5vcm1hbGl6ZWRba2V5XSA9IG51bGwpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGV4dGVuZChub3JtYWxpemVkLCByYXcpO1xyXG4gICAgfVxyXG4gICAgY2FjaGUuc2V0KGNvbXAsIG5vcm1hbGl6ZWQpO1xyXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XHJcbn1cclxuLy8gQ2hlY2sgaWYgYW4gaW5jb21pbmcgcHJvcCBrZXkgaXMgYSBkZWNsYXJlZCBlbWl0IGV2ZW50IGxpc3RlbmVyLlxyXG4vLyBlLmcuIFdpdGggYGVtaXRzOiB7IGNsaWNrOiBudWxsIH1gLCBwcm9wcyBuYW1lZCBgb25DbGlja2AgYW5kIGBvbmNsaWNrYCBhcmVcclxuLy8gYm90aCBjb25zaWRlcmVkIG1hdGNoZWQgbGlzdGVuZXJzLlxyXG5mdW5jdGlvbiBpc0VtaXRMaXN0ZW5lcihvcHRpb25zLCBrZXkpIHtcclxuICAgIGlmICghb3B0aW9ucyB8fCAhaXNPbihrZXkpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAga2V5ID0ga2V5LnNsaWNlKDIpLnJlcGxhY2UoL09uY2UkLywgJycpO1xyXG4gICAgcmV0dXJuIChoYXNPd24ob3B0aW9ucywga2V5WzBdLnRvTG93ZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSkpIHx8XHJcbiAgICAgICAgaGFzT3duKG9wdGlvbnMsIGh5cGhlbmF0ZShrZXkpKSB8fFxyXG4gICAgICAgIGhhc093bihvcHRpb25zLCBrZXkpKTtcclxufVxuXG4vKipcclxuICogbWFyayB0aGUgY3VycmVudCByZW5kZXJpbmcgaW5zdGFuY2UgZm9yIGFzc2V0IHJlc29sdXRpb24gKGUuZy5cclxuICogcmVzb2x2ZUNvbXBvbmVudCwgcmVzb2x2ZURpcmVjdGl2ZSkgZHVyaW5nIHJlbmRlclxyXG4gKi9cclxubGV0IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IG51bGw7XHJcbmxldCBjdXJyZW50U2NvcGVJZCA9IG51bGw7XHJcbi8qKlxyXG4gKiBOb3RlOiByZW5kZXJpbmcgY2FsbHMgbWF5YmUgbmVzdGVkLiBUaGUgZnVuY3Rpb24gcmV0dXJucyB0aGUgcGFyZW50IHJlbmRlcmluZ1xyXG4gKiBpbnN0YW5jZSBpZiBwcmVzZW50LCB3aGljaCBzaG91bGQgYmUgcmVzdG9yZWQgYWZ0ZXIgdGhlIHJlbmRlciBpcyBkb25lOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBjb25zdCBwcmV2ID0gc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKGkpXHJcbiAqIC8vIC4uLnJlbmRlclxyXG4gKiBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UocHJldilcclxuICogYGBgXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UoaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IHByZXYgPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XHJcbiAgICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBpbnN0YW5jZTtcclxuICAgIGN1cnJlbnRTY29wZUlkID0gKGluc3RhbmNlICYmIGluc3RhbmNlLnR5cGUuX19zY29wZUlkKSB8fCBudWxsO1xyXG4gICAgcmV0dXJuIHByZXY7XHJcbn1cclxuLyoqXHJcbiAqIFNldCBzY29wZSBpZCB3aGVuIGNyZWF0aW5nIGhvaXN0ZWQgdm5vZGVzLlxyXG4gKiBAcHJpdmF0ZSBjb21waWxlciBoZWxwZXJcclxuICovXHJcbmZ1bmN0aW9uIHB1c2hTY29wZUlkKGlkKSB7XHJcbiAgICBjdXJyZW50U2NvcGVJZCA9IGlkO1xyXG59XHJcbi8qKlxyXG4gKiBUZWNobmljYWxseSB3ZSBubyBsb25nZXIgbmVlZCB0aGlzIGFmdGVyIDMuMC44IGJ1dCB3ZSBuZWVkIHRvIGtlZXAgdGhlIHNhbWVcclxuICogQVBJIGZvciBiYWNrd2FyZHMgY29tcGF0IHcvIGNvZGUgZ2VuZXJhdGVkIGJ5IGNvbXBpbGVycy5cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHBvcFNjb3BlSWQoKSB7XHJcbiAgICBjdXJyZW50U2NvcGVJZCA9IG51bGw7XHJcbn1cclxuLyoqXHJcbiAqIE9ubHkgZm9yIGJhY2t3YXJkcyBjb21wYXRcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IHdpdGhTY29wZUlkID0gKF9pZCkgPT4gd2l0aEN0eDtcclxuLyoqXHJcbiAqIFdyYXAgYSBzbG90IGZ1bmN0aW9uIHRvIG1lbW9pemUgY3VycmVudCByZW5kZXJpbmcgaW5zdGFuY2VcclxuICogQHByaXZhdGUgY29tcGlsZXIgaGVscGVyXHJcbiAqL1xyXG5mdW5jdGlvbiB3aXRoQ3R4KGZuLCBjdHggPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UsIGlzTm9uU2NvcGVkU2xvdCAvLyBmYWxzZSBvbmx5XHJcbikge1xyXG4gICAgaWYgKCFjdHgpXHJcbiAgICAgICAgcmV0dXJuIGZuO1xyXG4gICAgLy8gYWxyZWFkeSBub3JtYWxpemVkXHJcbiAgICBpZiAoZm4uX24pIHtcclxuICAgICAgICByZXR1cm4gZm47XHJcbiAgICB9XHJcbiAgICBjb25zdCByZW5kZXJGbldpdGhDb250ZXh0ID0gKC4uLmFyZ3MpID0+IHtcclxuICAgICAgICAvLyBJZiBhIHVzZXIgY2FsbHMgYSBjb21waWxlZCBzbG90IGluc2lkZSBhIHRlbXBsYXRlIGV4cHJlc3Npb24gKCMxNzQ1KSwgaXRcclxuICAgICAgICAvLyBjYW4gbWVzcyB1cCBibG9jayB0cmFja2luZywgc28gYnkgZGVmYXVsdCB3ZSBkaXNhYmxlIGJsb2NrIHRyYWNraW5nIGFuZFxyXG4gICAgICAgIC8vIGZvcmNlIGJhaWwgb3V0IHdoZW4gaW52b2tpbmcgYSBjb21waWxlZCBzbG90IChpbmRpY2F0ZWQgYnkgdGhlIC5fZCBmbGFnKS5cclxuICAgICAgICAvLyBUaGlzIGlzbid0IG5lY2Vzc2FyeSBpZiByZW5kZXJpbmcgYSBjb21waWxlZCBgPHNsb3Q+YCwgc28gd2UgZmxpcCB0aGVcclxuICAgICAgICAvLyAuX2QgZmxhZyBvZmYgd2hlbiBpbnZva2luZyB0aGUgd3JhcHBlZCBmbiBpbnNpZGUgYHJlbmRlclNsb3RgLlxyXG4gICAgICAgIGlmIChyZW5kZXJGbldpdGhDb250ZXh0Ll9kKSB7XHJcbiAgICAgICAgICAgIHNldEJsb2NrVHJhY2tpbmcoLTEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwcmV2SW5zdGFuY2UgPSBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UoY3R4KTtcclxuICAgICAgICBjb25zdCByZXMgPSBmbiguLi5hcmdzKTtcclxuICAgICAgICBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UocHJldkluc3RhbmNlKTtcclxuICAgICAgICBpZiAocmVuZGVyRm5XaXRoQ29udGV4dC5fZCkge1xyXG4gICAgICAgICAgICBzZXRCbG9ja1RyYWNraW5nKDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudFVwZGF0ZWQoY3R4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH07XHJcbiAgICAvLyBtYXJrIG5vcm1hbGl6ZWQgdG8gYXZvaWQgZHVwbGljYXRlZCB3cmFwcGluZ1xyXG4gICAgcmVuZGVyRm5XaXRoQ29udGV4dC5fbiA9IHRydWU7XHJcbiAgICAvLyBtYXJrIHRoaXMgYXMgY29tcGlsZWQgYnkgZGVmYXVsdFxyXG4gICAgLy8gdGhpcyBpcyB1c2VkIGluIHZub2RlLnRzIC0+IG5vcm1hbGl6ZUNoaWxkcmVuKCkgdG8gc2V0IHRoZSBzbG90XHJcbiAgICAvLyByZW5kZXJpbmcgZmxhZy5cclxuICAgIHJlbmRlckZuV2l0aENvbnRleHQuX2MgPSB0cnVlO1xyXG4gICAgLy8gZGlzYWJsZSBibG9jayB0cmFja2luZyBieSBkZWZhdWx0XHJcbiAgICByZW5kZXJGbldpdGhDb250ZXh0Ll9kID0gdHJ1ZTtcclxuICAgIHJldHVybiByZW5kZXJGbldpdGhDb250ZXh0O1xyXG59XG5cbi8qKlxyXG4gKiBkZXYgb25seSBmbGFnIHRvIHRyYWNrIHdoZXRoZXIgJGF0dHJzIHdhcyB1c2VkIGR1cmluZyByZW5kZXIuXHJcbiAqIElmICRhdHRycyB3YXMgdXNlZCBkdXJpbmcgcmVuZGVyIHRoZW4gdGhlIHdhcm5pbmcgZm9yIGZhaWxlZCBhdHRyc1xyXG4gKiBmYWxsdGhyb3VnaCBjYW4gYmUgc3VwcHJlc3NlZC5cclxuICovXHJcbmxldCBhY2Nlc3NlZEF0dHJzID0gZmFsc2U7XHJcbmZ1bmN0aW9uIG1hcmtBdHRyc0FjY2Vzc2VkKCkge1xyXG4gICAgYWNjZXNzZWRBdHRycyA9IHRydWU7XHJcbn1cclxuZnVuY3Rpb24gcmVuZGVyQ29tcG9uZW50Um9vdChpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgeyB0eXBlOiBDb21wb25lbnQsIHZub2RlLCBwcm94eSwgd2l0aFByb3h5LCBwcm9wcywgcHJvcHNPcHRpb25zOiBbcHJvcHNPcHRpb25zXSwgc2xvdHMsIGF0dHJzLCBlbWl0LCByZW5kZXIsIHJlbmRlckNhY2hlLCBkYXRhLCBzZXR1cFN0YXRlLCBjdHgsIGluaGVyaXRBdHRycyB9ID0gaW5zdGFuY2U7XHJcbiAgICBsZXQgcmVzdWx0O1xyXG4gICAgY29uc3QgcHJldiA9IHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShpbnN0YW5jZSk7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgYWNjZXNzZWRBdHRycyA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICBsZXQgZmFsbHRocm91Z2hBdHRycztcclxuICAgICAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgNCAvKiBTVEFURUZVTF9DT01QT05FTlQgKi8pIHtcclxuICAgICAgICAgICAgLy8gd2l0aFByb3h5IGlzIGEgcHJveHkgd2l0aCBhIGRpZmZlcmVudCBgaGFzYCB0cmFwIG9ubHkgZm9yXHJcbiAgICAgICAgICAgIC8vIHJ1bnRpbWUtY29tcGlsZWQgcmVuZGVyIGZ1bmN0aW9ucyB1c2luZyBgd2l0aGAgYmxvY2suXHJcbiAgICAgICAgICAgIGNvbnN0IHByb3h5VG9Vc2UgPSB3aXRoUHJveHkgfHwgcHJveHk7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IG5vcm1hbGl6ZVZOb2RlKHJlbmRlci5jYWxsKHByb3h5VG9Vc2UsIHByb3h5VG9Vc2UsIHJlbmRlckNhY2hlLCBwcm9wcywgc2V0dXBTdGF0ZSwgZGF0YSwgY3R4KSk7XHJcbiAgICAgICAgICAgIGZhbGx0aHJvdWdoQXR0cnMgPSBhdHRycztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9uYWxcclxuICAgICAgICAgICAgY29uc3QgcmVuZGVyID0gQ29tcG9uZW50O1xyXG4gICAgICAgICAgICAvLyBpbiBkZXYsIG1hcmsgYXR0cnMgYWNjZXNzZWQgaWYgb3B0aW9uYWwgcHJvcHMgKGF0dHJzID09PSBwcm9wcylcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBhdHRycyA9PT0gcHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0ID0gbm9ybWFsaXplVk5vZGUocmVuZGVyLmxlbmd0aCA+IDFcclxuICAgICAgICAgICAgICAgID8gcmVuZGVyKHByb3BzLCAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgICAgICAgICAgICAgICAgICA/IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGF0dHJzKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya0F0dHJzQWNjZXNzZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhdHRycztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2xvdHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgOiB7IGF0dHJzLCBzbG90cywgZW1pdCB9KVxyXG4gICAgICAgICAgICAgICAgOiByZW5kZXIocHJvcHMsIG51bGwgLyogd2Uga25vdyBpdCBkb2Vzbid0IG5lZWQgaXQgKi8pKTtcclxuICAgICAgICAgICAgZmFsbHRocm91Z2hBdHRycyA9IENvbXBvbmVudC5wcm9wc1xyXG4gICAgICAgICAgICAgICAgPyBhdHRyc1xyXG4gICAgICAgICAgICAgICAgOiBnZXRGdW5jdGlvbmFsRmFsbHRocm91Z2goYXR0cnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhdHRyIG1lcmdpbmdcclxuICAgICAgICAvLyBpbiBkZXYgbW9kZSwgY29tbWVudHMgYXJlIHByZXNlcnZlZCwgYW5kIGl0J3MgcG9zc2libGUgZm9yIGEgdGVtcGxhdGVcclxuICAgICAgICAvLyB0byBoYXZlIGNvbW1lbnRzIGFsb25nIHNpZGUgdGhlIHJvb3QgZWxlbWVudCB3aGljaCBtYWtlcyBpdCBhIGZyYWdtZW50XHJcbiAgICAgICAgbGV0IHJvb3QgPSByZXN1bHQ7XHJcbiAgICAgICAgbGV0IHNldFJvb3QgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICByZXN1bHQucGF0Y2hGbGFnID4gMCAmJlxyXG4gICAgICAgICAgICByZXN1bHQucGF0Y2hGbGFnICYgMjA0OCAvKiBERVZfUk9PVF9GUkFHTUVOVCAqLykge1xyXG4gICAgICAgICAgICA7XHJcbiAgICAgICAgICAgIFtyb290LCBzZXRSb290XSA9IGdldENoaWxkUm9vdChyZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZmFsbHRocm91Z2hBdHRycyAmJiBpbmhlcml0QXR0cnMgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhmYWxsdGhyb3VnaEF0dHJzKTtcclxuICAgICAgICAgICAgY29uc3QgeyBzaGFwZUZsYWcgfSA9IHJvb3Q7XHJcbiAgICAgICAgICAgIGlmIChrZXlzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEgLyogRUxFTUVOVCAqLyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BzT3B0aW9ucyAmJiBrZXlzLnNvbWUoaXNNb2RlbExpc3RlbmVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBhIHYtbW9kZWwgbGlzdGVuZXIgKG9uVXBkYXRlOnh4eCkgaGFzIGEgY29ycmVzcG9uZGluZyBkZWNsYXJlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9wLCBpdCBpbmRpY2F0ZXMgdGhpcyBjb21wb25lbnQgZXhwZWN0cyB0byBoYW5kbGUgdi1tb2RlbCBhbmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgc2hvdWxkIG5vdCBmYWxsdGhyb3VnaC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVsYXRlZDogIzE1NDMsICMxNjQzLCAjMTk4OVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWxsdGhyb3VnaEF0dHJzID0gZmlsdGVyTW9kZWxMaXN0ZW5lcnMoZmFsbHRocm91Z2hBdHRycywgcHJvcHNPcHRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcm9vdCA9IGNsb25lVk5vZGUocm9vdCwgZmFsbHRocm91Z2hBdHRycyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWFjY2Vzc2VkQXR0cnMgJiYgcm9vdC50eXBlICE9PSBDb21tZW50JDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbGxBdHRycyA9IE9iamVjdC5rZXlzKGF0dHJzKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBldmVudEF0dHJzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXh0cmFBdHRycyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gYWxsQXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGFsbEF0dHJzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNPbihrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgdi1tb2RlbCBoYW5kbGVycyB3aGVuIHRoZXkgZmFpbCB0byBmYWxsdGhyb3VnaFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc01vZGVsTGlzdGVuZXIoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBgb25gLCBsb3dlcmNhc2UgZmlyc3QgbGV0dGVyIHRvIHJlZmxlY3QgZXZlbnQgY2FzaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWNjdXJhdGVseVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50QXR0cnMucHVzaChrZXlbMl0udG9Mb3dlckNhc2UoKSArIGtleS5zbGljZSgzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYUF0dHJzLnB1c2goa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXh0cmFBdHRycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgRXh0cmFuZW91cyBub24tcHJvcHMgYXR0cmlidXRlcyAoYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgJHtleHRyYUF0dHJzLmpvaW4oJywgJyl9KSBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGB3ZXJlIHBhc3NlZCB0byBjb21wb25lbnQgYnV0IGNvdWxkIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGluaGVyaXRlZCBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBiZWNhdXNlIGNvbXBvbmVudCByZW5kZXJzIGZyYWdtZW50IG9yIHRleHQgcm9vdCBub2Rlcy5gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50QXR0cnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYEV4dHJhbmVvdXMgbm9uLWVtaXRzIGV2ZW50IGxpc3RlbmVycyAoYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgJHtldmVudEF0dHJzLmpvaW4oJywgJyl9KSBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGB3ZXJlIHBhc3NlZCB0byBjb21wb25lbnQgYnV0IGNvdWxkIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGluaGVyaXRlZCBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBiZWNhdXNlIGNvbXBvbmVudCByZW5kZXJzIGZyYWdtZW50IG9yIHRleHQgcm9vdCBub2Rlcy4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgSWYgdGhlIGxpc3RlbmVyIGlzIGludGVuZGVkIHRvIGJlIGEgY29tcG9uZW50IGN1c3RvbSBldmVudCBsaXN0ZW5lciBvbmx5LCBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBkZWNsYXJlIGl0IHVzaW5nIHRoZSBcImVtaXRzXCIgb3B0aW9uLmApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZmFsc2UgJiZcclxuICAgICAgICAgICAgaXNDb21wYXRFbmFibGVkKFwiSU5TVEFOQ0VfQVRUUlNfQ0xBU1NfU1RZTEVcIiAvKiBJTlNUQU5DRV9BVFRSU19DTEFTU19TVFlMRSAqLywgaW5zdGFuY2UpICYmXHJcbiAgICAgICAgICAgIHZub2RlLnNoYXBlRmxhZyAmIDQgLyogU1RBVEVGVUxfQ09NUE9ORU5UICovICYmXHJcbiAgICAgICAgICAgIChyb290LnNoYXBlRmxhZyAmIDEgLyogRUxFTUVOVCAqLyB8fFxyXG4gICAgICAgICAgICAgICAgcm9vdC5zaGFwZUZsYWcgJiA2IC8qIENPTVBPTkVOVCAqLykpIDtcclxuICAgICAgICAvLyBpbmhlcml0IGRpcmVjdGl2ZXNcclxuICAgICAgICBpZiAodm5vZGUuZGlycykge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc0VsZW1lbnRSb290KHJvb3QpKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBSdW50aW1lIGRpcmVjdGl2ZSB1c2VkIG9uIGNvbXBvbmVudCB3aXRoIG5vbi1lbGVtZW50IHJvb3Qgbm9kZS4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYFRoZSBkaXJlY3RpdmVzIHdpbGwgbm90IGZ1bmN0aW9uIGFzIGludGVuZGVkLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJvb3QuZGlycyA9IHJvb3QuZGlycyA/IHJvb3QuZGlycy5jb25jYXQodm5vZGUuZGlycykgOiB2bm9kZS5kaXJzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpbmhlcml0IHRyYW5zaXRpb24gZGF0YVxyXG4gICAgICAgIGlmICh2bm9kZS50cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzRWxlbWVudFJvb3Qocm9vdCkpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYENvbXBvbmVudCBpbnNpZGUgPFRyYW5zaXRpb24+IHJlbmRlcnMgbm9uLWVsZW1lbnQgcm9vdCBub2RlIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGB0aGF0IGNhbm5vdCBiZSBhbmltYXRlZC5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByb290LnRyYW5zaXRpb24gPSB2bm9kZS50cmFuc2l0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHNldFJvb3QpIHtcclxuICAgICAgICAgICAgc2V0Um9vdChyb290KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJvb3Q7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgIGJsb2NrU3RhY2subGVuZ3RoID0gMDtcclxuICAgICAgICBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCAxIC8qIFJFTkRFUl9GVU5DVElPTiAqLyk7XHJcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlVk5vZGUoQ29tbWVudCQxKTtcclxuICAgIH1cclxuICAgIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShwcmV2KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLyoqXHJcbiAqIGRldiBvbmx5XHJcbiAqIEluIGRldiBtb2RlLCB0ZW1wbGF0ZSByb290IGxldmVsIGNvbW1lbnRzIGFyZSByZW5kZXJlZCwgd2hpY2ggdHVybnMgdGhlXHJcbiAqIHRlbXBsYXRlIGludG8gYSBmcmFnbWVudCByb290LCBidXQgd2UgbmVlZCB0byBsb2NhdGUgdGhlIHNpbmdsZSBlbGVtZW50XHJcbiAqIHJvb3QgZm9yIGF0dHJzIGFuZCBzY29wZSBpZCBwcm9jZXNzaW5nLlxyXG4gKi9cclxuY29uc3QgZ2V0Q2hpbGRSb290ID0gKHZub2RlKSA9PiB7XHJcbiAgICBjb25zdCByYXdDaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xyXG4gICAgY29uc3QgZHluYW1pY0NoaWxkcmVuID0gdm5vZGUuZHluYW1pY0NoaWxkcmVuO1xyXG4gICAgY29uc3QgY2hpbGRSb290ID0gZmlsdGVyU2luZ2xlUm9vdChyYXdDaGlsZHJlbik7XHJcbiAgICBpZiAoIWNoaWxkUm9vdCkge1xyXG4gICAgICAgIHJldHVybiBbdm5vZGUsIHVuZGVmaW5lZF07XHJcbiAgICB9XHJcbiAgICBjb25zdCBpbmRleCA9IHJhd0NoaWxkcmVuLmluZGV4T2YoY2hpbGRSb290KTtcclxuICAgIGNvbnN0IGR5bmFtaWNJbmRleCA9IGR5bmFtaWNDaGlsZHJlbiA/IGR5bmFtaWNDaGlsZHJlbi5pbmRleE9mKGNoaWxkUm9vdCkgOiAtMTtcclxuICAgIGNvbnN0IHNldFJvb3QgPSAodXBkYXRlZFJvb3QpID0+IHtcclxuICAgICAgICByYXdDaGlsZHJlbltpbmRleF0gPSB1cGRhdGVkUm9vdDtcclxuICAgICAgICBpZiAoZHluYW1pY0NoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIGlmIChkeW5hbWljSW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgZHluYW1pY0NoaWxkcmVuW2R5bmFtaWNJbmRleF0gPSB1cGRhdGVkUm9vdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh1cGRhdGVkUm9vdC5wYXRjaEZsYWcgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZS5keW5hbWljQ2hpbGRyZW4gPSBbLi4uZHluYW1pY0NoaWxkcmVuLCB1cGRhdGVkUm9vdF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFtub3JtYWxpemVWTm9kZShjaGlsZFJvb3QpLCBzZXRSb290XTtcclxufTtcclxuZnVuY3Rpb24gZmlsdGVyU2luZ2xlUm9vdChjaGlsZHJlbikge1xyXG4gICAgbGV0IHNpbmdsZVJvb3Q7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICBpZiAoaXNWTm9kZShjaGlsZCkpIHtcclxuICAgICAgICAgICAgLy8gaWdub3JlIHVzZXIgY29tbWVudFxyXG4gICAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPT0gQ29tbWVudCQxIHx8IGNoaWxkLmNoaWxkcmVuID09PSAndi1pZicpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzaW5nbGVSb290KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFzIG1vcmUgdGhhbiAxIG5vbi1jb21tZW50IGNoaWxkLCByZXR1cm4gbm93XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2luZ2xlUm9vdCA9IGNoaWxkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNpbmdsZVJvb3Q7XHJcbn1cclxuY29uc3QgZ2V0RnVuY3Rpb25hbEZhbGx0aHJvdWdoID0gKGF0dHJzKSA9PiB7XHJcbiAgICBsZXQgcmVzO1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cnMpIHtcclxuICAgICAgICBpZiAoa2V5ID09PSAnY2xhc3MnIHx8IGtleSA9PT0gJ3N0eWxlJyB8fCBpc09uKGtleSkpIHtcclxuICAgICAgICAgICAgKHJlcyB8fCAocmVzID0ge30pKVtrZXldID0gYXR0cnNba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59O1xyXG5jb25zdCBmaWx0ZXJNb2RlbExpc3RlbmVycyA9IChhdHRycywgcHJvcHMpID0+IHtcclxuICAgIGNvbnN0IHJlcyA9IHt9O1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cnMpIHtcclxuICAgICAgICBpZiAoIWlzTW9kZWxMaXN0ZW5lcihrZXkpIHx8ICEoa2V5LnNsaWNlKDkpIGluIHByb3BzKSkge1xyXG4gICAgICAgICAgICByZXNba2V5XSA9IGF0dHJzW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufTtcclxuY29uc3QgaXNFbGVtZW50Um9vdCA9ICh2bm9kZSkgPT4ge1xyXG4gICAgcmV0dXJuICh2bm9kZS5zaGFwZUZsYWcgJiA2IC8qIENPTVBPTkVOVCAqLyB8fFxyXG4gICAgICAgIHZub2RlLnNoYXBlRmxhZyAmIDEgLyogRUxFTUVOVCAqLyB8fFxyXG4gICAgICAgIHZub2RlLnR5cGUgPT09IENvbW1lbnQkMSAvLyBwb3RlbnRpYWwgdi1pZiBicmFuY2ggc3dpdGNoXHJcbiAgICApO1xyXG59O1xyXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVDb21wb25lbnQocHJldlZOb2RlLCBuZXh0Vk5vZGUsIG9wdGltaXplZCkge1xyXG4gICAgY29uc3QgeyBwcm9wczogcHJldlByb3BzLCBjaGlsZHJlbjogcHJldkNoaWxkcmVuLCBjb21wb25lbnQgfSA9IHByZXZWTm9kZTtcclxuICAgIGNvbnN0IHsgcHJvcHM6IG5leHRQcm9wcywgY2hpbGRyZW46IG5leHRDaGlsZHJlbiwgcGF0Y2hGbGFnIH0gPSBuZXh0Vk5vZGU7XHJcbiAgICBjb25zdCBlbWl0cyA9IGNvbXBvbmVudC5lbWl0c09wdGlvbnM7XHJcbiAgICAvLyBQYXJlbnQgY29tcG9uZW50J3MgcmVuZGVyIGZ1bmN0aW9uIHdhcyBob3QtdXBkYXRlZC4gU2luY2UgdGhpcyBtYXkgaGF2ZVxyXG4gICAgLy8gY2F1c2VkIHRoZSBjaGlsZCBjb21wb25lbnQncyBzbG90cyBjb250ZW50IHRvIGhhdmUgY2hhbmdlZCwgd2UgbmVlZCB0b1xyXG4gICAgLy8gZm9yY2UgdGhlIGNoaWxkIHRvIHVwZGF0ZSBhcyB3ZWxsLlxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAocHJldkNoaWxkcmVuIHx8IG5leHRDaGlsZHJlbikgJiYgaXNIbXJVcGRhdGluZykge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLy8gZm9yY2UgY2hpbGQgdXBkYXRlIGZvciBydW50aW1lIGRpcmVjdGl2ZSBvciB0cmFuc2l0aW9uIG9uIGNvbXBvbmVudCB2bm9kZS5cclxuICAgIGlmIChuZXh0Vk5vZGUuZGlycyB8fCBuZXh0Vk5vZGUudHJhbnNpdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdGltaXplZCAmJiBwYXRjaEZsYWcgPj0gMCkge1xyXG4gICAgICAgIGlmIChwYXRjaEZsYWcgJiAxMDI0IC8qIERZTkFNSUNfU0xPVFMgKi8pIHtcclxuICAgICAgICAgICAgLy8gc2xvdCBjb250ZW50IHRoYXQgcmVmZXJlbmNlcyB2YWx1ZXMgdGhhdCBtaWdodCBoYXZlIGNoYW5nZWQsXHJcbiAgICAgICAgICAgIC8vIGUuZy4gaW4gYSB2LWZvclxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDE2IC8qIEZVTExfUFJPUFMgKi8pIHtcclxuICAgICAgICAgICAgaWYgKCFwcmV2UHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhIW5leHRQcm9wcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBwcmVzZW5jZSBvZiB0aGlzIGZsYWcgaW5kaWNhdGVzIHByb3BzIGFyZSBhbHdheXMgbm9uLW51bGxcclxuICAgICAgICAgICAgcmV0dXJuIGhhc1Byb3BzQ2hhbmdlZChwcmV2UHJvcHMsIG5leHRQcm9wcywgZW1pdHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwYXRjaEZsYWcgJiA4IC8qIFBST1BTICovKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGR5bmFtaWNQcm9wcyA9IG5leHRWTm9kZS5keW5hbWljUHJvcHM7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHluYW1pY1Byb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBkeW5hbWljUHJvcHNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dFByb3BzW2tleV0gIT09IHByZXZQcm9wc1trZXldICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIWlzRW1pdExpc3RlbmVyKGVtaXRzLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyB0aGlzIHBhdGggaXMgb25seSB0YWtlbiBieSBtYW51YWxseSB3cml0dGVuIHJlbmRlciBmdW5jdGlvbnNcclxuICAgICAgICAvLyBzbyBwcmVzZW5jZSBvZiBhbnkgY2hpbGRyZW4gbGVhZHMgdG8gYSBmb3JjZWQgdXBkYXRlXHJcbiAgICAgICAgaWYgKHByZXZDaGlsZHJlbiB8fCBuZXh0Q2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4gfHwgIW5leHRDaGlsZHJlbi4kc3RhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJldlByb3BzID09PSBuZXh0UHJvcHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXByZXZQcm9wcykge1xyXG4gICAgICAgICAgICByZXR1cm4gISFuZXh0UHJvcHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbmV4dFByb3BzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaGFzUHJvcHNDaGFuZ2VkKHByZXZQcm9wcywgbmV4dFByb3BzLCBlbWl0cyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gaGFzUHJvcHNDaGFuZ2VkKHByZXZQcm9wcywgbmV4dFByb3BzLCBlbWl0c09wdGlvbnMpIHtcclxuICAgIGNvbnN0IG5leHRLZXlzID0gT2JqZWN0LmtleXMobmV4dFByb3BzKTtcclxuICAgIGlmIChuZXh0S2V5cy5sZW5ndGggIT09IE9iamVjdC5rZXlzKHByZXZQcm9wcykubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5leHRLZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gbmV4dEtleXNbaV07XHJcbiAgICAgICAgaWYgKG5leHRQcm9wc1trZXldICE9PSBwcmV2UHJvcHNba2V5XSAmJlxyXG4gICAgICAgICAgICAhaXNFbWl0TGlzdGVuZXIoZW1pdHNPcHRpb25zLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiB1cGRhdGVIT0NIb3N0RWwoeyB2bm9kZSwgcGFyZW50IH0sIGVsIC8vIEhvc3ROb2RlXHJcbikge1xyXG4gICAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQuc3ViVHJlZSA9PT0gdm5vZGUpIHtcclxuICAgICAgICAodm5vZGUgPSBwYXJlbnQudm5vZGUpLmVsID0gZWw7XHJcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcclxuICAgIH1cclxufVxuXG5jb25zdCBpc1N1c3BlbnNlID0gKHR5cGUpID0+IHR5cGUuX19pc1N1c3BlbnNlO1xyXG4vLyBTdXNwZW5zZSBleHBvc2VzIGEgY29tcG9uZW50LWxpa2UgQVBJLCBhbmQgaXMgdHJlYXRlZCBsaWtlIGEgY29tcG9uZW50XHJcbi8vIGluIHRoZSBjb21waWxlciwgYnV0IGludGVybmFsbHkgaXQncyBhIHNwZWNpYWwgYnVpbHQtaW4gdHlwZSB0aGF0IGhvb2tzXHJcbi8vIGRpcmVjdGx5IGludG8gdGhlIHJlbmRlcmVyLlxyXG5jb25zdCBTdXNwZW5zZUltcGwgPSB7XHJcbiAgICBuYW1lOiAnU3VzcGVuc2UnLFxyXG4gICAgLy8gSW4gb3JkZXIgdG8gbWFrZSBTdXNwZW5zZSB0cmVlLXNoYWthYmxlLCB3ZSBuZWVkIHRvIGF2b2lkIGltcG9ydGluZyBpdFxyXG4gICAgLy8gZGlyZWN0bHkgaW4gdGhlIHJlbmRlcmVyLiBUaGUgcmVuZGVyZXIgY2hlY2tzIGZvciB0aGUgX19pc1N1c3BlbnNlIGZsYWdcclxuICAgIC8vIG9uIGEgdm5vZGUncyB0eXBlIGFuZCBjYWxscyB0aGUgYHByb2Nlc3NgIG1ldGhvZCwgcGFzc2luZyBpbiByZW5kZXJlclxyXG4gICAgLy8gaW50ZXJuYWxzLlxyXG4gICAgX19pc1N1c3BlbnNlOiB0cnVlLFxyXG4gICAgcHJvY2VzcyhuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIFxyXG4gICAgLy8gcGxhdGZvcm0tc3BlY2lmaWMgaW1wbCBwYXNzZWQgZnJvbSByZW5kZXJlclxyXG4gICAgcmVuZGVyZXJJbnRlcm5hbHMpIHtcclxuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBtb3VudFN1c3BlbnNlKG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwYXRjaFN1c3BlbnNlKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGh5ZHJhdGU6IGh5ZHJhdGVTdXNwZW5zZSxcclxuICAgIGNyZWF0ZTogY3JlYXRlU3VzcGVuc2VCb3VuZGFyeSxcclxuICAgIG5vcm1hbGl6ZTogbm9ybWFsaXplU3VzcGVuc2VDaGlsZHJlblxyXG59O1xyXG4vLyBGb3JjZS1jYXN0ZWQgcHVibGljIHR5cGluZyBmb3IgaCBhbmQgVFNYIHByb3BzIGluZmVyZW5jZVxyXG5jb25zdCBTdXNwZW5zZSA9IChTdXNwZW5zZUltcGxcclxuICAgICk7XHJcbmZ1bmN0aW9uIG1vdW50U3VzcGVuc2Uodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzKSB7XHJcbiAgICBjb25zdCB7IHA6IHBhdGNoLCBvOiB7IGNyZWF0ZUVsZW1lbnQgfSB9ID0gcmVuZGVyZXJJbnRlcm5hbHM7XHJcbiAgICBjb25zdCBoaWRkZW5Db250YWluZXIgPSBjcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIGNvbnN0IHN1c3BlbnNlID0gKHZub2RlLnN1c3BlbnNlID0gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeSh2bm9kZSwgcGFyZW50U3VzcGVuc2UsIHBhcmVudENvbXBvbmVudCwgY29udGFpbmVyLCBoaWRkZW5Db250YWluZXIsIGFuY2hvciwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscykpO1xyXG4gICAgLy8gc3RhcnQgbW91bnRpbmcgdGhlIGNvbnRlbnQgc3VidHJlZSBpbiBhbiBvZmYtZG9tIGNvbnRhaW5lclxyXG4gICAgcGF0Y2gobnVsbCwgKHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSB2bm9kZS5zc0NvbnRlbnQpLCBoaWRkZW5Db250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMpO1xyXG4gICAgLy8gbm93IGNoZWNrIGlmIHdlIGhhdmUgZW5jb3VudGVyZWQgYW55IGFzeW5jIGRlcHNcclxuICAgIGlmIChzdXNwZW5zZS5kZXBzID4gMCkge1xyXG4gICAgICAgIC8vIGhhcyBhc3luY1xyXG4gICAgICAgIC8vIG1vdW50IHRoZSBmYWxsYmFjayB0cmVlXHJcbiAgICAgICAgcGF0Y2gobnVsbCwgdm5vZGUuc3NGYWxsYmFjaywgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgbnVsbCwgLy8gZmFsbGJhY2sgdHJlZSB3aWxsIG5vdCBoYXZlIHN1c3BlbnNlIGNvbnRleHRcclxuICAgICAgICBpc1NWRywgc2xvdFNjb3BlSWRzKTtcclxuICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIHZub2RlLnNzRmFsbGJhY2spO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gU3VzcGVuc2UgaGFzIG5vIGFzeW5jIGRlcHMuIEp1c3QgcmVzb2x2ZS5cclxuICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcGF0Y2hTdXNwZW5zZShuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgeyBwOiBwYXRjaCwgdW06IHVubW91bnQsIG86IHsgY3JlYXRlRWxlbWVudCB9IH0pIHtcclxuICAgIGNvbnN0IHN1c3BlbnNlID0gKG4yLnN1c3BlbnNlID0gbjEuc3VzcGVuc2UpO1xyXG4gICAgc3VzcGVuc2Uudm5vZGUgPSBuMjtcclxuICAgIG4yLmVsID0gbjEuZWw7XHJcbiAgICBjb25zdCBuZXdCcmFuY2ggPSBuMi5zc0NvbnRlbnQ7XHJcbiAgICBjb25zdCBuZXdGYWxsYmFjayA9IG4yLnNzRmFsbGJhY2s7XHJcbiAgICBjb25zdCB7IGFjdGl2ZUJyYW5jaCwgcGVuZGluZ0JyYW5jaCwgaXNJbkZhbGxiYWNrLCBpc0h5ZHJhdGluZyB9ID0gc3VzcGVuc2U7XHJcbiAgICBpZiAocGVuZGluZ0JyYW5jaCkge1xyXG4gICAgICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSBuZXdCcmFuY2g7XHJcbiAgICAgICAgaWYgKGlzU2FtZVZOb2RlVHlwZShuZXdCcmFuY2gsIHBlbmRpbmdCcmFuY2gpKSB7XHJcbiAgICAgICAgICAgIC8vIHNhbWUgcm9vdCB0eXBlIGJ1dCBjb250ZW50IG1heSBoYXZlIGNoYW5nZWQuXHJcbiAgICAgICAgICAgIHBhdGNoKHBlbmRpbmdCcmFuY2gsIG5ld0JyYW5jaCwgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICBpZiAoc3VzcGVuc2UuZGVwcyA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNJbkZhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRjaChhY3RpdmVCcmFuY2gsIG5ld0ZhbGxiYWNrLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBudWxsLCAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxyXG4gICAgICAgICAgICAgICAgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgbmV3RmFsbGJhY2spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB0b2dnbGVkIGJlZm9yZSBwZW5kaW5nIHRyZWUgaXMgcmVzb2x2ZWRcclxuICAgICAgICAgICAgc3VzcGVuc2UucGVuZGluZ0lkKys7XHJcbiAgICAgICAgICAgIGlmIChpc0h5ZHJhdGluZykge1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgdG9nZ2xlZCBiZWZvcmUgaHlkcmF0aW9uIGlzIGZpbmlzaGVkLCB0aGUgY3VycmVudCBET00gdHJlZSBpc1xyXG4gICAgICAgICAgICAgICAgLy8gbm8gbG9uZ2VyIHZhbGlkLiBzZXQgaXQgYXMgdGhlIGFjdGl2ZSBicmFuY2ggc28gaXQgd2lsbCBiZSB1bm1vdW50ZWRcclxuICAgICAgICAgICAgICAgIC8vIHdoZW4gcmVzb2x2ZWRcclxuICAgICAgICAgICAgICAgIHN1c3BlbnNlLmlzSHlkcmF0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBzdXNwZW5zZS5hY3RpdmVCcmFuY2ggPSBwZW5kaW5nQnJhbmNoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdW5tb3VudChwZW5kaW5nQnJhbmNoLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpbmNyZW1lbnQgcGVuZGluZyBJRC4gdGhpcyBpcyB1c2VkIHRvIGludmFsaWRhdGUgYXN5bmMgY2FsbGJhY2tzXHJcbiAgICAgICAgICAgIC8vIHJlc2V0IHN1c3BlbnNlIHN0YXRlXHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmRlcHMgPSAwO1xyXG4gICAgICAgICAgICAvLyBkaXNjYXJkIGVmZmVjdHMgZnJvbSBwZW5kaW5nIGJyYW5jaFxyXG4gICAgICAgICAgICBzdXNwZW5zZS5lZmZlY3RzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIC8vIGRpc2NhcmQgcHJldmlvdXMgY29udGFpbmVyXHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICBpZiAoaXNJbkZhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IGluIGZhbGxiYWNrIHN0YXRlXHJcbiAgICAgICAgICAgICAgICBwYXRjaChudWxsLCBuZXdCcmFuY2gsIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRjaChhY3RpdmVCcmFuY2gsIG5ld0ZhbGxiYWNrLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBudWxsLCAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxyXG4gICAgICAgICAgICAgICAgICAgIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBuZXdGYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYWN0aXZlQnJhbmNoICYmIGlzU2FtZVZOb2RlVHlwZShuZXdCcmFuY2gsIGFjdGl2ZUJyYW5jaCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIHRvZ2dsZWQgXCJiYWNrXCIgdG8gY3VycmVudCBhY3RpdmUgYnJhbmNoXHJcbiAgICAgICAgICAgICAgICBwYXRjaChhY3RpdmVCcmFuY2gsIG5ld0JyYW5jaCwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICAvLyBmb3JjZSByZXNvbHZlXHJcbiAgICAgICAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gc3dpdGNoZWQgdG8gYSAzcmQgYnJhbmNoXHJcbiAgICAgICAgICAgICAgICBwYXRjaChudWxsLCBuZXdCcmFuY2gsIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoYWN0aXZlQnJhbmNoICYmIGlzU2FtZVZOb2RlVHlwZShuZXdCcmFuY2gsIGFjdGl2ZUJyYW5jaCkpIHtcclxuICAgICAgICAgICAgLy8gcm9vdCBkaWQgbm90IGNoYW5nZSwganVzdCBub3JtYWwgcGF0Y2hcclxuICAgICAgICAgICAgcGF0Y2goYWN0aXZlQnJhbmNoLCBuZXdCcmFuY2gsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIG5ld0JyYW5jaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyByb290IG5vZGUgdG9nZ2xlZFxyXG4gICAgICAgICAgICAvLyBpbnZva2UgQHBlbmRpbmcgZXZlbnRcclxuICAgICAgICAgICAgY29uc3Qgb25QZW5kaW5nID0gbjIucHJvcHMgJiYgbjIucHJvcHMub25QZW5kaW5nO1xyXG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihvblBlbmRpbmcpKSB7XHJcbiAgICAgICAgICAgICAgICBvblBlbmRpbmcoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBtb3VudCBwZW5kaW5nIGJyYW5jaCBpbiBvZmYtZG9tIGNvbnRhaW5lclxyXG4gICAgICAgICAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gbmV3QnJhbmNoO1xyXG4gICAgICAgICAgICBzdXNwZW5zZS5wZW5kaW5nSWQrKztcclxuICAgICAgICAgICAgcGF0Y2gobnVsbCwgbmV3QnJhbmNoLCBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIGluY29taW5nIGJyYW5jaCBoYXMgbm8gYXN5bmMgZGVwcywgcmVzb2x2ZSBub3cuXHJcbiAgICAgICAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHRpbWVvdXQsIHBlbmRpbmdJZCB9ID0gc3VzcGVuc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAodGltZW91dCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1c3BlbnNlLnBlbmRpbmdJZCA9PT0gcGVuZGluZ0lkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdXNwZW5zZS5mYWxsYmFjayhuZXdGYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRpbWVvdXQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBzdXNwZW5zZS5mYWxsYmFjayhuZXdGYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxubGV0IGhhc1dhcm5lZCA9IGZhbHNlO1xyXG5mdW5jdGlvbiBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KHZub2RlLCBwYXJlbnQsIHBhcmVudENvbXBvbmVudCwgY29udGFpbmVyLCBoaWRkZW5Db250YWluZXIsIGFuY2hvciwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscywgaXNIeWRyYXRpbmcgPSBmYWxzZSkge1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFmYWxzZSAmJiAhaGFzV2FybmVkKSB7XHJcbiAgICAgICAgaGFzV2FybmVkID0gdHJ1ZTtcclxuICAgICAgICAvLyBAdHMtaWdub3JlIGBjb25zb2xlLmluZm9gIGNhbm5vdCBiZSBudWxsIGVycm9yXHJcbiAgICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oYDxTdXNwZW5zZT4gaXMgYW4gZXhwZXJpbWVudGFsIGZlYXR1cmUgYW5kIGl0cyBBUEkgd2lsbCBsaWtlbHkgY2hhbmdlLmApO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBwOiBwYXRjaCwgbTogbW92ZSwgdW06IHVubW91bnQsIG46IG5leHQsIG86IHsgcGFyZW50Tm9kZSwgcmVtb3ZlIH0gfSA9IHJlbmRlcmVySW50ZXJuYWxzO1xyXG4gICAgY29uc3QgdGltZW91dCA9IHRvTnVtYmVyKHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLnRpbWVvdXQpO1xyXG4gICAgY29uc3Qgc3VzcGVuc2UgPSB7XHJcbiAgICAgICAgdm5vZGUsXHJcbiAgICAgICAgcGFyZW50LFxyXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcclxuICAgICAgICBpc1NWRyxcclxuICAgICAgICBjb250YWluZXIsXHJcbiAgICAgICAgaGlkZGVuQ29udGFpbmVyLFxyXG4gICAgICAgIGFuY2hvcixcclxuICAgICAgICBkZXBzOiAwLFxyXG4gICAgICAgIHBlbmRpbmdJZDogMCxcclxuICAgICAgICB0aW1lb3V0OiB0eXBlb2YgdGltZW91dCA9PT0gJ251bWJlcicgPyB0aW1lb3V0IDogLTEsXHJcbiAgICAgICAgYWN0aXZlQnJhbmNoOiBudWxsLFxyXG4gICAgICAgIHBlbmRpbmdCcmFuY2g6IG51bGwsXHJcbiAgICAgICAgaXNJbkZhbGxiYWNrOiB0cnVlLFxyXG4gICAgICAgIGlzSHlkcmF0aW5nLFxyXG4gICAgICAgIGlzVW5tb3VudGVkOiBmYWxzZSxcclxuICAgICAgICBlZmZlY3RzOiBbXSxcclxuICAgICAgICByZXNvbHZlKHJlc3VtZSA9IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIGlmICghcmVzdW1lICYmICFzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzdXNwZW5zZS5yZXNvbHZlKCkgaXMgY2FsbGVkIHdpdGhvdXQgYSBwZW5kaW5nIGJyYW5jaC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzdXNwZW5zZS5pc1VubW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc3VzcGVuc2UucmVzb2x2ZSgpIGlzIGNhbGxlZCBvbiBhbiBhbHJlYWR5IHVubW91bnRlZCBzdXNwZW5zZSBib3VuZGFyeS5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB7IHZub2RlLCBhY3RpdmVCcmFuY2gsIHBlbmRpbmdCcmFuY2gsIHBlbmRpbmdJZCwgZWZmZWN0cywgcGFyZW50Q29tcG9uZW50LCBjb250YWluZXIgfSA9IHN1c3BlbnNlO1xyXG4gICAgICAgICAgICBpZiAoc3VzcGVuc2UuaXNIeWRyYXRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHN1c3BlbnNlLmlzSHlkcmF0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIXJlc3VtZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGVsYXlFbnRlciA9IGFjdGl2ZUJyYW5jaCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdCcmFuY2gudHJhbnNpdGlvbiAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdCcmFuY2gudHJhbnNpdGlvbi5tb2RlID09PSAnb3V0LWluJztcclxuICAgICAgICAgICAgICAgIGlmIChkZWxheUVudGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlQnJhbmNoLnRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlbmRpbmdJZCA9PT0gc3VzcGVuc2UucGVuZGluZ0lkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3ZlKHBlbmRpbmdCcmFuY2gsIGNvbnRhaW5lciwgYW5jaG9yLCAwIC8qIEVOVEVSICovKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGluaXRpYWwgYW5jaG9yIG9uIG1vdW50XHJcbiAgICAgICAgICAgICAgICBsZXQgeyBhbmNob3IgfSA9IHN1c3BlbnNlO1xyXG4gICAgICAgICAgICAgICAgLy8gdW5tb3VudCBjdXJyZW50IGFjdGl2ZSB0cmVlXHJcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlQnJhbmNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGZhbGxiYWNrIHRyZWUgd2FzIG1vdW50ZWQsIGl0IG1heSBoYXZlIGJlZW4gbW92ZWRcclxuICAgICAgICAgICAgICAgICAgICAvLyBhcyBwYXJ0IG9mIGEgcGFyZW50IHN1c3BlbnNlLiBnZXQgdGhlIGxhdGVzdCBhbmNob3IgZm9yIGluc2VydGlvblxyXG4gICAgICAgICAgICAgICAgICAgIGFuY2hvciA9IG5leHQoYWN0aXZlQnJhbmNoKTtcclxuICAgICAgICAgICAgICAgICAgICB1bm1vdW50KGFjdGl2ZUJyYW5jaCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRlbGF5RW50ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlIGNvbnRlbnQgZnJvbSBvZmYtZG9tIGNvbnRhaW5lciB0byBhY3R1YWwgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAgICAgbW92ZShwZW5kaW5nQnJhbmNoLCBjb250YWluZXIsIGFuY2hvciwgMCAvKiBFTlRFUiAqLyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBwZW5kaW5nQnJhbmNoKTtcclxuICAgICAgICAgICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IG51bGw7XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmlzSW5GYWxsYmFjayA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvLyBmbHVzaCBidWZmZXJlZCBlZmZlY3RzXHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGlzIGEgcGVuZGluZyBwYXJlbnQgc3VzcGVuc2VcclxuICAgICAgICAgICAgbGV0IHBhcmVudCA9IHN1c3BlbnNlLnBhcmVudDtcclxuICAgICAgICAgICAgbGV0IGhhc1VucmVzb2x2ZWRBbmNlc3RvciA9IGZhbHNlO1xyXG4gICAgICAgICAgICB3aGlsZSAocGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50LnBlbmRpbmdCcmFuY2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBmb3VuZCBhIHBlbmRpbmcgcGFyZW50IHN1c3BlbnNlLCBtZXJnZSBidWZmZXJlZCBwb3N0IGpvYnNcclxuICAgICAgICAgICAgICAgICAgICAvLyBpbnRvIHRoYXQgcGFyZW50XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmVmZmVjdHMucHVzaCguLi5lZmZlY3RzKTtcclxuICAgICAgICAgICAgICAgICAgICBoYXNVbnJlc29sdmVkQW5jZXN0b3IgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBubyBwZW5kaW5nIHBhcmVudCBzdXNwZW5zZSwgZmx1c2ggYWxsIGpvYnNcclxuICAgICAgICAgICAgaWYgKCFoYXNVbnJlc29sdmVkQW5jZXN0b3IpIHtcclxuICAgICAgICAgICAgICAgIHF1ZXVlUG9zdEZsdXNoQ2IoZWZmZWN0cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3VzcGVuc2UuZWZmZWN0cyA9IFtdO1xyXG4gICAgICAgICAgICAvLyBpbnZva2UgQHJlc29sdmUgZXZlbnRcclxuICAgICAgICAgICAgY29uc3Qgb25SZXNvbHZlID0gdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMub25SZXNvbHZlO1xyXG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihvblJlc29sdmUpKSB7XHJcbiAgICAgICAgICAgICAgICBvblJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZmFsbGJhY2soZmFsbGJhY2tWTm9kZSkge1xyXG4gICAgICAgICAgICBpZiAoIXN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB7IHZub2RlLCBhY3RpdmVCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgY29udGFpbmVyLCBpc1NWRyB9ID0gc3VzcGVuc2U7XHJcbiAgICAgICAgICAgIC8vIGludm9rZSBAZmFsbGJhY2sgZXZlbnRcclxuICAgICAgICAgICAgY29uc3Qgb25GYWxsYmFjayA9IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLm9uRmFsbGJhY2s7XHJcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKG9uRmFsbGJhY2spKSB7XHJcbiAgICAgICAgICAgICAgICBvbkZhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgYW5jaG9yID0gbmV4dChhY3RpdmVCcmFuY2gpO1xyXG4gICAgICAgICAgICBjb25zdCBtb3VudEZhbGxiYWNrID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzdXNwZW5zZS5pc0luRmFsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBtb3VudCB0aGUgZmFsbGJhY2sgdHJlZVxyXG4gICAgICAgICAgICAgICAgcGF0Y2gobnVsbCwgZmFsbGJhY2tWTm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgbnVsbCwgLy8gZmFsbGJhY2sgdHJlZSB3aWxsIG5vdCBoYXZlIHN1c3BlbnNlIGNvbnRleHRcclxuICAgICAgICAgICAgICAgIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIGZhbGxiYWNrVk5vZGUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBkZWxheUVudGVyID0gZmFsbGJhY2tWTm9kZS50cmFuc2l0aW9uICYmIGZhbGxiYWNrVk5vZGUudHJhbnNpdGlvbi5tb2RlID09PSAnb3V0LWluJztcclxuICAgICAgICAgICAgaWYgKGRlbGF5RW50ZXIpIHtcclxuICAgICAgICAgICAgICAgIGFjdGl2ZUJyYW5jaC50cmFuc2l0aW9uLmFmdGVyTGVhdmUgPSBtb3VudEZhbGxiYWNrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHVubW91bnQgY3VycmVudCBhY3RpdmUgYnJhbmNoXHJcbiAgICAgICAgICAgIHVubW91bnQoYWN0aXZlQnJhbmNoLCBwYXJlbnRDb21wb25lbnQsIG51bGwsIC8vIG5vIHN1c3BlbnNlIHNvIHVubW91bnQgaG9va3MgZmlyZSBub3dcclxuICAgICAgICAgICAgdHJ1ZSAvLyBzaG91bGRSZW1vdmVcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgc3VzcGVuc2UuaXNJbkZhbGxiYWNrID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKCFkZWxheUVudGVyKSB7XHJcbiAgICAgICAgICAgICAgICBtb3VudEZhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG1vdmUoY29udGFpbmVyLCBhbmNob3IsIHR5cGUpIHtcclxuICAgICAgICAgICAgc3VzcGVuc2UuYWN0aXZlQnJhbmNoICYmXHJcbiAgICAgICAgICAgICAgICBtb3ZlKHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCwgY29udGFpbmVyLCBhbmNob3IsIHR5cGUpO1xyXG4gICAgICAgICAgICBzdXNwZW5zZS5jb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBuZXh0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3VzcGVuc2UuYWN0aXZlQnJhbmNoICYmIG5leHQoc3VzcGVuc2UuYWN0aXZlQnJhbmNoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlZ2lzdGVyRGVwKGluc3RhbmNlLCBzZXR1cFJlbmRlckVmZmVjdCkge1xyXG4gICAgICAgICAgICBjb25zdCBpc0luUGVuZGluZ1N1c3BlbnNlID0gISFzdXNwZW5zZS5wZW5kaW5nQnJhbmNoO1xyXG4gICAgICAgICAgICBpZiAoaXNJblBlbmRpbmdTdXNwZW5zZSkge1xyXG4gICAgICAgICAgICAgICAgc3VzcGVuc2UuZGVwcysrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGh5ZHJhdGVkRWwgPSBpbnN0YW5jZS52bm9kZS5lbDtcclxuICAgICAgICAgICAgaW5zdGFuY2VcclxuICAgICAgICAgICAgICAgIC5hc3luY0RlcC5jYXRjaChlcnIgPT4ge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgMCAvKiBTRVRVUF9GVU5DVElPTiAqLyk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAudGhlbihhc3luY1NldHVwUmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIHJldHJ5IHdoZW4gdGhlIHNldHVwKCkgcHJvbWlzZSByZXNvbHZlcy5cclxuICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudCBtYXkgaGF2ZSBiZWVuIHVubW91bnRlZCBiZWZvcmUgcmVzb2x2ZS5cclxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5pc1VubW91bnRlZCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLmlzVW5tb3VudGVkIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgc3VzcGVuc2UucGVuZGluZ0lkICE9PSBpbnN0YW5jZS5zdXNwZW5zZUlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gcmV0cnkgZnJvbSB0aGlzIGNvbXBvbmVudFxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuYXN5bmNSZXNvbHZlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHZub2RlIH0gPSBpbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBwdXNoV2FybmluZ0NvbnRleHQodm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIGFzeW5jU2V0dXBSZXN1bHQsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIGlmIChoeWRyYXRlZEVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdm5vZGUgbWF5IGhhdmUgYmVlbiByZXBsYWNlZCBpZiBhbiB1cGRhdGUgaGFwcGVuZWQgYmVmb3JlIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzeW5jIGRlcCBpcyByZXNvbHZlZC5cclxuICAgICAgICAgICAgICAgICAgICB2bm9kZS5lbCA9IGh5ZHJhdGVkRWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9ICFoeWRyYXRlZEVsICYmIGluc3RhbmNlLnN1YlRyZWUuZWw7XHJcbiAgICAgICAgICAgICAgICBzZXR1cFJlbmRlckVmZmVjdChpbnN0YW5jZSwgdm5vZGUsIFxyXG4gICAgICAgICAgICAgICAgLy8gY29tcG9uZW50IG1heSBoYXZlIGJlZW4gbW92ZWQgYmVmb3JlIHJlc29sdmUuXHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGlzIG5vdCBhIGh5ZHJhdGlvbiwgaW5zdGFuY2Uuc3ViVHJlZSB3aWxsIGJlIHRoZSBjb21tZW50XHJcbiAgICAgICAgICAgICAgICAvLyBwbGFjZWhvbGRlci5cclxuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUoaHlkcmF0ZWRFbCB8fCBpbnN0YW5jZS5zdWJUcmVlLmVsKSwgXHJcbiAgICAgICAgICAgICAgICAvLyBhbmNob3Igd2lsbCBub3QgYmUgdXNlZCBpZiB0aGlzIGlzIGh5ZHJhdGlvbiwgc28gb25seSBuZWVkIHRvXHJcbiAgICAgICAgICAgICAgICAvLyBjb25zaWRlciB0aGUgY29tbWVudCBwbGFjZWhvbGRlciBjYXNlLlxyXG4gICAgICAgICAgICAgICAgaHlkcmF0ZWRFbCA/IG51bGwgOiBuZXh0KGluc3RhbmNlLnN1YlRyZWUpLCBzdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocGxhY2Vob2xkZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmUocGxhY2Vob2xkZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdXBkYXRlSE9DSG9zdEVsKGluc3RhbmNlLCB2bm9kZS5lbCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG9ubHkgZGVjcmVhc2UgZGVwcyBjb3VudCBpZiBzdXNwZW5zZSBpcyBub3QgYWxyZWFkeSByZXNvbHZlZFxyXG4gICAgICAgICAgICAgICAgaWYgKGlzSW5QZW5kaW5nU3VzcGVuc2UgJiYgLS1zdXNwZW5zZS5kZXBzID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHVubW91bnQocGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKSB7XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmlzVW5tb3VudGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCkge1xyXG4gICAgICAgICAgICAgICAgdW5tb3VudChzdXNwZW5zZS5hY3RpdmVCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xyXG4gICAgICAgICAgICAgICAgdW5tb3VudChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHN1c3BlbnNlO1xyXG59XHJcbmZ1bmN0aW9uIGh5ZHJhdGVTdXNwZW5zZShub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscywgaHlkcmF0ZU5vZGUpIHtcclxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAqL1xyXG4gICAgY29uc3Qgc3VzcGVuc2UgPSAodm5vZGUuc3VzcGVuc2UgPSBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KHZub2RlLCBwYXJlbnRTdXNwZW5zZSwgcGFyZW50Q29tcG9uZW50LCBub2RlLnBhcmVudE5vZGUsIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLCBudWxsLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzLCB0cnVlIC8qIGh5ZHJhdGluZyAqLykpO1xyXG4gICAgLy8gdGhlcmUgYXJlIHR3byBwb3NzaWJsZSBzY2VuYXJpb3MgZm9yIHNlcnZlci1yZW5kZXJlZCBzdXNwZW5zZTpcclxuICAgIC8vIC0gc3VjY2Vzczogc3NyIGNvbnRlbnQgc2hvdWxkIGJlIGZ1bGx5IHJlc29sdmVkXHJcbiAgICAvLyAtIGZhaWx1cmU6IHNzciBjb250ZW50IHNob3VsZCBiZSB0aGUgZmFsbGJhY2sgYnJhbmNoLlxyXG4gICAgLy8gaG93ZXZlciwgb24gdGhlIGNsaWVudCB3ZSBkb24ndCByZWFsbHkga25vdyBpZiBpdCBoYXMgZmFpbGVkIG9yIG5vdFxyXG4gICAgLy8gYXR0ZW1wdCB0byBoeWRyYXRlIHRoZSBET00gYXNzdW1pbmcgaXQgaGFzIHN1Y2NlZWRlZCwgYnV0IHdlIHN0aWxsXHJcbiAgICAvLyBuZWVkIHRvIGNvbnN0cnVjdCBhIHN1c3BlbnNlIGJvdW5kYXJ5IGZpcnN0XHJcbiAgICBjb25zdCByZXN1bHQgPSBoeWRyYXRlTm9kZShub2RlLCAoc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IHZub2RlLnNzQ29udGVudCksIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgIGlmIChzdXNwZW5zZS5kZXBzID09PSAwKSB7XHJcbiAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIC8qIGVzbGludC1lbmFibGUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzICovXHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplU3VzcGVuc2VDaGlsZHJlbih2bm9kZSkge1xyXG4gICAgY29uc3QgeyBzaGFwZUZsYWcsIGNoaWxkcmVuIH0gPSB2bm9kZTtcclxuICAgIGNvbnN0IGlzU2xvdENoaWxkcmVuID0gc2hhcGVGbGFnICYgMzIgLyogU0xPVFNfQ0hJTERSRU4gKi87XHJcbiAgICB2bm9kZS5zc0NvbnRlbnQgPSBub3JtYWxpemVTdXNwZW5zZVNsb3QoaXNTbG90Q2hpbGRyZW4gPyBjaGlsZHJlbi5kZWZhdWx0IDogY2hpbGRyZW4pO1xyXG4gICAgdm5vZGUuc3NGYWxsYmFjayA9IGlzU2xvdENoaWxkcmVuXHJcbiAgICAgICAgPyBub3JtYWxpemVTdXNwZW5zZVNsb3QoY2hpbGRyZW4uZmFsbGJhY2spXHJcbiAgICAgICAgOiBjcmVhdGVWTm9kZShDb21tZW50KTtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVTdXNwZW5zZVNsb3Qocykge1xyXG4gICAgbGV0IGJsb2NrO1xyXG4gICAgaWYgKGlzRnVuY3Rpb24ocykpIHtcclxuICAgICAgICBjb25zdCBpc0NvbXBpbGVkU2xvdCA9IHMuX2M7XHJcbiAgICAgICAgaWYgKGlzQ29tcGlsZWRTbG90KSB7XHJcbiAgICAgICAgICAgIC8vIGRpc2FibGVUcmFja2luZzogZmFsc2VcclxuICAgICAgICAgICAgLy8gYWxsb3cgYmxvY2sgdHJhY2tpbmcgZm9yIGNvbXBpbGVkIHNsb3RzXHJcbiAgICAgICAgICAgIC8vIChzZWUgLi9jb21wb25lbnRSZW5kZXJDb250ZXh0LnRzKVxyXG4gICAgICAgICAgICBzLl9kID0gZmFsc2U7XHJcbiAgICAgICAgICAgIG9wZW5CbG9jaygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzID0gcygpO1xyXG4gICAgICAgIGlmIChpc0NvbXBpbGVkU2xvdCkge1xyXG4gICAgICAgICAgICBzLl9kID0gdHJ1ZTtcclxuICAgICAgICAgICAgYmxvY2sgPSBjdXJyZW50QmxvY2s7XHJcbiAgICAgICAgICAgIGNsb3NlQmxvY2soKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaXNBcnJheShzKSkge1xyXG4gICAgICAgIGNvbnN0IHNpbmdsZUNoaWxkID0gZmlsdGVyU2luZ2xlUm9vdChzKTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFzaW5nbGVDaGlsZCkge1xyXG4gICAgICAgICAgICB3YXJuKGA8U3VzcGVuc2U+IHNsb3RzIGV4cGVjdCBhIHNpbmdsZSByb290IG5vZGUuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHMgPSBzaW5nbGVDaGlsZDtcclxuICAgIH1cclxuICAgIHMgPSBub3JtYWxpemVWTm9kZShzKTtcclxuICAgIGlmIChibG9jaykge1xyXG4gICAgICAgIHMuZHluYW1pY0NoaWxkcmVuID0gYmxvY2suZmlsdGVyKGMgPT4gYyAhPT0gcyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcztcclxufVxyXG5mdW5jdGlvbiBxdWV1ZUVmZmVjdFdpdGhTdXNwZW5zZShmbiwgc3VzcGVuc2UpIHtcclxuICAgIGlmIChzdXNwZW5zZSAmJiBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XHJcbiAgICAgICAgaWYgKGlzQXJyYXkoZm4pKSB7XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmVmZmVjdHMucHVzaCguLi5mbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzdXNwZW5zZS5lZmZlY3RzLnB1c2goZm4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHF1ZXVlUG9zdEZsdXNoQ2IoZm4pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgYnJhbmNoKSB7XHJcbiAgICBzdXNwZW5zZS5hY3RpdmVCcmFuY2ggPSBicmFuY2g7XHJcbiAgICBjb25zdCB7IHZub2RlLCBwYXJlbnRDb21wb25lbnQgfSA9IHN1c3BlbnNlO1xyXG4gICAgY29uc3QgZWwgPSAodm5vZGUuZWwgPSBicmFuY2guZWwpO1xyXG4gICAgLy8gaW4gY2FzZSBzdXNwZW5zZSBpcyB0aGUgcm9vdCBub2RlIG9mIGEgY29tcG9uZW50LFxyXG4gICAgLy8gcmVjdXJzaXZlbHkgdXBkYXRlIHRoZSBIT0MgZWxcclxuICAgIGlmIChwYXJlbnRDb21wb25lbnQgJiYgcGFyZW50Q29tcG9uZW50LnN1YlRyZWUgPT09IHZub2RlKSB7XHJcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LnZub2RlLmVsID0gZWw7XHJcbiAgICAgICAgdXBkYXRlSE9DSG9zdEVsKHBhcmVudENvbXBvbmVudCwgZWwpO1xyXG4gICAgfVxyXG59XG5cbmZ1bmN0aW9uIHByb3ZpZGUoa2V5LCB2YWx1ZSkge1xyXG4gICAgaWYgKCFjdXJyZW50SW5zdGFuY2UpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYHByb3ZpZGUoKSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBzZXR1cCgpLmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGxldCBwcm92aWRlcyA9IGN1cnJlbnRJbnN0YW5jZS5wcm92aWRlcztcclxuICAgICAgICAvLyBieSBkZWZhdWx0IGFuIGluc3RhbmNlIGluaGVyaXRzIGl0cyBwYXJlbnQncyBwcm92aWRlcyBvYmplY3RcclxuICAgICAgICAvLyBidXQgd2hlbiBpdCBuZWVkcyB0byBwcm92aWRlIHZhbHVlcyBvZiBpdHMgb3duLCBpdCBjcmVhdGVzIGl0c1xyXG4gICAgICAgIC8vIG93biBwcm92aWRlcyBvYmplY3QgdXNpbmcgcGFyZW50IHByb3ZpZGVzIG9iamVjdCBhcyBwcm90b3R5cGUuXHJcbiAgICAgICAgLy8gdGhpcyB3YXkgaW4gYGluamVjdGAgd2UgY2FuIHNpbXBseSBsb29rIHVwIGluamVjdGlvbnMgZnJvbSBkaXJlY3RcclxuICAgICAgICAvLyBwYXJlbnQgYW5kIGxldCB0aGUgcHJvdG90eXBlIGNoYWluIGRvIHRoZSB3b3JrLlxyXG4gICAgICAgIGNvbnN0IHBhcmVudFByb3ZpZGVzID0gY3VycmVudEluc3RhbmNlLnBhcmVudCAmJiBjdXJyZW50SW5zdGFuY2UucGFyZW50LnByb3ZpZGVzO1xyXG4gICAgICAgIGlmIChwYXJlbnRQcm92aWRlcyA9PT0gcHJvdmlkZXMpIHtcclxuICAgICAgICAgICAgcHJvdmlkZXMgPSBjdXJyZW50SW5zdGFuY2UucHJvdmlkZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFByb3ZpZGVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVFMgZG9lc24ndCBhbGxvdyBzeW1ib2wgYXMgaW5kZXggdHlwZVxyXG4gICAgICAgIHByb3ZpZGVzW2tleV0gPSB2YWx1ZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpbmplY3Qoa2V5LCBkZWZhdWx0VmFsdWUsIHRyZWF0RGVmYXVsdEFzRmFjdG9yeSA9IGZhbHNlKSB7XHJcbiAgICAvLyBmYWxsYmFjayB0byBgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlYCBzbyB0aGF0IHRoaXMgY2FuIGJlIGNhbGxlZCBpblxyXG4gICAgLy8gYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxyXG4gICAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2UgfHwgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xyXG4gICAgaWYgKGluc3RhbmNlKSB7XHJcbiAgICAgICAgLy8gIzI0MDBcclxuICAgICAgICAvLyB0byBzdXBwb3J0IGBhcHAudXNlYCBwbHVnaW5zLFxyXG4gICAgICAgIC8vIGZhbGxiYWNrIHRvIGFwcENvbnRleHQncyBgcHJvdmlkZXNgIGlmIHRoZSBpbnRhbmNlIGlzIGF0IHJvb3RcclxuICAgICAgICBjb25zdCBwcm92aWRlcyA9IGluc3RhbmNlLnBhcmVudCA9PSBudWxsXHJcbiAgICAgICAgICAgID8gaW5zdGFuY2Uudm5vZGUuYXBwQ29udGV4dCAmJiBpbnN0YW5jZS52bm9kZS5hcHBDb250ZXh0LnByb3ZpZGVzXHJcbiAgICAgICAgICAgIDogaW5zdGFuY2UucGFyZW50LnByb3ZpZGVzO1xyXG4gICAgICAgIGlmIChwcm92aWRlcyAmJiBrZXkgaW4gcHJvdmlkZXMpIHtcclxuICAgICAgICAgICAgLy8gVFMgZG9lc24ndCBhbGxvdyBzeW1ib2wgYXMgaW5kZXggdHlwZVxyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXNba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRyZWF0RGVmYXVsdEFzRmFjdG9yeSAmJiBpc0Z1bmN0aW9uKGRlZmF1bHRWYWx1ZSlcclxuICAgICAgICAgICAgICAgID8gZGVmYXVsdFZhbHVlKClcclxuICAgICAgICAgICAgICAgIDogZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgd2FybihgaW5qZWN0aW9uIFwiJHtTdHJpbmcoa2V5KX1cIiBub3QgZm91bmQuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgd2FybihgaW5qZWN0KCkgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgc2V0dXAoKSBvciBmdW5jdGlvbmFsIGNvbXBvbmVudHMuYCk7XHJcbiAgICB9XHJcbn1cblxuLy8gU2ltcGxlIGVmZmVjdC5cclxuZnVuY3Rpb24gd2F0Y2hFZmZlY3QoZWZmZWN0LCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gZG9XYXRjaChlZmZlY3QsIG51bGwsIG9wdGlvbnMpO1xyXG59XHJcbi8vIGluaXRpYWwgdmFsdWUgZm9yIHdhdGNoZXJzIHRvIHRyaWdnZXIgb24gdW5kZWZpbmVkIGluaXRpYWwgdmFsdWVzXHJcbmNvbnN0IElOSVRJQUxfV0FUQ0hFUl9WQUxVRSA9IHt9O1xyXG4vLyBpbXBsZW1lbnRhdGlvblxyXG5mdW5jdGlvbiB3YXRjaChzb3VyY2UsIGNiLCBvcHRpb25zKSB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc0Z1bmN0aW9uKGNiKSkge1xyXG4gICAgICAgIHdhcm4oYFxcYHdhdGNoKGZuLCBvcHRpb25zPylcXGAgc2lnbmF0dXJlIGhhcyBiZWVuIG1vdmVkIHRvIGEgc2VwYXJhdGUgQVBJLiBgICtcclxuICAgICAgICAgICAgYFVzZSBcXGB3YXRjaEVmZmVjdChmbiwgb3B0aW9ucz8pXFxgIGluc3RlYWQuIFxcYHdhdGNoXFxgIG5vdyBvbmx5IGAgK1xyXG4gICAgICAgICAgICBgc3VwcG9ydHMgXFxgd2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucz8pIHNpZ25hdHVyZS5gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBkb1dhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnMpO1xyXG59XHJcbmZ1bmN0aW9uIGRvV2F0Y2goc291cmNlLCBjYiwgeyBpbW1lZGlhdGUsIGRlZXAsIGZsdXNoLCBvblRyYWNrLCBvblRyaWdnZXIgfSA9IEVNUFRZX09CSiwgaW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2UpIHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWNiKSB7XHJcbiAgICAgICAgaWYgKGltbWVkaWF0ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYHdhdGNoKCkgXCJpbW1lZGlhdGVcIiBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyB0aGUgYCArXHJcbiAgICAgICAgICAgICAgICBgd2F0Y2goc291cmNlLCBjYWxsYmFjaywgb3B0aW9ucz8pIHNpZ25hdHVyZS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRlZXAgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB3YXJuKGB3YXRjaCgpIFwiZGVlcFwiIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIHRoZSBgICtcclxuICAgICAgICAgICAgICAgIGB3YXRjaChzb3VyY2UsIGNhbGxiYWNrLCBvcHRpb25zPykgc2lnbmF0dXJlLmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IHdhcm5JbnZhbGlkU291cmNlID0gKHMpID0+IHtcclxuICAgICAgICB3YXJuKGBJbnZhbGlkIHdhdGNoIHNvdXJjZTogYCwgcywgYEEgd2F0Y2ggc291cmNlIGNhbiBvbmx5IGJlIGEgZ2V0dGVyL2VmZmVjdCBmdW5jdGlvbiwgYSByZWYsIGAgK1xyXG4gICAgICAgICAgICBgYSByZWFjdGl2ZSBvYmplY3QsIG9yIGFuIGFycmF5IG9mIHRoZXNlIHR5cGVzLmApO1xyXG4gICAgfTtcclxuICAgIGxldCBnZXR0ZXI7XHJcbiAgICBsZXQgZm9yY2VUcmlnZ2VyID0gZmFsc2U7XHJcbiAgICBsZXQgaXNNdWx0aVNvdXJjZSA9IGZhbHNlO1xyXG4gICAgaWYgKGlzUmVmKHNvdXJjZSkpIHtcclxuICAgICAgICBnZXR0ZXIgPSAoKSA9PiBzb3VyY2UudmFsdWU7XHJcbiAgICAgICAgZm9yY2VUcmlnZ2VyID0gISFzb3VyY2UuX3NoYWxsb3c7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1JlYWN0aXZlKHNvdXJjZSkpIHtcclxuICAgICAgICBnZXR0ZXIgPSAoKSA9PiBzb3VyY2U7XHJcbiAgICAgICAgZGVlcCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0FycmF5KHNvdXJjZSkpIHtcclxuICAgICAgICBpc011bHRpU291cmNlID0gdHJ1ZTtcclxuICAgICAgICBmb3JjZVRyaWdnZXIgPSBzb3VyY2Uuc29tZShpc1JlYWN0aXZlKTtcclxuICAgICAgICBnZXR0ZXIgPSAoKSA9PiBzb3VyY2UubWFwKHMgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaXNSZWYocykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVhY3RpdmUocykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cmF2ZXJzZShzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbFdpdGhFcnJvckhhbmRsaW5nKHMsIGluc3RhbmNlLCAyIC8qIFdBVENIX0dFVFRFUiAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybkludmFsaWRTb3VyY2Uocyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oc291cmNlKSkge1xyXG4gICAgICAgIGlmIChjYikge1xyXG4gICAgICAgICAgICAvLyBnZXR0ZXIgd2l0aCBjYlxyXG4gICAgICAgICAgICBnZXR0ZXIgPSAoKSA9PiBjYWxsV2l0aEVycm9ySGFuZGxpbmcoc291cmNlLCBpbnN0YW5jZSwgMiAvKiBXQVRDSF9HRVRURVIgKi8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gbm8gY2IgLT4gc2ltcGxlIGVmZmVjdFxyXG4gICAgICAgICAgICBnZXR0ZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2UuaXNVbm1vdW50ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY2xlYW51cCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhzb3VyY2UsIGluc3RhbmNlLCAzIC8qIFdBVENIX0NBTExCQUNLICovLCBbb25JbnZhbGlkYXRlXSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZ2V0dGVyID0gTk9PUDtcclxuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybkludmFsaWRTb3VyY2Uoc291cmNlKTtcclxuICAgIH1cclxuICAgIGlmIChjYiAmJiBkZWVwKSB7XHJcbiAgICAgICAgY29uc3QgYmFzZUdldHRlciA9IGdldHRlcjtcclxuICAgICAgICBnZXR0ZXIgPSAoKSA9PiB0cmF2ZXJzZShiYXNlR2V0dGVyKCkpO1xyXG4gICAgfVxyXG4gICAgbGV0IGNsZWFudXA7XHJcbiAgICBsZXQgb25JbnZhbGlkYXRlID0gKGZuKSA9PiB7XHJcbiAgICAgICAgY2xlYW51cCA9IHJ1bm5lci5vcHRpb25zLm9uU3RvcCA9ICgpID0+IHtcclxuICAgICAgICAgICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgNCAvKiBXQVRDSF9DTEVBTlVQICovKTtcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIGxldCBvbGRWYWx1ZSA9IGlzTXVsdGlTb3VyY2UgPyBbXSA6IElOSVRJQUxfV0FUQ0hFUl9WQUxVRTtcclxuICAgIGNvbnN0IGpvYiA9ICgpID0+IHtcclxuICAgICAgICBpZiAoIXJ1bm5lci5hY3RpdmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2IpIHtcclxuICAgICAgICAgICAgLy8gd2F0Y2goc291cmNlLCBjYilcclxuICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBydW5uZXIoKTtcclxuICAgICAgICAgICAgaWYgKGRlZXAgfHxcclxuICAgICAgICAgICAgICAgIGZvcmNlVHJpZ2dlciB8fFxyXG4gICAgICAgICAgICAgICAgKGlzTXVsdGlTb3VyY2VcclxuICAgICAgICAgICAgICAgICAgICA/IG5ld1ZhbHVlLnNvbWUoKHYsIGkpID0+IGhhc0NoYW5nZWQodiwgb2xkVmFsdWVbaV0pKVxyXG4gICAgICAgICAgICAgICAgICAgIDogaGFzQ2hhbmdlZChuZXdWYWx1ZSwgb2xkVmFsdWUpKSB8fFxyXG4gICAgICAgICAgICAgICAgKGZhbHNlICApKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjbGVhbnVwIGJlZm9yZSBydW5uaW5nIGNiIGFnYWluXHJcbiAgICAgICAgICAgICAgICBpZiAoY2xlYW51cCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGNiLCBpbnN0YW5jZSwgMyAvKiBXQVRDSF9DQUxMQkFDSyAqLywgW1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHBhc3MgdW5kZWZpbmVkIGFzIHRoZSBvbGQgdmFsdWUgd2hlbiBpdCdzIGNoYW5nZWQgZm9yIHRoZSBmaXJzdCB0aW1lXHJcbiAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWUgPT09IElOSVRJQUxfV0FUQ0hFUl9WQUxVRSA/IHVuZGVmaW5lZCA6IG9sZFZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uSW52YWxpZGF0ZVxyXG4gICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB3YXRjaEVmZmVjdFxyXG4gICAgICAgICAgICBydW5uZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gaW1wb3J0YW50OiBtYXJrIHRoZSBqb2IgYXMgYSB3YXRjaGVyIGNhbGxiYWNrIHNvIHRoYXQgc2NoZWR1bGVyIGtub3dzXHJcbiAgICAvLyBpdCBpcyBhbGxvd2VkIHRvIHNlbGYtdHJpZ2dlciAoIzE3MjcpXHJcbiAgICBqb2IuYWxsb3dSZWN1cnNlID0gISFjYjtcclxuICAgIGxldCBzY2hlZHVsZXI7XHJcbiAgICBpZiAoZmx1c2ggPT09ICdzeW5jJykge1xyXG4gICAgICAgIHNjaGVkdWxlciA9IGpvYjsgLy8gdGhlIHNjaGVkdWxlciBmdW5jdGlvbiBnZXRzIGNhbGxlZCBkaXJlY3RseVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZmx1c2ggPT09ICdwb3N0Jykge1xyXG4gICAgICAgIHNjaGVkdWxlciA9ICgpID0+IHF1ZXVlUG9zdFJlbmRlckVmZmVjdChqb2IsIGluc3RhbmNlICYmIGluc3RhbmNlLnN1c3BlbnNlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIGRlZmF1bHQ6ICdwcmUnXHJcbiAgICAgICAgc2NoZWR1bGVyID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWluc3RhbmNlIHx8IGluc3RhbmNlLmlzTW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgcXVldWVQcmVGbHVzaENiKGpvYik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyB3aXRoICdwcmUnIG9wdGlvbiwgdGhlIGZpcnN0IGNhbGwgbXVzdCBoYXBwZW4gYmVmb3JlXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQgc28gaXQgaXMgY2FsbGVkIHN5bmNocm9ub3VzbHkuXHJcbiAgICAgICAgICAgICAgICBqb2IoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBjb25zdCBydW5uZXIgPSBlZmZlY3QoZ2V0dGVyLCB7XHJcbiAgICAgICAgbGF6eTogdHJ1ZSxcclxuICAgICAgICBvblRyYWNrLFxyXG4gICAgICAgIG9uVHJpZ2dlcixcclxuICAgICAgICBzY2hlZHVsZXJcclxuICAgIH0pO1xyXG4gICAgcmVjb3JkSW5zdGFuY2VCb3VuZEVmZmVjdChydW5uZXIsIGluc3RhbmNlKTtcclxuICAgIC8vIGluaXRpYWwgcnVuXHJcbiAgICBpZiAoY2IpIHtcclxuICAgICAgICBpZiAoaW1tZWRpYXRlKSB7XHJcbiAgICAgICAgICAgIGpvYigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb2xkVmFsdWUgPSBydW5uZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChmbHVzaCA9PT0gJ3Bvc3QnKSB7XHJcbiAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KHJ1bm5lciwgaW5zdGFuY2UgJiYgaW5zdGFuY2Uuc3VzcGVuc2UpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcnVubmVyKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIHN0b3AocnVubmVyKTtcclxuICAgICAgICBpZiAoaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgcmVtb3ZlKGluc3RhbmNlLmVmZmVjdHMsIHJ1bm5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG4vLyB0aGlzLiR3YXRjaFxyXG5mdW5jdGlvbiBpbnN0YW5jZVdhdGNoKHNvdXJjZSwgdmFsdWUsIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IHB1YmxpY1RoaXMgPSB0aGlzLnByb3h5O1xyXG4gICAgY29uc3QgZ2V0dGVyID0gaXNTdHJpbmcoc291cmNlKVxyXG4gICAgICAgID8gc291cmNlLmluY2x1ZGVzKCcuJylcclxuICAgICAgICAgICAgPyBjcmVhdGVQYXRoR2V0dGVyKHB1YmxpY1RoaXMsIHNvdXJjZSlcclxuICAgICAgICAgICAgOiAoKSA9PiBwdWJsaWNUaGlzW3NvdXJjZV1cclxuICAgICAgICA6IHNvdXJjZS5iaW5kKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpO1xyXG4gICAgbGV0IGNiO1xyXG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XHJcbiAgICAgICAgY2IgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNiID0gdmFsdWUuaGFuZGxlcjtcclxuICAgICAgICBvcHRpb25zID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZG9XYXRjaChnZXR0ZXIsIGNiLmJpbmQocHVibGljVGhpcyksIG9wdGlvbnMsIHRoaXMpO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVBhdGhHZXR0ZXIoY3R4LCBwYXRoKSB7XHJcbiAgICBjb25zdCBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgbGV0IGN1ciA9IGN0eDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aCAmJiBjdXI7IGkrKykge1xyXG4gICAgICAgICAgICBjdXIgPSBjdXJbc2VnbWVudHNbaV1dO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3VyO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiB0cmF2ZXJzZSh2YWx1ZSwgc2VlbiA9IG5ldyBTZXQoKSkge1xyXG4gICAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHxcclxuICAgICAgICBzZWVuLmhhcyh2YWx1ZSkgfHxcclxuICAgICAgICB2YWx1ZVtcIl9fdl9za2lwXCIgLyogU0tJUCAqL10pIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBzZWVuLmFkZCh2YWx1ZSk7XHJcbiAgICBpZiAoaXNSZWYodmFsdWUpKSB7XHJcbiAgICAgICAgdHJhdmVyc2UodmFsdWUudmFsdWUsIHNlZW4pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRyYXZlcnNlKHZhbHVlW2ldLCBzZWVuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1NldCh2YWx1ZSkgfHwgaXNNYXAodmFsdWUpKSB7XHJcbiAgICAgICAgdmFsdWUuZm9yRWFjaCgodikgPT4ge1xyXG4gICAgICAgICAgICB0cmF2ZXJzZSh2LCBzZWVuKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsdWUpKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcclxuICAgICAgICAgICAgdHJhdmVyc2UodmFsdWVba2V5XSwgc2Vlbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XG5cbmZ1bmN0aW9uIHVzZVRyYW5zaXRpb25TdGF0ZSgpIHtcclxuICAgIGNvbnN0IHN0YXRlID0ge1xyXG4gICAgICAgIGlzTW91bnRlZDogZmFsc2UsXHJcbiAgICAgICAgaXNMZWF2aW5nOiBmYWxzZSxcclxuICAgICAgICBpc1VubW91bnRpbmc6IGZhbHNlLFxyXG4gICAgICAgIGxlYXZpbmdWTm9kZXM6IG5ldyBNYXAoKVxyXG4gICAgfTtcclxuICAgIG9uTW91bnRlZCgoKSA9PiB7XHJcbiAgICAgICAgc3RhdGUuaXNNb3VudGVkID0gdHJ1ZTtcclxuICAgIH0pO1xyXG4gICAgb25CZWZvcmVVbm1vdW50KCgpID0+IHtcclxuICAgICAgICBzdGF0ZS5pc1VubW91bnRpbmcgPSB0cnVlO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gc3RhdGU7XHJcbn1cclxuY29uc3QgVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IgPSBbRnVuY3Rpb24sIEFycmF5XTtcclxuY29uc3QgQmFzZVRyYW5zaXRpb25JbXBsID0ge1xyXG4gICAgbmFtZTogYEJhc2VUcmFuc2l0aW9uYCxcclxuICAgIHByb3BzOiB7XHJcbiAgICAgICAgbW9kZTogU3RyaW5nLFxyXG4gICAgICAgIGFwcGVhcjogQm9vbGVhbixcclxuICAgICAgICBwZXJzaXN0ZWQ6IEJvb2xlYW4sXHJcbiAgICAgICAgLy8gZW50ZXJcclxuICAgICAgICBvbkJlZm9yZUVudGVyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICBvbkVudGVyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICBvbkFmdGVyRW50ZXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIG9uRW50ZXJDYW5jZWxsZWQ6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIC8vIGxlYXZlXHJcbiAgICAgICAgb25CZWZvcmVMZWF2ZTogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgb25MZWF2ZTogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgb25BZnRlckxlYXZlOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICBvbkxlYXZlQ2FuY2VsbGVkOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICAvLyBhcHBlYXJcclxuICAgICAgICBvbkJlZm9yZUFwcGVhcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgb25BcHBlYXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIG9uQWZ0ZXJBcHBlYXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIG9uQXBwZWFyQ2FuY2VsbGVkOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvclxyXG4gICAgfSxcclxuICAgIHNldHVwKHByb3BzLCB7IHNsb3RzIH0pIHtcclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgICAgIGNvbnN0IHN0YXRlID0gdXNlVHJhbnNpdGlvblN0YXRlKCk7XHJcbiAgICAgICAgbGV0IHByZXZUcmFuc2l0aW9uS2V5O1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gc2xvdHMuZGVmYXVsdCAmJiBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4oc2xvdHMuZGVmYXVsdCgpLCB0cnVlKTtcclxuICAgICAgICAgICAgaWYgKCFjaGlsZHJlbiB8fCAhY2hpbGRyZW4ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQgb3IgY29tcG9uZW50LiBVc2UgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdGhlcmUncyBubyBuZWVkIHRvIHRyYWNrIHJlYWN0aXZpdHkgZm9yIHRoZXNlIHByb3BzIHNvIHVzZSB0aGUgcmF3XHJcbiAgICAgICAgICAgIC8vIHByb3BzIGZvciBhIGJpdCBiZXR0ZXIgcGVyZlxyXG4gICAgICAgICAgICBjb25zdCByYXdQcm9wcyA9IHRvUmF3KHByb3BzKTtcclxuICAgICAgICAgICAgY29uc3QgeyBtb2RlIH0gPSByYXdQcm9wcztcclxuICAgICAgICAgICAgLy8gY2hlY2sgbW9kZVxyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIG1vZGUgJiYgIVsnaW4tb3V0JywgJ291dC1pbicsICdkZWZhdWx0J10uaW5jbHVkZXMobW9kZSkpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYGludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICR7bW9kZX1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBhdCB0aGlzIHBvaW50IGNoaWxkcmVuIGhhcyBhIGd1YXJhbnRlZWQgbGVuZ3RoIG9mIDEuXHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5bMF07XHJcbiAgICAgICAgICAgIGlmIChzdGF0ZS5pc0xlYXZpbmcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eVBsYWNlaG9sZGVyKGNoaWxkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpbiB0aGUgY2FzZSBvZiA8dHJhbnNpdGlvbj48a2VlcC1hbGl2ZS8+PC90cmFuc2l0aW9uPiwgd2UgbmVlZCB0b1xyXG4gICAgICAgICAgICAvLyBjb21wYXJlIHRoZSB0eXBlIG9mIHRoZSBrZXB0LWFsaXZlIGNoaWxkcmVuLlxyXG4gICAgICAgICAgICBjb25zdCBpbm5lckNoaWxkID0gZ2V0S2VlcEFsaXZlQ2hpbGQoY2hpbGQpO1xyXG4gICAgICAgICAgICBpZiAoIWlubmVyQ2hpbGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eVBsYWNlaG9sZGVyKGNoaWxkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBlbnRlckhvb2tzID0gcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhpbm5lckNoaWxkLCByYXdQcm9wcywgc3RhdGUsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKGlubmVyQ2hpbGQsIGVudGVySG9va3MpO1xyXG4gICAgICAgICAgICBjb25zdCBvbGRDaGlsZCA9IGluc3RhbmNlLnN1YlRyZWU7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZElubmVyQ2hpbGQgPSBvbGRDaGlsZCAmJiBnZXRLZWVwQWxpdmVDaGlsZChvbGRDaGlsZCk7XHJcbiAgICAgICAgICAgIGxldCB0cmFuc2l0aW9uS2V5Q2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjb25zdCB7IGdldFRyYW5zaXRpb25LZXkgfSA9IGlubmVyQ2hpbGQudHlwZTtcclxuICAgICAgICAgICAgaWYgKGdldFRyYW5zaXRpb25LZXkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGdldFRyYW5zaXRpb25LZXkoKTtcclxuICAgICAgICAgICAgICAgIGlmIChwcmV2VHJhbnNpdGlvbktleSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldlRyYW5zaXRpb25LZXkgPSBrZXk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09IHByZXZUcmFuc2l0aW9uS2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldlRyYW5zaXRpb25LZXkgPSBrZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbktleUNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGhhbmRsZSBtb2RlXHJcbiAgICAgICAgICAgIGlmIChvbGRJbm5lckNoaWxkICYmXHJcbiAgICAgICAgICAgICAgICBvbGRJbm5lckNoaWxkLnR5cGUgIT09IENvbW1lbnQkMSAmJlxyXG4gICAgICAgICAgICAgICAgKCFpc1NhbWVWTm9kZVR5cGUoaW5uZXJDaGlsZCwgb2xkSW5uZXJDaGlsZCkgfHwgdHJhbnNpdGlvbktleUNoYW5nZWQpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsZWF2aW5nSG9va3MgPSByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKG9sZElubmVyQ2hpbGQsIHJhd1Byb3BzLCBzdGF0ZSwgaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIG9sZCB0cmVlJ3MgaG9va3MgaW4gY2FzZSBvZiBkeW5hbWljIHRyYW5zaXRpb25cclxuICAgICAgICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyhvbGRJbm5lckNoaWxkLCBsZWF2aW5nSG9va3MpO1xyXG4gICAgICAgICAgICAgICAgLy8gc3dpdGNoaW5nIGJldHdlZW4gZGlmZmVyZW50IHZpZXdzXHJcbiAgICAgICAgICAgICAgICBpZiAobW9kZSA9PT0gJ291dC1pbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pc0xlYXZpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xyXG4gICAgICAgICAgICAgICAgICAgIGxlYXZpbmdIb29rcy5hZnRlckxlYXZlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pc0xlYXZpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UudXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlQbGFjZWhvbGRlcihjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtb2RlID09PSAnaW4tb3V0JyAmJiBpbm5lckNoaWxkLnR5cGUgIT09IENvbW1lbnQkMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlYXZpbmdIb29rcy5kZWxheUxlYXZlID0gKGVsLCBlYXJseVJlbW92ZSwgZGVsYXllZExlYXZlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlYXZpbmdWTm9kZXNDYWNoZSA9IGdldExlYXZpbmdOb2Rlc0ZvclR5cGUoc3RhdGUsIG9sZElubmVyQ2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWF2aW5nVk5vZGVzQ2FjaGVbU3RyaW5nKG9sZElubmVyQ2hpbGQua2V5KV0gPSBvbGRJbm5lckNoaWxkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlYXJseSByZW1vdmFsIGNhbGxiYWNrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLl9sZWF2ZUNiID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWFybHlSZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLl9sZWF2ZUNiID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGVudGVySG9va3MuZGVsYXllZExlYXZlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRlckhvb2tzLmRlbGF5ZWRMZWF2ZSA9IGRlbGF5ZWRMZWF2ZTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjaGlsZDtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59O1xyXG4vLyBleHBvcnQgdGhlIHB1YmxpYyB0eXBlIGZvciBoL3RzeCBpbmZlcmVuY2VcclxuLy8gYWxzbyB0byBhdm9pZCBpbmxpbmUgaW1wb3J0KCkgaW4gZ2VuZXJhdGVkIGQudHMgZmlsZXNcclxuY29uc3QgQmFzZVRyYW5zaXRpb24gPSBCYXNlVHJhbnNpdGlvbkltcGw7XHJcbmZ1bmN0aW9uIGdldExlYXZpbmdOb2Rlc0ZvclR5cGUoc3RhdGUsIHZub2RlKSB7XHJcbiAgICBjb25zdCB7IGxlYXZpbmdWTm9kZXMgfSA9IHN0YXRlO1xyXG4gICAgbGV0IGxlYXZpbmdWTm9kZXNDYWNoZSA9IGxlYXZpbmdWTm9kZXMuZ2V0KHZub2RlLnR5cGUpO1xyXG4gICAgaWYgKCFsZWF2aW5nVk5vZGVzQ2FjaGUpIHtcclxuICAgICAgICBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgICAgIGxlYXZpbmdWTm9kZXMuc2V0KHZub2RlLnR5cGUsIGxlYXZpbmdWTm9kZXNDYWNoZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGVhdmluZ1ZOb2Rlc0NhY2hlO1xyXG59XHJcbi8vIFRoZSB0cmFuc2l0aW9uIGhvb2tzIGFyZSBhdHRhY2hlZCB0byB0aGUgdm5vZGUgYXMgdm5vZGUudHJhbnNpdGlvblxyXG4vLyBhbmQgd2lsbCBiZSBjYWxsZWQgYXQgYXBwcm9wcmlhdGUgdGltaW5nIGluIHRoZSByZW5kZXJlci5cclxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyh2bm9kZSwgcHJvcHMsIHN0YXRlLCBpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgeyBhcHBlYXIsIG1vZGUsIHBlcnNpc3RlZCA9IGZhbHNlLCBvbkJlZm9yZUVudGVyLCBvbkVudGVyLCBvbkFmdGVyRW50ZXIsIG9uRW50ZXJDYW5jZWxsZWQsIG9uQmVmb3JlTGVhdmUsIG9uTGVhdmUsIG9uQWZ0ZXJMZWF2ZSwgb25MZWF2ZUNhbmNlbGxlZCwgb25CZWZvcmVBcHBlYXIsIG9uQXBwZWFyLCBvbkFmdGVyQXBwZWFyLCBvbkFwcGVhckNhbmNlbGxlZCB9ID0gcHJvcHM7XHJcbiAgICBjb25zdCBrZXkgPSBTdHJpbmcodm5vZGUua2V5KTtcclxuICAgIGNvbnN0IGxlYXZpbmdWTm9kZXNDYWNoZSA9IGdldExlYXZpbmdOb2Rlc0ZvclR5cGUoc3RhdGUsIHZub2RlKTtcclxuICAgIGNvbnN0IGNhbGxIb29rID0gKGhvb2ssIGFyZ3MpID0+IHtcclxuICAgICAgICBob29rICYmXHJcbiAgICAgICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGhvb2ssIGluc3RhbmNlLCA5IC8qIFRSQU5TSVRJT05fSE9PSyAqLywgYXJncyk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgaG9va3MgPSB7XHJcbiAgICAgICAgbW9kZSxcclxuICAgICAgICBwZXJzaXN0ZWQsXHJcbiAgICAgICAgYmVmb3JlRW50ZXIoZWwpIHtcclxuICAgICAgICAgICAgbGV0IGhvb2sgPSBvbkJlZm9yZUVudGVyO1xyXG4gICAgICAgICAgICBpZiAoIXN0YXRlLmlzTW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFwcGVhcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvb2sgPSBvbkJlZm9yZUFwcGVhciB8fCBvbkJlZm9yZUVudGVyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGZvciBzYW1lIGVsZW1lbnQgKHYtc2hvdylcclxuICAgICAgICAgICAgaWYgKGVsLl9sZWF2ZUNiKSB7XHJcbiAgICAgICAgICAgICAgICBlbC5fbGVhdmVDYih0cnVlIC8qIGNhbmNlbGxlZCAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZm9yIHRvZ2dsZWQgZWxlbWVudCB3aXRoIHNhbWUga2V5ICh2LWlmKVxyXG4gICAgICAgICAgICBjb25zdCBsZWF2aW5nVk5vZGUgPSBsZWF2aW5nVk5vZGVzQ2FjaGVba2V5XTtcclxuICAgICAgICAgICAgaWYgKGxlYXZpbmdWTm9kZSAmJlxyXG4gICAgICAgICAgICAgICAgaXNTYW1lVk5vZGVUeXBlKHZub2RlLCBsZWF2aW5nVk5vZGUpICYmXHJcbiAgICAgICAgICAgICAgICBsZWF2aW5nVk5vZGUuZWwuX2xlYXZlQ2IpIHtcclxuICAgICAgICAgICAgICAgIC8vIGZvcmNlIGVhcmx5IHJlbW92YWwgKG5vdCBjYW5jZWxsZWQpXHJcbiAgICAgICAgICAgICAgICBsZWF2aW5nVk5vZGUuZWwuX2xlYXZlQ2IoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYWxsSG9vayhob29rLCBbZWxdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudGVyKGVsKSB7XHJcbiAgICAgICAgICAgIGxldCBob29rID0gb25FbnRlcjtcclxuICAgICAgICAgICAgbGV0IGFmdGVySG9vayA9IG9uQWZ0ZXJFbnRlcjtcclxuICAgICAgICAgICAgbGV0IGNhbmNlbEhvb2sgPSBvbkVudGVyQ2FuY2VsbGVkO1xyXG4gICAgICAgICAgICBpZiAoIXN0YXRlLmlzTW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFwcGVhcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvb2sgPSBvbkFwcGVhciB8fCBvbkVudGVyO1xyXG4gICAgICAgICAgICAgICAgICAgIGFmdGVySG9vayA9IG9uQWZ0ZXJBcHBlYXIgfHwgb25BZnRlckVudGVyO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbEhvb2sgPSBvbkFwcGVhckNhbmNlbGxlZCB8fCBvbkVudGVyQ2FuY2VsbGVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgY29uc3QgZG9uZSA9IChlbC5fZW50ZXJDYiA9IChjYW5jZWxsZWQpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChjYWxsZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChjYW5jZWxsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsSG9vayhjYW5jZWxIb29rLCBbZWxdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxIb29rKGFmdGVySG9vaywgW2VsXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaG9va3MuZGVsYXllZExlYXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9va3MuZGVsYXllZExlYXZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbC5fZW50ZXJDYiA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChob29rKSB7XHJcbiAgICAgICAgICAgICAgICBob29rKGVsLCBkb25lKTtcclxuICAgICAgICAgICAgICAgIGlmIChob29rLmxlbmd0aCA8PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZG9uZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsZWF2ZShlbCwgcmVtb3ZlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IFN0cmluZyh2bm9kZS5rZXkpO1xyXG4gICAgICAgICAgICBpZiAoZWwuX2VudGVyQ2IpIHtcclxuICAgICAgICAgICAgICAgIGVsLl9lbnRlckNiKHRydWUgLyogY2FuY2VsbGVkICovKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc3RhdGUuaXNVbm1vdW50aW5nKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FsbEhvb2sob25CZWZvcmVMZWF2ZSwgW2VsXSk7XHJcbiAgICAgICAgICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgY29uc3QgZG9uZSA9IChlbC5fbGVhdmVDYiA9IChjYW5jZWxsZWQpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChjYWxsZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxIb29rKG9uTGVhdmVDYW5jZWxsZWQsIFtlbF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbEhvb2sob25BZnRlckxlYXZlLCBbZWxdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsLl9sZWF2ZUNiID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxlYXZpbmdWTm9kZXNDYWNoZVtrZXldID09PSB2bm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsZWF2aW5nVk5vZGVzQ2FjaGVba2V5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGxlYXZpbmdWTm9kZXNDYWNoZVtrZXldID0gdm5vZGU7XHJcbiAgICAgICAgICAgIGlmIChvbkxlYXZlKSB7XHJcbiAgICAgICAgICAgICAgICBvbkxlYXZlKGVsLCBkb25lKTtcclxuICAgICAgICAgICAgICAgIGlmIChvbkxlYXZlLmxlbmd0aCA8PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZG9uZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjbG9uZSh2bm9kZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyh2bm9kZSwgcHJvcHMsIHN0YXRlLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBob29rcztcclxufVxyXG4vLyB0aGUgcGxhY2Vob2xkZXIgcmVhbGx5IG9ubHkgaGFuZGxlcyBvbmUgc3BlY2lhbCBjYXNlOiBLZWVwQWxpdmVcclxuLy8gaW4gdGhlIGNhc2Ugb2YgYSBLZWVwQWxpdmUgaW4gYSBsZWF2ZSBwaGFzZSB3ZSBuZWVkIHRvIHJldHVybiBhIEtlZXBBbGl2ZVxyXG4vLyBwbGFjZWhvbGRlciB3aXRoIGVtcHR5IGNvbnRlbnQgdG8gYXZvaWQgdGhlIEtlZXBBbGl2ZSBpbnN0YW5jZSBmcm9tIGJlaW5nXHJcbi8vIHVubW91bnRlZC5cclxuZnVuY3Rpb24gZW1wdHlQbGFjZWhvbGRlcih2bm9kZSkge1xyXG4gICAgaWYgKGlzS2VlcEFsaXZlKHZub2RlKSkge1xyXG4gICAgICAgIHZub2RlID0gY2xvbmVWTm9kZSh2bm9kZSk7XHJcbiAgICAgICAgdm5vZGUuY2hpbGRyZW4gPSBudWxsO1xyXG4gICAgICAgIHJldHVybiB2bm9kZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRLZWVwQWxpdmVDaGlsZCh2bm9kZSkge1xyXG4gICAgcmV0dXJuIGlzS2VlcEFsaXZlKHZub2RlKVxyXG4gICAgICAgID8gdm5vZGUuY2hpbGRyZW5cclxuICAgICAgICAgICAgPyB2bm9kZS5jaGlsZHJlblswXVxyXG4gICAgICAgICAgICA6IHVuZGVmaW5lZFxyXG4gICAgICAgIDogdm5vZGU7XHJcbn1cclxuZnVuY3Rpb24gc2V0VHJhbnNpdGlvbkhvb2tzKHZub2RlLCBob29rcykge1xyXG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovICYmIHZub2RlLmNvbXBvbmVudCkge1xyXG4gICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyh2bm9kZS5jb21wb25lbnQuc3ViVHJlZSwgaG9va3MpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovKSB7XHJcbiAgICAgICAgdm5vZGUuc3NDb250ZW50LnRyYW5zaXRpb24gPSBob29rcy5jbG9uZSh2bm9kZS5zc0NvbnRlbnQpO1xyXG4gICAgICAgIHZub2RlLnNzRmFsbGJhY2sudHJhbnNpdGlvbiA9IGhvb2tzLmNsb25lKHZub2RlLnNzRmFsbGJhY2spO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdm5vZGUudHJhbnNpdGlvbiA9IGhvb2tzO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbihjaGlsZHJlbiwga2VlcENvbW1lbnQgPSBmYWxzZSkge1xyXG4gICAgbGV0IHJldCA9IFtdO1xyXG4gICAgbGV0IGtleWVkRnJhZ21lbnRDb3VudCA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAvLyBoYW5kbGUgZnJhZ21lbnQgY2hpbGRyZW4gY2FzZSwgZS5nLiB2LWZvclxyXG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSBGcmFnbWVudCkge1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQucGF0Y2hGbGFnICYgMTI4IC8qIEtFWUVEX0ZSQUdNRU5UICovKVxyXG4gICAgICAgICAgICAgICAga2V5ZWRGcmFnbWVudENvdW50Kys7XHJcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKGNoaWxkLmNoaWxkcmVuLCBrZWVwQ29tbWVudCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb21tZW50IHBsYWNlaG9sZGVycyBzaG91bGQgYmUgc2tpcHBlZCwgZS5nLiB2LWlmXHJcbiAgICAgICAgZWxzZSBpZiAoa2VlcENvbW1lbnQgfHwgY2hpbGQudHlwZSAhPT0gQ29tbWVudCQxKSB7XHJcbiAgICAgICAgICAgIHJldC5wdXNoKGNoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyAjMTEyNiBpZiBhIHRyYW5zaXRpb24gY2hpbGRyZW4gbGlzdCBjb250YWlucyBtdWx0aXBsZSBzdWIgZnJhZ21lbnRzLCB0aGVzZVxyXG4gICAgLy8gZnJhZ21lbnRzIHdpbGwgYmUgbWVyZ2VkIGludG8gYSBmbGF0IGNoaWxkcmVuIGFycmF5LiBTaW5jZSBlYWNoIHYtZm9yXHJcbiAgICAvLyBmcmFnbWVudCBtYXkgY29udGFpbiBkaWZmZXJlbnQgc3RhdGljIGJpbmRpbmdzIGluc2lkZSwgd2UgbmVlZCB0byBkZS1vcFxyXG4gICAgLy8gdGhlc2UgY2hpbGRyZW4gdG8gZm9yY2UgZnVsbCBkaWZmcyB0byBlbnN1cmUgY29ycmVjdCBiZWhhdmlvci5cclxuICAgIGlmIChrZXllZEZyYWdtZW50Q291bnQgPiAxKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcmV0W2ldLnBhdGNoRmxhZyA9IC0yIC8qIEJBSUwgKi87XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldDtcclxufVxuXG4vLyBpbXBsZW1lbnRhdGlvbiwgY2xvc2UgdG8gbm8tb3BcclxuZnVuY3Rpb24gZGVmaW5lQ29tcG9uZW50KG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBpc0Z1bmN0aW9uKG9wdGlvbnMpID8geyBzZXR1cDogb3B0aW9ucywgbmFtZTogb3B0aW9ucy5uYW1lIH0gOiBvcHRpb25zO1xyXG59XG5cbmNvbnN0IGlzQXN5bmNXcmFwcGVyID0gKGkpID0+ICEhaS50eXBlLl9fYXN5bmNMb2FkZXI7XHJcbmZ1bmN0aW9uIGRlZmluZUFzeW5jQ29tcG9uZW50KHNvdXJjZSkge1xyXG4gICAgaWYgKGlzRnVuY3Rpb24oc291cmNlKSkge1xyXG4gICAgICAgIHNvdXJjZSA9IHsgbG9hZGVyOiBzb3VyY2UgfTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgbG9hZGVyLCBsb2FkaW5nQ29tcG9uZW50LCBlcnJvckNvbXBvbmVudCwgZGVsYXkgPSAyMDAsIHRpbWVvdXQsIC8vIHVuZGVmaW5lZCA9IG5ldmVyIHRpbWVzIG91dFxyXG4gICAgc3VzcGVuc2libGUgPSB0cnVlLCBvbkVycm9yOiB1c2VyT25FcnJvciB9ID0gc291cmNlO1xyXG4gICAgbGV0IHBlbmRpbmdSZXF1ZXN0ID0gbnVsbDtcclxuICAgIGxldCByZXNvbHZlZENvbXA7XHJcbiAgICBsZXQgcmV0cmllcyA9IDA7XHJcbiAgICBjb25zdCByZXRyeSA9ICgpID0+IHtcclxuICAgICAgICByZXRyaWVzKys7XHJcbiAgICAgICAgcGVuZGluZ1JlcXVlc3QgPSBudWxsO1xyXG4gICAgICAgIHJldHVybiBsb2FkKCk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgbG9hZCA9ICgpID0+IHtcclxuICAgICAgICBsZXQgdGhpc1JlcXVlc3Q7XHJcbiAgICAgICAgcmV0dXJuIChwZW5kaW5nUmVxdWVzdCB8fFxyXG4gICAgICAgICAgICAodGhpc1JlcXVlc3QgPSBwZW5kaW5nUmVxdWVzdCA9IGxvYWRlcigpXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcclxuICAgICAgICAgICAgICAgIGVyciA9IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyIDogbmV3IEVycm9yKFN0cmluZyhlcnIpKTtcclxuICAgICAgICAgICAgICAgIGlmICh1c2VyT25FcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJSZXRyeSA9ICgpID0+IHJlc29sdmUocmV0cnkoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJGYWlsID0gKCkgPT4gcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJPbkVycm9yKGVyciwgdXNlclJldHJ5LCB1c2VyRmFpbCwgcmV0cmllcyArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKGNvbXApID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzUmVxdWVzdCAhPT0gcGVuZGluZ1JlcXVlc3QgJiYgcGVuZGluZ1JlcXVlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGVuZGluZ1JlcXVlc3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFjb21wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQXN5bmMgY29tcG9uZW50IGxvYWRlciByZXNvbHZlZCB0byB1bmRlZmluZWQuIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgSWYgeW91IGFyZSB1c2luZyByZXRyeSgpLCBtYWtlIHN1cmUgdG8gcmV0dXJuIGl0cyByZXR1cm4gdmFsdWUuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBpbnRlcm9wIG1vZHVsZSBkZWZhdWx0XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIChjb21wLl9fZXNNb2R1bGUgfHwgY29tcFtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTW9kdWxlJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb21wID0gY29tcC5kZWZhdWx0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjb21wICYmICFpc09iamVjdChjb21wKSAmJiAhaXNGdW5jdGlvbihjb21wKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhc3luYyBjb21wb25lbnQgbG9hZCByZXN1bHQ6ICR7Y29tcH1gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc29sdmVkQ29tcCA9IGNvbXA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcDtcclxuICAgICAgICAgICAgfSkpKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZGVmaW5lQ29tcG9uZW50KHtcclxuICAgICAgICBuYW1lOiAnQXN5bmNDb21wb25lbnRXcmFwcGVyJyxcclxuICAgICAgICBfX2FzeW5jTG9hZGVyOiBsb2FkLFxyXG4gICAgICAgIGdldCBfX2FzeW5jUmVzb2x2ZWQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlZENvbXA7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXR1cCgpIHtcclxuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2U7XHJcbiAgICAgICAgICAgIC8vIGFscmVhZHkgcmVzb2x2ZWRcclxuICAgICAgICAgICAgaWYgKHJlc29sdmVkQ29tcCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IGNyZWF0ZUlubmVyQ29tcChyZXNvbHZlZENvbXAsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBvbkVycm9yID0gKGVycikgPT4ge1xyXG4gICAgICAgICAgICAgICAgcGVuZGluZ1JlcXVlc3QgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgMTMgLyogQVNZTkNfQ09NUE9ORU5UX0xPQURFUiAqLywgIWVycm9yQ29tcG9uZW50IC8qIGRvIG5vdCB0aHJvdyBpbiBkZXYgaWYgdXNlciBwcm92aWRlZCBlcnJvciBjb21wb25lbnQgKi8pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvLyBzdXNwZW5zZS1jb250cm9sbGVkIG9yIFNTUi5cclxuICAgICAgICAgICAgaWYgKChzdXNwZW5zaWJsZSAmJiBpbnN0YW5jZS5zdXNwZW5zZSkgfHxcclxuICAgICAgICAgICAgICAgIChmYWxzZSApKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9hZCgpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oY29tcCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IGNyZWF0ZUlubmVyQ29tcChjb21wLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gZXJyb3JDb21wb25lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjcmVhdGVWTm9kZShlcnJvckNvbXBvbmVudCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVyclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBsb2FkZWQgPSByZWYoZmFsc2UpO1xyXG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IHJlZigpO1xyXG4gICAgICAgICAgICBjb25zdCBkZWxheWVkID0gcmVmKCEhZGVsYXkpO1xyXG4gICAgICAgICAgICBpZiAoZGVsYXkpIHtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGF5ZWQudmFsdWUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0sIGRlbGF5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGltZW91dCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWxvYWRlZC52YWx1ZSAmJiAhZXJyb3IudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGBBc3luYyBjb21wb25lbnQgdGltZWQgb3V0IGFmdGVyICR7dGltZW91dH1tcy5gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvcihlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvci52YWx1ZSA9IGVycjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsb2FkKClcclxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGxvYWRlZC52YWx1ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UucGFyZW50ICYmIGlzS2VlcEFsaXZlKGluc3RhbmNlLnBhcmVudC52bm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBwYXJlbnQgaXMga2VlcC1hbGl2ZSwgZm9yY2UgdXBkYXRlIHNvIHRoZSBsb2FkZWQgY29tcG9uZW50J3NcclxuICAgICAgICAgICAgICAgICAgICAvLyBuYW1lIGlzIHRha2VuIGludG8gYWNjb3VudFxyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlSm9iKGluc3RhbmNlLnBhcmVudC51cGRhdGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgICAgICAgICBvbkVycm9yKGVycik7XHJcbiAgICAgICAgICAgICAgICBlcnJvci52YWx1ZSA9IGVycjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAobG9hZGVkLnZhbHVlICYmIHJlc29sdmVkQ29tcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbm5lckNvbXAocmVzb2x2ZWRDb21wLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlcnJvci52YWx1ZSAmJiBlcnJvckNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZShlcnJvckNvbXBvbmVudCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IudmFsdWVcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxvYWRpbmdDb21wb25lbnQgJiYgIWRlbGF5ZWQudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUobG9hZGluZ0NvbXBvbmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlSW5uZXJDb21wKGNvbXAsIHsgdm5vZGU6IHsgcmVmLCBwcm9wcywgY2hpbGRyZW4gfSB9KSB7XHJcbiAgICBjb25zdCB2bm9kZSA9IGNyZWF0ZVZOb2RlKGNvbXAsIHByb3BzLCBjaGlsZHJlbik7XHJcbiAgICAvLyBlbnN1cmUgaW5uZXIgY29tcG9uZW50IGluaGVyaXRzIHRoZSBhc3luYyB3cmFwcGVyJ3MgcmVmIG93bmVyXHJcbiAgICB2bm9kZS5yZWYgPSByZWY7XHJcbiAgICByZXR1cm4gdm5vZGU7XHJcbn1cblxuY29uc3QgaXNLZWVwQWxpdmUgPSAodm5vZGUpID0+IHZub2RlLnR5cGUuX19pc0tlZXBBbGl2ZTtcclxuY29uc3QgS2VlcEFsaXZlSW1wbCA9IHtcclxuICAgIG5hbWU6IGBLZWVwQWxpdmVgLFxyXG4gICAgLy8gTWFya2VyIGZvciBzcGVjaWFsIGhhbmRsaW5nIGluc2lkZSB0aGUgcmVuZGVyZXIuIFdlIGFyZSBub3QgdXNpbmcgYSA9PT1cclxuICAgIC8vIGNoZWNrIGRpcmVjdGx5IG9uIEtlZXBBbGl2ZSBpbiB0aGUgcmVuZGVyZXIsIGJlY2F1c2UgaW1wb3J0aW5nIGl0IGRpcmVjdGx5XHJcbiAgICAvLyB3b3VsZCBwcmV2ZW50IGl0IGZyb20gYmVpbmcgdHJlZS1zaGFrZW4uXHJcbiAgICBfX2lzS2VlcEFsaXZlOiB0cnVlLFxyXG4gICAgcHJvcHM6IHtcclxuICAgICAgICBpbmNsdWRlOiBbU3RyaW5nLCBSZWdFeHAsIEFycmF5XSxcclxuICAgICAgICBleGNsdWRlOiBbU3RyaW5nLCBSZWdFeHAsIEFycmF5XSxcclxuICAgICAgICBtYXg6IFtTdHJpbmcsIE51bWJlcl1cclxuICAgIH0sXHJcbiAgICBzZXR1cChwcm9wcywgeyBzbG90cyB9KSB7XHJcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgICAgICAvLyBLZWVwQWxpdmUgY29tbXVuaWNhdGVzIHdpdGggdGhlIGluc3RhbnRpYXRlZCByZW5kZXJlciB2aWEgdGhlXHJcbiAgICAgICAgLy8gY3R4IHdoZXJlIHRoZSByZW5kZXJlciBwYXNzZXMgaW4gaXRzIGludGVybmFscyxcclxuICAgICAgICAvLyBhbmQgdGhlIEtlZXBBbGl2ZSBpbnN0YW5jZSBleHBvc2VzIGFjdGl2YXRlL2RlYWN0aXZhdGUgaW1wbGVtZW50YXRpb25zLlxyXG4gICAgICAgIC8vIFRoZSB3aG9sZSBwb2ludCBvZiB0aGlzIGlzIHRvIGF2b2lkIGltcG9ydGluZyBLZWVwQWxpdmUgZGlyZWN0bHkgaW4gdGhlXHJcbiAgICAgICAgLy8gcmVuZGVyZXIgdG8gZmFjaWxpdGF0ZSB0cmVlLXNoYWtpbmcuXHJcbiAgICAgICAgY29uc3Qgc2hhcmVkQ29udGV4dCA9IGluc3RhbmNlLmN0eDtcclxuICAgICAgICAvLyBpZiB0aGUgaW50ZXJuYWwgcmVuZGVyZXIgaXMgbm90IHJlZ2lzdGVyZWQsIGl0IGluZGljYXRlcyB0aGF0IHRoaXMgaXMgc2VydmVyLXNpZGUgcmVuZGVyaW5nLFxyXG4gICAgICAgIC8vIGZvciBLZWVwQWxpdmUsIHdlIGp1c3QgbmVlZCB0byByZW5kZXIgaXRzIGNoaWxkcmVuXHJcbiAgICAgICAgaWYgKCFzaGFyZWRDb250ZXh0LnJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzbG90cy5kZWZhdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjYWNoZSA9IG5ldyBNYXAoKTtcclxuICAgICAgICBjb25zdCBrZXlzID0gbmV3IFNldCgpO1xyXG4gICAgICAgIGxldCBjdXJyZW50ID0gbnVsbDtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5fX3ZfY2FjaGUgPSBjYWNoZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGFyZW50U3VzcGVuc2UgPSBpbnN0YW5jZS5zdXNwZW5zZTtcclxuICAgICAgICBjb25zdCB7IHJlbmRlcmVyOiB7IHA6IHBhdGNoLCBtOiBtb3ZlLCB1bTogX3VubW91bnQsIG86IHsgY3JlYXRlRWxlbWVudCB9IH0gfSA9IHNoYXJlZENvbnRleHQ7XHJcbiAgICAgICAgY29uc3Qgc3RvcmFnZUNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIHNoYXJlZENvbnRleHQuYWN0aXZhdGUgPSAodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50O1xyXG4gICAgICAgICAgICBtb3ZlKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgMCAvKiBFTlRFUiAqLywgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICAvLyBpbiBjYXNlIHByb3BzIGhhdmUgY2hhbmdlZFxyXG4gICAgICAgICAgICBwYXRjaChpbnN0YW5jZS52bm9kZSwgdm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCB2bm9kZS5zbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5pc0RlYWN0aXZhdGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UuYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGludm9rZUFycmF5Rm5zKGluc3RhbmNlLmEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgdm5vZGVIb29rID0gdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMub25Wbm9kZU1vdW50ZWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAodm5vZGVIb29rKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgaW5zdGFuY2UucGFyZW50LCB2bm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBjb21wb25lbnRzIHRyZWVcclxuICAgICAgICAgICAgICAgIGRldnRvb2xzQ29tcG9uZW50QWRkZWQoaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBzaGFyZWRDb250ZXh0LmRlYWN0aXZhdGUgPSAodm5vZGUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnQ7XHJcbiAgICAgICAgICAgIG1vdmUodm5vZGUsIHN0b3JhZ2VDb250YWluZXIsIG51bGwsIDEgLyogTEVBVkUgKi8sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5kYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGludm9rZUFycmF5Rm5zKGluc3RhbmNlLmRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHZub2RlSG9vayA9IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLm9uVm5vZGVVbm1vdW50ZWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAodm5vZGVIb29rKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgaW5zdGFuY2UucGFyZW50LCB2bm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5pc0RlYWN0aXZhdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGNvbXBvbmVudHMgdHJlZVxyXG4gICAgICAgICAgICAgICAgZGV2dG9vbHNDb21wb25lbnRBZGRlZChpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGZ1bmN0aW9uIHVubW91bnQodm5vZGUpIHtcclxuICAgICAgICAgICAgLy8gcmVzZXQgdGhlIHNoYXBlRmxhZyBzbyBpdCBjYW4gYmUgcHJvcGVybHkgdW5tb3VudGVkXHJcbiAgICAgICAgICAgIHJlc2V0U2hhcGVGbGFnKHZub2RlKTtcclxuICAgICAgICAgICAgX3VubW91bnQodm5vZGUsIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHBydW5lQ2FjaGUoZmlsdGVyKSB7XHJcbiAgICAgICAgICAgIGNhY2hlLmZvckVhY2goKHZub2RlLCBrZXkpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHZub2RlLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgJiYgKCFmaWx0ZXIgfHwgIWZpbHRlcihuYW1lKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoa2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHBydW5lQ2FjaGVFbnRyeShrZXkpIHtcclxuICAgICAgICAgICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGtleSk7XHJcbiAgICAgICAgICAgIGlmICghY3VycmVudCB8fCBjYWNoZWQudHlwZSAhPT0gY3VycmVudC50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50KGNhY2hlZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgLy8gY3VycmVudCBhY3RpdmUgaW5zdGFuY2Ugc2hvdWxkIG5vIGxvbmdlciBiZSBrZXB0LWFsaXZlLlxyXG4gICAgICAgICAgICAgICAgLy8gd2UgY2FuJ3QgdW5tb3VudCBpdCBub3cgYnV0IGl0IG1pZ2h0IGJlIGxhdGVyLCBzbyByZXNldCBpdHMgZmxhZyBub3cuXHJcbiAgICAgICAgICAgICAgICByZXNldFNoYXBlRmxhZyhjdXJyZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYWNoZS5kZWxldGUoa2V5KTtcclxuICAgICAgICAgICAga2V5cy5kZWxldGUoa2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcHJ1bmUgY2FjaGUgb24gaW5jbHVkZS9leGNsdWRlIHByb3AgY2hhbmdlXHJcbiAgICAgICAgd2F0Y2goKCkgPT4gW3Byb3BzLmluY2x1ZGUsIHByb3BzLmV4Y2x1ZGVdLCAoW2luY2x1ZGUsIGV4Y2x1ZGVdKSA9PiB7XHJcbiAgICAgICAgICAgIGluY2x1ZGUgJiYgcHJ1bmVDYWNoZShuYW1lID0+IG1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpO1xyXG4gICAgICAgICAgICBleGNsdWRlICYmIHBydW5lQ2FjaGUobmFtZSA9PiAhbWF0Y2hlcyhleGNsdWRlLCBuYW1lKSk7XHJcbiAgICAgICAgfSwgXHJcbiAgICAgICAgLy8gcHJ1bmUgcG9zdC1yZW5kZXIgYWZ0ZXIgYGN1cnJlbnRgIGhhcyBiZWVuIHVwZGF0ZWRcclxuICAgICAgICB7IGZsdXNoOiAncG9zdCcsIGRlZXA6IHRydWUgfSk7XHJcbiAgICAgICAgLy8gY2FjaGUgc3ViIHRyZWUgYWZ0ZXIgcmVuZGVyXHJcbiAgICAgICAgbGV0IHBlbmRpbmdDYWNoZUtleSA9IG51bGw7XHJcbiAgICAgICAgY29uc3QgY2FjaGVTdWJ0cmVlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBmaXggIzE2MjEsIHRoZSBwZW5kaW5nQ2FjaGVLZXkgY291bGQgYmUgMFxyXG4gICAgICAgICAgICBpZiAocGVuZGluZ0NhY2hlS2V5ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNhY2hlLnNldChwZW5kaW5nQ2FjaGVLZXksIGdldElubmVyQ2hpbGQoaW5zdGFuY2Uuc3ViVHJlZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBvbk1vdW50ZWQoY2FjaGVTdWJ0cmVlKTtcclxuICAgICAgICBvblVwZGF0ZWQoY2FjaGVTdWJ0cmVlKTtcclxuICAgICAgICBvbkJlZm9yZVVubW91bnQoKCkgPT4ge1xyXG4gICAgICAgICAgICBjYWNoZS5mb3JFYWNoKGNhY2hlZCA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHN1YlRyZWUsIHN1c3BlbnNlIH0gPSBpbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZub2RlID0gZ2V0SW5uZXJDaGlsZChzdWJUcmVlKTtcclxuICAgICAgICAgICAgICAgIGlmIChjYWNoZWQudHlwZSA9PT0gdm5vZGUudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgaW5zdGFuY2Ugd2lsbCBiZSB1bm1vdW50ZWQgYXMgcGFydCBvZiBrZWVwLWFsaXZlJ3MgdW5tb3VudFxyXG4gICAgICAgICAgICAgICAgICAgIHJlc2V0U2hhcGVGbGFnKHZub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgaW52b2tlIGl0cyBkZWFjdGl2YXRlZCBob29rIGhlcmVcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYSA9IHZub2RlLmNvbXBvbmVudC5kYTtcclxuICAgICAgICAgICAgICAgICAgICBkYSAmJiBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoZGEsIHN1c3BlbnNlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50KGNhY2hlZCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIHBlbmRpbmdDYWNoZUtleSA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmICghc2xvdHMuZGVmYXVsdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBzbG90cy5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJhd1ZOb2RlID0gY2hpbGRyZW5bMF07XHJcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgS2VlcEFsaXZlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIGNvbXBvbmVudCBjaGlsZC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc1ZOb2RlKHJhd1ZOb2RlKSB8fFxyXG4gICAgICAgICAgICAgICAgKCEocmF3Vk5vZGUuc2hhcGVGbGFnICYgNCAvKiBTVEFURUZVTF9DT01QT05FTlQgKi8pICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIShyYXdWTm9kZS5zaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8pKSkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmF3Vk5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHZub2RlID0gZ2V0SW5uZXJDaGlsZChyYXdWTm9kZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbXAgPSB2bm9kZS50eXBlO1xyXG4gICAgICAgICAgICAvLyBmb3IgYXN5bmMgY29tcG9uZW50cywgbmFtZSBjaGVjayBzaG91bGQgYmUgYmFzZWQgaW4gaXRzIGxvYWRlZFxyXG4gICAgICAgICAgICAvLyBpbm5lciBjb21wb25lbnQgaWYgYXZhaWxhYmxlXHJcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGlzQXN5bmNXcmFwcGVyKHZub2RlKVxyXG4gICAgICAgICAgICAgICAgPyB2bm9kZS50eXBlLl9fYXN5bmNSZXNvbHZlZCB8fCB7fVxyXG4gICAgICAgICAgICAgICAgOiBjb21wKTtcclxuICAgICAgICAgICAgY29uc3QgeyBpbmNsdWRlLCBleGNsdWRlLCBtYXggfSA9IHByb3BzO1xyXG4gICAgICAgICAgICBpZiAoKGluY2x1ZGUgJiYgKCFuYW1lIHx8ICFtYXRjaGVzKGluY2x1ZGUsIG5hbWUpKSkgfHxcclxuICAgICAgICAgICAgICAgIChleGNsdWRlICYmIG5hbWUgJiYgbWF0Y2hlcyhleGNsdWRlLCBuYW1lKSkpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSB2bm9kZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByYXdWTm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbCA/IGNvbXAgOiB2bm9kZS5rZXk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZFZOb2RlID0gY2FjaGUuZ2V0KGtleSk7XHJcbiAgICAgICAgICAgIC8vIGNsb25lIHZub2RlIGlmIGl0J3MgcmV1c2VkIGJlY2F1c2Ugd2UgYXJlIGdvaW5nIHRvIG11dGF0ZSBpdFxyXG4gICAgICAgICAgICBpZiAodm5vZGUuZWwpIHtcclxuICAgICAgICAgICAgICAgIHZub2RlID0gY2xvbmVWTm9kZSh2bm9kZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmF3Vk5vZGUuc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmF3Vk5vZGUuc3NDb250ZW50ID0gdm5vZGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gIzE1MTMgaXQncyBwb3NzaWJsZSBmb3IgdGhlIHJldHVybmVkIHZub2RlIHRvIGJlIGNsb25lZCBkdWUgdG8gYXR0clxyXG4gICAgICAgICAgICAvLyBmYWxsdGhyb3VnaCBvciBzY29wZUlkLCBzbyB0aGUgdm5vZGUgaGVyZSBtYXkgbm90IGJlIHRoZSBmaW5hbCB2bm9kZVxyXG4gICAgICAgICAgICAvLyB0aGF0IGlzIG1vdW50ZWQuIEluc3RlYWQgb2YgY2FjaGluZyBpdCBkaXJlY3RseSwgd2Ugc3RvcmUgdGhlIHBlbmRpbmdcclxuICAgICAgICAgICAgLy8ga2V5IGFuZCBjYWNoZSBgaW5zdGFuY2Uuc3ViVHJlZWAgKHRoZSBub3JtYWxpemVkIHZub2RlKSBpblxyXG4gICAgICAgICAgICAvLyBiZWZvcmVNb3VudC9iZWZvcmVVcGRhdGUgaG9va3MuXHJcbiAgICAgICAgICAgIHBlbmRpbmdDYWNoZUtleSA9IGtleTtcclxuICAgICAgICAgICAgaWYgKGNhY2hlZFZOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb3B5IG92ZXIgbW91bnRlZCBzdGF0ZVxyXG4gICAgICAgICAgICAgICAgdm5vZGUuZWwgPSBjYWNoZWRWTm9kZS5lbDtcclxuICAgICAgICAgICAgICAgIHZub2RlLmNvbXBvbmVudCA9IGNhY2hlZFZOb2RlLmNvbXBvbmVudDtcclxuICAgICAgICAgICAgICAgIGlmICh2bm9kZS50cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVjdXJzaXZlbHkgdXBkYXRlIHRyYW5zaXRpb24gaG9va3Mgb24gc3ViVHJlZVxyXG4gICAgICAgICAgICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyh2bm9kZSwgdm5vZGUudHJhbnNpdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBhdm9pZCB2bm9kZSBiZWluZyBtb3VudGVkIGFzIGZyZXNoXHJcbiAgICAgICAgICAgICAgICB2bm9kZS5zaGFwZUZsYWcgfD0gNTEyIC8qIENPTVBPTkVOVF9LRVBUX0FMSVZFICovO1xyXG4gICAgICAgICAgICAgICAgLy8gbWFrZSB0aGlzIGtleSB0aGUgZnJlc2hlc3RcclxuICAgICAgICAgICAgICAgIGtleXMuZGVsZXRlKGtleSk7XHJcbiAgICAgICAgICAgICAgICBrZXlzLmFkZChrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAga2V5cy5hZGQoa2V5KTtcclxuICAgICAgICAgICAgICAgIC8vIHBydW5lIG9sZGVzdCBlbnRyeVxyXG4gICAgICAgICAgICAgICAgaWYgKG1heCAmJiBrZXlzLnNpemUgPiBwYXJzZUludChtYXgsIDEwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShrZXlzLnZhbHVlcygpLm5leHQoKS52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gYXZvaWQgdm5vZGUgYmVpbmcgdW5tb3VudGVkXHJcbiAgICAgICAgICAgIHZub2RlLnNoYXBlRmxhZyB8PSAyNTYgLyogQ09NUE9ORU5UX1NIT1VMRF9LRUVQX0FMSVZFICovO1xyXG4gICAgICAgICAgICBjdXJyZW50ID0gdm5vZGU7XHJcbiAgICAgICAgICAgIHJldHVybiByYXdWTm9kZTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59O1xyXG4vLyBleHBvcnQgdGhlIHB1YmxpYyB0eXBlIGZvciBoL3RzeCBpbmZlcmVuY2VcclxuLy8gYWxzbyB0byBhdm9pZCBpbmxpbmUgaW1wb3J0KCkgaW4gZ2VuZXJhdGVkIGQudHMgZmlsZXNcclxuY29uc3QgS2VlcEFsaXZlID0gS2VlcEFsaXZlSW1wbDtcclxuZnVuY3Rpb24gbWF0Y2hlcyhwYXR0ZXJuLCBuYW1lKSB7XHJcbiAgICBpZiAoaXNBcnJheShwYXR0ZXJuKSkge1xyXG4gICAgICAgIHJldHVybiBwYXR0ZXJuLnNvbWUoKHApID0+IG1hdGNoZXMocCwgbmFtZSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNTdHJpbmcocGF0dGVybikpIHtcclxuICAgICAgICByZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluZGV4T2YobmFtZSkgPiAtMTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHBhdHRlcm4udGVzdCkge1xyXG4gICAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSk7XHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIG9uQWN0aXZhdGVkKGhvb2ssIHRhcmdldCkge1xyXG4gICAgcmVnaXN0ZXJLZWVwQWxpdmVIb29rKGhvb2ssIFwiYVwiIC8qIEFDVElWQVRFRCAqLywgdGFyZ2V0KTtcclxufVxyXG5mdW5jdGlvbiBvbkRlYWN0aXZhdGVkKGhvb2ssIHRhcmdldCkge1xyXG4gICAgcmVnaXN0ZXJLZWVwQWxpdmVIb29rKGhvb2ssIFwiZGFcIiAvKiBERUFDVElWQVRFRCAqLywgdGFyZ2V0KTtcclxufVxyXG5mdW5jdGlvbiByZWdpc3RlcktlZXBBbGl2ZUhvb2soaG9vaywgdHlwZSwgdGFyZ2V0ID0gY3VycmVudEluc3RhbmNlKSB7XHJcbiAgICAvLyBjYWNoZSB0aGUgZGVhY3RpdmF0ZSBicmFuY2ggY2hlY2sgd3JhcHBlciBmb3IgaW5qZWN0ZWQgaG9va3Mgc28gdGhlIHNhbWVcclxuICAgIC8vIGhvb2sgY2FuIGJlIHByb3Blcmx5IGRlZHVwZWQgYnkgdGhlIHNjaGVkdWxlci4gXCJfX3dkY1wiIHN0YW5kcyBmb3IgXCJ3aXRoXHJcbiAgICAvLyBkZWFjdGl2YXRpb24gY2hlY2tcIi5cclxuICAgIGNvbnN0IHdyYXBwZWRIb29rID0gaG9vay5fX3dkYyB8fFxyXG4gICAgICAgIChob29rLl9fd2RjID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBvbmx5IGZpcmUgdGhlIGhvb2sgaWYgdGhlIHRhcmdldCBpbnN0YW5jZSBpcyBOT1QgaW4gYSBkZWFjdGl2YXRlZCBicmFuY2guXHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQuaXNEZWFjdGl2YXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBob29rKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICBpbmplY3RIb29rKHR5cGUsIHdyYXBwZWRIb29rLCB0YXJnZXQpO1xyXG4gICAgLy8gSW4gYWRkaXRpb24gdG8gcmVnaXN0ZXJpbmcgaXQgb24gdGhlIHRhcmdldCBpbnN0YW5jZSwgd2Ugd2FsayB1cCB0aGUgcGFyZW50XHJcbiAgICAvLyBjaGFpbiBhbmQgcmVnaXN0ZXIgaXQgb24gYWxsIGFuY2VzdG9yIGluc3RhbmNlcyB0aGF0IGFyZSBrZWVwLWFsaXZlIHJvb3RzLlxyXG4gICAgLy8gVGhpcyBhdm9pZHMgdGhlIG5lZWQgdG8gd2FsayB0aGUgZW50aXJlIGNvbXBvbmVudCB0cmVlIHdoZW4gaW52b2tpbmcgdGhlc2VcclxuICAgIC8vIGhvb2tzLCBhbmQgbW9yZSBpbXBvcnRhbnRseSwgYXZvaWRzIHRoZSBuZWVkIHRvIHRyYWNrIGNoaWxkIGNvbXBvbmVudHMgaW5cclxuICAgIC8vIGFycmF5cy5cclxuICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICBsZXQgY3VycmVudCA9IHRhcmdldC5wYXJlbnQ7XHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudC5wYXJlbnQpIHtcclxuICAgICAgICAgICAgaWYgKGlzS2VlcEFsaXZlKGN1cnJlbnQucGFyZW50LnZub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgaW5qZWN0VG9LZWVwQWxpdmVSb290KHdyYXBwZWRIb29rLCB0eXBlLCB0YXJnZXQsIGN1cnJlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaW5qZWN0VG9LZWVwQWxpdmVSb290KGhvb2ssIHR5cGUsIHRhcmdldCwga2VlcEFsaXZlUm9vdCkge1xyXG4gICAgLy8gaW5qZWN0SG9vayB3cmFwcyB0aGUgb3JpZ2luYWwgZm9yIGVycm9yIGhhbmRsaW5nLCBzbyBtYWtlIHN1cmUgdG8gcmVtb3ZlXHJcbiAgICAvLyB0aGUgd3JhcHBlZCB2ZXJzaW9uLlxyXG4gICAgY29uc3QgaW5qZWN0ZWQgPSBpbmplY3RIb29rKHR5cGUsIGhvb2ssIGtlZXBBbGl2ZVJvb3QsIHRydWUgLyogcHJlcGVuZCAqLyk7XHJcbiAgICBvblVubW91bnRlZCgoKSA9PiB7XHJcbiAgICAgICAgcmVtb3ZlKGtlZXBBbGl2ZVJvb3RbdHlwZV0sIGluamVjdGVkKTtcclxuICAgIH0sIHRhcmdldCk7XHJcbn1cclxuZnVuY3Rpb24gcmVzZXRTaGFwZUZsYWcodm5vZGUpIHtcclxuICAgIGxldCBzaGFwZUZsYWcgPSB2bm9kZS5zaGFwZUZsYWc7XHJcbiAgICBpZiAoc2hhcGVGbGFnICYgMjU2IC8qIENPTVBPTkVOVF9TSE9VTERfS0VFUF9BTElWRSAqLykge1xyXG4gICAgICAgIHNoYXBlRmxhZyAtPSAyNTYgLyogQ09NUE9ORU5UX1NIT1VMRF9LRUVQX0FMSVZFICovO1xyXG4gICAgfVxyXG4gICAgaWYgKHNoYXBlRmxhZyAmIDUxMiAvKiBDT01QT05FTlRfS0VQVF9BTElWRSAqLykge1xyXG4gICAgICAgIHNoYXBlRmxhZyAtPSA1MTIgLyogQ09NUE9ORU5UX0tFUFRfQUxJVkUgKi87XHJcbiAgICB9XHJcbiAgICB2bm9kZS5zaGFwZUZsYWcgPSBzaGFwZUZsYWc7XHJcbn1cclxuZnVuY3Rpb24gZ2V0SW5uZXJDaGlsZCh2bm9kZSkge1xyXG4gICAgcmV0dXJuIHZub2RlLnNoYXBlRmxhZyAmIDEyOCAvKiBTVVNQRU5TRSAqLyA/IHZub2RlLnNzQ29udGVudCA6IHZub2RlO1xyXG59XG5cbmZ1bmN0aW9uIGluamVjdEhvb2sodHlwZSwgaG9vaywgdGFyZ2V0ID0gY3VycmVudEluc3RhbmNlLCBwcmVwZW5kID0gZmFsc2UpIHtcclxuICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICBjb25zdCBob29rcyA9IHRhcmdldFt0eXBlXSB8fCAodGFyZ2V0W3R5cGVdID0gW10pO1xyXG4gICAgICAgIC8vIGNhY2hlIHRoZSBlcnJvciBoYW5kbGluZyB3cmFwcGVyIGZvciBpbmplY3RlZCBob29rcyBzbyB0aGUgc2FtZSBob29rXHJcbiAgICAgICAgLy8gY2FuIGJlIHByb3Blcmx5IGRlZHVwZWQgYnkgdGhlIHNjaGVkdWxlci4gXCJfX3dlaFwiIHN0YW5kcyBmb3IgXCJ3aXRoIGVycm9yXHJcbiAgICAgICAgLy8gaGFuZGxpbmdcIi5cclxuICAgICAgICBjb25zdCB3cmFwcGVkSG9vayA9IGhvb2suX193ZWggfHxcclxuICAgICAgICAgICAgKGhvb2suX193ZWggPSAoLi4uYXJncykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldC5pc1VubW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGRpc2FibGUgdHJhY2tpbmcgaW5zaWRlIGFsbCBsaWZlY3ljbGUgaG9va3NcclxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZXkgY2FuIHBvdGVudGlhbGx5IGJlIGNhbGxlZCBpbnNpZGUgZWZmZWN0cy5cclxuICAgICAgICAgICAgICAgIHBhdXNlVHJhY2tpbmcoKTtcclxuICAgICAgICAgICAgICAgIC8vIFNldCBjdXJyZW50SW5zdGFuY2UgZHVyaW5nIGhvb2sgaW52b2NhdGlvbi5cclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgYXNzdW1lcyB0aGUgaG9vayBkb2VzIG5vdCBzeW5jaHJvbm91c2x5IHRyaWdnZXIgb3RoZXIgaG9va3MsIHdoaWNoXHJcbiAgICAgICAgICAgICAgICAvLyBjYW4gb25seSBiZSBmYWxzZSB3aGVuIHRoZSB1c2VyIGRvZXMgc29tZXRoaW5nIHJlYWxseSBmdW5reS5cclxuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZSh0YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0gY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaG9vaywgdGFyZ2V0LCB0eXBlLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZShudWxsKTtcclxuICAgICAgICAgICAgICAgIHJlc2V0VHJhY2tpbmcoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChwcmVwZW5kKSB7XHJcbiAgICAgICAgICAgIGhvb2tzLnVuc2hpZnQod3JhcHBlZEhvb2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaG9va3MucHVzaCh3cmFwcGVkSG9vayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB3cmFwcGVkSG9vaztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGNvbnN0IGFwaU5hbWUgPSB0b0hhbmRsZXJLZXkoRXJyb3JUeXBlU3RyaW5nc1t0eXBlXS5yZXBsYWNlKC8gaG9vayQvLCAnJykpO1xyXG4gICAgICAgIHdhcm4oYCR7YXBpTmFtZX0gaXMgY2FsbGVkIHdoZW4gdGhlcmUgaXMgbm8gYWN0aXZlIGNvbXBvbmVudCBpbnN0YW5jZSB0byBiZSBgICtcclxuICAgICAgICAgICAgYGFzc29jaWF0ZWQgd2l0aC4gYCArXHJcbiAgICAgICAgICAgIGBMaWZlY3ljbGUgaW5qZWN0aW9uIEFQSXMgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgZXhlY3V0aW9uIG9mIHNldHVwKCkuYCArXHJcbiAgICAgICAgICAgIChgIElmIHlvdSBhcmUgdXNpbmcgYXN5bmMgc2V0dXAoKSwgbWFrZSBzdXJlIHRvIHJlZ2lzdGVyIGxpZmVjeWNsZSBgICtcclxuICAgICAgICAgICAgICAgICAgICBgaG9va3MgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdCBzdGF0ZW1lbnQuYFxyXG4gICAgICAgICAgICAgICAgKSk7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgY3JlYXRlSG9vayA9IChsaWZlY3ljbGUpID0+IChob29rLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UpID0+IFxyXG4vLyBwb3N0LWNyZWF0ZSBsaWZlY3ljbGUgcmVnaXN0cmF0aW9ucyBhcmUgbm9vcHMgZHVyaW5nIFNTUiAoZXhjZXB0IGZvciBzZXJ2ZXJQcmVmZXRjaClcclxuKCFpc0luU1NSQ29tcG9uZW50U2V0dXAgfHwgbGlmZWN5Y2xlID09PSBcInNwXCIgLyogU0VSVkVSX1BSRUZFVENIICovKSAmJlxyXG4gICAgaW5qZWN0SG9vayhsaWZlY3ljbGUsIGhvb2ssIHRhcmdldCk7XHJcbmNvbnN0IG9uQmVmb3JlTW91bnQgPSBjcmVhdGVIb29rKFwiYm1cIiAvKiBCRUZPUkVfTU9VTlQgKi8pO1xyXG5jb25zdCBvbk1vdW50ZWQgPSBjcmVhdGVIb29rKFwibVwiIC8qIE1PVU5URUQgKi8pO1xyXG5jb25zdCBvbkJlZm9yZVVwZGF0ZSA9IGNyZWF0ZUhvb2soXCJidVwiIC8qIEJFRk9SRV9VUERBVEUgKi8pO1xyXG5jb25zdCBvblVwZGF0ZWQgPSBjcmVhdGVIb29rKFwidVwiIC8qIFVQREFURUQgKi8pO1xyXG5jb25zdCBvbkJlZm9yZVVubW91bnQgPSBjcmVhdGVIb29rKFwiYnVtXCIgLyogQkVGT1JFX1VOTU9VTlQgKi8pO1xyXG5jb25zdCBvblVubW91bnRlZCA9IGNyZWF0ZUhvb2soXCJ1bVwiIC8qIFVOTU9VTlRFRCAqLyk7XHJcbmNvbnN0IG9uU2VydmVyUHJlZmV0Y2ggPSBjcmVhdGVIb29rKFwic3BcIiAvKiBTRVJWRVJfUFJFRkVUQ0ggKi8pO1xyXG5jb25zdCBvblJlbmRlclRyaWdnZXJlZCA9IGNyZWF0ZUhvb2soXCJydGdcIiAvKiBSRU5ERVJfVFJJR0dFUkVEICovKTtcclxuY29uc3Qgb25SZW5kZXJUcmFja2VkID0gY3JlYXRlSG9vayhcInJ0Y1wiIC8qIFJFTkRFUl9UUkFDS0VEICovKTtcclxuZnVuY3Rpb24gb25FcnJvckNhcHR1cmVkKGhvb2ssIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSkge1xyXG4gICAgaW5qZWN0SG9vayhcImVjXCIgLyogRVJST1JfQ0FQVFVSRUQgKi8sIGhvb2ssIHRhcmdldCk7XHJcbn1cblxuZnVuY3Rpb24gY3JlYXRlRHVwbGljYXRlQ2hlY2tlcigpIHtcclxuICAgIGNvbnN0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIHJldHVybiAodHlwZSwga2V5KSA9PiB7XHJcbiAgICAgICAgaWYgKGNhY2hlW2tleV0pIHtcclxuICAgICAgICAgICAgd2FybihgJHt0eXBlfSBwcm9wZXJ0eSBcIiR7a2V5fVwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiAke2NhY2hlW2tleV19LmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY2FjaGVba2V5XSA9IHR5cGU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5sZXQgc2hvdWxkQ2FjaGVBY2Nlc3MgPSB0cnVlO1xyXG5mdW5jdGlvbiBhcHBseU9wdGlvbnMoaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IG9wdGlvbnMgPSByZXNvbHZlTWVyZ2VkT3B0aW9ucyhpbnN0YW5jZSk7XHJcbiAgICBjb25zdCBwdWJsaWNUaGlzID0gaW5zdGFuY2UucHJveHk7XHJcbiAgICBjb25zdCBjdHggPSBpbnN0YW5jZS5jdHg7XHJcbiAgICAvLyBkbyBub3QgY2FjaGUgcHJvcGVydHkgYWNjZXNzIG9uIHB1YmxpYyBwcm94eSBkdXJpbmcgc3RhdGUgaW5pdGlhbGl6YXRpb25cclxuICAgIHNob3VsZENhY2hlQWNjZXNzID0gZmFsc2U7XHJcbiAgICAvLyBjYWxsIGJlZm9yZUNyZWF0ZSBmaXJzdCBiZWZvcmUgYWNjZXNzaW5nIG90aGVyIG9wdGlvbnMgc2luY2VcclxuICAgIC8vIHRoZSBob29rIG1heSBtdXRhdGUgcmVzb2x2ZWQgb3B0aW9ucyAoIzI3OTEpXHJcbiAgICBpZiAob3B0aW9ucy5iZWZvcmVDcmVhdGUpIHtcclxuICAgICAgICBjYWxsSG9vayhvcHRpb25zLmJlZm9yZUNyZWF0ZSwgaW5zdGFuY2UsIFwiYmNcIiAvKiBCRUZPUkVfQ1JFQVRFICovKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgXHJcbiAgICAvLyBzdGF0ZVxyXG4gICAgZGF0YTogZGF0YU9wdGlvbnMsIGNvbXB1dGVkOiBjb21wdXRlZE9wdGlvbnMsIG1ldGhvZHMsIHdhdGNoOiB3YXRjaE9wdGlvbnMsIHByb3ZpZGU6IHByb3ZpZGVPcHRpb25zLCBpbmplY3Q6IGluamVjdE9wdGlvbnMsIFxyXG4gICAgLy8gbGlmZWN5Y2xlXHJcbiAgICBjcmVhdGVkLCBiZWZvcmVNb3VudCwgbW91bnRlZCwgYmVmb3JlVXBkYXRlLCB1cGRhdGVkLCBhY3RpdmF0ZWQsIGRlYWN0aXZhdGVkLCBiZWZvcmVEZXN0cm95LCBiZWZvcmVVbm1vdW50LCBkZXN0cm95ZWQsIHVubW91bnRlZCwgcmVuZGVyLCByZW5kZXJUcmFja2VkLCByZW5kZXJUcmlnZ2VyZWQsIGVycm9yQ2FwdHVyZWQsIHNlcnZlclByZWZldGNoLCBcclxuICAgIC8vIHB1YmxpYyBBUElcclxuICAgIGV4cG9zZSwgaW5oZXJpdEF0dHJzLCBcclxuICAgIC8vIGFzc2V0c1xyXG4gICAgY29tcG9uZW50cywgZGlyZWN0aXZlcywgZmlsdGVycyB9ID0gb3B0aW9ucztcclxuICAgIGNvbnN0IGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGNyZWF0ZUR1cGxpY2F0ZUNoZWNrZXIoKSA6IG51bGw7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgY29uc3QgW3Byb3BzT3B0aW9uc10gPSBpbnN0YW5jZS5wcm9wc09wdGlvbnM7XHJcbiAgICAgICAgaWYgKHByb3BzT3B0aW9ucykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wc09wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIlByb3BzXCIgLyogUFJPUFMgKi8sIGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBvcHRpb25zIGluaXRpYWxpemF0aW9uIG9yZGVyICh0byBiZSBjb25zaXN0ZW50IHdpdGggVnVlIDIpOlxyXG4gICAgLy8gLSBwcm9wcyAoYWxyZWFkeSBkb25lIG91dHNpZGUgb2YgdGhpcyBmdW5jdGlvbilcclxuICAgIC8vIC0gaW5qZWN0XHJcbiAgICAvLyAtIG1ldGhvZHNcclxuICAgIC8vIC0gZGF0YSAoZGVmZXJyZWQgc2luY2UgaXQgcmVsaWVzIG9uIGB0aGlzYCBhY2Nlc3MpXHJcbiAgICAvLyAtIGNvbXB1dGVkXHJcbiAgICAvLyAtIHdhdGNoIChkZWZlcnJlZCBzaW5jZSBpdCByZWxpZXMgb24gYHRoaXNgIGFjY2VzcylcclxuICAgIGlmIChpbmplY3RPcHRpb25zKSB7XHJcbiAgICAgICAgcmVzb2x2ZUluamVjdGlvbnMoaW5qZWN0T3B0aW9ucywgY3R4LCBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMpO1xyXG4gICAgfVxyXG4gICAgaWYgKG1ldGhvZHMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBtZXRob2RzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1ldGhvZEhhbmRsZXIgPSBtZXRob2RzW2tleV07XHJcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKG1ldGhvZEhhbmRsZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJbiBkZXYgbW9kZSwgd2UgdXNlIHRoZSBgY3JlYXRlUmVuZGVyQ29udGV4dGAgZnVuY3Rpb24gdG8gZGVmaW5lIG1ldGhvZHMgdG8gdGhlIHByb3h5IHRhcmdldCxcclxuICAgICAgICAgICAgICAgIC8vIGFuZCB0aG9zZSBhcmUgcmVhZC1vbmx5IGJ1dCByZWNvbmZpZ3VyYWJsZSwgc28gaXQgbmVlZHMgdG8gYmUgcmVkZWZpbmVkIGhlcmVcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG1ldGhvZEhhbmRsZXIuYmluZChwdWJsaWNUaGlzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4W2tleV0gPSBtZXRob2RIYW5kbGVyLmJpbmQocHVibGljVGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiTWV0aG9kc1wiIC8qIE1FVEhPRFMgKi8sIGtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBNZXRob2QgXCIke2tleX1cIiBoYXMgdHlwZSBcIiR7dHlwZW9mIG1ldGhvZEhhbmRsZXJ9XCIgaW4gdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLiBgICtcclxuICAgICAgICAgICAgICAgICAgICBgRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChkYXRhT3B0aW9ucykge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzRnVuY3Rpb24oZGF0YU9wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYFRoZSBkYXRhIG9wdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb24uIGAgK1xyXG4gICAgICAgICAgICAgICAgYFBsYWluIG9iamVjdCB1c2FnZSBpcyBubyBsb25nZXIgc3VwcG9ydGVkLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkYXRhID0gZGF0YU9wdGlvbnMuY2FsbChwdWJsaWNUaGlzLCBwdWJsaWNUaGlzKTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGlzUHJvbWlzZShkYXRhKSkge1xyXG4gICAgICAgICAgICB3YXJuKGBkYXRhKCkgcmV0dXJuZWQgYSBQcm9taXNlIC0gbm90ZSBkYXRhKCkgY2Fubm90IGJlIGFzeW5jOyBJZiB5b3UgYCArXHJcbiAgICAgICAgICAgICAgICBgaW50ZW5kIHRvIHBlcmZvcm0gZGF0YSBmZXRjaGluZyBiZWZvcmUgY29tcG9uZW50IHJlbmRlcnMsIHVzZSBgICtcclxuICAgICAgICAgICAgICAgIGBhc3luYyBzZXR1cCgpICsgPFN1c3BlbnNlPi5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc09iamVjdChkYXRhKSkge1xyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybihgZGF0YSgpIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0LmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UuZGF0YSA9IHJlYWN0aXZlKGRhdGEpO1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiRGF0YVwiIC8qIERBVEEgKi8sIGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhwb3NlIGRhdGEgb24gY3R4IGR1cmluZyBkZXZcclxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5WzBdICE9PSAnJCcgJiYga2V5WzBdICE9PSAnXycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiBkYXRhW2tleV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQ6IE5PT1BcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gc3RhdGUgaW5pdGlhbGl6YXRpb24gY29tcGxldGUgYXQgdGhpcyBwb2ludCAtIHN0YXJ0IGNhY2hpbmcgYWNjZXNzXHJcbiAgICBzaG91bGRDYWNoZUFjY2VzcyA9IHRydWU7XHJcbiAgICBpZiAoY29tcHV0ZWRPcHRpb25zKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY29tcHV0ZWRPcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9wdCA9IGNvbXB1dGVkT3B0aW9uc1trZXldO1xyXG4gICAgICAgICAgICBjb25zdCBnZXQgPSBpc0Z1bmN0aW9uKG9wdClcclxuICAgICAgICAgICAgICAgID8gb3B0LmJpbmQocHVibGljVGhpcywgcHVibGljVGhpcylcclxuICAgICAgICAgICAgICAgIDogaXNGdW5jdGlvbihvcHQuZ2V0KVxyXG4gICAgICAgICAgICAgICAgICAgID8gb3B0LmdldC5iaW5kKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBOT09QO1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGdldCA9PT0gTk9PUCkge1xyXG4gICAgICAgICAgICAgICAgd2FybihgQ29tcHV0ZWQgcHJvcGVydHkgXCIke2tleX1cIiBoYXMgbm8gZ2V0dGVyLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHNldCA9ICFpc0Z1bmN0aW9uKG9wdCkgJiYgaXNGdW5jdGlvbihvcHQuc2V0KVxyXG4gICAgICAgICAgICAgICAgPyBvcHQuc2V0LmJpbmQocHVibGljVGhpcylcclxuICAgICAgICAgICAgICAgIDogKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgICAgICAgICAgICAgPyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYFdyaXRlIG9wZXJhdGlvbiBmYWlsZWQ6IGNvbXB1dGVkIHByb3BlcnR5IFwiJHtrZXl9XCIgaXMgcmVhZG9ubHkuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIDogTk9PUDtcclxuICAgICAgICAgICAgY29uc3QgYyA9IGNvbXB1dGVkKHtcclxuICAgICAgICAgICAgICAgIGdldCxcclxuICAgICAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiBjLnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgc2V0OiB2ID0+IChjLnZhbHVlID0gdilcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIkNvbXB1dGVkXCIgLyogQ09NUFVURUQgKi8sIGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAod2F0Y2hPcHRpb25zKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gd2F0Y2hPcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGNyZWF0ZVdhdGNoZXIod2F0Y2hPcHRpb25zW2tleV0sIGN0eCwgcHVibGljVGhpcywga2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocHJvdmlkZU9wdGlvbnMpIHtcclxuICAgICAgICBjb25zdCBwcm92aWRlcyA9IGlzRnVuY3Rpb24ocHJvdmlkZU9wdGlvbnMpXHJcbiAgICAgICAgICAgID8gcHJvdmlkZU9wdGlvbnMuY2FsbChwdWJsaWNUaGlzKVxyXG4gICAgICAgICAgICA6IHByb3ZpZGVPcHRpb25zO1xyXG4gICAgICAgIFJlZmxlY3Qub3duS2V5cyhwcm92aWRlcykuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgICBwcm92aWRlKGtleSwgcHJvdmlkZXNba2V5XSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAoY3JlYXRlZCkge1xyXG4gICAgICAgIGNhbGxIb29rKGNyZWF0ZWQsIGluc3RhbmNlLCBcImNcIiAvKiBDUkVBVEVEICovKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhyZWdpc3RlciwgaG9vaykge1xyXG4gICAgICAgIGlmIChpc0FycmF5KGhvb2spKSB7XHJcbiAgICAgICAgICAgIGhvb2suZm9yRWFjaChfaG9vayA9PiByZWdpc3RlcihfaG9vay5iaW5kKHB1YmxpY1RoaXMpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGhvb2spIHtcclxuICAgICAgICAgICAgcmVnaXN0ZXIoaG9vay5iaW5kKHB1YmxpY1RoaXMpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25CZWZvcmVNb3VudCwgYmVmb3JlTW91bnQpO1xyXG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uTW91bnRlZCwgbW91bnRlZCk7XHJcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25CZWZvcmVVcGRhdGUsIGJlZm9yZVVwZGF0ZSk7XHJcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25VcGRhdGVkLCB1cGRhdGVkKTtcclxuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkFjdGl2YXRlZCwgYWN0aXZhdGVkKTtcclxuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkRlYWN0aXZhdGVkLCBkZWFjdGl2YXRlZCk7XHJcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25FcnJvckNhcHR1cmVkLCBlcnJvckNhcHR1cmVkKTtcclxuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblJlbmRlclRyYWNrZWQsIHJlbmRlclRyYWNrZWQpO1xyXG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uUmVuZGVyVHJpZ2dlcmVkLCByZW5kZXJUcmlnZ2VyZWQpO1xyXG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uQmVmb3JlVW5tb3VudCwgYmVmb3JlVW5tb3VudCk7XHJcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25Vbm1vdW50ZWQsIHVubW91bnRlZCk7XHJcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25TZXJ2ZXJQcmVmZXRjaCwgc2VydmVyUHJlZmV0Y2gpO1xyXG4gICAgaWYgKGlzQXJyYXkoZXhwb3NlKSkge1xyXG4gICAgICAgIGlmIChleHBvc2UubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4cG9zZWQgPSBpbnN0YW5jZS5leHBvc2VkIHx8IChpbnN0YW5jZS5leHBvc2VkID0gcHJveHlSZWZzKHt9KSk7XHJcbiAgICAgICAgICAgIGV4cG9zZS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgICAgICBleHBvc2VkW2tleV0gPSB0b1JlZihwdWJsaWNUaGlzLCBrZXkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIWluc3RhbmNlLmV4cG9zZWQpIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UuZXhwb3NlZCA9IEVNUFRZX09CSjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBvcHRpb25zIHRoYXQgYXJlIGhhbmRsZWQgd2hlbiBjcmVhdGluZyB0aGUgaW5zdGFuY2UgYnV0IGFsc28gbmVlZCB0byBiZVxyXG4gICAgLy8gYXBwbGllZCBmcm9tIG1peGluc1xyXG4gICAgaWYgKHJlbmRlciAmJiBpbnN0YW5jZS5yZW5kZXIgPT09IE5PT1ApIHtcclxuICAgICAgICBpbnN0YW5jZS5yZW5kZXIgPSByZW5kZXI7XHJcbiAgICB9XHJcbiAgICBpZiAoaW5oZXJpdEF0dHJzICE9IG51bGwpIHtcclxuICAgICAgICBpbnN0YW5jZS5pbmhlcml0QXR0cnMgPSBpbmhlcml0QXR0cnM7XHJcbiAgICB9XHJcbiAgICAvLyBhc3NldCBvcHRpb25zLlxyXG4gICAgaWYgKGNvbXBvbmVudHMpXHJcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50cyA9IGNvbXBvbmVudHM7XHJcbiAgICBpZiAoZGlyZWN0aXZlcylcclxuICAgICAgICBpbnN0YW5jZS5kaXJlY3RpdmVzID0gZGlyZWN0aXZlcztcclxufVxyXG5mdW5jdGlvbiByZXNvbHZlSW5qZWN0aW9ucyhpbmplY3RPcHRpb25zLCBjdHgsIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyA9IE5PT1ApIHtcclxuICAgIGlmIChpc0FycmF5KGluamVjdE9wdGlvbnMpKSB7XHJcbiAgICAgICAgaW5qZWN0T3B0aW9ucyA9IG5vcm1hbGl6ZUluamVjdChpbmplY3RPcHRpb25zKTtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3Qga2V5IGluIGluamVjdE9wdGlvbnMpIHtcclxuICAgICAgICBjb25zdCBvcHQgPSBpbmplY3RPcHRpb25zW2tleV07XHJcbiAgICAgICAgaWYgKGlzT2JqZWN0KG9wdCkpIHtcclxuICAgICAgICAgICAgaWYgKCdkZWZhdWx0JyBpbiBvcHQpIHtcclxuICAgICAgICAgICAgICAgIGN0eFtrZXldID0gaW5qZWN0KG9wdC5mcm9tIHx8IGtleSwgb3B0LmRlZmF1bHQsIHRydWUgLyogdHJlYXQgZGVmYXVsdCBmdW5jdGlvbiBhcyBmYWN0b3J5ICovKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGN0eFtrZXldID0gaW5qZWN0KG9wdC5mcm9tIHx8IGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGN0eFtrZXldID0gaW5qZWN0KG9wdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiSW5qZWN0XCIgLyogSU5KRUNUICovLCBrZXkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjYWxsSG9vayhob29rLCBpbnN0YW5jZSwgdHlwZSkge1xyXG4gICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaXNBcnJheShob29rKVxyXG4gICAgICAgID8gaG9vay5tYXAoaCA9PiBoLmJpbmQoaW5zdGFuY2UucHJveHkpKVxyXG4gICAgICAgIDogaG9vay5iaW5kKGluc3RhbmNlLnByb3h5KSwgaW5zdGFuY2UsIHR5cGUpO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIocmF3LCBjdHgsIHB1YmxpY1RoaXMsIGtleSkge1xyXG4gICAgY29uc3QgZ2V0dGVyID0ga2V5LmluY2x1ZGVzKCcuJylcclxuICAgICAgICA/IGNyZWF0ZVBhdGhHZXR0ZXIocHVibGljVGhpcywga2V5KVxyXG4gICAgICAgIDogKCkgPT4gcHVibGljVGhpc1trZXldO1xyXG4gICAgaWYgKGlzU3RyaW5nKHJhdykpIHtcclxuICAgICAgICBjb25zdCBoYW5kbGVyID0gY3R4W3Jhd107XHJcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcclxuICAgICAgICAgICAgd2F0Y2goZ2V0dGVyLCBoYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYEludmFsaWQgd2F0Y2ggaGFuZGxlciBzcGVjaWZpZWQgYnkga2V5IFwiJHtyYXd9XCJgLCBoYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHJhdykpIHtcclxuICAgICAgICB3YXRjaChnZXR0ZXIsIHJhdy5iaW5kKHB1YmxpY1RoaXMpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHJhdykpIHtcclxuICAgICAgICBpZiAoaXNBcnJheShyYXcpKSB7XHJcbiAgICAgICAgICAgIHJhdy5mb3JFYWNoKHIgPT4gY3JlYXRlV2F0Y2hlcihyLCBjdHgsIHB1YmxpY1RoaXMsIGtleSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IGlzRnVuY3Rpb24ocmF3LmhhbmRsZXIpXHJcbiAgICAgICAgICAgICAgICA/IHJhdy5oYW5kbGVyLmJpbmQocHVibGljVGhpcylcclxuICAgICAgICAgICAgICAgIDogY3R4W3Jhdy5oYW5kbGVyXTtcclxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcclxuICAgICAgICAgICAgICAgIHdhdGNoKGdldHRlciwgaGFuZGxlciwgcmF3KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYEludmFsaWQgd2F0Y2ggaGFuZGxlciBzcGVjaWZpZWQgYnkga2V5IFwiJHtyYXcuaGFuZGxlcn1cImAsIGhhbmRsZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgd2FybihgSW52YWxpZCB3YXRjaCBvcHRpb246IFwiJHtrZXl9XCJgLCByYXcpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXNvbHZlIG1lcmdlZCBvcHRpb25zIGFuZCBjYWNoZSBpdCBvbiB0aGUgY29tcG9uZW50LlxyXG4gKiBUaGlzIGlzIGRvbmUgb25seSBvbmNlIHBlci1jb21wb25lbnQgc2luY2UgdGhlIG1lcmdpbmcgZG9lcyBub3QgaW52b2x2ZVxyXG4gKiBpbnN0YW5jZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiByZXNvbHZlTWVyZ2VkT3B0aW9ucyhpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgYmFzZSA9IGluc3RhbmNlLnR5cGU7XHJcbiAgICBjb25zdCB7IG1peGlucywgZXh0ZW5kczogZXh0ZW5kc09wdGlvbnMgfSA9IGJhc2U7XHJcbiAgICBjb25zdCB7IG1peGluczogZ2xvYmFsTWl4aW5zLCBvcHRpb25zQ2FjaGU6IGNhY2hlLCBjb25maWc6IHsgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzIH0gfSA9IGluc3RhbmNlLmFwcENvbnRleHQ7XHJcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoYmFzZSk7XHJcbiAgICBsZXQgcmVzb2x2ZWQ7XHJcbiAgICBpZiAoY2FjaGVkKSB7XHJcbiAgICAgICAgcmVzb2x2ZWQgPSBjYWNoZWQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICghZ2xvYmFsTWl4aW5zLmxlbmd0aCAmJiAhbWl4aW5zICYmICFleHRlbmRzT3B0aW9ucykge1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmVzb2x2ZWQgPSBiYXNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJlc29sdmVkID0ge307XHJcbiAgICAgICAgaWYgKGdsb2JhbE1peGlucy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgZ2xvYmFsTWl4aW5zLmZvckVhY2gobSA9PiBtZXJnZU9wdGlvbnMocmVzb2x2ZWQsIG0sIG9wdGlvbk1lcmdlU3RyYXRlZ2llcywgdHJ1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtZXJnZU9wdGlvbnMocmVzb2x2ZWQsIGJhc2UsIG9wdGlvbk1lcmdlU3RyYXRlZ2llcyk7XHJcbiAgICB9XHJcbiAgICBjYWNoZS5zZXQoYmFzZSwgcmVzb2x2ZWQpO1xyXG4gICAgcmV0dXJuIHJlc29sdmVkO1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyh0bywgZnJvbSwgc3RyYXRzLCBhc01peGluID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IHsgbWl4aW5zLCBleHRlbmRzOiBleHRlbmRzT3B0aW9ucyB9ID0gZnJvbTtcclxuICAgIGlmIChleHRlbmRzT3B0aW9ucykge1xyXG4gICAgICAgIG1lcmdlT3B0aW9ucyh0bywgZXh0ZW5kc09wdGlvbnMsIHN0cmF0cywgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBpZiAobWl4aW5zKSB7XHJcbiAgICAgICAgbWl4aW5zLmZvckVhY2goKG0pID0+IG1lcmdlT3B0aW9ucyh0bywgbSwgc3RyYXRzLCB0cnVlKSk7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBmcm9tKSB7XHJcbiAgICAgICAgaWYgKGFzTWl4aW4gJiYga2V5ID09PSAnZXhwb3NlJykge1xyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgIHdhcm4oYFwiZXhwb3NlXCIgb3B0aW9uIGlzIGlnbm9yZWQgd2hlbiBkZWNsYXJlZCBpbiBtaXhpbnMgb3IgZXh0ZW5kcy4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYEl0IHNob3VsZCBvbmx5IGJlIGRlY2xhcmVkIGluIHRoZSBiYXNlIGNvbXBvbmVudCBpdHNlbGYuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBzdHJhdCA9IGludGVybmFsT3B0aW9uTWVyZ2VTdHJhdHNba2V5XSB8fCAoc3RyYXRzICYmIHN0cmF0c1trZXldKTtcclxuICAgICAgICAgICAgdG9ba2V5XSA9IHN0cmF0ID8gc3RyYXQodG9ba2V5XSwgZnJvbVtrZXldKSA6IGZyb21ba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG87XHJcbn1cclxuY29uc3QgaW50ZXJuYWxPcHRpb25NZXJnZVN0cmF0cyA9IHtcclxuICAgIGRhdGE6IG1lcmdlRGF0YUZuLFxyXG4gICAgcHJvcHM6IG1lcmdlT2JqZWN0T3B0aW9ucyxcclxuICAgIGVtaXRzOiBtZXJnZU9iamVjdE9wdGlvbnMsXHJcbiAgICAvLyBvYmplY3RzXHJcbiAgICBtZXRob2RzOiBtZXJnZU9iamVjdE9wdGlvbnMsXHJcbiAgICBjb21wdXRlZDogbWVyZ2VPYmplY3RPcHRpb25zLFxyXG4gICAgLy8gbGlmZWN5Y2xlXHJcbiAgICBiZWZvcmVDcmVhdGU6IG1lcmdlSG9vayxcclxuICAgIGNyZWF0ZWQ6IG1lcmdlSG9vayxcclxuICAgIGJlZm9yZU1vdW50OiBtZXJnZUhvb2ssXHJcbiAgICBtb3VudGVkOiBtZXJnZUhvb2ssXHJcbiAgICBiZWZvcmVVcGRhdGU6IG1lcmdlSG9vayxcclxuICAgIHVwZGF0ZWQ6IG1lcmdlSG9vayxcclxuICAgIGJlZm9yZURlc3Ryb3k6IG1lcmdlSG9vayxcclxuICAgIGRlc3Ryb3llZDogbWVyZ2VIb29rLFxyXG4gICAgYWN0aXZhdGVkOiBtZXJnZUhvb2ssXHJcbiAgICBkZWFjdGl2YXRlZDogbWVyZ2VIb29rLFxyXG4gICAgZXJyb3JDYXB0dXJlZDogbWVyZ2VIb29rLFxyXG4gICAgc2VydmVyUHJlZmV0Y2g6IG1lcmdlSG9vayxcclxuICAgIC8vIGFzc2V0c1xyXG4gICAgY29tcG9uZW50czogbWVyZ2VPYmplY3RPcHRpb25zLFxyXG4gICAgZGlyZWN0aXZlczogbWVyZ2VPYmplY3RPcHRpb25zLFxyXG4gICAgLy8gd2F0Y2ggaGFzIHNwZWNpYWwgbWVyZ2UgYmVoYXZpb3IgaW4gdjIsIGJ1dCBpc24ndCBhY3R1YWxseSBuZWVkZWQgaW4gdjMuXHJcbiAgICAvLyBzaW5jZSB3ZSBhcmUgb25seSBleHBvc2luZyB0aGVzZSBmb3IgY29tcGF0IGFuZCBub2JvZHkgc2hvdWxkIGJlIHJlbHlpbmdcclxuICAgIC8vIG9uIHRoZSB3YXRjaC1zcGVjaWZpYyBiZWhhdmlvciwganVzdCBleHBvc2UgdGhlIG9iamVjdCBtZXJnZSBzdHJhdC5cclxuICAgIHdhdGNoOiBtZXJnZU9iamVjdE9wdGlvbnMsXHJcbiAgICAvLyBwcm92aWRlIC8gaW5qZWN0XHJcbiAgICBwcm92aWRlOiBtZXJnZURhdGFGbixcclxuICAgIGluamVjdDogbWVyZ2VJbmplY3RcclxufTtcclxuZnVuY3Rpb24gbWVyZ2VEYXRhRm4odG8sIGZyb20pIHtcclxuICAgIGlmICghZnJvbSkge1xyXG4gICAgICAgIHJldHVybiB0bztcclxuICAgIH1cclxuICAgIGlmICghdG8pIHtcclxuICAgICAgICByZXR1cm4gZnJvbTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4oKSB7XHJcbiAgICAgICAgcmV0dXJuIChleHRlbmQpKGlzRnVuY3Rpb24odG8pID8gdG8uY2FsbCh0aGlzLCB0aGlzKSA6IHRvLCBpc0Z1bmN0aW9uKGZyb20pID8gZnJvbS5jYWxsKHRoaXMsIHRoaXMpIDogZnJvbSk7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlSW5qZWN0KHRvLCBmcm9tKSB7XHJcbiAgICByZXR1cm4gbWVyZ2VPYmplY3RPcHRpb25zKG5vcm1hbGl6ZUluamVjdCh0byksIG5vcm1hbGl6ZUluamVjdChmcm9tKSk7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplSW5qZWN0KHJhdykge1xyXG4gICAgaWYgKGlzQXJyYXkocmF3KSkge1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IHt9O1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmF3Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJlc1tyYXdbaV1dID0gcmF3W2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJhdztcclxufVxyXG5mdW5jdGlvbiBtZXJnZUhvb2sodG8sIGZyb20pIHtcclxuICAgIHJldHVybiB0byA/IFsuLi5uZXcgU2V0KFtdLmNvbmNhdCh0bywgZnJvbSkpXSA6IGZyb207XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2VPYmplY3RPcHRpb25zKHRvLCBmcm9tKSB7XHJcbiAgICByZXR1cm4gdG8gPyBleHRlbmQoZXh0ZW5kKE9iamVjdC5jcmVhdGUobnVsbCksIHRvKSwgZnJvbSkgOiBmcm9tO1xyXG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIGlzU3RhdGVmdWwsIC8vIHJlc3VsdCBvZiBiaXR3aXNlIGZsYWcgY29tcGFyaXNvblxyXG5pc1NTUiA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCBwcm9wcyA9IHt9O1xyXG4gICAgY29uc3QgYXR0cnMgPSB7fTtcclxuICAgIGRlZihhdHRycywgSW50ZXJuYWxPYmplY3RLZXksIDEpO1xyXG4gICAgaW5zdGFuY2UucHJvcHNEZWZhdWx0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICBzZXRGdWxsUHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCBwcm9wcywgYXR0cnMpO1xyXG4gICAgLy8gZW5zdXJlIGFsbCBkZWNsYXJlZCBwcm9wIGtleXMgYXJlIHByZXNlbnRcclxuICAgIGZvciAoY29uc3Qga2V5IGluIGluc3RhbmNlLnByb3BzT3B0aW9uc1swXSkge1xyXG4gICAgICAgIGlmICghKGtleSBpbiBwcm9wcykpIHtcclxuICAgICAgICAgICAgcHJvcHNba2V5XSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyB2YWxpZGF0aW9uXHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgdmFsaWRhdGVQcm9wcyhyYXdQcm9wcyB8fCB7fSwgcHJvcHMsIGluc3RhbmNlKTtcclxuICAgIH1cclxuICAgIGlmIChpc1N0YXRlZnVsKSB7XHJcbiAgICAgICAgLy8gc3RhdGVmdWxcclxuICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IGlzU1NSID8gcHJvcHMgOiBzaGFsbG93UmVhY3RpdmUocHJvcHMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKCFpbnN0YW5jZS50eXBlLnByb3BzKSB7XHJcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9uYWwgdy8gb3B0aW9uYWwgcHJvcHMsIHByb3BzID09PSBhdHRyc1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IGF0dHJzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gZnVuY3Rpb25hbCB3LyBkZWNsYXJlZCBwcm9wc1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IHByb3BzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGluc3RhbmNlLmF0dHJzID0gYXR0cnM7XHJcbn1cclxuZnVuY3Rpb24gdXBkYXRlUHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCByYXdQcmV2UHJvcHMsIG9wdGltaXplZCkge1xyXG4gICAgY29uc3QgeyBwcm9wcywgYXR0cnMsIHZub2RlOiB7IHBhdGNoRmxhZyB9IH0gPSBpbnN0YW5jZTtcclxuICAgIGNvbnN0IHJhd0N1cnJlbnRQcm9wcyA9IHRvUmF3KHByb3BzKTtcclxuICAgIGNvbnN0IFtvcHRpb25zXSA9IGluc3RhbmNlLnByb3BzT3B0aW9ucztcclxuICAgIGxldCBoYXNBdHRyc0NoYW5nZWQgPSBmYWxzZTtcclxuICAgIGlmIChcclxuICAgIC8vIGFsd2F5cyBmb3JjZSBmdWxsIGRpZmYgaW4gZGV2XHJcbiAgICAvLyAtICMxOTQyIGlmIGhtciBpcyBlbmFibGVkIHdpdGggc2ZjIGNvbXBvbmVudFxyXG4gICAgLy8gLSB2aXRlIzg3MiBub24tc2ZjIGNvbXBvbmVudCB1c2VkIGJ5IHNmYyBjb21wb25lbnRcclxuICAgICEoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgKGluc3RhbmNlLnR5cGUuX19obXJJZCB8fFxyXG4gICAgICAgICAgICAoaW5zdGFuY2UucGFyZW50ICYmIGluc3RhbmNlLnBhcmVudC50eXBlLl9faG1ySWQpKSkgJiZcclxuICAgICAgICAob3B0aW1pemVkIHx8IHBhdGNoRmxhZyA+IDApICYmXHJcbiAgICAgICAgIShwYXRjaEZsYWcgJiAxNiAvKiBGVUxMX1BST1BTICovKSkge1xyXG4gICAgICAgIGlmIChwYXRjaEZsYWcgJiA4IC8qIFBST1BTICovKSB7XHJcbiAgICAgICAgICAgIC8vIENvbXBpbGVyLWdlbmVyYXRlZCBwcm9wcyAmIG5vIGtleXMgY2hhbmdlLCBqdXN0IHNldCB0aGUgdXBkYXRlZFxyXG4gICAgICAgICAgICAvLyB0aGUgcHJvcHMuXHJcbiAgICAgICAgICAgIGNvbnN0IHByb3BzVG9VcGRhdGUgPSBpbnN0YW5jZS52bm9kZS5keW5hbWljUHJvcHM7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHNUb1VwZGF0ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGtleSA9IHByb3BzVG9VcGRhdGVbaV07XHJcbiAgICAgICAgICAgICAgICAvLyBQUk9QUyBmbGFnIGd1YXJhbnRlZXMgcmF3UHJvcHMgdG8gYmUgbm9uLW51bGxcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmF3UHJvcHNba2V5XTtcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXR0ciAvIHByb3BzIHNlcGFyYXRpb24gd2FzIGRvbmUgb24gaW5pdCBhbmQgd2lsbCBiZSBjb25zaXN0ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gdGhpcyBjb2RlIHBhdGgsIHNvIGp1c3QgY2hlY2sgaWYgYXR0cnMgaGF2ZSBpdC5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzT3duKGF0dHJzLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gYXR0cnNba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnNba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FtZWxpemVkS2V5ID0gY2FtZWxpemUoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNbY2FtZWxpemVkS2V5XSA9IHJlc29sdmVQcm9wVmFsdWUob3B0aW9ucywgcmF3Q3VycmVudFByb3BzLCBjYW1lbGl6ZWRLZXksIHZhbHVlLCBpbnN0YW5jZSwgZmFsc2UgLyogaXNBYnNlbnQgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gYXR0cnNba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyc1trZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0F0dHJzQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gZnVsbCBwcm9wcyB1cGRhdGUuXHJcbiAgICAgICAgaWYgKHNldEZ1bGxQcm9wcyhpbnN0YW5jZSwgcmF3UHJvcHMsIHByb3BzLCBhdHRycykpIHtcclxuICAgICAgICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaW4gY2FzZSBvZiBkeW5hbWljIHByb3BzLCBjaGVjayBpZiB3ZSBuZWVkIHRvIGRlbGV0ZSBrZXlzIGZyb21cclxuICAgICAgICAvLyB0aGUgcHJvcHMgb2JqZWN0XHJcbiAgICAgICAgbGV0IGtlYmFiS2V5O1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJhd0N1cnJlbnRQcm9wcykge1xyXG4gICAgICAgICAgICBpZiAoIXJhd1Byb3BzIHx8XHJcbiAgICAgICAgICAgICAgICAvLyBmb3IgY2FtZWxDYXNlXHJcbiAgICAgICAgICAgICAgICAoIWhhc093bihyYXdQcm9wcywga2V5KSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhlIG9yaWdpbmFsIHByb3BzIHdhcyBwYXNzZWQgaW4gYXMga2ViYWItY2FzZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBjb252ZXJ0ZWQgdG8gY2FtZWxDYXNlICgjOTU1KVxyXG4gICAgICAgICAgICAgICAgICAgICgoa2ViYWJLZXkgPSBoeXBoZW5hdGUoa2V5KSkgPT09IGtleSB8fCAhaGFzT3duKHJhd1Byb3BzLCBrZWJhYktleSkpKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmF3UHJldlByb3BzICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciBjYW1lbENhc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHJhd1ByZXZQcm9wc1trZXldICE9PSB1bmRlZmluZWQgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciBrZWJhYi1jYXNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXdQcmV2UHJvcHNba2ViYWJLZXldICE9PSB1bmRlZmluZWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzW2tleV0gPSByZXNvbHZlUHJvcFZhbHVlKG9wdGlvbnMsIHJhd0N1cnJlbnRQcm9wcywga2V5LCB1bmRlZmluZWQsIGluc3RhbmNlLCB0cnVlIC8qIGlzQWJzZW50ICovKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcHJvcHNba2V5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpbiB0aGUgY2FzZSBvZiBmdW5jdGlvbmFsIGNvbXBvbmVudCB3L28gcHJvcHMgZGVjbGFyYXRpb24sIHByb3BzIGFuZFxyXG4gICAgICAgIC8vIGF0dHJzIHBvaW50IHRvIHRoZSBzYW1lIG9iamVjdCBzbyBpdCBzaG91bGQgYWxyZWFkeSBoYXZlIGJlZW4gdXBkYXRlZC5cclxuICAgICAgICBpZiAoYXR0cnMgIT09IHJhd0N1cnJlbnRQcm9wcykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFyYXdQcm9wcyB8fCAhaGFzT3duKHJhd1Byb3BzLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGF0dHJzW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHRyaWdnZXIgdXBkYXRlcyBmb3IgJGF0dHJzIGluIGNhc2UgaXQncyB1c2VkIGluIGNvbXBvbmVudCBzbG90c1xyXG4gICAgaWYgKGhhc0F0dHJzQ2hhbmdlZCkge1xyXG4gICAgICAgIHRyaWdnZXIoaW5zdGFuY2UsIFwic2V0XCIgLyogU0VUICovLCAnJGF0dHJzJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgdmFsaWRhdGVQcm9wcyhyYXdQcm9wcyB8fCB7fSwgcHJvcHMsIGluc3RhbmNlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzZXRGdWxsUHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCBwcm9wcywgYXR0cnMpIHtcclxuICAgIGNvbnN0IFtvcHRpb25zLCBuZWVkQ2FzdEtleXNdID0gaW5zdGFuY2UucHJvcHNPcHRpb25zO1xyXG4gICAgbGV0IGhhc0F0dHJzQ2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgbGV0IHJhd0Nhc3RWYWx1ZXM7XHJcbiAgICBpZiAocmF3UHJvcHMpIHtcclxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gcmF3UHJvcHMpIHtcclxuICAgICAgICAgICAgLy8ga2V5LCByZWYgYXJlIHJlc2VydmVkIGFuZCBuZXZlciBwYXNzZWQgZG93blxyXG4gICAgICAgICAgICBpZiAoaXNSZXNlcnZlZFByb3Aoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByYXdQcm9wc1trZXldO1xyXG4gICAgICAgICAgICAvLyBwcm9wIG9wdGlvbiBuYW1lcyBhcmUgY2FtZWxpemVkIGR1cmluZyBub3JtYWxpemF0aW9uLCBzbyB0byBzdXBwb3J0XHJcbiAgICAgICAgICAgIC8vIGtlYmFiIC0+IGNhbWVsIGNvbnZlcnNpb24gaGVyZSB3ZSBuZWVkIHRvIGNhbWVsaXplIHRoZSBrZXkuXHJcbiAgICAgICAgICAgIGxldCBjYW1lbEtleTtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgaGFzT3duKG9wdGlvbnMsIChjYW1lbEtleSA9IGNhbWVsaXplKGtleSkpKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFuZWVkQ2FzdEtleXMgfHwgIW5lZWRDYXN0S2V5cy5pbmNsdWRlcyhjYW1lbEtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wc1tjYW1lbEtleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIChyYXdDYXN0VmFsdWVzIHx8IChyYXdDYXN0VmFsdWVzID0ge30pKVtjYW1lbEtleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghaXNFbWl0TGlzdGVuZXIoaW5zdGFuY2UuZW1pdHNPcHRpb25zLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IGF0dHJzW2tleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBhdHRyc1trZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChuZWVkQ2FzdEtleXMpIHtcclxuICAgICAgICBjb25zdCByYXdDdXJyZW50UHJvcHMgPSB0b1Jhdyhwcm9wcyk7XHJcbiAgICAgICAgY29uc3QgY2FzdFZhbHVlcyA9IHJhd0Nhc3RWYWx1ZXMgfHwgRU1QVFlfT0JKO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmVlZENhc3RLZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IG5lZWRDYXN0S2V5c1tpXTtcclxuICAgICAgICAgICAgcHJvcHNba2V5XSA9IHJlc29sdmVQcm9wVmFsdWUob3B0aW9ucywgcmF3Q3VycmVudFByb3BzLCBrZXksIGNhc3RWYWx1ZXNba2V5XSwgaW5zdGFuY2UsICFoYXNPd24oY2FzdFZhbHVlcywga2V5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGhhc0F0dHJzQ2hhbmdlZDtcclxufVxyXG5mdW5jdGlvbiByZXNvbHZlUHJvcFZhbHVlKG9wdGlvbnMsIHByb3BzLCBrZXksIHZhbHVlLCBpbnN0YW5jZSwgaXNBYnNlbnQpIHtcclxuICAgIGNvbnN0IG9wdCA9IG9wdGlvbnNba2V5XTtcclxuICAgIGlmIChvcHQgIT0gbnVsbCkge1xyXG4gICAgICAgIGNvbnN0IGhhc0RlZmF1bHQgPSBoYXNPd24ob3B0LCAnZGVmYXVsdCcpO1xyXG4gICAgICAgIC8vIGRlZmF1bHQgdmFsdWVzXHJcbiAgICAgICAgaWYgKGhhc0RlZmF1bHQgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBvcHQuZGVmYXVsdDtcclxuICAgICAgICAgICAgaWYgKG9wdC50eXBlICE9PSBGdW5jdGlvbiAmJiBpc0Z1bmN0aW9uKGRlZmF1bHRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcHJvcHNEZWZhdWx0cyB9ID0gaW5zdGFuY2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5IGluIHByb3BzRGVmYXVsdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHByb3BzRGVmYXVsdHNba2V5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZShpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwcm9wc0RlZmF1bHRzW2tleV0gPSBkZWZhdWx0VmFsdWUuY2FsbChudWxsLCBwcm9wcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYm9vbGVhbiBjYXN0aW5nXHJcbiAgICAgICAgaWYgKG9wdFswIC8qIHNob3VsZENhc3QgKi9dKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0Fic2VudCAmJiAhaGFzRGVmYXVsdCkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcHRbMSAvKiBzaG91bGRDYXN0VHJ1ZSAqL10gJiZcclxuICAgICAgICAgICAgICAgICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzT3B0aW9ucyhjb21wLCBhcHBDb250ZXh0LCBhc01peGluID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IGNhY2hlID0gYXBwQ29udGV4dC5wcm9wc0NhY2hlO1xyXG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGNvbXApO1xyXG4gICAgaWYgKGNhY2hlZCkge1xyXG4gICAgICAgIHJldHVybiBjYWNoZWQ7XHJcbiAgICB9XHJcbiAgICBjb25zdCByYXcgPSBjb21wLnByb3BzO1xyXG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IHt9O1xyXG4gICAgY29uc3QgbmVlZENhc3RLZXlzID0gW107XHJcbiAgICAvLyBhcHBseSBtaXhpbi9leHRlbmRzIHByb3BzXHJcbiAgICBsZXQgaGFzRXh0ZW5kcyA9IGZhbHNlO1xyXG4gICAgaWYgKF9fVlVFX09QVElPTlNfQVBJX18gJiYgIWlzRnVuY3Rpb24oY29tcCkpIHtcclxuICAgICAgICBjb25zdCBleHRlbmRQcm9wcyA9IChyYXcpID0+IHtcclxuICAgICAgICAgICAgaGFzRXh0ZW5kcyA9IHRydWU7XHJcbiAgICAgICAgICAgIGNvbnN0IFtwcm9wcywga2V5c10gPSBub3JtYWxpemVQcm9wc09wdGlvbnMocmF3LCBhcHBDb250ZXh0LCB0cnVlKTtcclxuICAgICAgICAgICAgZXh0ZW5kKG5vcm1hbGl6ZWQsIHByb3BzKTtcclxuICAgICAgICAgICAgaWYgKGtleXMpXHJcbiAgICAgICAgICAgICAgICBuZWVkQ2FzdEtleXMucHVzaCguLi5rZXlzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICghYXNNaXhpbiAmJiBhcHBDb250ZXh0Lm1peGlucy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgYXBwQ29udGV4dC5taXhpbnMuZm9yRWFjaChleHRlbmRQcm9wcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb21wLmV4dGVuZHMpIHtcclxuICAgICAgICAgICAgZXh0ZW5kUHJvcHMoY29tcC5leHRlbmRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbXAubWl4aW5zKSB7XHJcbiAgICAgICAgICAgIGNvbXAubWl4aW5zLmZvckVhY2goZXh0ZW5kUHJvcHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghcmF3ICYmICFoYXNFeHRlbmRzKSB7XHJcbiAgICAgICAgY2FjaGUuc2V0KGNvbXAsIEVNUFRZX0FSUik7XHJcbiAgICAgICAgcmV0dXJuIEVNUFRZX0FSUjtcclxuICAgIH1cclxuICAgIGlmIChpc0FycmF5KHJhdykpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhdy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc1N0cmluZyhyYXdbaV0pKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBwcm9wcyBtdXN0IGJlIHN0cmluZ3Mgd2hlbiB1c2luZyBhcnJheSBzeW50YXguYCwgcmF3W2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkS2V5ID0gY2FtZWxpemUocmF3W2ldKTtcclxuICAgICAgICAgICAgaWYgKHZhbGlkYXRlUHJvcE5hbWUobm9ybWFsaXplZEtleSkpIHtcclxuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRbbm9ybWFsaXplZEtleV0gPSBFTVBUWV9PQko7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChyYXcpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc09iamVjdChyYXcpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYGludmFsaWQgcHJvcHMgb3B0aW9uc2AsIHJhdyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJhdykge1xyXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkS2V5ID0gY2FtZWxpemUoa2V5KTtcclxuICAgICAgICAgICAgaWYgKHZhbGlkYXRlUHJvcE5hbWUobm9ybWFsaXplZEtleSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9wdCA9IHJhd1trZXldO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcCA9IChub3JtYWxpemVkW25vcm1hbGl6ZWRLZXldID1cclxuICAgICAgICAgICAgICAgICAgICBpc0FycmF5KG9wdCkgfHwgaXNGdW5jdGlvbihvcHQpID8geyB0eXBlOiBvcHQgfSA6IG9wdCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvb2xlYW5JbmRleCA9IGdldFR5cGVJbmRleChCb29sZWFuLCBwcm9wLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0cmluZ0luZGV4ID0gZ2V0VHlwZUluZGV4KFN0cmluZywgcHJvcC50eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wWzAgLyogc2hvdWxkQ2FzdCAqL10gPSBib29sZWFuSW5kZXggPiAtMTtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wWzEgLyogc2hvdWxkQ2FzdFRydWUgKi9dID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nSW5kZXggPCAwIHx8IGJvb2xlYW5JbmRleCA8IHN0cmluZ0luZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBwcm9wIG5lZWRzIGJvb2xlYW4gY2FzdGluZyBvciBkZWZhdWx0IHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvb2xlYW5JbmRleCA+IC0xIHx8IGhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lZWRDYXN0S2V5cy5wdXNoKG5vcm1hbGl6ZWRLZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IHJlcyA9IFtub3JtYWxpemVkLCBuZWVkQ2FzdEtleXNdO1xyXG4gICAgY2FjaGUuc2V0KGNvbXAsIHJlcyk7XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcE5hbWUoa2V5KSB7XHJcbiAgICBpZiAoa2V5WzBdICE9PSAnJCcpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHdhcm4oYEludmFsaWQgcHJvcCBuYW1lOiBcIiR7a2V5fVwiIGlzIGEgcmVzZXJ2ZWQgcHJvcGVydHkuYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuLy8gdXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIHR5cGUgY29uc3RydWN0b3JzXHJcbi8vIHNvIHRoYXQgaXQgd29ya3MgYWNyb3NzIHZtcyAvIGlmcmFtZXMuXHJcbmZ1bmN0aW9uIGdldFR5cGUoY3Rvcikge1xyXG4gICAgY29uc3QgbWF0Y2ggPSBjdG9yICYmIGN0b3IudG9TdHJpbmcoKS5tYXRjaCgvXlxccypmdW5jdGlvbiAoXFx3KykvKTtcclxuICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogJyc7XHJcbn1cclxuZnVuY3Rpb24gaXNTYW1lVHlwZShhLCBiKSB7XHJcbiAgICByZXR1cm4gZ2V0VHlwZShhKSA9PT0gZ2V0VHlwZShiKTtcclxufVxyXG5mdW5jdGlvbiBnZXRUeXBlSW5kZXgodHlwZSwgZXhwZWN0ZWRUeXBlcykge1xyXG4gICAgaWYgKGlzQXJyYXkoZXhwZWN0ZWRUeXBlcykpIHtcclxuICAgICAgICByZXR1cm4gZXhwZWN0ZWRUeXBlcy5maW5kSW5kZXgodCA9PiBpc1NhbWVUeXBlKHQsIHR5cGUpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oZXhwZWN0ZWRUeXBlcykpIHtcclxuICAgICAgICByZXR1cm4gaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzLCB0eXBlKSA/IDAgOiAtMTtcclxuICAgIH1cclxuICAgIHJldHVybiAtMTtcclxufVxyXG4vKipcclxuICogZGV2IG9ubHlcclxuICovXHJcbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcHMocmF3UHJvcHMsIHByb3BzLCBpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgcmVzb2x2ZWRWYWx1ZXMgPSB0b1Jhdyhwcm9wcyk7XHJcbiAgICBjb25zdCBvcHRpb25zID0gaW5zdGFuY2UucHJvcHNPcHRpb25zWzBdO1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucykge1xyXG4gICAgICAgIGxldCBvcHQgPSBvcHRpb25zW2tleV07XHJcbiAgICAgICAgaWYgKG9wdCA9PSBudWxsKVxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB2YWxpZGF0ZVByb3Aoa2V5LCByZXNvbHZlZFZhbHVlc1trZXldLCBvcHQsICFoYXNPd24ocmF3UHJvcHMsIGtleSkgJiYgIWhhc093bihyYXdQcm9wcywgaHlwaGVuYXRlKGtleSkpKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogZGV2IG9ubHlcclxuICovXHJcbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcChuYW1lLCB2YWx1ZSwgcHJvcCwgaXNBYnNlbnQpIHtcclxuICAgIGNvbnN0IHsgdHlwZSwgcmVxdWlyZWQsIHZhbGlkYXRvciB9ID0gcHJvcDtcclxuICAgIC8vIHJlcXVpcmVkIVxyXG4gICAgaWYgKHJlcXVpcmVkICYmIGlzQWJzZW50KSB7XHJcbiAgICAgICAgd2FybignTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcIicgKyBuYW1lICsgJ1wiJyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gbWlzc2luZyBidXQgb3B0aW9uYWxcclxuICAgIGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gdHlwZSBjaGVja1xyXG4gICAgaWYgKHR5cGUgIT0gbnVsbCAmJiB0eXBlICE9PSB0cnVlKSB7XHJcbiAgICAgICAgbGV0IGlzVmFsaWQgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCB0eXBlcyA9IGlzQXJyYXkodHlwZSkgPyB0eXBlIDogW3R5cGVdO1xyXG4gICAgICAgIGNvbnN0IGV4cGVjdGVkVHlwZXMgPSBbXTtcclxuICAgICAgICAvLyB2YWx1ZSBpcyB2YWxpZCBhcyBsb25nIGFzIG9uZSBvZiB0aGUgc3BlY2lmaWVkIHR5cGVzIG1hdGNoXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGggJiYgIWlzVmFsaWQ7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCB7IHZhbGlkLCBleHBlY3RlZFR5cGUgfSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVzW2ldKTtcclxuICAgICAgICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGV4cGVjdGVkVHlwZSB8fCAnJyk7XHJcbiAgICAgICAgICAgIGlzVmFsaWQgPSB2YWxpZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XHJcbiAgICAgICAgICAgIHdhcm4oZ2V0SW52YWxpZFR5cGVNZXNzYWdlKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBjdXN0b20gdmFsaWRhdG9yXHJcbiAgICBpZiAodmFsaWRhdG9yICYmICF2YWxpZGF0b3IodmFsdWUpKSB7XHJcbiAgICAgICAgd2FybignSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicpO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGlzU2ltcGxlVHlwZSA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcCgnU3RyaW5nLE51bWJlcixCb29sZWFuLEZ1bmN0aW9uLFN5bWJvbCxCaWdJbnQnKTtcclxuLyoqXHJcbiAqIGRldiBvbmx5XHJcbiAqL1xyXG5mdW5jdGlvbiBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlKSB7XHJcbiAgICBsZXQgdmFsaWQ7XHJcbiAgICBjb25zdCBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xyXG4gICAgaWYgKGlzU2ltcGxlVHlwZShleHBlY3RlZFR5cGUpKSB7XHJcbiAgICAgICAgY29uc3QgdCA9IHR5cGVvZiB2YWx1ZTtcclxuICAgICAgICB2YWxpZCA9IHQgPT09IGV4cGVjdGVkVHlwZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIC8vIGZvciBwcmltaXRpdmUgd3JhcHBlciBvYmplY3RzXHJcbiAgICAgICAgaWYgKCF2YWxpZCAmJiB0ID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdPYmplY3QnKSB7XHJcbiAgICAgICAgdmFsaWQgPSBpc09iamVjdCh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdBcnJheScpIHtcclxuICAgICAgICB2YWxpZCA9IGlzQXJyYXkodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHZhbGlkLFxyXG4gICAgICAgIGV4cGVjdGVkVHlwZVxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogZGV2IG9ubHlcclxuICovXHJcbmZ1bmN0aW9uIGdldEludmFsaWRUeXBlTWVzc2FnZShuYW1lLCB2YWx1ZSwgZXhwZWN0ZWRUeXBlcykge1xyXG4gICAgbGV0IG1lc3NhZ2UgPSBgSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIiR7bmFtZX1cIi5gICtcclxuICAgICAgICBgIEV4cGVjdGVkICR7ZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbignLCAnKX1gO1xyXG4gICAgY29uc3QgZXhwZWN0ZWRUeXBlID0gZXhwZWN0ZWRUeXBlc1swXTtcclxuICAgIGNvbnN0IHJlY2VpdmVkVHlwZSA9IHRvUmF3VHlwZSh2YWx1ZSk7XHJcbiAgICBjb25zdCBleHBlY3RlZFZhbHVlID0gc3R5bGVWYWx1ZSh2YWx1ZSwgZXhwZWN0ZWRUeXBlKTtcclxuICAgIGNvbnN0IHJlY2VpdmVkVmFsdWUgPSBzdHlsZVZhbHVlKHZhbHVlLCByZWNlaXZlZFR5cGUpO1xyXG4gICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBzcGVjaWZ5IGV4cGVjdGVkIHZhbHVlXHJcbiAgICBpZiAoZXhwZWN0ZWRUeXBlcy5sZW5ndGggPT09IDEgJiZcclxuICAgICAgICBpc0V4cGxpY2FibGUoZXhwZWN0ZWRUeXBlKSAmJlxyXG4gICAgICAgICFpc0Jvb2xlYW4oZXhwZWN0ZWRUeXBlLCByZWNlaXZlZFR5cGUpKSB7XHJcbiAgICAgICAgbWVzc2FnZSArPSBgIHdpdGggdmFsdWUgJHtleHBlY3RlZFZhbHVlfWA7XHJcbiAgICB9XHJcbiAgICBtZXNzYWdlICs9IGAsIGdvdCAke3JlY2VpdmVkVHlwZX0gYDtcclxuICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gc3BlY2lmeSByZWNlaXZlZCB2YWx1ZVxyXG4gICAgaWYgKGlzRXhwbGljYWJsZShyZWNlaXZlZFR5cGUpKSB7XHJcbiAgICAgICAgbWVzc2FnZSArPSBgd2l0aCB2YWx1ZSAke3JlY2VpdmVkVmFsdWV9LmA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWVzc2FnZTtcclxufVxyXG4vKipcclxuICogZGV2IG9ubHlcclxuICovXHJcbmZ1bmN0aW9uIHN0eWxlVmFsdWUodmFsdWUsIHR5cGUpIHtcclxuICAgIGlmICh0eXBlID09PSAnU3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiBgXCIke3ZhbHVlfVwiYDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGUgPT09ICdOdW1iZXInKSB7XHJcbiAgICAgICAgcmV0dXJuIGAke051bWJlcih2YWx1ZSl9YDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBgJHt2YWx1ZX1gO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBkZXYgb25seVxyXG4gKi9cclxuZnVuY3Rpb24gaXNFeHBsaWNhYmxlKHR5cGUpIHtcclxuICAgIGNvbnN0IGV4cGxpY2l0VHlwZXMgPSBbJ3N0cmluZycsICdudW1iZXInLCAnYm9vbGVhbiddO1xyXG4gICAgcmV0dXJuIGV4cGxpY2l0VHlwZXMuc29tZShlbGVtID0+IHR5cGUudG9Mb3dlckNhc2UoKSA9PT0gZWxlbSk7XHJcbn1cclxuLyoqXHJcbiAqIGRldiBvbmx5XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0Jvb2xlYW4oLi4uYXJncykge1xyXG4gICAgcmV0dXJuIGFyZ3Muc29tZShlbGVtID0+IGVsZW0udG9Mb3dlckNhc2UoKSA9PT0gJ2Jvb2xlYW4nKTtcclxufVxuXG5jb25zdCBpc0ludGVybmFsS2V5ID0gKGtleSkgPT4ga2V5WzBdID09PSAnXycgfHwga2V5ID09PSAnJHN0YWJsZSc7XHJcbmNvbnN0IG5vcm1hbGl6ZVNsb3RWYWx1ZSA9ICh2YWx1ZSkgPT4gaXNBcnJheSh2YWx1ZSlcclxuICAgID8gdmFsdWUubWFwKG5vcm1hbGl6ZVZOb2RlKVxyXG4gICAgOiBbbm9ybWFsaXplVk5vZGUodmFsdWUpXTtcclxuY29uc3Qgbm9ybWFsaXplU2xvdCA9IChrZXksIHJhd1Nsb3QsIGN0eCkgPT4ge1xyXG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IHdpdGhDdHgoKHByb3BzKSA9PiB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjdXJyZW50SW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgd2FybihgU2xvdCBcIiR7a2V5fVwiIGludm9rZWQgb3V0c2lkZSBvZiB0aGUgcmVuZGVyIGZ1bmN0aW9uOiBgICtcclxuICAgICAgICAgICAgICAgIGB0aGlzIHdpbGwgbm90IHRyYWNrIGRlcGVuZGVuY2llcyB1c2VkIGluIHRoZSBzbG90LiBgICtcclxuICAgICAgICAgICAgICAgIGBJbnZva2UgdGhlIHNsb3QgZnVuY3Rpb24gaW5zaWRlIHRoZSByZW5kZXIgZnVuY3Rpb24gaW5zdGVhZC5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVNsb3RWYWx1ZShyYXdTbG90KHByb3BzKSk7XHJcbiAgICB9LCBjdHgpO1xyXG4gICAgbm9ybWFsaXplZC5fYyA9IGZhbHNlO1xyXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XHJcbn07XHJcbmNvbnN0IG5vcm1hbGl6ZU9iamVjdFNsb3RzID0gKHJhd1Nsb3RzLCBzbG90cywgaW5zdGFuY2UpID0+IHtcclxuICAgIGNvbnN0IGN0eCA9IHJhd1Nsb3RzLl9jdHg7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiByYXdTbG90cykge1xyXG4gICAgICAgIGlmIChpc0ludGVybmFsS2V5KGtleSkpXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gcmF3U2xvdHNba2V5XTtcclxuICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgc2xvdHNba2V5XSA9IG5vcm1hbGl6ZVNsb3Qoa2V5LCB2YWx1ZSwgY3R4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICAhKGZhbHNlICkpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYE5vbi1mdW5jdGlvbiB2YWx1ZSBlbmNvdW50ZXJlZCBmb3Igc2xvdCBcIiR7a2V5fVwiLiBgICtcclxuICAgICAgICAgICAgICAgICAgICBgUHJlZmVyIGZ1bmN0aW9uIHNsb3RzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVNsb3RWYWx1ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIHNsb3RzW2tleV0gPSAoKSA9PiBub3JtYWxpemVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuY29uc3Qgbm9ybWFsaXplVk5vZGVTbG90cyA9IChpbnN0YW5jZSwgY2hpbGRyZW4pID0+IHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAhaXNLZWVwQWxpdmUoaW5zdGFuY2Uudm5vZGUpICYmXHJcbiAgICAgICAgIShmYWxzZSApKSB7XHJcbiAgICAgICAgd2FybihgTm9uLWZ1bmN0aW9uIHZhbHVlIGVuY291bnRlcmVkIGZvciBkZWZhdWx0IHNsb3QuIGAgK1xyXG4gICAgICAgICAgICBgUHJlZmVyIGZ1bmN0aW9uIHNsb3RzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuYCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplU2xvdFZhbHVlKGNoaWxkcmVuKTtcclxuICAgIGluc3RhbmNlLnNsb3RzLmRlZmF1bHQgPSAoKSA9PiBub3JtYWxpemVkO1xyXG59O1xyXG5jb25zdCBpbml0U2xvdHMgPSAoaW5zdGFuY2UsIGNoaWxkcmVuKSA9PiB7XHJcbiAgICBpZiAoaW5zdGFuY2Uudm5vZGUuc2hhcGVGbGFnICYgMzIgLyogU0xPVFNfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICBjb25zdCB0eXBlID0gY2hpbGRyZW4uXztcclxuICAgICAgICBpZiAodHlwZSkge1xyXG4gICAgICAgICAgICAvLyB1c2VycyBjYW4gZ2V0IHRoZSBzaGFsbG93IHJlYWRvbmx5IHZlcnNpb24gb2YgdGhlIHNsb3RzIG9iamVjdCB0aHJvdWdoIGB0aGlzLiRzbG90c2AsXHJcbiAgICAgICAgICAgIC8vIHdlIHNob3VsZCBhdm9pZCB0aGUgcHJveHkgb2JqZWN0IHBvbGx1dGluZyB0aGUgc2xvdHMgb2YgdGhlIGludGVybmFsIGluc3RhbmNlXHJcbiAgICAgICAgICAgIGluc3RhbmNlLnNsb3RzID0gdG9SYXcoY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAvLyBtYWtlIGNvbXBpbGVyIG1hcmtlciBub24tZW51bWVyYWJsZVxyXG4gICAgICAgICAgICBkZWYoY2hpbGRyZW4sICdfJywgdHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBub3JtYWxpemVPYmplY3RTbG90cyhjaGlsZHJlbiwgKGluc3RhbmNlLnNsb3RzID0ge30pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpbnN0YW5jZS5zbG90cyA9IHt9O1xyXG4gICAgICAgIGlmIChjaGlsZHJlbikge1xyXG4gICAgICAgICAgICBub3JtYWxpemVWTm9kZVNsb3RzKGluc3RhbmNlLCBjaGlsZHJlbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGVmKGluc3RhbmNlLnNsb3RzLCBJbnRlcm5hbE9iamVjdEtleSwgMSk7XHJcbn07XHJcbmNvbnN0IHVwZGF0ZVNsb3RzID0gKGluc3RhbmNlLCBjaGlsZHJlbiwgb3B0aW1pemVkKSA9PiB7XHJcbiAgICBjb25zdCB7IHZub2RlLCBzbG90cyB9ID0gaW5zdGFuY2U7XHJcbiAgICBsZXQgbmVlZERlbGV0aW9uQ2hlY2sgPSB0cnVlO1xyXG4gICAgbGV0IGRlbGV0aW9uQ29tcGFyaXNvblRhcmdldCA9IEVNUFRZX09CSjtcclxuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAzMiAvKiBTTE9UU19DSElMRFJFTiAqLykge1xyXG4gICAgICAgIGNvbnN0IHR5cGUgPSBjaGlsZHJlbi5fO1xyXG4gICAgICAgIGlmICh0eXBlKSB7XHJcbiAgICAgICAgICAgIC8vIGNvbXBpbGVkIHNsb3RzLlxyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGlzSG1yVXBkYXRpbmcpIHtcclxuICAgICAgICAgICAgICAgIC8vIFBhcmVudCB3YXMgSE1SIHVwZGF0ZWQgc28gc2xvdCBjb250ZW50IG1heSBoYXZlIGNoYW5nZWQuXHJcbiAgICAgICAgICAgICAgICAvLyBmb3JjZSB1cGRhdGUgc2xvdHMgYW5kIG1hcmsgaW5zdGFuY2UgZm9yIGhtciBhcyB3ZWxsXHJcbiAgICAgICAgICAgICAgICBleHRlbmQoc2xvdHMsIGNoaWxkcmVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpbWl6ZWQgJiYgdHlwZSA9PT0gMSAvKiBTVEFCTEUgKi8pIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbXBpbGVkIEFORCBzdGFibGUuXHJcbiAgICAgICAgICAgICAgICAvLyBubyBuZWVkIHRvIHVwZGF0ZSwgYW5kIHNraXAgc3RhbGUgc2xvdHMgcmVtb3ZhbC5cclxuICAgICAgICAgICAgICAgIG5lZWREZWxldGlvbkNoZWNrID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb21waWxlZCBidXQgZHluYW1pYyAodi1pZi92LWZvciBvbiBzbG90cykgLSB1cGRhdGUgc2xvdHMsIGJ1dCBza2lwXHJcbiAgICAgICAgICAgICAgICAvLyBub3JtYWxpemF0aW9uLlxyXG4gICAgICAgICAgICAgICAgZXh0ZW5kKHNsb3RzLCBjaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICAvLyAjMjg5M1xyXG4gICAgICAgICAgICAgICAgLy8gd2hlbiByZW5kZXJpbmcgdGhlIG9wdGltaXplZCBzbG90cyBieSBtYW51YWxseSB3cml0dGVuIHJlbmRlciBmdW5jdGlvbixcclxuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gZGVsZXRlIHRoZSBgc2xvdHMuX2AgZmxhZyBpZiBuZWNlc3NhcnkgdG8gbWFrZSBzdWJzZXF1ZW50IHVwZGF0ZXMgcmVsaWFibGUsXHJcbiAgICAgICAgICAgICAgICAvLyBpLmUuIGxldCB0aGUgYHJlbmRlclNsb3RgIGNyZWF0ZSB0aGUgYmFpbGVkIEZyYWdtZW50XHJcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGltaXplZCAmJiB0eXBlID09PSAxIC8qIFNUQUJMRSAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzbG90cy5fO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBuZWVkRGVsZXRpb25DaGVjayA9ICFjaGlsZHJlbi4kc3RhYmxlO1xyXG4gICAgICAgICAgICBub3JtYWxpemVPYmplY3RTbG90cyhjaGlsZHJlbiwgc2xvdHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQgPSBjaGlsZHJlbjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGNoaWxkcmVuKSB7XHJcbiAgICAgICAgLy8gbm9uIHNsb3Qgb2JqZWN0IGNoaWxkcmVuIChkaXJlY3QgdmFsdWUpIHBhc3NlZCB0byBhIGNvbXBvbmVudFxyXG4gICAgICAgIG5vcm1hbGl6ZVZOb2RlU2xvdHMoaW5zdGFuY2UsIGNoaWxkcmVuKTtcclxuICAgICAgICBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQgPSB7IGRlZmF1bHQ6IDEgfTtcclxuICAgIH1cclxuICAgIC8vIGRlbGV0ZSBzdGFsZSBzbG90c1xyXG4gICAgaWYgKG5lZWREZWxldGlvbkNoZWNrKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2xvdHMpIHtcclxuICAgICAgICAgICAgaWYgKCFpc0ludGVybmFsS2V5KGtleSkgJiYgIShrZXkgaW4gZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHNsb3RzW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XG5cbi8qKlxyXG5SdW50aW1lIGhlbHBlciBmb3IgYXBwbHlpbmcgZGlyZWN0aXZlcyB0byBhIHZub2RlLiBFeGFtcGxlIHVzYWdlOlxyXG5cbmNvbnN0IGNvbXAgPSByZXNvbHZlQ29tcG9uZW50KCdjb21wJylcclxuY29uc3QgZm9vID0gcmVzb2x2ZURpcmVjdGl2ZSgnZm9vJylcclxuY29uc3QgYmFyID0gcmVzb2x2ZURpcmVjdGl2ZSgnYmFyJylcclxuXG5yZXR1cm4gd2l0aERpcmVjdGl2ZXMoaChjb21wKSwgW1xyXG4gIFtmb28sIHRoaXMueF0sXHJcbiAgW2JhciwgdGhpcy55XVxyXG5dKVxyXG4qL1xyXG5jb25zdCBpc0J1aWx0SW5EaXJlY3RpdmUgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoJ2JpbmQsY2xvYWssZWxzZS1pZixlbHNlLGZvcixodG1sLGlmLG1vZGVsLG9uLG9uY2UscHJlLHNob3csc2xvdCx0ZXh0Jyk7XHJcbmZ1bmN0aW9uIHZhbGlkYXRlRGlyZWN0aXZlTmFtZShuYW1lKSB7XHJcbiAgICBpZiAoaXNCdWlsdEluRGlyZWN0aXZlKG5hbWUpKSB7XHJcbiAgICAgICAgd2FybignRG8gbm90IHVzZSBidWlsdC1pbiBkaXJlY3RpdmUgaWRzIGFzIGN1c3RvbSBkaXJlY3RpdmUgaWQ6ICcgKyBuYW1lKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQWRkcyBkaXJlY3RpdmVzIHRvIGEgVk5vZGUuXHJcbiAqL1xyXG5mdW5jdGlvbiB3aXRoRGlyZWN0aXZlcyh2bm9kZSwgZGlyZWN0aXZlcykge1xyXG4gICAgY29uc3QgaW50ZXJuYWxJbnN0YW5jZSA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcclxuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlID09PSBudWxsKSB7XHJcbiAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm4oYHdpdGhEaXJlY3RpdmVzIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHJlbmRlciBmdW5jdGlvbnMuYCk7XHJcbiAgICAgICAgcmV0dXJuIHZub2RlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaW5zdGFuY2UgPSBpbnRlcm5hbEluc3RhbmNlLnByb3h5O1xyXG4gICAgY29uc3QgYmluZGluZ3MgPSB2bm9kZS5kaXJzIHx8ICh2bm9kZS5kaXJzID0gW10pO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaXJlY3RpdmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IFtkaXIsIHZhbHVlLCBhcmcsIG1vZGlmaWVycyA9IEVNUFRZX09CSl0gPSBkaXJlY3RpdmVzW2ldO1xyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGRpcikpIHtcclxuICAgICAgICAgICAgZGlyID0ge1xyXG4gICAgICAgICAgICAgICAgbW91bnRlZDogZGlyLFxyXG4gICAgICAgICAgICAgICAgdXBkYXRlZDogZGlyXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJpbmRpbmdzLnB1c2goe1xyXG4gICAgICAgICAgICBkaXIsXHJcbiAgICAgICAgICAgIGluc3RhbmNlLFxyXG4gICAgICAgICAgICB2YWx1ZSxcclxuICAgICAgICAgICAgb2xkVmFsdWU6IHZvaWQgMCxcclxuICAgICAgICAgICAgYXJnLFxyXG4gICAgICAgICAgICBtb2RpZmllcnNcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiB2bm9kZTtcclxufVxyXG5mdW5jdGlvbiBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBwcmV2Vk5vZGUsIGluc3RhbmNlLCBuYW1lKSB7XHJcbiAgICBjb25zdCBiaW5kaW5ncyA9IHZub2RlLmRpcnM7XHJcbiAgICBjb25zdCBvbGRCaW5kaW5ncyA9IHByZXZWTm9kZSAmJiBwcmV2Vk5vZGUuZGlycztcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluZGluZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBiaW5kaW5nID0gYmluZGluZ3NbaV07XHJcbiAgICAgICAgaWYgKG9sZEJpbmRpbmdzKSB7XHJcbiAgICAgICAgICAgIGJpbmRpbmcub2xkVmFsdWUgPSBvbGRCaW5kaW5nc1tpXS52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGhvb2sgPSBiaW5kaW5nLmRpcltuYW1lXTtcclxuICAgICAgICBpZiAoaG9vaykge1xyXG4gICAgICAgICAgICAvLyBkaXNhYmxlIHRyYWNraW5nIGluc2lkZSBhbGwgbGlmZWN5Y2xlIGhvb2tzXHJcbiAgICAgICAgICAgIC8vIHNpbmNlIHRoZXkgY2FuIHBvdGVudGlhbGx5IGJlIGNhbGxlZCBpbnNpZGUgZWZmZWN0cy5cclxuICAgICAgICAgICAgcGF1c2VUcmFja2luZygpO1xyXG4gICAgICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCBpbnN0YW5jZSwgOCAvKiBESVJFQ1RJVkVfSE9PSyAqLywgW1xyXG4gICAgICAgICAgICAgICAgdm5vZGUuZWwsXHJcbiAgICAgICAgICAgICAgICBiaW5kaW5nLFxyXG4gICAgICAgICAgICAgICAgdm5vZGUsXHJcbiAgICAgICAgICAgICAgICBwcmV2Vk5vZGVcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgIHJlc2V0VHJhY2tpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXBwQ29udGV4dCgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgYXBwOiBudWxsLFxyXG4gICAgICAgIGNvbmZpZzoge1xyXG4gICAgICAgICAgICBpc05hdGl2ZVRhZzogTk8sXHJcbiAgICAgICAgICAgIHBlcmZvcm1hbmNlOiBmYWxzZSxcclxuICAgICAgICAgICAgZ2xvYmFsUHJvcGVydGllczoge30sXHJcbiAgICAgICAgICAgIG9wdGlvbk1lcmdlU3RyYXRlZ2llczoge30sXHJcbiAgICAgICAgICAgIGVycm9ySGFuZGxlcjogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICB3YXJuSGFuZGxlcjogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBjb21waWxlck9wdGlvbnM6IHt9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtaXhpbnM6IFtdLFxyXG4gICAgICAgIGNvbXBvbmVudHM6IHt9LFxyXG4gICAgICAgIGRpcmVjdGl2ZXM6IHt9LFxyXG4gICAgICAgIHByb3ZpZGVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxyXG4gICAgICAgIG9wdGlvbnNDYWNoZTogbmV3IFdlYWtNYXAoKSxcclxuICAgICAgICBwcm9wc0NhY2hlOiBuZXcgV2Vha01hcCgpLFxyXG4gICAgICAgIGVtaXRzQ2FjaGU6IG5ldyBXZWFrTWFwKClcclxuICAgIH07XHJcbn1cclxubGV0IHVpZCA9IDA7XHJcbmZ1bmN0aW9uIGNyZWF0ZUFwcEFQSShyZW5kZXIsIGh5ZHJhdGUpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVBcHAocm9vdENvbXBvbmVudCwgcm9vdFByb3BzID0gbnVsbCkge1xyXG4gICAgICAgIGlmIChyb290UHJvcHMgIT0gbnVsbCAmJiAhaXNPYmplY3Qocm9vdFByb3BzKSkge1xyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2Fybihgcm9vdCBwcm9wcyBwYXNzZWQgdG8gYXBwLm1vdW50KCkgbXVzdCBiZSBhbiBvYmplY3QuYCk7XHJcbiAgICAgICAgICAgIHJvb3RQcm9wcyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVBcHBDb250ZXh0KCk7XHJcbiAgICAgICAgY29uc3QgaW5zdGFsbGVkUGx1Z2lucyA9IG5ldyBTZXQoKTtcclxuICAgICAgICBsZXQgaXNNb3VudGVkID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgYXBwID0gKGNvbnRleHQuYXBwID0ge1xyXG4gICAgICAgICAgICBfdWlkOiB1aWQrKyxcclxuICAgICAgICAgICAgX2NvbXBvbmVudDogcm9vdENvbXBvbmVudCxcclxuICAgICAgICAgICAgX3Byb3BzOiByb290UHJvcHMsXHJcbiAgICAgICAgICAgIF9jb250YWluZXI6IG51bGwsXHJcbiAgICAgICAgICAgIF9jb250ZXh0OiBjb250ZXh0LFxyXG4gICAgICAgICAgICB2ZXJzaW9uLFxyXG4gICAgICAgICAgICBnZXQgY29uZmlnKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuY29uZmlnO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQgY29uZmlnKHYpIHtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBhcHAuY29uZmlnIGNhbm5vdCBiZSByZXBsYWNlZC4gTW9kaWZ5IGluZGl2aWR1YWwgb3B0aW9ucyBpbnN0ZWFkLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB1c2UocGx1Z2luLCAuLi5vcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFsbGVkUGx1Z2lucy5oYXMocGx1Z2luKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuKGBQbHVnaW4gaGFzIGFscmVhZHkgYmVlbiBhcHBsaWVkIHRvIHRhcmdldCBhcHAuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwbHVnaW4gJiYgaXNGdW5jdGlvbihwbHVnaW4uaW5zdGFsbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnN0YWxsZWRQbHVnaW5zLmFkZChwbHVnaW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbi5pbnN0YWxsKGFwcCwgLi4ub3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHBsdWdpbikpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnN0YWxsZWRQbHVnaW5zLmFkZChwbHVnaW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbihhcHAsIC4uLm9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQSBwbHVnaW4gbXVzdCBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhbiBvYmplY3Qgd2l0aCBhbiBcImluc3RhbGxcIiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYGZ1bmN0aW9uLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbWl4aW4obWl4aW4pIHtcclxuICAgICAgICAgICAgICAgIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250ZXh0Lm1peGlucy5pbmNsdWRlcyhtaXhpbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5taXhpbnMucHVzaChtaXhpbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKCdNaXhpbiBoYXMgYWxyZWFkeSBiZWVuIGFwcGxpZWQgdG8gdGFyZ2V0IGFwcCcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1peGluLm5hbWUgPyBgOiAke21peGluLm5hbWV9YCA6ICcnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybignTWl4aW5zIGFyZSBvbmx5IGF2YWlsYWJsZSBpbiBidWlsZHMgc3VwcG9ydGluZyBPcHRpb25zIEFQSScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY29tcG9uZW50KG5hbWUsIGNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lLCBjb250ZXh0LmNvbmZpZyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmNvbXBvbmVudHNbbmFtZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNvbnRleHQuY29tcG9uZW50c1tuYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYENvbXBvbmVudCBcIiR7bmFtZX1cIiBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQgaW4gdGFyZ2V0IGFwcC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRleHQuY29tcG9uZW50c1tuYW1lXSA9IGNvbXBvbmVudDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhcHA7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRpcmVjdGl2ZShuYW1lLCBkaXJlY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZURpcmVjdGl2ZU5hbWUobmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRpcmVjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmRpcmVjdGl2ZXNbbmFtZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNvbnRleHQuZGlyZWN0aXZlc1tuYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYERpcmVjdGl2ZSBcIiR7bmFtZX1cIiBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQgaW4gdGFyZ2V0IGFwcC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRleHQuZGlyZWN0aXZlc1tuYW1lXSA9IGRpcmVjdGl2ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhcHA7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG1vdW50KHJvb3RDb250YWluZXIsIGlzSHlkcmF0ZSwgaXNTVkcpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNNb3VudGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgdm5vZGUgPSBjcmVhdGVWTm9kZShyb290Q29tcG9uZW50LCByb290UHJvcHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIGFwcCBjb250ZXh0IG9uIHRoZSByb290IFZOb2RlLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBiZSBzZXQgb24gdGhlIHJvb3QgaW5zdGFuY2Ugb24gaW5pdGlhbCBtb3VudC5cclxuICAgICAgICAgICAgICAgICAgICB2bm9kZS5hcHBDb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICAgICAgICAgICAgICAvLyBITVIgcm9vdCByZWxvYWRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucmVsb2FkID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyKGNsb25lVk5vZGUodm5vZGUpLCByb290Q29udGFpbmVyLCBpc1NWRyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0h5ZHJhdGUgJiYgaHlkcmF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoeWRyYXRlKHZub2RlLCByb290Q29udGFpbmVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcih2bm9kZSwgcm9vdENvbnRhaW5lciwgaXNTVkcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpc01vdW50ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGFwcC5fY29udGFpbmVyID0gcm9vdENvbnRhaW5lcjtcclxuICAgICAgICAgICAgICAgICAgICByb290Q29udGFpbmVyLl9fdnVlX2FwcF9fID0gYXBwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldnRvb2xzSW5pdEFwcChhcHAsIHZlcnNpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdm5vZGUuY29tcG9uZW50LnByb3h5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQXBwIGhhcyBhbHJlYWR5IGJlZW4gbW91bnRlZC5cXG5gICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYElmIHlvdSB3YW50IHRvIHJlbW91bnQgdGhlIHNhbWUgYXBwLCBtb3ZlIHlvdXIgYXBwIGNyZWF0aW9uIGxvZ2ljIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgaW50byBhIGZhY3RvcnkgZnVuY3Rpb24gYW5kIGNyZWF0ZSBmcmVzaCBhcHAgaW5zdGFuY2VzIGZvciBlYWNoIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgbW91bnQgLSBlLmcuIFxcYGNvbnN0IGNyZWF0ZU15QXBwID0gKCkgPT4gY3JlYXRlQXBwKEFwcClcXGBgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdW5tb3VudCgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc01vdW50ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXIobnVsbCwgYXBwLl9jb250YWluZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldnRvb2xzVW5tb3VudEFwcChhcHApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXBwLl9jb250YWluZXIuX192dWVfYXBwX187XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBDYW5ub3QgdW5tb3VudCBhbiBhcHAgdGhhdCBpcyBub3QgbW91bnRlZC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcHJvdmlkZShrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGtleSBpbiBjb250ZXh0LnByb3ZpZGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQXBwIGFscmVhZHkgcHJvdmlkZXMgcHJvcGVydHkgd2l0aCBrZXkgXCIke1N0cmluZyhrZXkpfVwiLiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYEl0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gd2l0aCB0aGUgbmV3IHZhbHVlLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gVHlwZVNjcmlwdCBkb2Vzbid0IGFsbG93IHN5bWJvbHMgYXMgaW5kZXggdHlwZVxyXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8yNDU4N1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5wcm92aWRlc1trZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGFwcDtcclxuICAgIH07XHJcbn1cblxubGV0IGhhc01pc21hdGNoID0gZmFsc2U7XHJcbmNvbnN0IGlzU1ZHQ29udGFpbmVyID0gKGNvbnRhaW5lcikgPT4gL3N2Zy8udGVzdChjb250YWluZXIubmFtZXNwYWNlVVJJKSAmJiBjb250YWluZXIudGFnTmFtZSAhPT0gJ2ZvcmVpZ25PYmplY3QnO1xyXG5jb25zdCBpc0NvbW1lbnQgPSAobm9kZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gOCAvKiBDT01NRU5UICovO1xyXG4vLyBOb3RlOiBoeWRyYXRpb24gaXMgRE9NLXNwZWNpZmljXHJcbi8vIEJ1dCB3ZSBoYXZlIHRvIHBsYWNlIGl0IGluIGNvcmUgZHVlIHRvIHRpZ2h0IGNvdXBsaW5nIHdpdGggY29yZSAtIHNwbGl0dGluZ1xyXG4vLyBpdCBvdXQgY3JlYXRlcyBhIHRvbiBvZiB1bm5lY2Vzc2FyeSBjb21wbGV4aXR5LlxyXG4vLyBIeWRyYXRpb24gYWxzbyBkZXBlbmRzIG9uIHNvbWUgcmVuZGVyZXIgaW50ZXJuYWwgbG9naWMgd2hpY2ggbmVlZHMgdG8gYmVcclxuLy8gcGFzc2VkIGluIHZpYSBhcmd1bWVudHMuXHJcbmZ1bmN0aW9uIGNyZWF0ZUh5ZHJhdGlvbkZ1bmN0aW9ucyhyZW5kZXJlckludGVybmFscykge1xyXG4gICAgY29uc3QgeyBtdDogbW91bnRDb21wb25lbnQsIHA6IHBhdGNoLCBvOiB7IHBhdGNoUHJvcCwgbmV4dFNpYmxpbmcsIHBhcmVudE5vZGUsIHJlbW92ZSwgaW5zZXJ0LCBjcmVhdGVDb21tZW50IH0gfSA9IHJlbmRlcmVySW50ZXJuYWxzO1xyXG4gICAgY29uc3QgaHlkcmF0ZSA9ICh2bm9kZSwgY29udGFpbmVyKSA9PiB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhY29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSkge1xyXG4gICAgICAgICAgICB3YXJuKGBBdHRlbXB0aW5nIHRvIGh5ZHJhdGUgZXhpc3RpbmcgbWFya3VwIGJ1dCBjb250YWluZXIgaXMgZW1wdHkuIGAgK1xyXG4gICAgICAgICAgICAgICAgYFBlcmZvcm1pbmcgZnVsbCBtb3VudCBpbnN0ZWFkLmApO1xyXG4gICAgICAgICAgICBwYXRjaChudWxsLCB2bm9kZSwgY29udGFpbmVyKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBoYXNNaXNtYXRjaCA9IGZhbHNlO1xyXG4gICAgICAgIGh5ZHJhdGVOb2RlKGNvbnRhaW5lci5maXJzdENoaWxkLCB2bm9kZSwgbnVsbCwgbnVsbCwgbnVsbCk7XHJcbiAgICAgICAgZmx1c2hQb3N0Rmx1c2hDYnMoKTtcclxuICAgICAgICBpZiAoaGFzTWlzbWF0Y2ggJiYgIWZhbHNlKSB7XHJcbiAgICAgICAgICAgIC8vIHRoaXMgZXJyb3Igc2hvdWxkIHNob3cgdXAgaW4gcHJvZHVjdGlvblxyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBIeWRyYXRpb24gY29tcGxldGVkIGJ1dCBjb250YWlucyBtaXNtYXRjaGVzLmApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBoeWRyYXRlTm9kZSA9IChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQgPSBmYWxzZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGlzRnJhZ21lbnRTdGFydCA9IGlzQ29tbWVudChub2RlKSAmJiBub2RlLmRhdGEgPT09ICdbJztcclxuICAgICAgICBjb25zdCBvbk1pc21hdGNoID0gKCkgPT4gaGFuZGxlTWlzbWF0Y2gobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgaXNGcmFnbWVudFN0YXJ0KTtcclxuICAgICAgICBjb25zdCB7IHR5cGUsIHJlZiwgc2hhcGVGbGFnIH0gPSB2bm9kZTtcclxuICAgICAgICBjb25zdCBkb21UeXBlID0gbm9kZS5ub2RlVHlwZTtcclxuICAgICAgICB2bm9kZS5lbCA9IG5vZGU7XHJcbiAgICAgICAgbGV0IG5leHROb2RlID0gbnVsbDtcclxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBUZXh0OlxyXG4gICAgICAgICAgICAgICAgaWYgKGRvbVR5cGUgIT09IDMgLyogVEVYVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuZGF0YSAhPT0gdm5vZGUuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYEh5ZHJhdGlvbiB0ZXh0IG1pc21hdGNoOmAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcXG4tIENsaWVudDogJHtKU09OLnN0cmluZ2lmeShub2RlLmRhdGEpfWAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcXG4tIFNlcnZlcjogJHtKU09OLnN0cmluZ2lmeSh2bm9kZS5jaGlsZHJlbil9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZGF0YSA9IHZub2RlLmNoaWxkcmVuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWVudCQxOlxyXG4gICAgICAgICAgICAgICAgaWYgKGRvbVR5cGUgIT09IDggLyogQ09NTUVOVCAqLyB8fCBpc0ZyYWdtZW50U3RhcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBTdGF0aWM6XHJcbiAgICAgICAgICAgICAgICBpZiAoZG9tVHlwZSAhPT0gMSAvKiBFTEVNRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBkZXRlcm1pbmUgYW5jaG9yLCBhZG9wdCBjb250ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBzdGF0aWMgdm5vZGUgaGFzIGl0cyBjb250ZW50IHN0cmlwcGVkIGR1cmluZyBidWlsZCxcclxuICAgICAgICAgICAgICAgICAgICAvLyBhZG9wdCBpdCBmcm9tIHRoZSBzZXJ2ZXItcmVuZGVyZWQgSFRNTC5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZWVkVG9BZG9wdENvbnRlbnQgPSAhdm5vZGUuY2hpbGRyZW4ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdm5vZGUuc3RhdGljQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmVlZFRvQWRvcHRDb250ZW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdm5vZGUuY2hpbGRyZW4gKz0gbmV4dE5vZGUub3V0ZXJIVE1MO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gdm5vZGUuc3RhdGljQ291bnQgLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2bm9kZS5hbmNob3IgPSBuZXh0Tm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5leHROb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHROb2RlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgRnJhZ21lbnQ6XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzRnJhZ21lbnRTdGFydCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBoeWRyYXRlRnJhZ21lbnQobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEgLyogRUxFTUVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21UeXBlICE9PSAxIC8qIEVMRU1FTlQgKi8gfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdm5vZGUudHlwZS50b0xvd2VyQ2FzZSgpICE9PVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IGh5ZHJhdGVFbGVtZW50KG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGVGbGFnICYgNiAvKiBDT01QT05FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIHNldHRpbmcgdXAgdGhlIHJlbmRlciBlZmZlY3QsIGlmIHRoZSBpbml0aWFsIHZub2RlIGFscmVhZHlcclxuICAgICAgICAgICAgICAgICAgICAvLyBoYXMgLmVsIHNldCwgdGhlIGNvbXBvbmVudCB3aWxsIHBlcmZvcm0gaHlkcmF0aW9uIGluc3RlYWQgb2YgbW91bnRcclxuICAgICAgICAgICAgICAgICAgICAvLyBvbiBpdHMgc3ViLXRyZWUuXHJcbiAgICAgICAgICAgICAgICAgICAgdm5vZGUuc2xvdFNjb3BlSWRzID0gc2xvdFNjb3BlSWRzO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHBhcmVudE5vZGUobm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbW91bnRDb21wb25lbnQodm5vZGUsIGNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkdDb250YWluZXIoY29udGFpbmVyKSwgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb21wb25lbnQgbWF5IGJlIGFzeW5jLCBzbyBpbiB0aGUgY2FzZSBvZiBmcmFnbWVudHMgd2UgY2Fubm90IHJlbHlcclxuICAgICAgICAgICAgICAgICAgICAvLyBvbiBjb21wb25lbnQncyByZW5kZXJlZCBvdXRwdXQgdG8gZGV0ZXJtaW5lIHRoZSBlbmQgb2YgdGhlIGZyYWdtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5zdGVhZCwgd2UgZG8gYSBsb29rYWhlYWQgdG8gZmluZCB0aGUgZW5kIGFuY2hvciBub2RlLlxyXG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gaXNGcmFnbWVudFN0YXJ0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbG9jYXRlQ2xvc2luZ0FzeW5jQW5jaG9yKG5vZGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbmV4dFNpYmxpbmcobm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gIzM3ODdcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBjb21wb25lbnQgaXMgYXN5bmMsIGl0IG1heSBnZXQgbW92ZWQgLyB1bm1vdW50ZWQgYmVmb3JlIGl0c1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlubmVyIGNvbXBvbmVudCBpcyBsb2FkZWQsIHNvIHdlIG5lZWQgdG8gZ2l2ZSBpdCBhIHBsYWNlaG9sZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdm5vZGUgdGhhdCBtYXRjaGVzIGl0cyBhZG9wdGVkIERPTS5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBc3luY1dyYXBwZXIodm5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdWJUcmVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGcmFnbWVudFN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJUcmVlID0gY3JlYXRlVk5vZGUoRnJhZ21lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViVHJlZS5hbmNob3IgPSBuZXh0Tm9kZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbmV4dE5vZGUucHJldmlvdXNTaWJsaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjb250YWluZXIubGFzdENoaWxkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViVHJlZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5ub2RlVHlwZSA9PT0gMyA/IGNyZWF0ZVRleHRWTm9kZSgnJykgOiBjcmVhdGVWTm9kZSgnZGl2Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ViVHJlZS5lbCA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZub2RlLmNvbXBvbmVudC5zdWJUcmVlID0gc3ViVHJlZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiA2NCAvKiBURUxFUE9SVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21UeXBlICE9PSA4IC8qIENPTU1FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IHZub2RlLnR5cGUuaHlkcmF0ZShub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzLCBoeWRyYXRlQ2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNoYXBlRmxhZyAmIDEyOCAvKiBTVVNQRU5TRSAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gdm5vZGUudHlwZS5oeWRyYXRlKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWR0NvbnRhaW5lcihwYXJlbnROb2RlKG5vZGUpKSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzLCBoeWRyYXRlTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKCdJbnZhbGlkIEhvc3RWTm9kZSB0eXBlOicsIHR5cGUsIGAoJHt0eXBlb2YgdHlwZX0pYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZWYgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzZXRSZWYocmVmLCBudWxsLCBwYXJlbnRTdXNwZW5zZSwgdm5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV4dE5vZGU7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgaHlkcmF0ZUVsZW1lbnQgPSAoZWwsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIG9wdGltaXplZCA9IG9wdGltaXplZCB8fCAhIXZub2RlLmR5bmFtaWNDaGlsZHJlbjtcclxuICAgICAgICBjb25zdCB7IHByb3BzLCBwYXRjaEZsYWcsIHNoYXBlRmxhZywgZGlycyB9ID0gdm5vZGU7XHJcbiAgICAgICAgLy8gc2tpcCBwcm9wcyAmIGNoaWxkcmVuIGlmIHRoaXMgaXMgaG9pc3RlZCBzdGF0aWMgbm9kZXNcclxuICAgICAgICBpZiAocGF0Y2hGbGFnICE9PSAtMSAvKiBIT0lTVEVEICovKSB7XHJcbiAgICAgICAgICAgIGlmIChkaXJzKSB7XHJcbiAgICAgICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICdjcmVhdGVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcHJvcHNcclxuICAgICAgICAgICAgaWYgKHByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGltaXplZCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChwYXRjaEZsYWcgJiAxNiAvKiBGVUxMX1BST1BTICovIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoRmxhZyAmIDMyIC8qIEhZRFJBVEVfRVZFTlRTICovKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNSZXNlcnZlZFByb3Aoa2V5KSAmJiBpc09uKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoUHJvcChlbCwga2V5LCBudWxsLCBwcm9wc1trZXldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb3BzLm9uQ2xpY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBGYXN0IHBhdGggZm9yIGNsaWNrIGxpc3RlbmVycyAod2hpY2ggaXMgbW9zdCBvZnRlbikgdG8gYXZvaWRcclxuICAgICAgICAgICAgICAgICAgICAvLyBpdGVyYXRpbmcgdGhyb3VnaCBwcm9wcy5cclxuICAgICAgICAgICAgICAgICAgICBwYXRjaFByb3AoZWwsICdvbkNsaWNrJywgbnVsbCwgcHJvcHMub25DbGljayk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdm5vZGUgLyBkaXJlY3RpdmUgaG9va3NcclxuICAgICAgICAgICAgbGV0IHZub2RlSG9va3M7XHJcbiAgICAgICAgICAgIGlmICgodm5vZGVIb29rcyA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVCZWZvcmVNb3VudCkpIHtcclxuICAgICAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2tzLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGlycykge1xyXG4gICAgICAgICAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnYmVmb3JlTW91bnQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKHZub2RlSG9va3MgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlTW91bnRlZCkgfHwgZGlycykge1xyXG4gICAgICAgICAgICAgICAgcXVldWVFZmZlY3RXaXRoU3VzcGVuc2UoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHZub2RlSG9va3MgJiYgaW52b2tlVk5vZGVIb29rKHZub2RlSG9va3MsIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpcnMgJiYgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnbW91bnRlZCcpO1xyXG4gICAgICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNoaWxkcmVuXHJcbiAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLyAmJlxyXG4gICAgICAgICAgICAgICAgLy8gc2tpcCBpZiBlbGVtZW50IGhhcyBpbm5lckhUTUwgLyB0ZXh0Q29udGVudFxyXG4gICAgICAgICAgICAgICAgIShwcm9wcyAmJiAocHJvcHMuaW5uZXJIVE1MIHx8IHByb3BzLnRleHRDb250ZW50KSkpIHtcclxuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gaHlkcmF0ZUNoaWxkcmVuKGVsLmZpcnN0Q2hpbGQsIHZub2RlLCBlbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGhhc1dhcm5lZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBoYXNNaXNtYXRjaCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaGFzV2FybmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYEh5ZHJhdGlvbiBjaGlsZHJlbiBtaXNtYXRjaCBpbiA8JHt2bm9kZS50eXBlfT46IGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYHNlcnZlciByZW5kZXJlZCBlbGVtZW50IGNvbnRhaW5zIG1vcmUgY2hpbGQgbm9kZXMgdGhhbiBjbGllbnQgdmRvbS5gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzV2FybmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIFNTUmVkIERPTSBjb250YWlucyBtb3JlIG5vZGVzIHRoYW4gaXQgc2hvdWxkLiBSZW1vdmUgdGhlbS5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXIgPSBuZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZShjdXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNoYXBlRmxhZyAmIDggLyogVEVYVF9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsLnRleHRDb250ZW50ICE9PSB2bm9kZS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc01pc21hdGNoID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgSHlkcmF0aW9uIHRleHQgY29udGVudCBtaXNtYXRjaCBpbiA8JHt2bm9kZS50eXBlfT46XFxuYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgLSBDbGllbnQ6ICR7ZWwudGV4dENvbnRlbnR9XFxuYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgLSBTZXJ2ZXI6ICR7dm5vZGUuY2hpbGRyZW59YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWwudGV4dENvbnRlbnQgPSB2bm9kZS5jaGlsZHJlbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZWwubmV4dFNpYmxpbmc7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgaHlkcmF0ZUNoaWxkcmVuID0gKG5vZGUsIHBhcmVudFZOb2RlLCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgb3B0aW1pemVkID0gb3B0aW1pemVkIHx8ICEhcGFyZW50Vk5vZGUuZHluYW1pY0NoaWxkcmVuO1xyXG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50Vk5vZGUuY2hpbGRyZW47XHJcbiAgICAgICAgY29uc3QgbCA9IGNoaWxkcmVuLmxlbmd0aDtcclxuICAgICAgICBsZXQgaGFzV2FybmVkID0gZmFsc2U7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3Qgdm5vZGUgPSBvcHRpbWl6ZWRcclxuICAgICAgICAgICAgICAgID8gY2hpbGRyZW5baV1cclxuICAgICAgICAgICAgICAgIDogKGNoaWxkcmVuW2ldID0gbm9ybWFsaXplVk5vZGUoY2hpbGRyZW5baV0pKTtcclxuICAgICAgICAgICAgaWYgKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBoeWRyYXRlTm9kZShub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHZub2RlLnR5cGUgPT09IFRleHQgJiYgIXZub2RlLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGhhc01pc21hdGNoID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWhhc1dhcm5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYEh5ZHJhdGlvbiBjaGlsZHJlbiBtaXNtYXRjaCBpbiA8JHtjb250YWluZXIudGFnTmFtZS50b0xvd2VyQ2FzZSgpfT46IGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgc2VydmVyIHJlbmRlcmVkIGVsZW1lbnQgY29udGFpbnMgZmV3ZXIgY2hpbGQgbm9kZXMgdGhhbiBjbGllbnQgdmRvbS5gKTtcclxuICAgICAgICAgICAgICAgICAgICBoYXNXYXJuZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIFNTUmVkIERPTSBkaWRuJ3QgY29udGFpbiBlbm91Z2ggbm9kZXMuIE1vdW50IHRoZSBtaXNzaW5nIG9uZXMuXHJcbiAgICAgICAgICAgICAgICBwYXRjaChudWxsLCB2bm9kZSwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWR0NvbnRhaW5lcihjb250YWluZXIpLCBzbG90U2NvcGVJZHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGh5ZHJhdGVGcmFnbWVudCA9IChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBjb25zdCB7IHNsb3RTY29wZUlkczogZnJhZ21lbnRTbG90U2NvcGVJZHMgfSA9IHZub2RlO1xyXG4gICAgICAgIGlmIChmcmFnbWVudFNsb3RTY29wZUlkcykge1xyXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMgPSBzbG90U2NvcGVJZHNcclxuICAgICAgICAgICAgICAgID8gc2xvdFNjb3BlSWRzLmNvbmNhdChmcmFnbWVudFNsb3RTY29wZUlkcylcclxuICAgICAgICAgICAgICAgIDogZnJhZ21lbnRTbG90U2NvcGVJZHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHBhcmVudE5vZGUobm9kZSk7XHJcbiAgICAgICAgY29uc3QgbmV4dCA9IGh5ZHJhdGVDaGlsZHJlbihuZXh0U2libGluZyhub2RlKSwgdm5vZGUsIGNvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgIGlmIChuZXh0ICYmIGlzQ29tbWVudChuZXh0KSAmJiBuZXh0LmRhdGEgPT09ICddJykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV4dFNpYmxpbmcoKHZub2RlLmFuY2hvciA9IG5leHQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGZyYWdtZW50IGRpZG4ndCBoeWRyYXRlIHN1Y2Nlc3NmdWxseSwgc2luY2Ugd2UgZGlkbid0IGdldCBhIGVuZCBhbmNob3JcclxuICAgICAgICAgICAgLy8gYmFjay4gVGhpcyBzaG91bGQgaGF2ZSBsZWQgdG8gbm9kZS9jaGlsZHJlbiBtaXNtYXRjaCB3YXJuaW5ncy5cclxuICAgICAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICAvLyBzaW5jZSB0aGUgYW5jaG9yIGlzIG1pc3NpbmcsIHdlIG5lZWQgdG8gY3JlYXRlIG9uZSBhbmQgaW5zZXJ0IGl0XHJcbiAgICAgICAgICAgIGluc2VydCgodm5vZGUuYW5jaG9yID0gY3JlYXRlQ29tbWVudChgXWApKSwgY29udGFpbmVyLCBuZXh0KTtcclxuICAgICAgICAgICAgcmV0dXJuIG5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IGhhbmRsZU1pc21hdGNoID0gKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIGlzRnJhZ21lbnQpID0+IHtcclxuICAgICAgICBoYXNNaXNtYXRjaCA9IHRydWU7XHJcbiAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgIHdhcm4oYEh5ZHJhdGlvbiBub2RlIG1pc21hdGNoOlxcbi0gQ2xpZW50IHZub2RlOmAsIHZub2RlLnR5cGUsIGBcXG4tIFNlcnZlciByZW5kZXJlZCBET006YCwgbm9kZSwgbm9kZS5ub2RlVHlwZSA9PT0gMyAvKiBURVhUICovXHJcbiAgICAgICAgICAgICAgICA/IGAodGV4dClgXHJcbiAgICAgICAgICAgICAgICA6IGlzQ29tbWVudChub2RlKSAmJiBub2RlLmRhdGEgPT09ICdbJ1xyXG4gICAgICAgICAgICAgICAgICAgID8gYChzdGFydCBvZiBmcmFnbWVudClgXHJcbiAgICAgICAgICAgICAgICAgICAgOiBgYCk7XHJcbiAgICAgICAgdm5vZGUuZWwgPSBudWxsO1xyXG4gICAgICAgIGlmIChpc0ZyYWdtZW50KSB7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSBleGNlc3NpdmUgZnJhZ21lbnQgbm9kZXNcclxuICAgICAgICAgICAgY29uc3QgZW5kID0gbG9jYXRlQ2xvc2luZ0FzeW5jQW5jaG9yKG5vZGUpO1xyXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IG5leHRTaWJsaW5nKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHQgJiYgbmV4dCAhPT0gZW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKG5leHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbmV4dCA9IG5leHRTaWJsaW5nKG5vZGUpO1xyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHBhcmVudE5vZGUobm9kZSk7XHJcbiAgICAgICAgcmVtb3ZlKG5vZGUpO1xyXG4gICAgICAgIHBhdGNoKG51bGwsIHZub2RlLCBjb250YWluZXIsIG5leHQsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHQ29udGFpbmVyKGNvbnRhaW5lciksIHNsb3RTY29wZUlkcyk7XHJcbiAgICAgICAgcmV0dXJuIG5leHQ7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgbG9jYXRlQ2xvc2luZ0FzeW5jQW5jaG9yID0gKG5vZGUpID0+IHtcclxuICAgICAgICBsZXQgbWF0Y2ggPSAwO1xyXG4gICAgICAgIHdoaWxlIChub2RlKSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcclxuICAgICAgICAgICAgaWYgKG5vZGUgJiYgaXNDb21tZW50KG5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5kYXRhID09PSAnWycpXHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2grKztcclxuICAgICAgICAgICAgICAgIGlmIChub2RlLmRhdGEgPT09ICddJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dFNpYmxpbmcobm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaC0tO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gW2h5ZHJhdGUsIGh5ZHJhdGVOb2RlXTtcclxufVxuXG5sZXQgc3VwcG9ydGVkO1xyXG5sZXQgcGVyZjtcclxuZnVuY3Rpb24gc3RhcnRNZWFzdXJlKGluc3RhbmNlLCB0eXBlKSB7XHJcbiAgICBpZiAoaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcucGVyZm9ybWFuY2UgJiYgaXNTdXBwb3J0ZWQoKSkge1xyXG4gICAgICAgIHBlcmYubWFyayhgdnVlLSR7dHlwZX0tJHtpbnN0YW5jZS51aWR9YCk7XHJcbiAgICB9XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgIGRldnRvb2xzUGVyZlN0YXJ0KGluc3RhbmNlLCB0eXBlLCBzdXBwb3J0ZWQgPyBwZXJmLm5vdygpIDogRGF0ZS5ub3coKSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZW5kTWVhc3VyZShpbnN0YW5jZSwgdHlwZSkge1xyXG4gICAgaWYgKGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLnBlcmZvcm1hbmNlICYmIGlzU3VwcG9ydGVkKCkpIHtcclxuICAgICAgICBjb25zdCBzdGFydFRhZyA9IGB2dWUtJHt0eXBlfS0ke2luc3RhbmNlLnVpZH1gO1xyXG4gICAgICAgIGNvbnN0IGVuZFRhZyA9IHN0YXJ0VGFnICsgYDplbmRgO1xyXG4gICAgICAgIHBlcmYubWFyayhlbmRUYWcpO1xyXG4gICAgICAgIHBlcmYubWVhc3VyZShgPCR7Zm9ybWF0Q29tcG9uZW50TmFtZShpbnN0YW5jZSwgaW5zdGFuY2UudHlwZSl9PiAke3R5cGV9YCwgc3RhcnRUYWcsIGVuZFRhZyk7XHJcbiAgICAgICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcclxuICAgICAgICBwZXJmLmNsZWFyTWFya3MoZW5kVGFnKTtcclxuICAgIH1cclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgZGV2dG9vbHNQZXJmRW5kKGluc3RhbmNlLCB0eXBlLCBzdXBwb3J0ZWQgPyBwZXJmLm5vdygpIDogRGF0ZS5ub3coKSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaXNTdXBwb3J0ZWQoKSB7XHJcbiAgICBpZiAoc3VwcG9ydGVkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gc3VwcG9ydGVkO1xyXG4gICAgfVxyXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzICovXHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnBlcmZvcm1hbmNlKSB7XHJcbiAgICAgICAgc3VwcG9ydGVkID0gdHJ1ZTtcclxuICAgICAgICBwZXJmID0gd2luZG93LnBlcmZvcm1hbmNlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgc3VwcG9ydGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAqL1xyXG4gICAgcmV0dXJuIHN1cHBvcnRlZDtcclxufVxuXG4vKipcclxuICogVGhpcyBpcyBvbmx5IGNhbGxlZCBpbiBlc20tYnVuZGxlciBidWlsZHMuXHJcbiAqIEl0IGlzIGNhbGxlZCB3aGVuIGEgcmVuZGVyZXIgaXMgY3JlYXRlZCwgaW4gYGJhc2VDcmVhdGVSZW5kZXJlcmAgc28gdGhhdFxyXG4gKiBpbXBvcnRpbmcgcnVudGltZS1jb3JlIGlzIHNpZGUtZWZmZWN0cyBmcmVlLlxyXG4gKlxyXG4gKiBpc3RhbmJ1bC1pZ25vcmUtbmV4dFxyXG4gKi9cclxuZnVuY3Rpb24gaW5pdEZlYXR1cmVGbGFncygpIHtcclxuICAgIGxldCBuZWVkV2FybiA9IGZhbHNlO1xyXG4gICAgaWYgKHR5cGVvZiBfX1ZVRV9PUFRJT05TX0FQSV9fICE9PSAnYm9vbGVhbicpIHtcclxuICAgICAgICBuZWVkV2FybiA9IHRydWU7XHJcbiAgICAgICAgZ2V0R2xvYmFsVGhpcygpLl9fVlVFX09QVElPTlNfQVBJX18gPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBfX1ZVRV9QUk9EX0RFVlRPT0xTX18gIT09ICdib29sZWFuJykge1xyXG4gICAgICAgIG5lZWRXYXJuID0gdHJ1ZTtcclxuICAgICAgICBnZXRHbG9iYWxUaGlzKCkuX19WVUVfUFJPRF9ERVZUT09MU19fID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIG5lZWRXYXJuKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGBZb3UgYXJlIHJ1bm5pbmcgdGhlIGVzbS1idW5kbGVyIGJ1aWxkIG9mIFZ1ZS4gSXQgaXMgcmVjb21tZW5kZWQgdG8gYCArXHJcbiAgICAgICAgICAgIGBjb25maWd1cmUgeW91ciBidW5kbGVyIHRvIGV4cGxpY2l0bHkgcmVwbGFjZSBmZWF0dXJlIGZsYWcgZ2xvYmFscyBgICtcclxuICAgICAgICAgICAgYHdpdGggYm9vbGVhbiBsaXRlcmFscyB0byBnZXQgcHJvcGVyIHRyZWUtc2hha2luZyBpbiB0aGUgZmluYWwgYnVuZGxlLiBgICtcclxuICAgICAgICAgICAgYFNlZSBodHRwOi8vbGluay52dWVqcy5vcmcvZmVhdHVyZS1mbGFncyBmb3IgbW9yZSBkZXRhaWxzLmApO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IHByb2RFZmZlY3RPcHRpb25zID0ge1xyXG4gICAgc2NoZWR1bGVyOiBxdWV1ZUpvYixcclxuICAgIC8vICMxODAxLCAjMjA0MyBjb21wb25lbnQgcmVuZGVyIGVmZmVjdHMgc2hvdWxkIGFsbG93IHJlY3Vyc2l2ZSB1cGRhdGVzXHJcbiAgICBhbGxvd1JlY3Vyc2U6IHRydWVcclxufTtcclxuZnVuY3Rpb24gY3JlYXRlRGV2RWZmZWN0T3B0aW9ucyhpbnN0YW5jZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzY2hlZHVsZXI6IHF1ZXVlSm9iLFxyXG4gICAgICAgIGFsbG93UmVjdXJzZTogdHJ1ZSxcclxuICAgICAgICBvblRyYWNrOiBpbnN0YW5jZS5ydGMgPyBlID0+IGludm9rZUFycmF5Rm5zKGluc3RhbmNlLnJ0YywgZSkgOiB2b2lkIDAsXHJcbiAgICAgICAgb25UcmlnZ2VyOiBpbnN0YW5jZS5ydGcgPyBlID0+IGludm9rZUFycmF5Rm5zKGluc3RhbmNlLnJ0ZywgZSkgOiB2b2lkIDBcclxuICAgIH07XHJcbn1cclxuY29uc3QgcXVldWVQb3N0UmVuZGVyRWZmZWN0ID0gcXVldWVFZmZlY3RXaXRoU3VzcGVuc2VcclxuICAgIDtcclxuY29uc3Qgc2V0UmVmID0gKHJhd1JlZiwgb2xkUmF3UmVmLCBwYXJlbnRTdXNwZW5zZSwgdm5vZGUsIGlzVW5tb3VudCA9IGZhbHNlKSA9PiB7XHJcbiAgICBpZiAoaXNBcnJheShyYXdSZWYpKSB7XHJcbiAgICAgICAgcmF3UmVmLmZvckVhY2goKHIsIGkpID0+IHNldFJlZihyLCBvbGRSYXdSZWYgJiYgKGlzQXJyYXkob2xkUmF3UmVmKSA/IG9sZFJhd1JlZltpXSA6IG9sZFJhd1JlZiksIHBhcmVudFN1c3BlbnNlLCB2bm9kZSwgaXNVbm1vdW50KSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzQXN5bmNXcmFwcGVyKHZub2RlKSAmJiAhaXNVbm1vdW50KSB7XHJcbiAgICAgICAgLy8gd2hlbiBtb3VudGluZyBhc3luYyBjb21wb25lbnRzLCBub3RoaW5nIG5lZWRzIHRvIGJlIGRvbmUsXHJcbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgdGVtcGxhdGUgcmVmIGlzIGZvcndhcmRlZCB0byBpbm5lciBjb21wb25lbnRcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCByZWZWYWx1ZSA9IHZub2RlLnNoYXBlRmxhZyAmIDQgLyogU1RBVEVGVUxfQ09NUE9ORU5UICovXHJcbiAgICAgICAgPyB2bm9kZS5jb21wb25lbnQuZXhwb3NlZCB8fCB2bm9kZS5jb21wb25lbnQucHJveHlcclxuICAgICAgICA6IHZub2RlLmVsO1xyXG4gICAgY29uc3QgdmFsdWUgPSBpc1VubW91bnQgPyBudWxsIDogcmVmVmFsdWU7XHJcbiAgICBjb25zdCB7IGk6IG93bmVyLCByOiByZWYgfSA9IHJhd1JlZjtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIW93bmVyKSB7XHJcbiAgICAgICAgd2FybihgTWlzc2luZyByZWYgb3duZXIgY29udGV4dC4gcmVmIGNhbm5vdCBiZSB1c2VkIG9uIGhvaXN0ZWQgdm5vZGVzLiBgICtcclxuICAgICAgICAgICAgYEEgdm5vZGUgd2l0aCByZWYgbXVzdCBiZSBjcmVhdGVkIGluc2lkZSB0aGUgcmVuZGVyIGZ1bmN0aW9uLmApO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IG9sZFJlZiA9IG9sZFJhd1JlZiAmJiBvbGRSYXdSZWYucjtcclxuICAgIGNvbnN0IHJlZnMgPSBvd25lci5yZWZzID09PSBFTVBUWV9PQkogPyAob3duZXIucmVmcyA9IHt9KSA6IG93bmVyLnJlZnM7XHJcbiAgICBjb25zdCBzZXR1cFN0YXRlID0gb3duZXIuc2V0dXBTdGF0ZTtcclxuICAgIC8vIGR5bmFtaWMgcmVmIGNoYW5nZWQuIHVuc2V0IG9sZCByZWZcclxuICAgIGlmIChvbGRSZWYgIT0gbnVsbCAmJiBvbGRSZWYgIT09IHJlZikge1xyXG4gICAgICAgIGlmIChpc1N0cmluZyhvbGRSZWYpKSB7XHJcbiAgICAgICAgICAgIHJlZnNbb2xkUmVmXSA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChoYXNPd24oc2V0dXBTdGF0ZSwgb2xkUmVmKSkge1xyXG4gICAgICAgICAgICAgICAgc2V0dXBTdGF0ZVtvbGRSZWZdID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc1JlZihvbGRSZWYpKSB7XHJcbiAgICAgICAgICAgIG9sZFJlZi52YWx1ZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGlzU3RyaW5nKHJlZikpIHtcclxuICAgICAgICBjb25zdCBkb1NldCA9ICgpID0+IHtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmVmc1tyZWZdID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGhhc093bihzZXR1cFN0YXRlLCByZWYpKSB7XHJcbiAgICAgICAgICAgICAgICBzZXR1cFN0YXRlW3JlZl0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gIzE3ODk6IGZvciBub24tbnVsbCB2YWx1ZXMsIHNldCB0aGVtIGFmdGVyIHJlbmRlclxyXG4gICAgICAgIC8vIG51bGwgdmFsdWVzIG1lYW5zIHRoaXMgaXMgdW5tb3VudCBhbmQgaXQgc2hvdWxkIG5vdCBvdmVyd3JpdGUgYW5vdGhlclxyXG4gICAgICAgIC8vIHJlZiB3aXRoIHRoZSBzYW1lIGtleVxyXG4gICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBkb1NldC5pZCA9IC0xO1xyXG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoZG9TZXQsIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRvU2V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNSZWYocmVmKSkge1xyXG4gICAgICAgIGNvbnN0IGRvU2V0ID0gKCkgPT4ge1xyXG4gICAgICAgICAgICByZWYudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBkb1NldC5pZCA9IC0xO1xyXG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoZG9TZXQsIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRvU2V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbihyZWYpKSB7XHJcbiAgICAgICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKHJlZiwgb3duZXIsIDEyIC8qIEZVTkNUSU9OX1JFRiAqLywgW3ZhbHVlLCByZWZzXSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB3YXJuKCdJbnZhbGlkIHRlbXBsYXRlIHJlZiB0eXBlOicsIHZhbHVlLCBgKCR7dHlwZW9mIHZhbHVlfSlgKTtcclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIFRoZSBjcmVhdGVSZW5kZXJlciBmdW5jdGlvbiBhY2NlcHRzIHR3byBnZW5lcmljIGFyZ3VtZW50czpcclxuICogSG9zdE5vZGUgYW5kIEhvc3RFbGVtZW50LCBjb3JyZXNwb25kaW5nIHRvIE5vZGUgYW5kIEVsZW1lbnQgdHlwZXMgaW4gdGhlXHJcbiAqIGhvc3QgZW52aXJvbm1lbnQuIEZvciBleGFtcGxlLCBmb3IgcnVudGltZS1kb20sIEhvc3ROb2RlIHdvdWxkIGJlIHRoZSBET01cclxuICogYE5vZGVgIGludGVyZmFjZSBhbmQgSG9zdEVsZW1lbnQgd291bGQgYmUgdGhlIERPTSBgRWxlbWVudGAgaW50ZXJmYWNlLlxyXG4gKlxyXG4gKiBDdXN0b20gcmVuZGVyZXJzIGNhbiBwYXNzIGluIHRoZSBwbGF0Zm9ybSBzcGVjaWZpYyB0eXBlcyBsaWtlIHRoaXM6XHJcbiAqXHJcbiAqIGBgYCBqc1xyXG4gKiBjb25zdCB7IHJlbmRlciwgY3JlYXRlQXBwIH0gPSBjcmVhdGVSZW5kZXJlcjxOb2RlLCBFbGVtZW50Pih7XHJcbiAqICAgcGF0Y2hQcm9wLFxyXG4gKiAgIC4uLm5vZGVPcHNcclxuICogfSlcclxuICogYGBgXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVSZW5kZXJlcihvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gYmFzZUNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMpO1xyXG59XHJcbi8vIFNlcGFyYXRlIEFQSSBmb3IgY3JlYXRpbmcgaHlkcmF0aW9uLWVuYWJsZWQgcmVuZGVyZXIuXHJcbi8vIEh5ZHJhdGlvbiBsb2dpYyBpcyBvbmx5IHVzZWQgd2hlbiBjYWxsaW5nIHRoaXMgZnVuY3Rpb24sIG1ha2luZyBpdFxyXG4vLyB0cmVlLXNoYWthYmxlLlxyXG5mdW5jdGlvbiBjcmVhdGVIeWRyYXRpb25SZW5kZXJlcihvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gYmFzZUNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMsIGNyZWF0ZUh5ZHJhdGlvbkZ1bmN0aW9ucyk7XHJcbn1cclxuLy8gaW1wbGVtZW50YXRpb25cclxuZnVuY3Rpb24gYmFzZUNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMsIGNyZWF0ZUh5ZHJhdGlvbkZucykge1xyXG4gICAgLy8gY29tcGlsZS10aW1lIGZlYXR1cmUgZmxhZ3MgY2hlY2tcclxuICAgIHtcclxuICAgICAgICBpbml0RmVhdHVyZUZsYWdzKCk7XHJcbiAgICB9XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGdldEdsb2JhbFRoaXMoKTtcclxuICAgICAgICB0YXJnZXQuX19WVUVfXyA9IHRydWU7XHJcbiAgICAgICAgc2V0RGV2dG9vbHNIb29rKHRhcmdldC5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgaW5zZXJ0OiBob3N0SW5zZXJ0LCByZW1vdmU6IGhvc3RSZW1vdmUsIHBhdGNoUHJvcDogaG9zdFBhdGNoUHJvcCwgZm9yY2VQYXRjaFByb3A6IGhvc3RGb3JjZVBhdGNoUHJvcCwgY3JlYXRlRWxlbWVudDogaG9zdENyZWF0ZUVsZW1lbnQsIGNyZWF0ZVRleHQ6IGhvc3RDcmVhdGVUZXh0LCBjcmVhdGVDb21tZW50OiBob3N0Q3JlYXRlQ29tbWVudCwgc2V0VGV4dDogaG9zdFNldFRleHQsIHNldEVsZW1lbnRUZXh0OiBob3N0U2V0RWxlbWVudFRleHQsIHBhcmVudE5vZGU6IGhvc3RQYXJlbnROb2RlLCBuZXh0U2libGluZzogaG9zdE5leHRTaWJsaW5nLCBzZXRTY29wZUlkOiBob3N0U2V0U2NvcGVJZCA9IE5PT1AsIGNsb25lTm9kZTogaG9zdENsb25lTm9kZSwgaW5zZXJ0U3RhdGljQ29udGVudDogaG9zdEluc2VydFN0YXRpY0NvbnRlbnQgfSA9IG9wdGlvbnM7XHJcbiAgICAvLyBOb3RlOiBmdW5jdGlvbnMgaW5zaWRlIHRoaXMgY2xvc3VyZSBzaG91bGQgdXNlIGBjb25zdCB4eHggPSAoKSA9PiB7fWBcclxuICAgIC8vIHN0eWxlIGluIG9yZGVyIHRvIHByZXZlbnQgYmVpbmcgaW5saW5lZCBieSBtaW5pZmllcnMuXHJcbiAgICBjb25zdCBwYXRjaCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yID0gbnVsbCwgcGFyZW50Q29tcG9uZW50ID0gbnVsbCwgcGFyZW50U3VzcGVuc2UgPSBudWxsLCBpc1NWRyA9IGZhbHNlLCBzbG90U2NvcGVJZHMgPSBudWxsLCBvcHRpbWl6ZWQgPSBmYWxzZSkgPT4ge1xyXG4gICAgICAgIC8vIHBhdGNoaW5nICYgbm90IHNhbWUgdHlwZSwgdW5tb3VudCBvbGQgdHJlZVxyXG4gICAgICAgIGlmIChuMSAmJiAhaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikpIHtcclxuICAgICAgICAgICAgYW5jaG9yID0gZ2V0TmV4dEhvc3ROb2RlKG4xKTtcclxuICAgICAgICAgICAgdW5tb3VudChuMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIG4xID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG4yLnBhdGNoRmxhZyA9PT0gLTIgLyogQkFJTCAqLykge1xyXG4gICAgICAgICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgbjIuZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyB0eXBlLCByZWYsIHNoYXBlRmxhZyB9ID0gbjI7XHJcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgVGV4dDpcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NUZXh0KG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgQ29tbWVudCQxOlxyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc0NvbW1lbnROb2RlKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgU3RhdGljOlxyXG4gICAgICAgICAgICAgICAgaWYgKG4xID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBtb3VudFN0YXRpY05vZGUobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRjaFN0YXRpY05vZGUobjEsIG4yLCBjb250YWluZXIsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIEZyYWdtZW50OlxyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc0ZyYWdtZW50KG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxIC8qIEVMRU1FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzRWxlbWVudChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGVGbGFnICYgNiAvKiBDT01QT05FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzQ29tcG9uZW50KG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiA2NCAvKiBURUxFUE9SVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGUucHJvY2VzcyhuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIGludGVybmFscyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlLnByb2Nlc3MobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCBpbnRlcm5hbHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybignSW52YWxpZCBWTm9kZSB0eXBlOicsIHR5cGUsIGAoJHt0eXBlb2YgdHlwZX0pYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNldCByZWZcclxuICAgICAgICBpZiAocmVmICE9IG51bGwgJiYgcGFyZW50Q29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIHNldFJlZihyZWYsIG4xICYmIG4xLnJlZiwgcGFyZW50U3VzcGVuc2UsIG4yIHx8IG4xLCAhbjIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBwcm9jZXNzVGV4dCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yKSA9PiB7XHJcbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcclxuICAgICAgICAgICAgaG9zdEluc2VydCgobjIuZWwgPSBob3N0Q3JlYXRlVGV4dChuMi5jaGlsZHJlbikpLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBlbCA9IChuMi5lbCA9IG4xLmVsKTtcclxuICAgICAgICAgICAgaWYgKG4yLmNoaWxkcmVuICE9PSBuMS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgaG9zdFNldFRleHQoZWwsIG4yLmNoaWxkcmVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBwcm9jZXNzQ29tbWVudE5vZGUgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvcikgPT4ge1xyXG4gICAgICAgIGlmIChuMSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoKG4yLmVsID0gaG9zdENyZWF0ZUNvbW1lbnQobjIuY2hpbGRyZW4gfHwgJycpKSwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdGhlcmUncyBubyBzdXBwb3J0IGZvciBkeW5hbWljIGNvbW1lbnRzXHJcbiAgICAgICAgICAgIG4yLmVsID0gbjEuZWw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IG1vdW50U3RhdGljTm9kZSA9IChuMiwgY29udGFpbmVyLCBhbmNob3IsIGlzU1ZHKSA9PiB7XHJcbiAgICAgICAgW24yLmVsLCBuMi5hbmNob3JdID0gaG9zdEluc2VydFN0YXRpY0NvbnRlbnQobjIuY2hpbGRyZW4sIGNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXYgLyBITVIgb25seVxyXG4gICAgICovXHJcbiAgICBjb25zdCBwYXRjaFN0YXRpY05vZGUgPSAobjEsIG4yLCBjb250YWluZXIsIGlzU1ZHKSA9PiB7XHJcbiAgICAgICAgLy8gc3RhdGljIG5vZGVzIGFyZSBvbmx5IHBhdGNoZWQgZHVyaW5nIGRldiBmb3IgSE1SXHJcbiAgICAgICAgaWYgKG4yLmNoaWxkcmVuICE9PSBuMS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICBjb25zdCBhbmNob3IgPSBob3N0TmV4dFNpYmxpbmcobjEuYW5jaG9yKTtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIGV4aXN0aW5nXHJcbiAgICAgICAgICAgIHJlbW92ZVN0YXRpY05vZGUobjEpO1xyXG4gICAgICAgICAgICBbbjIuZWwsIG4yLmFuY2hvcl0gPSBob3N0SW5zZXJ0U3RhdGljQ29udGVudChuMi5jaGlsZHJlbiwgY29udGFpbmVyLCBhbmNob3IsIGlzU1ZHKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG4yLmVsID0gbjEuZWw7XHJcbiAgICAgICAgICAgIG4yLmFuY2hvciA9IG4xLmFuY2hvcjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgbW92ZVN0YXRpY05vZGUgPSAoeyBlbCwgYW5jaG9yIH0sIGNvbnRhaW5lciwgbmV4dFNpYmxpbmcpID0+IHtcclxuICAgICAgICBsZXQgbmV4dDtcclxuICAgICAgICB3aGlsZSAoZWwgJiYgZWwgIT09IGFuY2hvcikge1xyXG4gICAgICAgICAgICBuZXh0ID0gaG9zdE5leHRTaWJsaW5nKGVsKTtcclxuICAgICAgICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBuZXh0U2libGluZyk7XHJcbiAgICAgICAgICAgIGVsID0gbmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaG9zdEluc2VydChhbmNob3IsIGNvbnRhaW5lciwgbmV4dFNpYmxpbmcpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlbW92ZVN0YXRpY05vZGUgPSAoeyBlbCwgYW5jaG9yIH0pID0+IHtcclxuICAgICAgICBsZXQgbmV4dDtcclxuICAgICAgICB3aGlsZSAoZWwgJiYgZWwgIT09IGFuY2hvcikge1xyXG4gICAgICAgICAgICBuZXh0ID0gaG9zdE5leHRTaWJsaW5nKGVsKTtcclxuICAgICAgICAgICAgaG9zdFJlbW92ZShlbCk7XHJcbiAgICAgICAgICAgIGVsID0gbmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaG9zdFJlbW92ZShhbmNob3IpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHByb2Nlc3NFbGVtZW50ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIGlzU1ZHID0gaXNTVkcgfHwgbjIudHlwZSA9PT0gJ3N2Zyc7XHJcbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcclxuICAgICAgICAgICAgbW91bnRFbGVtZW50KG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHBhdGNoRWxlbWVudChuMSwgbjIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IG1vdW50RWxlbWVudCA9ICh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIGxldCBlbDtcclxuICAgICAgICBsZXQgdm5vZGVIb29rO1xyXG4gICAgICAgIGNvbnN0IHsgdHlwZSwgcHJvcHMsIHNoYXBlRmxhZywgdHJhbnNpdGlvbiwgcGF0Y2hGbGFnLCBkaXJzIH0gPSB2bm9kZTtcclxuICAgICAgICBpZiAoIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICB2bm9kZS5lbCAmJlxyXG4gICAgICAgICAgICBob3N0Q2xvbmVOb2RlICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgICAgcGF0Y2hGbGFnID09PSAtMSAvKiBIT0lTVEVEICovKSB7XHJcbiAgICAgICAgICAgIC8vIElmIGEgdm5vZGUgaGFzIG5vbi1udWxsIGVsLCBpdCBtZWFucyBpdCdzIGJlaW5nIHJldXNlZC5cclxuICAgICAgICAgICAgLy8gT25seSBzdGF0aWMgdm5vZGVzIGNhbiBiZSByZXVzZWQsIHNvIGl0cyBtb3VudGVkIERPTSBub2RlcyBzaG91bGQgYmVcclxuICAgICAgICAgICAgLy8gZXhhY3RseSB0aGUgc2FtZSwgYW5kIHdlIGNhbiBzaW1wbHkgZG8gYSBjbG9uZSBoZXJlLlxyXG4gICAgICAgICAgICAvLyBvbmx5IGRvIHRoaXMgaW4gcHJvZHVjdGlvbiBzaW5jZSBjbG9uZWQgdHJlZXMgY2Fubm90IGJlIEhNUiB1cGRhdGVkLlxyXG4gICAgICAgICAgICBlbCA9IHZub2RlLmVsID0gaG9zdENsb25lTm9kZSh2bm9kZS5lbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbCA9IHZub2RlLmVsID0gaG9zdENyZWF0ZUVsZW1lbnQodm5vZGUudHlwZSwgaXNTVkcsIHByb3BzICYmIHByb3BzLmlzLCBwcm9wcyk7XHJcbiAgICAgICAgICAgIC8vIG1vdW50IGNoaWxkcmVuIGZpcnN0LCBzaW5jZSBzb21lIHByb3BzIG1heSByZWx5IG9uIGNoaWxkIGNvbnRlbnRcclxuICAgICAgICAgICAgLy8gYmVpbmcgYWxyZWFkeSByZW5kZXJlZCwgZS5nLiBgPHNlbGVjdCB2YWx1ZT5gXHJcbiAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiA4IC8qIFRFWFRfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChlbCwgdm5vZGUuY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIEFSUkFZX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgICAgICBtb3VudENoaWxkcmVuKHZub2RlLmNoaWxkcmVuLCBlbCwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcgJiYgdHlwZSAhPT0gJ2ZvcmVpZ25PYmplY3QnLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCB8fCAhIXZub2RlLmR5bmFtaWNDaGlsZHJlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRpcnMpIHtcclxuICAgICAgICAgICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgJ2NyZWF0ZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBwcm9wc1xyXG4gICAgICAgICAgICBpZiAocHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1Jlc2VydmVkUHJvcChrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIGtleSwgbnVsbCwgcHJvcHNba2V5XSwgaXNTVkcsIHZub2RlLmNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB1bm1vdW50Q2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgodm5vZGVIb29rID0gcHJvcHMub25Wbm9kZUJlZm9yZU1vdW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHNjb3BlSWRcclxuICAgICAgICAgICAgc2V0U2NvcGVJZChlbCwgdm5vZGUsIHZub2RlLnNjb3BlSWQsIHNsb3RTY29wZUlkcywgcGFyZW50Q29tcG9uZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsLCAnX192bm9kZScsIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB2bm9kZSxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWwsICdfX3Z1ZVBhcmVudENvbXBvbmVudCcsIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJlbnRDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRpcnMpIHtcclxuICAgICAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnYmVmb3JlTW91bnQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gIzE1ODMgRm9yIGluc2lkZSBzdXNwZW5zZSArIHN1c3BlbnNlIG5vdCByZXNvbHZlZCBjYXNlLCBlbnRlciBob29rIHNob3VsZCBjYWxsIHdoZW4gc3VzcGVuc2UgcmVzb2x2ZWRcclxuICAgICAgICAvLyAjMTY4OSBGb3IgaW5zaWRlIHN1c3BlbnNlICsgc3VzcGVuc2UgcmVzb2x2ZWQgY2FzZSwganVzdCBjYWxsIGl0XHJcbiAgICAgICAgY29uc3QgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MgPSAoIXBhcmVudFN1c3BlbnNlIHx8IChwYXJlbnRTdXNwZW5zZSAmJiAhcGFyZW50U3VzcGVuc2UucGVuZGluZ0JyYW5jaCkpICYmXHJcbiAgICAgICAgICAgIHRyYW5zaXRpb24gJiZcclxuICAgICAgICAgICAgIXRyYW5zaXRpb24ucGVyc2lzdGVkO1xyXG4gICAgICAgIGlmIChuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcykge1xyXG4gICAgICAgICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgIGlmICgodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZU1vdW50ZWQpIHx8XHJcbiAgICAgICAgICAgIG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzIHx8XHJcbiAgICAgICAgICAgIGRpcnMpIHtcclxuICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHZub2RlSG9vayAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcclxuICAgICAgICAgICAgICAgIG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzICYmIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xyXG4gICAgICAgICAgICAgICAgZGlycyAmJiBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICdtb3VudGVkJyk7XHJcbiAgICAgICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3Qgc2V0U2NvcGVJZCA9IChlbCwgdm5vZGUsIHNjb3BlSWQsIHNsb3RTY29wZUlkcywgcGFyZW50Q29tcG9uZW50KSA9PiB7XHJcbiAgICAgICAgaWYgKHNjb3BlSWQpIHtcclxuICAgICAgICAgICAgaG9zdFNldFNjb3BlSWQoZWwsIHNjb3BlSWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2xvdFNjb3BlSWRzKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xvdFNjb3BlSWRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBob3N0U2V0U2NvcGVJZChlbCwgc2xvdFNjb3BlSWRzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGFyZW50Q29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIGxldCBzdWJUcmVlID0gcGFyZW50Q29tcG9uZW50LnN1YlRyZWU7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgIHN1YlRyZWUucGF0Y2hGbGFnID4gMCAmJlxyXG4gICAgICAgICAgICAgICAgc3ViVHJlZS5wYXRjaEZsYWcgJiAyMDQ4IC8qIERFVl9ST09UX0ZSQUdNRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICBzdWJUcmVlID1cclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJTaW5nbGVSb290KHN1YlRyZWUuY2hpbGRyZW4pIHx8IHN1YlRyZWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZub2RlID09PSBzdWJUcmVlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRWTm9kZSA9IHBhcmVudENvbXBvbmVudC52bm9kZTtcclxuICAgICAgICAgICAgICAgIHNldFNjb3BlSWQoZWwsIHBhcmVudFZOb2RlLCBwYXJlbnRWTm9kZS5zY29wZUlkLCBwYXJlbnRWTm9kZS5zbG90U2NvcGVJZHMsIHBhcmVudENvbXBvbmVudC5wYXJlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IG1vdW50Q2hpbGRyZW4gPSAoY2hpbGRyZW4sIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHN0YXJ0ID0gMCkgPT4ge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gKGNoaWxkcmVuW2ldID0gb3B0aW1pemVkXHJcbiAgICAgICAgICAgICAgICA/IGNsb25lSWZNb3VudGVkKGNoaWxkcmVuW2ldKVxyXG4gICAgICAgICAgICAgICAgOiBub3JtYWxpemVWTm9kZShjaGlsZHJlbltpXSkpO1xyXG4gICAgICAgICAgICBwYXRjaChudWxsLCBjaGlsZCwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHBhdGNoRWxlbWVudCA9IChuMSwgbjIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGVsID0gKG4yLmVsID0gbjEuZWwpO1xyXG4gICAgICAgIGxldCB7IHBhdGNoRmxhZywgZHluYW1pY0NoaWxkcmVuLCBkaXJzIH0gPSBuMjtcclxuICAgICAgICAvLyAjMTQyNiB0YWtlIHRoZSBvbGQgdm5vZGUncyBwYXRjaCBmbGFnIGludG8gYWNjb3VudCBzaW5jZSB1c2VyIG1heSBjbG9uZSBhXHJcbiAgICAgICAgLy8gY29tcGlsZXItZ2VuZXJhdGVkIHZub2RlLCB3aGljaCBkZS1vcHRzIHRvIEZVTExfUFJPUFNcclxuICAgICAgICBwYXRjaEZsYWcgfD0gbjEucGF0Y2hGbGFnICYgMTYgLyogRlVMTF9QUk9QUyAqLztcclxuICAgICAgICBjb25zdCBvbGRQcm9wcyA9IG4xLnByb3BzIHx8IEVNUFRZX09CSjtcclxuICAgICAgICBjb25zdCBuZXdQcm9wcyA9IG4yLnByb3BzIHx8IEVNUFRZX09CSjtcclxuICAgICAgICBsZXQgdm5vZGVIb29rO1xyXG4gICAgICAgIGlmICgodm5vZGVIb29rID0gbmV3UHJvcHMub25Wbm9kZUJlZm9yZVVwZGF0ZSkpIHtcclxuICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCBuMiwgbjEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGlycykge1xyXG4gICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKG4yLCBuMSwgcGFyZW50Q29tcG9uZW50LCAnYmVmb3JlVXBkYXRlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaXNIbXJVcGRhdGluZykge1xyXG4gICAgICAgICAgICAvLyBITVIgdXBkYXRlZCwgZm9yY2UgZnVsbCBkaWZmXHJcbiAgICAgICAgICAgIHBhdGNoRmxhZyA9IDA7XHJcbiAgICAgICAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBkeW5hbWljQ2hpbGRyZW4gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGF0Y2hGbGFnID4gMCkge1xyXG4gICAgICAgICAgICAvLyB0aGUgcHJlc2VuY2Ugb2YgYSBwYXRjaEZsYWcgbWVhbnMgdGhpcyBlbGVtZW50J3MgcmVuZGVyIGNvZGUgd2FzXHJcbiAgICAgICAgICAgIC8vIGdlbmVyYXRlZCBieSB0aGUgY29tcGlsZXIgYW5kIGNhbiB0YWtlIHRoZSBmYXN0IHBhdGguXHJcbiAgICAgICAgICAgIC8vIGluIHRoaXMgcGF0aCBvbGQgbm9kZSBhbmQgbmV3IG5vZGUgYXJlIGd1YXJhbnRlZWQgdG8gaGF2ZSB0aGUgc2FtZSBzaGFwZVxyXG4gICAgICAgICAgICAvLyAoaS5lLiBhdCB0aGUgZXhhY3Qgc2FtZSBwb3NpdGlvbiBpbiB0aGUgc291cmNlIHRlbXBsYXRlKVxyXG4gICAgICAgICAgICBpZiAocGF0Y2hGbGFnICYgMTYgLyogRlVMTF9QUk9QUyAqLykge1xyXG4gICAgICAgICAgICAgICAgLy8gZWxlbWVudCBwcm9wcyBjb250YWluIGR5bmFtaWMga2V5cywgZnVsbCBkaWZmIG5lZWRlZFxyXG4gICAgICAgICAgICAgICAgcGF0Y2hQcm9wcyhlbCwgbjIsIG9sZFByb3BzLCBuZXdQcm9wcywgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gY2xhc3NcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgZmxhZyBpcyBtYXRjaGVkIHdoZW4gdGhlIGVsZW1lbnQgaGFzIGR5bmFtaWMgY2xhc3MgYmluZGluZ3MuXHJcbiAgICAgICAgICAgICAgICBpZiAocGF0Y2hGbGFnICYgMiAvKiBDTEFTUyAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRQcm9wcy5jbGFzcyAhPT0gbmV3UHJvcHMuY2xhc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgJ2NsYXNzJywgbnVsbCwgbmV3UHJvcHMuY2xhc3MsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBzdHlsZVxyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBmbGFnIGlzIG1hdGNoZWQgd2hlbiB0aGUgZWxlbWVudCBoYXMgZHluYW1pYyBzdHlsZSBiaW5kaW5nc1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDQgLyogU1RZTEUgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCAnc3R5bGUnLCBvbGRQcm9wcy5zdHlsZSwgbmV3UHJvcHMuc3R5bGUsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHByb3BzXHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGZsYWcgaXMgbWF0Y2hlZCB3aGVuIHRoZSBlbGVtZW50IGhhcyBkeW5hbWljIHByb3AvYXR0ciBiaW5kaW5nc1xyXG4gICAgICAgICAgICAgICAgLy8gb3RoZXIgdGhhbiBjbGFzcyBhbmQgc3R5bGUuIFRoZSBrZXlzIG9mIGR5bmFtaWMgcHJvcC9hdHRycyBhcmUgc2F2ZWQgZm9yXHJcbiAgICAgICAgICAgICAgICAvLyBmYXN0ZXIgaXRlcmF0aW9uLlxyXG4gICAgICAgICAgICAgICAgLy8gTm90ZSBkeW5hbWljIGtleXMgbGlrZSA6W2Zvb109XCJiYXJcIiB3aWxsIGNhdXNlIHRoaXMgb3B0aW1pemF0aW9uIHRvXHJcbiAgICAgICAgICAgICAgICAvLyBiYWlsIG91dCBhbmQgZ28gdGhyb3VnaCBhIGZ1bGwgZGlmZiBiZWNhdXNlIHdlIG5lZWQgdG8gdW5zZXQgdGhlIG9sZCBrZXlcclxuICAgICAgICAgICAgICAgIGlmIChwYXRjaEZsYWcgJiA4IC8qIFBST1BTICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGZsYWcgaXMgcHJlc2VudCB0aGVuIGR5bmFtaWNQcm9wcyBtdXN0IGJlIG5vbi1udWxsXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcHNUb1VwZGF0ZSA9IG4yLmR5bmFtaWNQcm9wcztcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzVG9VcGRhdGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gcHJvcHNUb1VwZGF0ZVtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IG9sZFByb3BzW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBuZXdQcm9wc1trZXldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCAhPT0gcHJldiB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGhvc3RGb3JjZVBhdGNoUHJvcCAmJiBob3N0Rm9yY2VQYXRjaFByb3AoZWwsIGtleSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBrZXksIHByZXYsIG5leHQsIGlzU1ZHLCBuMS5jaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdW5tb3VudENoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB0ZXh0XHJcbiAgICAgICAgICAgIC8vIFRoaXMgZmxhZyBpcyBtYXRjaGVkIHdoZW4gdGhlIGVsZW1lbnQgaGFzIG9ubHkgZHluYW1pYyB0ZXh0IGNoaWxkcmVuLlxyXG4gICAgICAgICAgICBpZiAocGF0Y2hGbGFnICYgMSAvKiBURVhUICovKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobjEuY2hpbGRyZW4gIT09IG4yLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9zdFNldEVsZW1lbnRUZXh0KGVsLCBuMi5jaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIW9wdGltaXplZCAmJiBkeW5hbWljQ2hpbGRyZW4gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyB1bm9wdGltaXplZCwgZnVsbCBkaWZmXHJcbiAgICAgICAgICAgIHBhdGNoUHJvcHMoZWwsIG4yLCBvbGRQcm9wcywgbmV3UHJvcHMsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYXJlQ2hpbGRyZW5TVkcgPSBpc1NWRyAmJiBuMi50eXBlICE9PSAnZm9yZWlnbk9iamVjdCc7XHJcbiAgICAgICAgaWYgKGR5bmFtaWNDaGlsZHJlbikge1xyXG4gICAgICAgICAgICBwYXRjaEJsb2NrQ2hpbGRyZW4objEuZHluYW1pY0NoaWxkcmVuLCBkeW5hbWljQ2hpbGRyZW4sIGVsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBhcmVDaGlsZHJlblNWRywgc2xvdFNjb3BlSWRzKTtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBwYXJlbnRDb21wb25lbnQgJiYgcGFyZW50Q29tcG9uZW50LnR5cGUuX19obXJJZCkge1xyXG4gICAgICAgICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCFvcHRpbWl6ZWQpIHtcclxuICAgICAgICAgICAgLy8gZnVsbCBkaWZmXHJcbiAgICAgICAgICAgIHBhdGNoQ2hpbGRyZW4objEsIG4yLCBlbCwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgYXJlQ2hpbGRyZW5TVkcsIHNsb3RTY29wZUlkcywgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHZub2RlSG9vayA9IG5ld1Byb3BzLm9uVm5vZGVVcGRhdGVkKSB8fCBkaXJzKSB7XHJcbiAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZUhvb2sgJiYgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCBuMiwgbjEpO1xyXG4gICAgICAgICAgICAgICAgZGlycyAmJiBpbnZva2VEaXJlY3RpdmVIb29rKG4yLCBuMSwgcGFyZW50Q29tcG9uZW50LCAndXBkYXRlZCcpO1xyXG4gICAgICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFRoZSBmYXN0IHBhdGggZm9yIGJsb2Nrcy5cclxuICAgIGNvbnN0IHBhdGNoQmxvY2tDaGlsZHJlbiA9IChvbGRDaGlsZHJlbiwgbmV3Q2hpbGRyZW4sIGZhbGxiYWNrQ29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzKSA9PiB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBvbGRWTm9kZSA9IG9sZENoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICBjb25zdCBuZXdWTm9kZSA9IG5ld0NoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIGNvbnRhaW5lciAocGFyZW50IGVsZW1lbnQpIGZvciB0aGUgcGF0Y2guXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IFxyXG4gICAgICAgICAgICAvLyBvbGRWTm9kZSBtYXkgYmUgYW4gZXJyb3JlZCBhc3luYyBzZXR1cCgpIGNvbXBvbmVudCBpbnNpZGUgU3VzcGVuc2VcclxuICAgICAgICAgICAgLy8gd2hpY2ggd2lsbCBub3QgaGF2ZSBhIG1vdW50ZWQgZWxlbWVudFxyXG4gICAgICAgICAgICBvbGRWTm9kZS5lbCAmJlxyXG4gICAgICAgICAgICAgICAgLy8gLSBJbiB0aGUgY2FzZSBvZiBhIEZyYWdtZW50LCB3ZSBuZWVkIHRvIHByb3ZpZGUgdGhlIGFjdHVhbCBwYXJlbnRcclxuICAgICAgICAgICAgICAgIC8vIG9mIHRoZSBGcmFnbWVudCBpdHNlbGYgc28gaXQgY2FuIG1vdmUgaXRzIGNoaWxkcmVuLlxyXG4gICAgICAgICAgICAgICAgKG9sZFZOb2RlLnR5cGUgPT09IEZyYWdtZW50IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gLSBJbiB0aGUgY2FzZSBvZiBkaWZmZXJlbnQgbm9kZXMsIHRoZXJlIGlzIGdvaW5nIHRvIGJlIGEgcmVwbGFjZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCBhbHNvIHJlcXVpcmVzIHRoZSBjb3JyZWN0IHBhcmVudCBjb250YWluZXJcclxuICAgICAgICAgICAgICAgICAgICAhaXNTYW1lVk5vZGVUeXBlKG9sZFZOb2RlLCBuZXdWTm9kZSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAvLyAtIEluIHRoZSBjYXNlIG9mIGEgY29tcG9uZW50LCBpdCBjb3VsZCBjb250YWluIGFueXRoaW5nLlxyXG4gICAgICAgICAgICAgICAgICAgIG9sZFZOb2RlLnNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgb2xkVk5vZGUuc2hhcGVGbGFnICYgNjQgLyogVEVMRVBPUlQgKi8pXHJcbiAgICAgICAgICAgICAgICA/IGhvc3RQYXJlbnROb2RlKG9sZFZOb2RlLmVsKVxyXG4gICAgICAgICAgICAgICAgOiAvLyBJbiBvdGhlciBjYXNlcywgdGhlIHBhcmVudCBjb250YWluZXIgaXMgbm90IGFjdHVhbGx5IHVzZWQgc28gd2VcclxuICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IHBhc3MgdGhlIGJsb2NrIGVsZW1lbnQgaGVyZSB0byBhdm9pZCBhIERPTSBwYXJlbnROb2RlIGNhbGwuXHJcbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2tDb250YWluZXI7XHJcbiAgICAgICAgICAgIHBhdGNoKG9sZFZOb2RlLCBuZXdWTm9kZSwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcGF0Y2hQcm9wcyA9IChlbCwgdm5vZGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcpID0+IHtcclxuICAgICAgICBpZiAob2xkUHJvcHMgIT09IG5ld1Byb3BzKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5ld1Byb3BzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBlbXB0eSBzdHJpbmcgaXMgbm90IHZhbGlkIHByb3BcclxuICAgICAgICAgICAgICAgIGlmIChpc1Jlc2VydmVkUHJvcChrZXkpKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IG5ld1Byb3BzW2tleV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2ID0gb2xkUHJvcHNba2V5XTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9PSBwcmV2IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKGhvc3RGb3JjZVBhdGNoUHJvcCAmJiBob3N0Rm9yY2VQYXRjaFByb3AoZWwsIGtleSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwga2V5LCBwcmV2LCBuZXh0LCBpc1NWRywgdm5vZGUuY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9sZFByb3BzICE9PSBFTVBUWV9PQkopIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9sZFByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1Jlc2VydmVkUHJvcChrZXkpICYmICEoa2V5IGluIG5ld1Byb3BzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBrZXksIG9sZFByb3BzW2tleV0sIG51bGwsIGlzU1ZHLCB2bm9kZS5jaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdW5tb3VudENoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcHJvY2Vzc0ZyYWdtZW50ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGZyYWdtZW50U3RhcnRBbmNob3IgPSAobjIuZWwgPSBuMSA/IG4xLmVsIDogaG9zdENyZWF0ZVRleHQoJycpKTtcclxuICAgICAgICBjb25zdCBmcmFnbWVudEVuZEFuY2hvciA9IChuMi5hbmNob3IgPSBuMSA/IG4xLmFuY2hvciA6IGhvc3RDcmVhdGVUZXh0KCcnKSk7XHJcbiAgICAgICAgbGV0IHsgcGF0Y2hGbGFnLCBkeW5hbWljQ2hpbGRyZW4sIHNsb3RTY29wZUlkczogZnJhZ21lbnRTbG90U2NvcGVJZHMgfSA9IG4yO1xyXG4gICAgICAgIGlmIChkeW5hbWljQ2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgb3B0aW1pemVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBhIHNsb3QgZnJhZ21lbnQgd2l0aCA6c2xvdHRlZCBzY29wZSBpZHNcclxuICAgICAgICBpZiAoZnJhZ21lbnRTbG90U2NvcGVJZHMpIHtcclxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzID0gc2xvdFNjb3BlSWRzXHJcbiAgICAgICAgICAgICAgICA/IHNsb3RTY29wZUlkcy5jb25jYXQoZnJhZ21lbnRTbG90U2NvcGVJZHMpXHJcbiAgICAgICAgICAgICAgICA6IGZyYWdtZW50U2xvdFNjb3BlSWRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGlzSG1yVXBkYXRpbmcpIHtcclxuICAgICAgICAgICAgLy8gSE1SIHVwZGF0ZWQsIGZvcmNlIGZ1bGwgZGlmZlxyXG4gICAgICAgICAgICBwYXRjaEZsYWcgPSAwO1xyXG4gICAgICAgICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcclxuICAgICAgICAgICAgaG9zdEluc2VydChmcmFnbWVudFN0YXJ0QW5jaG9yLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoZnJhZ21lbnRFbmRBbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgLy8gYSBmcmFnbWVudCBjYW4gb25seSBoYXZlIGFycmF5IGNoaWxkcmVuXHJcbiAgICAgICAgICAgIC8vIHNpbmNlIHRoZXkgYXJlIGVpdGhlciBnZW5lcmF0ZWQgYnkgdGhlIGNvbXBpbGVyLCBvciBpbXBsaWNpdGx5IGNyZWF0ZWRcclxuICAgICAgICAgICAgLy8gZnJvbSBhcnJheXMuXHJcbiAgICAgICAgICAgIG1vdW50Q2hpbGRyZW4objIuY2hpbGRyZW4sIGNvbnRhaW5lciwgZnJhZ21lbnRFbmRBbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAocGF0Y2hGbGFnID4gMCAmJlxyXG4gICAgICAgICAgICAgICAgcGF0Y2hGbGFnICYgNjQgLyogU1RBQkxFX0ZSQUdNRU5UICovICYmXHJcbiAgICAgICAgICAgICAgICBkeW5hbWljQ2hpbGRyZW4gJiZcclxuICAgICAgICAgICAgICAgIC8vICMyNzE1IHRoZSBwcmV2aW91cyBmcmFnbWVudCBjb3VsZCd2ZSBiZWVuIGEgQkFJTGVkIG9uZSBhcyBhIHJlc3VsdFxyXG4gICAgICAgICAgICAgICAgLy8gb2YgcmVuZGVyU2xvdCgpIHdpdGggbm8gdmFsaWQgY2hpbGRyZW5cclxuICAgICAgICAgICAgICAgIG4xLmR5bmFtaWNDaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgLy8gYSBzdGFibGUgZnJhZ21lbnQgKHRlbXBsYXRlIHJvb3Qgb3IgPHRlbXBsYXRlIHYtZm9yPikgZG9lc24ndCBuZWVkIHRvXHJcbiAgICAgICAgICAgICAgICAvLyBwYXRjaCBjaGlsZHJlbiBvcmRlciwgYnV0IGl0IG1heSBjb250YWluIGR5bmFtaWNDaGlsZHJlbi5cclxuICAgICAgICAgICAgICAgIHBhdGNoQmxvY2tDaGlsZHJlbihuMS5keW5hbWljQ2hpbGRyZW4sIGR5bmFtaWNDaGlsZHJlbiwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzKTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgcGFyZW50Q29tcG9uZW50ICYmIHBhcmVudENvbXBvbmVudC50eXBlLl9faG1ySWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcclxuICAgICAgICAgICAgICAgIC8vICMyMDgwIGlmIHRoZSBzdGFibGUgZnJhZ21lbnQgaGFzIGEga2V5LCBpdCdzIGEgPHRlbXBsYXRlIHYtZm9yPiB0aGF0IG1heVxyXG4gICAgICAgICAgICAgICAgLy8gIGdldCBtb3ZlZCBhcm91bmQuIE1ha2Ugc3VyZSBhbGwgcm9vdCBsZXZlbCB2bm9kZXMgaW5oZXJpdCBlbC5cclxuICAgICAgICAgICAgICAgIC8vICMyMTM0IG9yIGlmIGl0J3MgYSBjb21wb25lbnQgcm9vdCwgaXQgbWF5IGFsc28gZ2V0IG1vdmVkIGFyb3VuZFxyXG4gICAgICAgICAgICAgICAgLy8gYXMgdGhlIGNvbXBvbmVudCBpcyBiZWluZyBtb3ZlZC5cclxuICAgICAgICAgICAgICAgIG4yLmtleSAhPSBudWxsIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKHBhcmVudENvbXBvbmVudCAmJiBuMiA9PT0gcGFyZW50Q29tcG9uZW50LnN1YlRyZWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIsIHRydWUgLyogc2hhbGxvdyAqLyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBrZXllZCAvIHVua2V5ZWQsIG9yIG1hbnVhbCBmcmFnbWVudHMuXHJcbiAgICAgICAgICAgICAgICAvLyBmb3Iga2V5ZWQgJiB1bmtleWVkLCBzaW5jZSB0aGV5IGFyZSBjb21waWxlciBnZW5lcmF0ZWQgZnJvbSB2LWZvcixcclxuICAgICAgICAgICAgICAgIC8vIGVhY2ggY2hpbGQgaXMgZ3VhcmFudGVlZCB0byBiZSBhIGJsb2NrIHNvIHRoZSBmcmFnbWVudCB3aWxsIG5ldmVyXHJcbiAgICAgICAgICAgICAgICAvLyBoYXZlIGR5bmFtaWNDaGlsZHJlbi5cclxuICAgICAgICAgICAgICAgIHBhdGNoQ2hpbGRyZW4objEsIG4yLCBjb250YWluZXIsIGZyYWdtZW50RW5kQW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHByb2Nlc3NDb21wb25lbnQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgbjIuc2xvdFNjb3BlSWRzID0gc2xvdFNjb3BlSWRzO1xyXG4gICAgICAgIGlmIChuMSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChuMi5zaGFwZUZsYWcgJiA1MTIgLyogQ09NUE9ORU5UX0tFUFRfQUxJVkUgKi8pIHtcclxuICAgICAgICAgICAgICAgIHBhcmVudENvbXBvbmVudC5jdHguYWN0aXZhdGUobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG1vdW50Q29tcG9uZW50KG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZUNvbXBvbmVudChuMSwgbjIsIG9wdGltaXplZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IG1vdW50Q29tcG9uZW50ID0gKGluaXRpYWxWTm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IChpbml0aWFsVk5vZGUuY29tcG9uZW50ID0gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2UoaW5pdGlhbFZOb2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlKSk7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpbnN0YW5jZS50eXBlLl9faG1ySWQpIHtcclxuICAgICAgICAgICAgcmVnaXN0ZXJITVIoaW5zdGFuY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHB1c2hXYXJuaW5nQ29udGV4dChpbml0aWFsVk5vZGUpO1xyXG4gICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBtb3VudGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpbmplY3QgcmVuZGVyZXIgaW50ZXJuYWxzIGZvciBrZWVwQWxpdmVcclxuICAgICAgICBpZiAoaXNLZWVwQWxpdmUoaW5pdGlhbFZOb2RlKSkge1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5jdHgucmVuZGVyZXIgPSBpbnRlcm5hbHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJlc29sdmUgcHJvcHMgYW5kIHNsb3RzIGZvciBzZXR1cCBjb250ZXh0XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBpbml0YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2V0dXBDb21wb25lbnQoaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgaW5pdGApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNldHVwKCkgaXMgYXN5bmMuIFRoaXMgY29tcG9uZW50IHJlbGllcyBvbiBhc3luYyBsb2dpYyB0byBiZSByZXNvbHZlZFxyXG4gICAgICAgIC8vIGJlZm9yZSBwcm9jZWVkaW5nXHJcbiAgICAgICAgaWYgKGluc3RhbmNlLmFzeW5jRGVwKSB7XHJcbiAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlICYmIHBhcmVudFN1c3BlbnNlLnJlZ2lzdGVyRGVwKGluc3RhbmNlLCBzZXR1cFJlbmRlckVmZmVjdCk7XHJcbiAgICAgICAgICAgIC8vIEdpdmUgaXQgYSBwbGFjZWhvbGRlciBpZiB0aGlzIGlzIG5vdCBoeWRyYXRpb25cclxuICAgICAgICAgICAgLy8gVE9ETyBoYW5kbGUgc2VsZi1kZWZpbmVkIGZhbGxiYWNrXHJcbiAgICAgICAgICAgIGlmICghaW5pdGlhbFZOb2RlLmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IChpbnN0YW5jZS5zdWJUcmVlID0gY3JlYXRlVk5vZGUoQ29tbWVudCQxKSk7XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzQ29tbWVudE5vZGUobnVsbCwgcGxhY2Vob2xkZXIsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldHVwUmVuZGVyRWZmZWN0KGluc3RhbmNlLCBpbml0aWFsVk5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCk7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xyXG4gICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgbW91bnRgKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgdXBkYXRlQ29tcG9uZW50ID0gKG4xLCBuMiwgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSAobjIuY29tcG9uZW50ID0gbjEuY29tcG9uZW50KTtcclxuICAgICAgICBpZiAoc2hvdWxkVXBkYXRlQ29tcG9uZW50KG4xLCBuMiwgb3B0aW1pemVkKSkge1xyXG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UuYXN5bmNEZXAgJiZcclxuICAgICAgICAgICAgICAgICFpbnN0YW5jZS5hc3luY1Jlc29sdmVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhc3luYyAmIHN0aWxsIHBlbmRpbmcgLSBqdXN0IHVwZGF0ZSBwcm9wcyBhbmQgc2xvdHNcclxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBjb21wb25lbnQncyByZWFjdGl2ZSBlZmZlY3QgZm9yIHJlbmRlciBpc24ndCBzZXQtdXAgeWV0XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KG4yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHVwZGF0ZUNvbXBvbmVudFByZVJlbmRlcihpbnN0YW5jZSwgbjIsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIG5vcm1hbCB1cGRhdGVcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLm5leHQgPSBuMjtcclxuICAgICAgICAgICAgICAgIC8vIGluIGNhc2UgdGhlIGNoaWxkIGNvbXBvbmVudCBpcyBhbHNvIHF1ZXVlZCwgcmVtb3ZlIGl0IHRvIGF2b2lkXHJcbiAgICAgICAgICAgICAgICAvLyBkb3VibGUgdXBkYXRpbmcgdGhlIHNhbWUgY2hpbGQgY29tcG9uZW50IGluIHRoZSBzYW1lIGZsdXNoLlxyXG4gICAgICAgICAgICAgICAgaW52YWxpZGF0ZUpvYihpbnN0YW5jZS51cGRhdGUpO1xyXG4gICAgICAgICAgICAgICAgLy8gaW5zdGFuY2UudXBkYXRlIGlzIHRoZSByZWFjdGl2ZSBlZmZlY3QgcnVubmVyLlxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UudXBkYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIG5vIHVwZGF0ZSBuZWVkZWQuIGp1c3QgY29weSBvdmVyIHByb3BlcnRpZXNcclxuICAgICAgICAgICAgbjIuY29tcG9uZW50ID0gbjEuY29tcG9uZW50O1xyXG4gICAgICAgICAgICBuMi5lbCA9IG4xLmVsO1xyXG4gICAgICAgICAgICBpbnN0YW5jZS52bm9kZSA9IG4yO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBzZXR1cFJlbmRlckVmZmVjdCA9IChpbnN0YW5jZSwgaW5pdGlhbFZOb2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICAvLyBjcmVhdGUgcmVhY3RpdmUgZWZmZWN0IGZvciByZW5kZXJpbmdcclxuICAgICAgICBpbnN0YW5jZS51cGRhdGUgPSBlZmZlY3QoZnVuY3Rpb24gY29tcG9uZW50RWZmZWN0KCkge1xyXG4gICAgICAgICAgICBpZiAoIWluc3RhbmNlLmlzTW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHZub2RlSG9vaztcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZWwsIHByb3BzIH0gPSBpbml0aWFsVk5vZGU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGJtLCBtLCBwYXJlbnQgfSA9IGluc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgLy8gYmVmb3JlTW91bnQgaG9va1xyXG4gICAgICAgICAgICAgICAgaWYgKGJtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlQXJyYXlGbnMoYm0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gb25Wbm9kZUJlZm9yZU1vdW50XHJcbiAgICAgICAgICAgICAgICBpZiAoKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVCZWZvcmVNb3VudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIGluaXRpYWxWTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZWwgJiYgaHlkcmF0ZU5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB2bm9kZSBoYXMgYWRvcHRlZCBob3N0IG5vZGUgLSBwZXJmb3JtIGh5ZHJhdGlvbiBpbnN0ZWFkIG9mIG1vdW50LlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGh5ZHJhdGVTdWJUcmVlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5zdWJUcmVlID0gcmVuZGVyQ29tcG9uZW50Um9vdChpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBoeWRyYXRlYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaHlkcmF0ZU5vZGUoZWwsIGluc3RhbmNlLnN1YlRyZWUsIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBoeWRyYXRlYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FzeW5jV3JhcHBlcihpbml0aWFsVk5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxWTm9kZS50eXBlLl9fYXN5bmNMb2FkZXIoKS50aGVuKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub3RlOiB3ZSBhcmUgbW92aW5nIHRoZSByZW5kZXIgY2FsbCBpbnRvIGFuIGFzeW5jIGNhbGxiYWNrLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCBtZWFucyBpdCB3b24ndCB0cmFjayBkZXBlbmRlbmNpZXMgLSBidXQgaXQncyBvayBiZWNhdXNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgc2VydmVyLXJlbmRlcmVkIGFzeW5jIHdyYXBwZXIgaXMgYWxyZWFkeSBpbiByZXNvbHZlZCBzdGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgaXQgd2lsbCBuZXZlciBuZWVkIHRvIGNoYW5nZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgKCkgPT4gIWluc3RhbmNlLmlzVW5tb3VudGVkICYmIGh5ZHJhdGVTdWJUcmVlKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaHlkcmF0ZVN1YlRyZWUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWJUcmVlID0gKGluc3RhbmNlLnN1YlRyZWUgPSByZW5kZXJDb21wb25lbnRSb290KGluc3RhbmNlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgcGF0Y2hgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2gobnVsbCwgc3ViVHJlZSwgY29udGFpbmVyLCBhbmNob3IsIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxWTm9kZS5lbCA9IHN1YlRyZWUuZWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBtb3VudGVkIGhvb2tcclxuICAgICAgICAgICAgICAgIGlmIChtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KG0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG9uVm5vZGVNb3VudGVkXHJcbiAgICAgICAgICAgICAgICBpZiAoKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVNb3VudGVkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjb3BlZEluaXRpYWxWTm9kZSA9IGluaXRpYWxWTm9kZTtcclxuICAgICAgICAgICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4gaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50LCBzY29wZWRJbml0aWFsVk5vZGUpLCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBhY3RpdmF0ZWQgaG9vayBmb3Iga2VlcC1hbGl2ZSByb290cy5cclxuICAgICAgICAgICAgICAgIC8vICMxNzQyIGFjdGl2YXRlZCBob29rIG11c3QgYmUgYWNjZXNzZWQgYWZ0ZXIgZmlyc3QgcmVuZGVyXHJcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGUgaG9vayBtYXkgYmUgaW5qZWN0ZWQgYnkgYSBjaGlsZCBrZWVwLWFsaXZlXHJcbiAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbFZOb2RlLnNoYXBlRmxhZyAmIDI1NiAvKiBDT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkUgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5hICYmIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChpbnN0YW5jZS5hLCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5pc01vdW50ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudEFkZGVkKGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vICMyNDU4OiBkZWZlcmVuY2UgbW91bnQtb25seSBvYmplY3QgcGFyYW1ldGVycyB0byBwcmV2ZW50IG1lbWxlYWtzXHJcbiAgICAgICAgICAgICAgICBpbml0aWFsVk5vZGUgPSBjb250YWluZXIgPSBhbmNob3IgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlQ29tcG9uZW50XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRyaWdnZXJlZCBieSBtdXRhdGlvbiBvZiBjb21wb25lbnQncyBvd24gc3RhdGUgKG5leHQ6IG51bGwpXHJcbiAgICAgICAgICAgICAgICAvLyBPUiBwYXJlbnQgY2FsbGluZyBwcm9jZXNzQ29tcG9uZW50IChuZXh0OiBWTm9kZSlcclxuICAgICAgICAgICAgICAgIGxldCB7IG5leHQsIGJ1LCB1LCBwYXJlbnQsIHZub2RlIH0gPSBpbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGxldCBvcmlnaW5OZXh0ID0gbmV4dDtcclxuICAgICAgICAgICAgICAgIGxldCB2bm9kZUhvb2s7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KG5leHQgfHwgaW5zdGFuY2Uudm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG5leHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0LmVsID0gdm5vZGUuZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ29tcG9uZW50UHJlUmVuZGVyKGluc3RhbmNlLCBuZXh0LCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHZub2RlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gYmVmb3JlVXBkYXRlIGhvb2tcclxuICAgICAgICAgICAgICAgIGlmIChidSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGludm9rZUFycmF5Rm5zKGJ1KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG9uVm5vZGVCZWZvcmVVcGRhdGVcclxuICAgICAgICAgICAgICAgIGlmICgodm5vZGVIb29rID0gbmV4dC5wcm9wcyAmJiBuZXh0LnByb3BzLm9uVm5vZGVCZWZvcmVVcGRhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50LCBuZXh0LCB2bm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyByZW5kZXJcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRUcmVlID0gcmVuZGVyQ29tcG9uZW50Um9vdChpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJldlRyZWUgPSBpbnN0YW5jZS5zdWJUcmVlO1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2Uuc3ViVHJlZSA9IG5leHRUcmVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwYXRjaChwcmV2VHJlZSwgbmV4dFRyZWUsIFxyXG4gICAgICAgICAgICAgICAgLy8gcGFyZW50IG1heSBoYXZlIGNoYW5nZWQgaWYgaXQncyBpbiBhIHRlbGVwb3J0XHJcbiAgICAgICAgICAgICAgICBob3N0UGFyZW50Tm9kZShwcmV2VHJlZS5lbCksIFxyXG4gICAgICAgICAgICAgICAgLy8gYW5jaG9yIG1heSBoYXZlIGNoYW5nZWQgaWYgaXQncyBpbiBhIGZyYWdtZW50XHJcbiAgICAgICAgICAgICAgICBnZXROZXh0SG9zdE5vZGUocHJldlRyZWUpLCBpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcGF0Y2hgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG5leHQuZWwgPSBuZXh0VHJlZS5lbDtcclxuICAgICAgICAgICAgICAgIGlmIChvcmlnaW5OZXh0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VsZi10cmlnZ2VyZWQgdXBkYXRlLiBJbiBjYXNlIG9mIEhPQywgdXBkYXRlIHBhcmVudCBjb21wb25lbnRcclxuICAgICAgICAgICAgICAgICAgICAvLyB2bm9kZSBlbC4gSE9DIGlzIGluZGljYXRlZCBieSBwYXJlbnQgaW5zdGFuY2UncyBzdWJUcmVlIHBvaW50aW5nXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gY2hpbGQgY29tcG9uZW50J3Mgdm5vZGVcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVIT0NIb3N0RWwoaW5zdGFuY2UsIG5leHRUcmVlLmVsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZWQgaG9va1xyXG4gICAgICAgICAgICAgICAgaWYgKHUpIHtcclxuICAgICAgICAgICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QodSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gb25Wbm9kZVVwZGF0ZWRcclxuICAgICAgICAgICAgICAgIGlmICgodm5vZGVIb29rID0gbmV4dC5wcm9wcyAmJiBuZXh0LnByb3BzLm9uVm5vZGVVcGRhdGVkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIG5leHQsIHZub2RlKSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudFVwZGF0ZWQoaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBjcmVhdGVEZXZFZmZlY3RPcHRpb25zKGluc3RhbmNlKSA6IHByb2RFZmZlY3RPcHRpb25zKTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICAgICAgaW5zdGFuY2UudXBkYXRlLm93bmVySW5zdGFuY2UgPSBpbnN0YW5jZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgdXBkYXRlQ29tcG9uZW50UHJlUmVuZGVyID0gKGluc3RhbmNlLCBuZXh0Vk5vZGUsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIG5leHRWTm9kZS5jb21wb25lbnQgPSBpbnN0YW5jZTtcclxuICAgICAgICBjb25zdCBwcmV2UHJvcHMgPSBpbnN0YW5jZS52bm9kZS5wcm9wcztcclxuICAgICAgICBpbnN0YW5jZS52bm9kZSA9IG5leHRWTm9kZTtcclxuICAgICAgICBpbnN0YW5jZS5uZXh0ID0gbnVsbDtcclxuICAgICAgICB1cGRhdGVQcm9wcyhpbnN0YW5jZSwgbmV4dFZOb2RlLnByb3BzLCBwcmV2UHJvcHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgdXBkYXRlU2xvdHMoaW5zdGFuY2UsIG5leHRWTm9kZS5jaGlsZHJlbiwgb3B0aW1pemVkKTtcclxuICAgICAgICBwYXVzZVRyYWNraW5nKCk7XHJcbiAgICAgICAgLy8gcHJvcHMgdXBkYXRlIG1heSBoYXZlIHRyaWdnZXJlZCBwcmUtZmx1c2ggd2F0Y2hlcnMuXHJcbiAgICAgICAgLy8gZmx1c2ggdGhlbSBiZWZvcmUgdGhlIHJlbmRlciB1cGRhdGUuXHJcbiAgICAgICAgZmx1c2hQcmVGbHVzaENicyh1bmRlZmluZWQsIGluc3RhbmNlLnVwZGF0ZSk7XHJcbiAgICAgICAgcmVzZXRUcmFja2luZygpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHBhdGNoQ2hpbGRyZW4gPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkID0gZmFsc2UpID0+IHtcclxuICAgICAgICBjb25zdCBjMSA9IG4xICYmIG4xLmNoaWxkcmVuO1xyXG4gICAgICAgIGNvbnN0IHByZXZTaGFwZUZsYWcgPSBuMSA/IG4xLnNoYXBlRmxhZyA6IDA7XHJcbiAgICAgICAgY29uc3QgYzIgPSBuMi5jaGlsZHJlbjtcclxuICAgICAgICBjb25zdCB7IHBhdGNoRmxhZywgc2hhcGVGbGFnIH0gPSBuMjtcclxuICAgICAgICAvLyBmYXN0IHBhdGhcclxuICAgICAgICBpZiAocGF0Y2hGbGFnID4gMCkge1xyXG4gICAgICAgICAgICBpZiAocGF0Y2hGbGFnICYgMTI4IC8qIEtFWUVEX0ZSQUdNRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNvdWxkIGJlIGVpdGhlciBmdWxseS1rZXllZCBvciBtaXhlZCAoc29tZSBrZXllZCBzb21lIG5vdClcclxuICAgICAgICAgICAgICAgIC8vIHByZXNlbmNlIG9mIHBhdGNoRmxhZyBtZWFucyBjaGlsZHJlbiBhcmUgZ3VhcmFudGVlZCB0byBiZSBhcnJheXNcclxuICAgICAgICAgICAgICAgIHBhdGNoS2V5ZWRDaGlsZHJlbihjMSwgYzIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHBhdGNoRmxhZyAmIDI1NiAvKiBVTktFWUVEX0ZSQUdNRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB1bmtleWVkXHJcbiAgICAgICAgICAgICAgICBwYXRjaFVua2V5ZWRDaGlsZHJlbihjMSwgYzIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNoaWxkcmVuIGhhcyAzIHBvc3NpYmlsaXRpZXM6IHRleHQsIGFycmF5IG9yIG5vIGNoaWxkcmVuLlxyXG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiA4IC8qIFRFWFRfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgLy8gdGV4dCBjaGlsZHJlbiBmYXN0IHBhdGhcclxuICAgICAgICAgICAgaWYgKHByZXZTaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAgICAgdW5tb3VudENoaWxkcmVuKGMxLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYzIgIT09IGMxKSB7XHJcbiAgICAgICAgICAgICAgICBob3N0U2V0RWxlbWVudFRleHQoY29udGFpbmVyLCBjMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChwcmV2U2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgICAgIC8vIHByZXYgY2hpbGRyZW4gd2FzIGFycmF5XHJcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB0d28gYXJyYXlzLCBjYW5ub3QgYXNzdW1lIGFueXRoaW5nLCBkbyBmdWxsIGRpZmZcclxuICAgICAgICAgICAgICAgICAgICBwYXRjaEtleWVkQ2hpbGRyZW4oYzEsIGMyLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vIG5ldyBjaGlsZHJlbiwganVzdCB1bm1vdW50IG9sZFxyXG4gICAgICAgICAgICAgICAgICAgIHVubW91bnRDaGlsZHJlbihjMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBwcmV2IGNoaWxkcmVuIHdhcyB0ZXh0IE9SIG51bGxcclxuICAgICAgICAgICAgICAgIC8vIG5ldyBjaGlsZHJlbiBpcyBhcnJheSBPUiBudWxsXHJcbiAgICAgICAgICAgICAgICBpZiAocHJldlNoYXBlRmxhZyAmIDggLyogVEVYVF9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChjb250YWluZXIsICcnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG1vdW50IG5ldyBpZiBhcnJheVxyXG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIEFSUkFZX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW91bnRDaGlsZHJlbihjMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcGF0Y2hVbmtleWVkQ2hpbGRyZW4gPSAoYzEsIGMyLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgYzEgPSBjMSB8fCBFTVBUWV9BUlI7XHJcbiAgICAgICAgYzIgPSBjMiB8fCBFTVBUWV9BUlI7XHJcbiAgICAgICAgY29uc3Qgb2xkTGVuZ3RoID0gYzEubGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IG5ld0xlbmd0aCA9IGMyLmxlbmd0aDtcclxuICAgICAgICBjb25zdCBjb21tb25MZW5ndGggPSBNYXRoLm1pbihvbGRMZW5ndGgsIG5ld0xlbmd0aCk7XHJcbiAgICAgICAgbGV0IGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbW1vbkxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IChjMltpXSA9IG9wdGltaXplZFxyXG4gICAgICAgICAgICAgICAgPyBjbG9uZUlmTW91bnRlZChjMltpXSlcclxuICAgICAgICAgICAgICAgIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pKTtcclxuICAgICAgICAgICAgcGF0Y2goYzFbaV0sIG5leHRDaGlsZCwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob2xkTGVuZ3RoID4gbmV3TGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSBvbGRcclxuICAgICAgICAgICAgdW5tb3VudENoaWxkcmVuKGMxLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlLCBmYWxzZSwgY29tbW9uTGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIG1vdW50IG5ld1xyXG4gICAgICAgICAgICBtb3VudENoaWxkcmVuKGMyLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCBjb21tb25MZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBjYW4gYmUgYWxsLWtleWVkIG9yIG1peGVkXHJcbiAgICBjb25zdCBwYXRjaEtleWVkQ2hpbGRyZW4gPSAoYzEsIGMyLCBjb250YWluZXIsIHBhcmVudEFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgIGNvbnN0IGwyID0gYzIubGVuZ3RoO1xyXG4gICAgICAgIGxldCBlMSA9IGMxLmxlbmd0aCAtIDE7IC8vIHByZXYgZW5kaW5nIGluZGV4XHJcbiAgICAgICAgbGV0IGUyID0gbDIgLSAxOyAvLyBuZXh0IGVuZGluZyBpbmRleFxyXG4gICAgICAgIC8vIDEuIHN5bmMgZnJvbSBzdGFydFxyXG4gICAgICAgIC8vIChhIGIpIGNcclxuICAgICAgICAvLyAoYSBiKSBkIGVcclxuICAgICAgICB3aGlsZSAoaSA8PSBlMSAmJiBpIDw9IGUyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG4xID0gYzFbaV07XHJcbiAgICAgICAgICAgIGNvbnN0IG4yID0gKGMyW2ldID0gb3B0aW1pemVkXHJcbiAgICAgICAgICAgICAgICA/IGNsb25lSWZNb3VudGVkKGMyW2ldKVxyXG4gICAgICAgICAgICAgICAgOiBub3JtYWxpemVWTm9kZShjMltpXSkpO1xyXG4gICAgICAgICAgICBpZiAoaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikpIHtcclxuICAgICAgICAgICAgICAgIHBhdGNoKG4xLCBuMiwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyAyLiBzeW5jIGZyb20gZW5kXHJcbiAgICAgICAgLy8gYSAoYiBjKVxyXG4gICAgICAgIC8vIGQgZSAoYiBjKVxyXG4gICAgICAgIHdoaWxlIChpIDw9IGUxICYmIGkgPD0gZTIpIHtcclxuICAgICAgICAgICAgY29uc3QgbjEgPSBjMVtlMV07XHJcbiAgICAgICAgICAgIGNvbnN0IG4yID0gKGMyW2UyXSA9IG9wdGltaXplZFxyXG4gICAgICAgICAgICAgICAgPyBjbG9uZUlmTW91bnRlZChjMltlMl0pXHJcbiAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZVZOb2RlKGMyW2UyXSkpO1xyXG4gICAgICAgICAgICBpZiAoaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikpIHtcclxuICAgICAgICAgICAgICAgIHBhdGNoKG4xLCBuMiwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZTEtLTtcclxuICAgICAgICAgICAgZTItLTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gMy4gY29tbW9uIHNlcXVlbmNlICsgbW91bnRcclxuICAgICAgICAvLyAoYSBiKVxyXG4gICAgICAgIC8vIChhIGIpIGNcclxuICAgICAgICAvLyBpID0gMiwgZTEgPSAxLCBlMiA9IDJcclxuICAgICAgICAvLyAoYSBiKVxyXG4gICAgICAgIC8vIGMgKGEgYilcclxuICAgICAgICAvLyBpID0gMCwgZTEgPSAtMSwgZTIgPSAwXHJcbiAgICAgICAgaWYgKGkgPiBlMSkge1xyXG4gICAgICAgICAgICBpZiAoaSA8PSBlMikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFBvcyA9IGUyICsgMTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IG5leHRQb3MgPCBsMiA/IGMyW25leHRQb3NdLmVsIDogcGFyZW50QW5jaG9yO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGkgPD0gZTIpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRjaChudWxsLCAoYzJbaV0gPSBvcHRpbWl6ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjbG9uZUlmTW91bnRlZChjMltpXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBub3JtYWxpemVWTm9kZShjMltpXSkpLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNC4gY29tbW9uIHNlcXVlbmNlICsgdW5tb3VudFxyXG4gICAgICAgIC8vIChhIGIpIGNcclxuICAgICAgICAvLyAoYSBiKVxyXG4gICAgICAgIC8vIGkgPSAyLCBlMSA9IDIsIGUyID0gMVxyXG4gICAgICAgIC8vIGEgKGIgYylcclxuICAgICAgICAvLyAoYiBjKVxyXG4gICAgICAgIC8vIGkgPSAwLCBlMSA9IDAsIGUyID0gLTFcclxuICAgICAgICBlbHNlIGlmIChpID4gZTIpIHtcclxuICAgICAgICAgICAgd2hpbGUgKGkgPD0gZTEpIHtcclxuICAgICAgICAgICAgICAgIHVubW91bnQoYzFbaV0sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDUuIHVua25vd24gc2VxdWVuY2VcclxuICAgICAgICAvLyBbaSAuLi4gZTEgKyAxXTogYSBiIFtjIGQgZV0gZiBnXHJcbiAgICAgICAgLy8gW2kgLi4uIGUyICsgMV06IGEgYiBbZSBkIGMgaF0gZiBnXHJcbiAgICAgICAgLy8gaSA9IDIsIGUxID0gNCwgZTIgPSA1XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHMxID0gaTsgLy8gcHJldiBzdGFydGluZyBpbmRleFxyXG4gICAgICAgICAgICBjb25zdCBzMiA9IGk7IC8vIG5leHQgc3RhcnRpbmcgaW5kZXhcclxuICAgICAgICAgICAgLy8gNS4xIGJ1aWxkIGtleTppbmRleCBtYXAgZm9yIG5ld0NoaWxkcmVuXHJcbiAgICAgICAgICAgIGNvbnN0IGtleVRvTmV3SW5kZXhNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IHMyOyBpIDw9IGUyOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IChjMltpXSA9IG9wdGltaXplZFxyXG4gICAgICAgICAgICAgICAgICAgID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pXHJcbiAgICAgICAgICAgICAgICAgICAgOiBub3JtYWxpemVWTm9kZShjMltpXSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHRDaGlsZC5rZXkgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYga2V5VG9OZXdJbmRleE1hcC5oYXMobmV4dENoaWxkLmtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgRHVwbGljYXRlIGtleXMgZm91bmQgZHVyaW5nIHVwZGF0ZTpgLCBKU09OLnN0cmluZ2lmeShuZXh0Q2hpbGQua2V5KSwgYE1ha2Ugc3VyZSBrZXlzIGFyZSB1bmlxdWUuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGtleVRvTmV3SW5kZXhNYXAuc2V0KG5leHRDaGlsZC5rZXksIGkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIDUuMiBsb29wIHRocm91Z2ggb2xkIGNoaWxkcmVuIGxlZnQgdG8gYmUgcGF0Y2hlZCBhbmQgdHJ5IHRvIHBhdGNoXHJcbiAgICAgICAgICAgIC8vIG1hdGNoaW5nIG5vZGVzICYgcmVtb3ZlIG5vZGVzIHRoYXQgYXJlIG5vIGxvbmdlciBwcmVzZW50XHJcbiAgICAgICAgICAgIGxldCBqO1xyXG4gICAgICAgICAgICBsZXQgcGF0Y2hlZCA9IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IHRvQmVQYXRjaGVkID0gZTIgLSBzMiArIDE7XHJcbiAgICAgICAgICAgIGxldCBtb3ZlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvLyB1c2VkIHRvIHRyYWNrIHdoZXRoZXIgYW55IG5vZGUgaGFzIG1vdmVkXHJcbiAgICAgICAgICAgIGxldCBtYXhOZXdJbmRleFNvRmFyID0gMDtcclxuICAgICAgICAgICAgLy8gd29ya3MgYXMgTWFwPG5ld0luZGV4LCBvbGRJbmRleD5cclxuICAgICAgICAgICAgLy8gTm90ZSB0aGF0IG9sZEluZGV4IGlzIG9mZnNldCBieSArMVxyXG4gICAgICAgICAgICAvLyBhbmQgb2xkSW5kZXggPSAwIGlzIGEgc3BlY2lhbCB2YWx1ZSBpbmRpY2F0aW5nIHRoZSBuZXcgbm9kZSBoYXNcclxuICAgICAgICAgICAgLy8gbm8gY29ycmVzcG9uZGluZyBvbGQgbm9kZS5cclxuICAgICAgICAgICAgLy8gdXNlZCBmb3IgZGV0ZXJtaW5pbmcgbG9uZ2VzdCBzdGFibGUgc3Vic2VxdWVuY2VcclxuICAgICAgICAgICAgY29uc3QgbmV3SW5kZXhUb09sZEluZGV4TWFwID0gbmV3IEFycmF5KHRvQmVQYXRjaGVkKTtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRvQmVQYXRjaGVkOyBpKyspXHJcbiAgICAgICAgICAgICAgICBuZXdJbmRleFRvT2xkSW5kZXhNYXBbaV0gPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSBzMTsgaSA8PSBlMTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2Q2hpbGQgPSBjMVtpXTtcclxuICAgICAgICAgICAgICAgIGlmIChwYXRjaGVkID49IHRvQmVQYXRjaGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWxsIG5ldyBjaGlsZHJlbiBoYXZlIGJlZW4gcGF0Y2hlZCBzbyB0aGlzIGNhbiBvbmx5IGJlIGEgcmVtb3ZhbFxyXG4gICAgICAgICAgICAgICAgICAgIHVubW91bnQocHJldkNoaWxkLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCBuZXdJbmRleDtcclxuICAgICAgICAgICAgICAgIGlmIChwcmV2Q2hpbGQua2V5ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdJbmRleCA9IGtleVRvTmV3SW5kZXhNYXAuZ2V0KHByZXZDaGlsZC5rZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8ga2V5LWxlc3Mgbm9kZSwgdHJ5IHRvIGxvY2F0ZSBhIGtleS1sZXNzIG5vZGUgb2YgdGhlIHNhbWUgdHlwZVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IHMyOyBqIDw9IGUyOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0luZGV4VG9PbGRJbmRleE1hcFtqIC0gczJdID09PSAwICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1NhbWVWTm9kZVR5cGUocHJldkNoaWxkLCBjMltqXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0luZGV4ID0gajtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG5ld0luZGV4ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB1bm1vdW50KHByZXZDaGlsZCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdJbmRleFRvT2xkSW5kZXhNYXBbbmV3SW5kZXggLSBzMl0gPSBpICsgMTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3SW5kZXggPj0gbWF4TmV3SW5kZXhTb0Zhcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhOZXdJbmRleFNvRmFyID0gbmV3SW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoKHByZXZDaGlsZCwgYzJbbmV3SW5kZXhdLCBjb250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hlZCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIDUuMyBtb3ZlIGFuZCBtb3VudFxyXG4gICAgICAgICAgICAvLyBnZW5lcmF0ZSBsb25nZXN0IHN0YWJsZSBzdWJzZXF1ZW5jZSBvbmx5IHdoZW4gbm9kZXMgaGF2ZSBtb3ZlZFxyXG4gICAgICAgICAgICBjb25zdCBpbmNyZWFzaW5nTmV3SW5kZXhTZXF1ZW5jZSA9IG1vdmVkXHJcbiAgICAgICAgICAgICAgICA/IGdldFNlcXVlbmNlKG5ld0luZGV4VG9PbGRJbmRleE1hcClcclxuICAgICAgICAgICAgICAgIDogRU1QVFlfQVJSO1xyXG4gICAgICAgICAgICBqID0gaW5jcmVhc2luZ05ld0luZGV4U2VxdWVuY2UubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgLy8gbG9vcGluZyBiYWNrd2FyZHMgc28gdGhhdCB3ZSBjYW4gdXNlIGxhc3QgcGF0Y2hlZCBub2RlIGFzIGFuY2hvclxyXG4gICAgICAgICAgICBmb3IgKGkgPSB0b0JlUGF0Y2hlZCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0SW5kZXggPSBzMiArIGk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0Q2hpbGQgPSBjMltuZXh0SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYW5jaG9yID0gbmV4dEluZGV4ICsgMSA8IGwyID8gYzJbbmV4dEluZGV4ICsgMV0uZWwgOiBwYXJlbnRBbmNob3I7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3SW5kZXhUb09sZEluZGV4TWFwW2ldID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbW91bnQgbmV3XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2gobnVsbCwgbmV4dENoaWxkLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1vdmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSBpZjpcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBzdGFibGUgc3Vic2VxdWVuY2UgKGUuZy4gYSByZXZlcnNlKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE9SIGN1cnJlbnQgbm9kZSBpcyBub3QgYW1vbmcgdGhlIHN0YWJsZSBzZXF1ZW5jZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqIDwgMCB8fCBpICE9PSBpbmNyZWFzaW5nTmV3SW5kZXhTZXF1ZW5jZVtqXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlKG5leHRDaGlsZCwgY29udGFpbmVyLCBhbmNob3IsIDIgLyogUkVPUkRFUiAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqLS07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IG1vdmUgPSAodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSwgcGFyZW50U3VzcGVuc2UgPSBudWxsKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBlbCwgdHlwZSwgdHJhbnNpdGlvbiwgY2hpbGRyZW4sIHNoYXBlRmxhZyB9ID0gdm5vZGU7XHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovKSB7XHJcbiAgICAgICAgICAgIG1vdmUodm5vZGUuY29tcG9uZW50LnN1YlRyZWUsIGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEyOCAvKiBTVVNQRU5TRSAqLykge1xyXG4gICAgICAgICAgICB2bm9kZS5zdXNwZW5zZS5tb3ZlKGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDY0IC8qIFRFTEVQT1JUICovKSB7XHJcbiAgICAgICAgICAgIHR5cGUubW92ZSh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIGludGVybmFscyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IEZyYWdtZW50KSB7XHJcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbW92ZShjaGlsZHJlbltpXSwgY29udGFpbmVyLCBhbmNob3IsIG1vdmVUeXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBob3N0SW5zZXJ0KHZub2RlLmFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlID09PSBTdGF0aWMpIHtcclxuICAgICAgICAgICAgbW92ZVN0YXRpY05vZGUodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzaW5nbGUgbm9kZXNcclxuICAgICAgICBjb25zdCBuZWVkVHJhbnNpdGlvbiA9IG1vdmVUeXBlICE9PSAyIC8qIFJFT1JERVIgKi8gJiZcclxuICAgICAgICAgICAgc2hhcGVGbGFnICYgMSAvKiBFTEVNRU5UICovICYmXHJcbiAgICAgICAgICAgIHRyYW5zaXRpb247XHJcbiAgICAgICAgaWYgKG5lZWRUcmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmIChtb3ZlVHlwZSA9PT0gMCAvKiBFTlRFUiAqLykge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihlbCk7XHJcbiAgICAgICAgICAgICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4gdHJhbnNpdGlvbi5lbnRlcihlbCksIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgbGVhdmUsIGRlbGF5TGVhdmUsIGFmdGVyTGVhdmUgfSA9IHRyYW5zaXRpb247XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZW1vdmUgPSAoKSA9PiBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwZXJmb3JtTGVhdmUgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVhdmUoZWwsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGlmIChkZWxheUxlYXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsYXlMZWF2ZShlbCwgcmVtb3ZlLCBwZXJmb3JtTGVhdmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGVyZm9ybUxlYXZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgdW5tb3VudCA9ICh2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUgPSBmYWxzZSwgb3B0aW1pemVkID0gZmFsc2UpID0+IHtcclxuICAgICAgICBjb25zdCB7IHR5cGUsIHByb3BzLCByZWYsIGNoaWxkcmVuLCBkeW5hbWljQ2hpbGRyZW4sIHNoYXBlRmxhZywgcGF0Y2hGbGFnLCBkaXJzIH0gPSB2bm9kZTtcclxuICAgICAgICAvLyB1bnNldCByZWZcclxuICAgICAgICBpZiAocmVmICE9IG51bGwpIHtcclxuICAgICAgICAgICAgc2V0UmVmKHJlZiwgbnVsbCwgcGFyZW50U3VzcGVuc2UsIHZub2RlLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDI1NiAvKiBDT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkUgKi8pIHtcclxuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LmN0eC5kZWFjdGl2YXRlKHZub2RlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzaG91bGRJbnZva2VEaXJzID0gc2hhcGVGbGFnICYgMSAvKiBFTEVNRU5UICovICYmIGRpcnM7XHJcbiAgICAgICAgbGV0IHZub2RlSG9vaztcclxuICAgICAgICBpZiAoKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVCZWZvcmVVbm1vdW50KSkge1xyXG4gICAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovKSB7XHJcbiAgICAgICAgICAgIHVubW91bnRDb21wb25lbnQodm5vZGUuY29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEyOCAvKiBTVVNQRU5TRSAqLykge1xyXG4gICAgICAgICAgICAgICAgdm5vZGUuc3VzcGVuc2UudW5tb3VudChwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzaG91bGRJbnZva2VEaXJzKSB7XHJcbiAgICAgICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICdiZWZvcmVVbm1vdW50Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDY0IC8qIFRFTEVQT1JUICovKSB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZS50eXBlLnJlbW92ZSh2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgb3B0aW1pemVkLCBpbnRlcm5hbHMsIGRvUmVtb3ZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkeW5hbWljQ2hpbGRyZW4gJiZcclxuICAgICAgICAgICAgICAgIC8vICMxMTUzOiBmYXN0IHBhdGggc2hvdWxkIG5vdCBiZSB0YWtlbiBmb3Igbm9uLXN0YWJsZSAodi1mb3IpIGZyYWdtZW50c1xyXG4gICAgICAgICAgICAgICAgKHR5cGUgIT09IEZyYWdtZW50IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKHBhdGNoRmxhZyA+IDAgJiYgcGF0Y2hGbGFnICYgNjQgLyogU1RBQkxFX0ZSQUdNRU5UICovKSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIGZhc3QgcGF0aCBmb3IgYmxvY2sgbm9kZXM6IG9ubHkgbmVlZCB0byB1bm1vdW50IGR5bmFtaWMgY2hpbGRyZW4uXHJcbiAgICAgICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4oZHluYW1pY0NoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBmYWxzZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoKHR5cGUgPT09IEZyYWdtZW50ICYmXHJcbiAgICAgICAgICAgICAgICAocGF0Y2hGbGFnICYgMTI4IC8qIEtFWUVEX0ZSQUdNRU5UICovIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hGbGFnICYgMjU2IC8qIFVOS0VZRURfRlJBR01FTlQgKi8pKSB8fFxyXG4gICAgICAgICAgICAgICAgKCFvcHRpbWl6ZWQgJiYgc2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pKSB7XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4oY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkb1JlbW92ZSkge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlKHZub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVVbm1vdW50ZWQpIHx8IHNob3VsZEludm9rZURpcnMpIHtcclxuICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHZub2RlSG9vayAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcclxuICAgICAgICAgICAgICAgIHNob3VsZEludm9rZURpcnMgJiZcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICd1bm1vdW50ZWQnKTtcclxuICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCByZW1vdmUgPSB2bm9kZSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyB0eXBlLCBlbCwgYW5jaG9yLCB0cmFuc2l0aW9uIH0gPSB2bm9kZTtcclxuICAgICAgICBpZiAodHlwZSA9PT0gRnJhZ21lbnQpIHtcclxuICAgICAgICAgICAgcmVtb3ZlRnJhZ21lbnQoZWwsIGFuY2hvcik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IFN0YXRpYykge1xyXG4gICAgICAgICAgICByZW1vdmVTdGF0aWNOb2RlKHZub2RlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwZXJmb3JtUmVtb3ZlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBob3N0UmVtb3ZlKGVsKTtcclxuICAgICAgICAgICAgaWYgKHRyYW5zaXRpb24gJiYgIXRyYW5zaXRpb24ucGVyc2lzdGVkICYmIHRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSkge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbi5hZnRlckxlYXZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxIC8qIEVMRU1FTlQgKi8gJiZcclxuICAgICAgICAgICAgdHJhbnNpdGlvbiAmJlxyXG4gICAgICAgICAgICAhdHJhbnNpdGlvbi5wZXJzaXN0ZWQpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBsZWF2ZSwgZGVsYXlMZWF2ZSB9ID0gdHJhbnNpdGlvbjtcclxuICAgICAgICAgICAgY29uc3QgcGVyZm9ybUxlYXZlID0gKCkgPT4gbGVhdmUoZWwsIHBlcmZvcm1SZW1vdmUpO1xyXG4gICAgICAgICAgICBpZiAoZGVsYXlMZWF2ZSkge1xyXG4gICAgICAgICAgICAgICAgZGVsYXlMZWF2ZSh2bm9kZS5lbCwgcGVyZm9ybVJlbW92ZSwgcGVyZm9ybUxlYXZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBlcmZvcm1MZWF2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwZXJmb3JtUmVtb3ZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlbW92ZUZyYWdtZW50ID0gKGN1ciwgZW5kKSA9PiB7XHJcbiAgICAgICAgLy8gRm9yIGZyYWdtZW50cywgZGlyZWN0bHkgcmVtb3ZlIGFsbCBjb250YWluZWQgRE9NIG5vZGVzLlxyXG4gICAgICAgIC8vIChmcmFnbWVudCBjaGlsZCBub2RlcyBjYW5ub3QgaGF2ZSB0cmFuc2l0aW9uKVxyXG4gICAgICAgIGxldCBuZXh0O1xyXG4gICAgICAgIHdoaWxlIChjdXIgIT09IGVuZCkge1xyXG4gICAgICAgICAgICBuZXh0ID0gaG9zdE5leHRTaWJsaW5nKGN1cik7XHJcbiAgICAgICAgICAgIGhvc3RSZW1vdmUoY3VyKTtcclxuICAgICAgICAgICAgY3VyID0gbmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaG9zdFJlbW92ZShlbmQpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHVubW91bnRDb21wb25lbnQgPSAoaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSkgPT4ge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaW5zdGFuY2UudHlwZS5fX2htcklkKSB7XHJcbiAgICAgICAgICAgIHVucmVnaXN0ZXJITVIoaW5zdGFuY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7IGJ1bSwgZWZmZWN0cywgdXBkYXRlLCBzdWJUcmVlLCB1bSB9ID0gaW5zdGFuY2U7XHJcbiAgICAgICAgLy8gYmVmb3JlVW5tb3VudCBob29rXHJcbiAgICAgICAgaWYgKGJ1bSkge1xyXG4gICAgICAgICAgICBpbnZva2VBcnJheUZucyhidW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZWZmZWN0cykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVmZmVjdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHN0b3AoZWZmZWN0c1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdXBkYXRlIG1heSBiZSBudWxsIGlmIGEgY29tcG9uZW50IGlzIHVubW91bnRlZCBiZWZvcmUgaXRzIGFzeW5jXHJcbiAgICAgICAgLy8gc2V0dXAgaGFzIHJlc29sdmVkLlxyXG4gICAgICAgIGlmICh1cGRhdGUpIHtcclxuICAgICAgICAgICAgc3RvcCh1cGRhdGUpO1xyXG4gICAgICAgICAgICB1bm1vdW50KHN1YlRyZWUsIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB1bm1vdW50ZWQgaG9va1xyXG4gICAgICAgIGlmICh1bSkge1xyXG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QodW0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgaW5zdGFuY2UuaXNVbm1vdW50ZWQgPSB0cnVlO1xyXG4gICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAvLyBBIGNvbXBvbmVudCB3aXRoIGFzeW5jIGRlcCBpbnNpZGUgYSBwZW5kaW5nIHN1c3BlbnNlIGlzIHVubW91bnRlZCBiZWZvcmVcclxuICAgICAgICAvLyBpdHMgYXN5bmMgZGVwIHJlc29sdmVzLiBUaGlzIHNob3VsZCByZW1vdmUgdGhlIGRlcCBmcm9tIHRoZSBzdXNwZW5zZSwgYW5kXHJcbiAgICAgICAgLy8gY2F1c2UgdGhlIHN1c3BlbnNlIHRvIHJlc29sdmUgaW1tZWRpYXRlbHkgaWYgdGhhdCB3YXMgdGhlIGxhc3QgZGVwLlxyXG4gICAgICAgIGlmIChwYXJlbnRTdXNwZW5zZSAmJlxyXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nQnJhbmNoICYmXHJcbiAgICAgICAgICAgICFwYXJlbnRTdXNwZW5zZS5pc1VubW91bnRlZCAmJlxyXG4gICAgICAgICAgICBpbnN0YW5jZS5hc3luY0RlcCAmJlxyXG4gICAgICAgICAgICAhaW5zdGFuY2UuYXN5bmNSZXNvbHZlZCAmJlxyXG4gICAgICAgICAgICBpbnN0YW5jZS5zdXNwZW5zZUlkID09PSBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nSWQpIHtcclxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UuZGVwcy0tO1xyXG4gICAgICAgICAgICBpZiAocGFyZW50U3VzcGVuc2UuZGVwcyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgIGRldnRvb2xzQ29tcG9uZW50UmVtb3ZlZChpbnN0YW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHVubW91bnRDaGlsZHJlbiA9IChjaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUgPSBmYWxzZSwgb3B0aW1pemVkID0gZmFsc2UsIHN0YXJ0ID0gMCkgPT4ge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHVubW91bnQoY2hpbGRyZW5baV0sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBnZXROZXh0SG9zdE5vZGUgPSB2bm9kZSA9PiB7XHJcbiAgICAgICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXROZXh0SG9zdE5vZGUodm5vZGUuY29tcG9uZW50LnN1YlRyZWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2bm9kZS5zdXNwZW5zZS5uZXh0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBob3N0TmV4dFNpYmxpbmcoKHZub2RlLmFuY2hvciB8fCB2bm9kZS5lbCkpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlbmRlciA9ICh2bm9kZSwgY29udGFpbmVyLCBpc1NWRykgPT4ge1xyXG4gICAgICAgIGlmICh2bm9kZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChjb250YWluZXIuX3Zub2RlKSB7XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50KGNvbnRhaW5lci5fdm5vZGUsIG51bGwsIG51bGwsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwYXRjaChjb250YWluZXIuX3Zub2RlIHx8IG51bGwsIHZub2RlLCBjb250YWluZXIsIG51bGwsIG51bGwsIG51bGwsIGlzU1ZHKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmx1c2hQb3N0Rmx1c2hDYnMoKTtcclxuICAgICAgICBjb250YWluZXIuX3Zub2RlID0gdm5vZGU7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgaW50ZXJuYWxzID0ge1xyXG4gICAgICAgIHA6IHBhdGNoLFxyXG4gICAgICAgIHVtOiB1bm1vdW50LFxyXG4gICAgICAgIG06IG1vdmUsXHJcbiAgICAgICAgcjogcmVtb3ZlLFxyXG4gICAgICAgIG10OiBtb3VudENvbXBvbmVudCxcclxuICAgICAgICBtYzogbW91bnRDaGlsZHJlbixcclxuICAgICAgICBwYzogcGF0Y2hDaGlsZHJlbixcclxuICAgICAgICBwYmM6IHBhdGNoQmxvY2tDaGlsZHJlbixcclxuICAgICAgICBuOiBnZXROZXh0SG9zdE5vZGUsXHJcbiAgICAgICAgbzogb3B0aW9uc1xyXG4gICAgfTtcclxuICAgIGxldCBoeWRyYXRlO1xyXG4gICAgbGV0IGh5ZHJhdGVOb2RlO1xyXG4gICAgaWYgKGNyZWF0ZUh5ZHJhdGlvbkZucykge1xyXG4gICAgICAgIFtoeWRyYXRlLCBoeWRyYXRlTm9kZV0gPSBjcmVhdGVIeWRyYXRpb25GbnMoaW50ZXJuYWxzKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVuZGVyLFxyXG4gICAgICAgIGh5ZHJhdGUsXHJcbiAgICAgICAgY3JlYXRlQXBwOiBjcmVhdGVBcHBBUEkocmVuZGVyLCBoeWRyYXRlKVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBpbnZva2VWTm9kZUhvb2soaG9vaywgaW5zdGFuY2UsIHZub2RlLCBwcmV2Vk5vZGUgPSBudWxsKSB7XHJcbiAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCBpbnN0YW5jZSwgNyAvKiBWTk9ERV9IT09LICovLCBbXHJcbiAgICAgICAgdm5vZGUsXHJcbiAgICAgICAgcHJldlZOb2RlXHJcbiAgICBdKTtcclxufVxyXG4vKipcclxuICogIzExNTZcclxuICogV2hlbiBhIGNvbXBvbmVudCBpcyBITVItZW5hYmxlZCwgd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhhdCBhbGwgc3RhdGljIG5vZGVzXHJcbiAqIGluc2lkZSBhIGJsb2NrIGFsc28gaW5oZXJpdCB0aGUgRE9NIGVsZW1lbnQgZnJvbSB0aGUgcHJldmlvdXMgdHJlZSBzbyB0aGF0XHJcbiAqIEhNUiB1cGRhdGVzICh3aGljaCBhcmUgZnVsbCB1cGRhdGVzKSBjYW4gcmV0cmlldmUgdGhlIGVsZW1lbnQgZm9yIHBhdGNoaW5nLlxyXG4gKlxyXG4gKiAjMjA4MFxyXG4gKiBJbnNpZGUga2V5ZWQgYHRlbXBsYXRlYCBmcmFnbWVudCBzdGF0aWMgY2hpbGRyZW4sIGlmIGEgZnJhZ21lbnQgaXMgbW92ZWQsXHJcbiAqIHRoZSBjaGlsZHJlbiB3aWxsIGFsd2F5cyBtb3ZlZCBzbyB0aGF0IG5lZWQgaW5oZXJpdCBlbCBmb3JtIHByZXZpb3VzIG5vZGVzXHJcbiAqIHRvIGVuc3VyZSBjb3JyZWN0IG1vdmVkIHBvc2l0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIsIHNoYWxsb3cgPSBmYWxzZSkge1xyXG4gICAgY29uc3QgY2gxID0gbjEuY2hpbGRyZW47XHJcbiAgICBjb25zdCBjaDIgPSBuMi5jaGlsZHJlbjtcclxuICAgIGlmIChpc0FycmF5KGNoMSkgJiYgaXNBcnJheShjaDIpKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaDEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gdGhpcyBpcyBvbmx5IGNhbGxlZCBpbiB0aGUgb3B0aW1pemVkIHBhdGggc28gYXJyYXkgY2hpbGRyZW4gYXJlXHJcbiAgICAgICAgICAgIC8vIGd1YXJhbnRlZWQgdG8gYmUgdm5vZGVzXHJcbiAgICAgICAgICAgIGNvbnN0IGMxID0gY2gxW2ldO1xyXG4gICAgICAgICAgICBsZXQgYzIgPSBjaDJbaV07XHJcbiAgICAgICAgICAgIGlmIChjMi5zaGFwZUZsYWcgJiAxIC8qIEVMRU1FTlQgKi8gJiYgIWMyLmR5bmFtaWNDaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGMyLnBhdGNoRmxhZyA8PSAwIHx8IGMyLnBhdGNoRmxhZyA9PT0gMzIgLyogSFlEUkFURV9FVkVOVFMgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBjMiA9IGNoMltpXSA9IGNsb25lSWZNb3VudGVkKGNoMltpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYzIuZWwgPSBjMS5lbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghc2hhbGxvdylcclxuICAgICAgICAgICAgICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKGMxLCBjMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gYWxzbyBpbmhlcml0IGZvciBjb21tZW50IG5vZGVzLCBidXQgbm90IHBsYWNlaG9sZGVycyAoZS5nLiB2LWlmIHdoaWNoXHJcbiAgICAgICAgICAgIC8vIHdvdWxkIGhhdmUgcmVjZWl2ZWQgLmVsIGR1cmluZyBibG9jayBwYXRjaClcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjMi50eXBlID09PSBDb21tZW50JDEgJiYgIWMyLmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjMi5lbCA9IGMxLmVsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xvbmdlc3RfaW5jcmVhc2luZ19zdWJzZXF1ZW5jZVxyXG5mdW5jdGlvbiBnZXRTZXF1ZW5jZShhcnIpIHtcclxuICAgIGNvbnN0IHAgPSBhcnIuc2xpY2UoKTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IFswXTtcclxuICAgIGxldCBpLCBqLCB1LCB2LCBjO1xyXG4gICAgY29uc3QgbGVuID0gYXJyLmxlbmd0aDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGFyckkgPSBhcnJbaV07XHJcbiAgICAgICAgaWYgKGFyckkgIT09IDApIHtcclxuICAgICAgICAgICAgaiA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIGlmIChhcnJbal0gPCBhcnJJKSB7XHJcbiAgICAgICAgICAgICAgICBwW2ldID0gajtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGkpO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdSA9IDA7XHJcbiAgICAgICAgICAgIHYgPSByZXN1bHQubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgd2hpbGUgKHUgPCB2KSB7XHJcbiAgICAgICAgICAgICAgICBjID0gKCh1ICsgdikgLyAyKSB8IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJyW3Jlc3VsdFtjXV0gPCBhcnJJKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdSA9IGMgKyAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdiA9IGM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGFyckkgPCBhcnJbcmVzdWx0W3VdXSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHUgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcFtpXSA9IHJlc3VsdFt1IC0gMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbdV0gPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdSA9IHJlc3VsdC5sZW5ndGg7XHJcbiAgICB2ID0gcmVzdWx0W3UgLSAxXTtcclxuICAgIHdoaWxlICh1LS0gPiAwKSB7XHJcbiAgICAgICAgcmVzdWx0W3VdID0gdjtcclxuICAgICAgICB2ID0gcFt2XTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cblxuY29uc3QgaXNUZWxlcG9ydCA9ICh0eXBlKSA9PiB0eXBlLl9faXNUZWxlcG9ydDtcclxuY29uc3QgaXNUZWxlcG9ydERpc2FibGVkID0gKHByb3BzKSA9PiBwcm9wcyAmJiAocHJvcHMuZGlzYWJsZWQgfHwgcHJvcHMuZGlzYWJsZWQgPT09ICcnKTtcclxuY29uc3QgaXNUYXJnZXRTVkcgPSAodGFyZ2V0KSA9PiB0eXBlb2YgU1ZHRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdGFyZ2V0IGluc3RhbmNlb2YgU1ZHRWxlbWVudDtcclxuY29uc3QgcmVzb2x2ZVRhcmdldCA9IChwcm9wcywgc2VsZWN0KSA9PiB7XHJcbiAgICBjb25zdCB0YXJnZXRTZWxlY3RvciA9IHByb3BzICYmIHByb3BzLnRvO1xyXG4gICAgaWYgKGlzU3RyaW5nKHRhcmdldFNlbGVjdG9yKSkge1xyXG4gICAgICAgIGlmICghc2VsZWN0KSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgd2FybihgQ3VycmVudCByZW5kZXJlciBkb2VzIG5vdCBzdXBwb3J0IHN0cmluZyB0YXJnZXQgZm9yIFRlbGVwb3J0cy4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYChtaXNzaW5nIHF1ZXJ5U2VsZWN0b3IgcmVuZGVyZXIgb3B0aW9uKWApO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHNlbGVjdCh0YXJnZXRTZWxlY3Rvcik7XHJcbiAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBGYWlsZWQgdG8gbG9jYXRlIFRlbGVwb3J0IHRhcmdldCB3aXRoIHNlbGVjdG9yIFwiJHt0YXJnZXRTZWxlY3Rvcn1cIi4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBOb3RlIHRoZSB0YXJnZXQgZWxlbWVudCBtdXN0IGV4aXN0IGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQgLSBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYGkuZS4gdGhlIHRhcmdldCBjYW5ub3QgYmUgcmVuZGVyZWQgYnkgdGhlIGNvbXBvbmVudCBpdHNlbGYsIGFuZCBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYGlkZWFsbHkgc2hvdWxkIGJlIG91dHNpZGUgb2YgdGhlIGVudGlyZSBWdWUgY29tcG9uZW50IHRyZWUuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICF0YXJnZXRTZWxlY3RvciAmJiAhaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKSkge1xyXG4gICAgICAgICAgICB3YXJuKGBJbnZhbGlkIFRlbGVwb3J0IHRhcmdldDogJHt0YXJnZXRTZWxlY3Rvcn1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldFNlbGVjdG9yO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBUZWxlcG9ydEltcGwgPSB7XHJcbiAgICBfX2lzVGVsZXBvcnQ6IHRydWUsXHJcbiAgICBwcm9jZXNzKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgaW50ZXJuYWxzKSB7XHJcbiAgICAgICAgY29uc3QgeyBtYzogbW91bnRDaGlsZHJlbiwgcGM6IHBhdGNoQ2hpbGRyZW4sIHBiYzogcGF0Y2hCbG9ja0NoaWxkcmVuLCBvOiB7IGluc2VydCwgcXVlcnlTZWxlY3RvciwgY3JlYXRlVGV4dCwgY3JlYXRlQ29tbWVudCB9IH0gPSBpbnRlcm5hbHM7XHJcbiAgICAgICAgY29uc3QgZGlzYWJsZWQgPSBpc1RlbGVwb3J0RGlzYWJsZWQobjIucHJvcHMpO1xyXG4gICAgICAgIGxldCB7IHNoYXBlRmxhZywgY2hpbGRyZW4sIGR5bmFtaWNDaGlsZHJlbiB9ID0gbjI7XHJcbiAgICAgICAgLy8gIzMzMDJcclxuICAgICAgICAvLyBITVIgdXBkYXRlZCwgZm9yY2UgZnVsbCBkaWZmXHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpc0htclVwZGF0aW5nKSB7XHJcbiAgICAgICAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBkeW5hbWljQ2hpbGRyZW4gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBpbnNlcnQgYW5jaG9ycyBpbiB0aGUgbWFpbiB2aWV3XHJcbiAgICAgICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gKG4yLmVsID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgICAgICAgICA/IGNyZWF0ZUNvbW1lbnQoJ3RlbGVwb3J0IHN0YXJ0JylcclxuICAgICAgICAgICAgICAgIDogY3JlYXRlVGV4dCgnJykpO1xyXG4gICAgICAgICAgICBjb25zdCBtYWluQW5jaG9yID0gKG4yLmFuY2hvciA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgICAgICAgICAgICAgPyBjcmVhdGVDb21tZW50KCd0ZWxlcG9ydCBlbmQnKVxyXG4gICAgICAgICAgICAgICAgOiBjcmVhdGVUZXh0KCcnKSk7XHJcbiAgICAgICAgICAgIGluc2VydChwbGFjZWhvbGRlciwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICBpbnNlcnQobWFpbkFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSAobjIudGFyZ2V0ID0gcmVzb2x2ZVRhcmdldChuMi5wcm9wcywgcXVlcnlTZWxlY3RvcikpO1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRBbmNob3IgPSAobjIudGFyZ2V0QW5jaG9yID0gY3JlYXRlVGV4dCgnJykpO1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICBpbnNlcnQodGFyZ2V0QW5jaG9yLCB0YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgLy8gIzI2NTIgd2UgY291bGQgYmUgdGVsZXBvcnRpbmcgZnJvbSBhIG5vbi1TVkcgdHJlZSBpbnRvIGFuIFNWRyB0cmVlXHJcbiAgICAgICAgICAgICAgICBpc1NWRyA9IGlzU1ZHIHx8IGlzVGFyZ2V0U1ZHKHRhcmdldCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFkaXNhYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgd2FybignSW52YWxpZCBUZWxlcG9ydCB0YXJnZXQgb24gbW91bnQ6JywgdGFyZ2V0LCBgKCR7dHlwZW9mIHRhcmdldH0pYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbW91bnQgPSAoY29udGFpbmVyLCBhbmNob3IpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFRlbGVwb3J0ICphbHdheXMqIGhhcyBBcnJheSBjaGlsZHJlbi4gVGhpcyBpcyBlbmZvcmNlZCBpbiBib3RoIHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gY29tcGlsZXIgYW5kIHZub2RlIGNoaWxkcmVuIG5vcm1hbGl6YXRpb24uXHJcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBtb3VudENoaWxkcmVuKGNoaWxkcmVuLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKGRpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICBtb3VudChjb250YWluZXIsIG1haW5BbmNob3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgbW91bnQodGFyZ2V0LCB0YXJnZXRBbmNob3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB1cGRhdGUgY29udGVudFxyXG4gICAgICAgICAgICBuMi5lbCA9IG4xLmVsO1xyXG4gICAgICAgICAgICBjb25zdCBtYWluQW5jaG9yID0gKG4yLmFuY2hvciA9IG4xLmFuY2hvcik7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IChuMi50YXJnZXQgPSBuMS50YXJnZXQpO1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRBbmNob3IgPSAobjIudGFyZ2V0QW5jaG9yID0gbjEudGFyZ2V0QW5jaG9yKTtcclxuICAgICAgICAgICAgY29uc3Qgd2FzRGlzYWJsZWQgPSBpc1RlbGVwb3J0RGlzYWJsZWQobjEucHJvcHMpO1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50Q29udGFpbmVyID0gd2FzRGlzYWJsZWQgPyBjb250YWluZXIgOiB0YXJnZXQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRBbmNob3IgPSB3YXNEaXNhYmxlZCA/IG1haW5BbmNob3IgOiB0YXJnZXRBbmNob3I7XHJcbiAgICAgICAgICAgIGlzU1ZHID0gaXNTVkcgfHwgaXNUYXJnZXRTVkcodGFyZ2V0KTtcclxuICAgICAgICAgICAgaWYgKGR5bmFtaWNDaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgLy8gZmFzdCBwYXRoIHdoZW4gdGhlIHRlbGVwb3J0IGhhcHBlbnMgdG8gYmUgYSBibG9jayByb290XHJcbiAgICAgICAgICAgICAgICBwYXRjaEJsb2NrQ2hpbGRyZW4objEuZHluYW1pY0NoaWxkcmVuLCBkeW5hbWljQ2hpbGRyZW4sIGN1cnJlbnRDb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMpO1xyXG4gICAgICAgICAgICAgICAgLy8gZXZlbiBpbiBibG9jayB0cmVlIG1vZGUgd2UgbmVlZCB0byBtYWtlIHN1cmUgYWxsIHJvb3QtbGV2ZWwgbm9kZXNcclxuICAgICAgICAgICAgICAgIC8vIGluIHRoZSB0ZWxlcG9ydCBpbmhlcml0IHByZXZpb3VzIERPTSByZWZlcmVuY2VzIHNvIHRoYXQgdGhleSBjYW5cclxuICAgICAgICAgICAgICAgIC8vIGJlIG1vdmVkIGluIGZ1dHVyZSBwYXRjaGVzLlxyXG4gICAgICAgICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFvcHRpbWl6ZWQpIHtcclxuICAgICAgICAgICAgICAgIHBhdGNoQ2hpbGRyZW4objEsIG4yLCBjdXJyZW50Q29udGFpbmVyLCBjdXJyZW50QW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXdhc0Rpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5hYmxlZCAtPiBkaXNhYmxlZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgaW50byBtYWluIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgICAgIG1vdmVUZWxlcG9ydChuMiwgY29udGFpbmVyLCBtYWluQW5jaG9yLCBpbnRlcm5hbHMsIDEgLyogVE9HR0xFICovKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHRhcmdldCBjaGFuZ2VkXHJcbiAgICAgICAgICAgICAgICBpZiAoKG4yLnByb3BzICYmIG4yLnByb3BzLnRvKSAhPT0gKG4xLnByb3BzICYmIG4xLnByb3BzLnRvKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRUYXJnZXQgPSAobjIudGFyZ2V0ID0gcmVzb2x2ZVRhcmdldChuMi5wcm9wcywgcXVlcnlTZWxlY3RvcikpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0VGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVUZWxlcG9ydChuMiwgbmV4dFRhcmdldCwgbnVsbCwgaW50ZXJuYWxzLCAwIC8qIFRBUkdFVF9DSEFOR0UgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybignSW52YWxpZCBUZWxlcG9ydCB0YXJnZXQgb24gdXBkYXRlOicsIHRhcmdldCwgYCgke3R5cGVvZiB0YXJnZXR9KWApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHdhc0Rpc2FibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZGlzYWJsZWQgLT4gZW5hYmxlZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgaW50byB0ZWxlcG9ydCB0YXJnZXRcclxuICAgICAgICAgICAgICAgICAgICBtb3ZlVGVsZXBvcnQobjIsIHRhcmdldCwgdGFyZ2V0QW5jaG9yLCBpbnRlcm5hbHMsIDEgLyogVE9HR0xFICovKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICByZW1vdmUodm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG9wdGltaXplZCwgeyB1bTogdW5tb3VudCwgbzogeyByZW1vdmU6IGhvc3RSZW1vdmUgfSB9LCBkb1JlbW92ZSkge1xyXG4gICAgICAgIGNvbnN0IHsgc2hhcGVGbGFnLCBjaGlsZHJlbiwgYW5jaG9yLCB0YXJnZXRBbmNob3IsIHRhcmdldCwgcHJvcHMgfSA9IHZub2RlO1xyXG4gICAgICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgaG9zdFJlbW92ZSh0YXJnZXRBbmNob3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhbiB1bm1vdW50ZWQgdGVsZXBvcnQgc2hvdWxkIGFsd2F5cyByZW1vdmUgaXRzIGNoaWxkcmVuIGlmIG5vdCBkaXNhYmxlZFxyXG4gICAgICAgIGlmIChkb1JlbW92ZSB8fCAhaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKSkge1xyXG4gICAgICAgICAgICBob3N0UmVtb3ZlKGFuY2hvcik7XHJcbiAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgICAgICAgICAgdW5tb3VudChjaGlsZCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSwgISFjaGlsZC5keW5hbWljQ2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1vdmU6IG1vdmVUZWxlcG9ydCxcclxuICAgIGh5ZHJhdGU6IGh5ZHJhdGVUZWxlcG9ydFxyXG59O1xyXG5mdW5jdGlvbiBtb3ZlVGVsZXBvcnQodm5vZGUsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yLCB7IG86IHsgaW5zZXJ0IH0sIG06IG1vdmUgfSwgbW92ZVR5cGUgPSAyIC8qIFJFT1JERVIgKi8pIHtcclxuICAgIC8vIG1vdmUgdGFyZ2V0IGFuY2hvciBpZiB0aGlzIGlzIGEgdGFyZ2V0IGNoYW5nZS5cclxuICAgIGlmIChtb3ZlVHlwZSA9PT0gMCAvKiBUQVJHRVRfQ0hBTkdFICovKSB7XHJcbiAgICAgICAgaW5zZXJ0KHZub2RlLnRhcmdldEFuY2hvciwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBlbCwgYW5jaG9yLCBzaGFwZUZsYWcsIGNoaWxkcmVuLCBwcm9wcyB9ID0gdm5vZGU7XHJcbiAgICBjb25zdCBpc1Jlb3JkZXIgPSBtb3ZlVHlwZSA9PT0gMiAvKiBSRU9SREVSICovO1xyXG4gICAgLy8gbW92ZSBtYWluIHZpZXcgYW5jaG9yIGlmIHRoaXMgaXMgYSByZS1vcmRlci5cclxuICAgIGlmIChpc1Jlb3JkZXIpIHtcclxuICAgICAgICBpbnNlcnQoZWwsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yKTtcclxuICAgIH1cclxuICAgIC8vIGlmIHRoaXMgaXMgYSByZS1vcmRlciBhbmQgdGVsZXBvcnQgaXMgZW5hYmxlZCAoY29udGVudCBpcyBpbiB0YXJnZXQpXHJcbiAgICAvLyBkbyBub3QgbW92ZSBjaGlsZHJlbi4gU28gdGhlIG9wcG9zaXRlIGlzOiBvbmx5IG1vdmUgY2hpbGRyZW4gaWYgdGhpc1xyXG4gICAgLy8gaXMgbm90IGEgcmVvcmRlciwgb3IgdGhlIHRlbGVwb3J0IGlzIGRpc2FibGVkXHJcbiAgICBpZiAoIWlzUmVvcmRlciB8fCBpc1RlbGVwb3J0RGlzYWJsZWQocHJvcHMpKSB7XHJcbiAgICAgICAgLy8gVGVsZXBvcnQgaGFzIGVpdGhlciBBcnJheSBjaGlsZHJlbiBvciBubyBjaGlsZHJlbi5cclxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbW92ZShjaGlsZHJlbltpXSwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IsIDIgLyogUkVPUkRFUiAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBtb3ZlIG1haW4gdmlldyBhbmNob3IgaWYgdGhpcyBpcyBhIHJlLW9yZGVyLlxyXG4gICAgaWYgKGlzUmVvcmRlcikge1xyXG4gICAgICAgIGluc2VydChhbmNob3IsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBoeWRyYXRlVGVsZXBvcnQobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCB7IG86IHsgbmV4dFNpYmxpbmcsIHBhcmVudE5vZGUsIHF1ZXJ5U2VsZWN0b3IgfSB9LCBoeWRyYXRlQ2hpbGRyZW4pIHtcclxuICAgIGNvbnN0IHRhcmdldCA9ICh2bm9kZS50YXJnZXQgPSByZXNvbHZlVGFyZ2V0KHZub2RlLnByb3BzLCBxdWVyeVNlbGVjdG9yKSk7XHJcbiAgICBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgLy8gaWYgbXVsdGlwbGUgdGVsZXBvcnRzIHJlbmRlcmVkIHRvIHRoZSBzYW1lIHRhcmdldCBlbGVtZW50LCB3ZSBuZWVkIHRvXHJcbiAgICAgICAgLy8gcGljayB1cCBmcm9tIHdoZXJlIHRoZSBsYXN0IHRlbGVwb3J0IGZpbmlzaGVkIGluc3RlYWQgb2YgdGhlIGZpcnN0IG5vZGVcclxuICAgICAgICBjb25zdCB0YXJnZXROb2RlID0gdGFyZ2V0Ll9scGEgfHwgdGFyZ2V0LmZpcnN0Q2hpbGQ7XHJcbiAgICAgICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDE2IC8qIEFSUkFZX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1RlbGVwb3J0RGlzYWJsZWQodm5vZGUucHJvcHMpKSB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZS5hbmNob3IgPSBoeWRyYXRlQ2hpbGRyZW4obmV4dFNpYmxpbmcobm9kZSksIHZub2RlLCBwYXJlbnROb2RlKG5vZGUpLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICB2bm9kZS50YXJnZXRBbmNob3IgPSB0YXJnZXROb2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdm5vZGUuYW5jaG9yID0gbmV4dFNpYmxpbmcobm9kZSk7XHJcbiAgICAgICAgICAgICAgICB2bm9kZS50YXJnZXRBbmNob3IgPSBoeWRyYXRlQ2hpbGRyZW4odGFyZ2V0Tm9kZSwgdm5vZGUsIHRhcmdldCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRhcmdldC5fbHBhID1cclxuICAgICAgICAgICAgICAgIHZub2RlLnRhcmdldEFuY2hvciAmJiBuZXh0U2libGluZyh2bm9kZS50YXJnZXRBbmNob3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB2bm9kZS5hbmNob3IgJiYgbmV4dFNpYmxpbmcodm5vZGUuYW5jaG9yKTtcclxufVxyXG4vLyBGb3JjZS1jYXN0ZWQgcHVibGljIHR5cGluZyBmb3IgaCBhbmQgVFNYIHByb3BzIGluZmVyZW5jZVxyXG5jb25zdCBUZWxlcG9ydCA9IFRlbGVwb3J0SW1wbDtcblxuY29uc3QgQ09NUE9ORU5UUyA9ICdjb21wb25lbnRzJztcclxuY29uc3QgRElSRUNUSVZFUyA9ICdkaXJlY3RpdmVzJztcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50KG5hbWUsIG1heWJlU2VsZlJlZmVyZW5jZSkge1xyXG4gICAgcmV0dXJuIHJlc29sdmVBc3NldChDT01QT05FTlRTLCBuYW1lLCB0cnVlLCBtYXliZVNlbGZSZWZlcmVuY2UpIHx8IG5hbWU7XHJcbn1cclxuY29uc3QgTlVMTF9EWU5BTUlDX0NPTVBPTkVOVCA9IFN5bWJvbCgpO1xyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHJlc29sdmVEeW5hbWljQ29tcG9uZW50KGNvbXBvbmVudCkge1xyXG4gICAgaWYgKGlzU3RyaW5nKGNvbXBvbmVudCkpIHtcclxuICAgICAgICByZXR1cm4gcmVzb2x2ZUFzc2V0KENPTVBPTkVOVFMsIGNvbXBvbmVudCwgZmFsc2UpIHx8IGNvbXBvbmVudDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIGludmFsaWQgdHlwZXMgd2lsbCBmYWxsdGhyb3VnaCB0byBjcmVhdGVWTm9kZSBhbmQgcmFpc2Ugd2FybmluZ1xyXG4gICAgICAgIHJldHVybiAoY29tcG9uZW50IHx8IE5VTExfRFlOQU1JQ19DT01QT05FTlQpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gcmVzb2x2ZURpcmVjdGl2ZShuYW1lKSB7XHJcbiAgICByZXR1cm4gcmVzb2x2ZUFzc2V0KERJUkVDVElWRVMsIG5hbWUpO1xyXG59XHJcbi8vIGltcGxlbWVudGF0aW9uXHJcbmZ1bmN0aW9uIHJlc29sdmVBc3NldCh0eXBlLCBuYW1lLCB3YXJuTWlzc2luZyA9IHRydWUsIG1heWJlU2VsZlJlZmVyZW5jZSA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCBpbnN0YW5jZSA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSB8fCBjdXJyZW50SW5zdGFuY2U7XHJcbiAgICBpZiAoaW5zdGFuY2UpIHtcclxuICAgICAgICBjb25zdCBDb21wb25lbnQgPSBpbnN0YW5jZS50eXBlO1xyXG4gICAgICAgIC8vIGV4cGxpY2l0IHNlbGYgbmFtZSBoYXMgaGlnaGVzdCBwcmlvcml0eVxyXG4gICAgICAgIGlmICh0eXBlID09PSBDT01QT05FTlRTKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlbGZOYW1lID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpO1xyXG4gICAgICAgICAgICBpZiAoc2VsZk5hbWUgJiZcclxuICAgICAgICAgICAgICAgIChzZWxmTmFtZSA9PT0gbmFtZSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGZOYW1lID09PSBjYW1lbGl6ZShuYW1lKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGZOYW1lID09PSBjYXBpdGFsaXplKGNhbWVsaXplKG5hbWUpKSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDb21wb25lbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzID0gXHJcbiAgICAgICAgLy8gbG9jYWwgcmVnaXN0cmF0aW9uXHJcbiAgICAgICAgLy8gY2hlY2sgaW5zdGFuY2VbdHlwZV0gZmlyc3Qgd2hpY2ggaXMgcmVzb2x2ZWQgZm9yIG9wdGlvbnMgQVBJXHJcbiAgICAgICAgcmVzb2x2ZShpbnN0YW5jZVt0eXBlXSB8fCBDb21wb25lbnRbdHlwZV0sIG5hbWUpIHx8XHJcbiAgICAgICAgICAgIC8vIGdsb2JhbCByZWdpc3RyYXRpb25cclxuICAgICAgICAgICAgcmVzb2x2ZShpbnN0YW5jZS5hcHBDb250ZXh0W3R5cGVdLCBuYW1lKTtcclxuICAgICAgICBpZiAoIXJlcyAmJiBtYXliZVNlbGZSZWZlcmVuY2UpIHtcclxuICAgICAgICAgICAgLy8gZmFsbGJhY2sgdG8gaW1wbGljaXQgc2VsZi1yZWZlcmVuY2VcclxuICAgICAgICAgICAgcmV0dXJuIENvbXBvbmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuTWlzc2luZyAmJiAhcmVzKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYEZhaWxlZCB0byByZXNvbHZlICR7dHlwZS5zbGljZSgwLCAtMSl9OiAke25hbWV9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB3YXJuKGByZXNvbHZlJHtjYXBpdGFsaXplKHR5cGUuc2xpY2UoMCwgLTEpKX0gYCArXHJcbiAgICAgICAgICAgIGBjYW4gb25seSBiZSB1c2VkIGluIHJlbmRlcigpIG9yIHNldHVwKCkuYCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVzb2x2ZShyZWdpc3RyeSwgbmFtZSkge1xyXG4gICAgcmV0dXJuIChyZWdpc3RyeSAmJlxyXG4gICAgICAgIChyZWdpc3RyeVtuYW1lXSB8fFxyXG4gICAgICAgICAgICByZWdpc3RyeVtjYW1lbGl6ZShuYW1lKV0gfHxcclxuICAgICAgICAgICAgcmVnaXN0cnlbY2FwaXRhbGl6ZShjYW1lbGl6ZShuYW1lKSldKSk7XHJcbn1cblxuY29uc3QgRnJhZ21lbnQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ0ZyYWdtZW50JyA6IHVuZGVmaW5lZCk7XHJcbmNvbnN0IFRleHQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ1RleHQnIDogdW5kZWZpbmVkKTtcclxuY29uc3QgQ29tbWVudCQxID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/ICdDb21tZW50JyA6IHVuZGVmaW5lZCk7XHJcbmNvbnN0IFN0YXRpYyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnU3RhdGljJyA6IHVuZGVmaW5lZCk7XHJcbi8vIFNpbmNlIHYtaWYgYW5kIHYtZm9yIGFyZSB0aGUgdHdvIHBvc3NpYmxlIHdheXMgbm9kZSBzdHJ1Y3R1cmUgY2FuIGR5bmFtaWNhbGx5XHJcbi8vIGNoYW5nZSwgb25jZSB3ZSBjb25zaWRlciB2LWlmIGJyYW5jaGVzIGFuZCBlYWNoIHYtZm9yIGZyYWdtZW50IGEgYmxvY2ssIHdlXHJcbi8vIGNhbiBkaXZpZGUgYSB0ZW1wbGF0ZSBpbnRvIG5lc3RlZCBibG9ja3MsIGFuZCB3aXRoaW4gZWFjaCBibG9jayB0aGUgbm9kZVxyXG4vLyBzdHJ1Y3R1cmUgd291bGQgYmUgc3RhYmxlLiBUaGlzIGFsbG93cyB1cyB0byBza2lwIG1vc3QgY2hpbGRyZW4gZGlmZmluZ1xyXG4vLyBhbmQgb25seSB3b3JyeSBhYm91dCB0aGUgZHluYW1pYyBub2RlcyAoaW5kaWNhdGVkIGJ5IHBhdGNoIGZsYWdzKS5cclxuY29uc3QgYmxvY2tTdGFjayA9IFtdO1xyXG5sZXQgY3VycmVudEJsb2NrID0gbnVsbDtcclxuLyoqXHJcbiAqIE9wZW4gYSBibG9jay5cclxuICogVGhpcyBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgYGNyZWF0ZUJsb2NrYC4gSXQgY2Fubm90IGJlIHBhcnQgb2YgYGNyZWF0ZUJsb2NrYFxyXG4gKiBiZWNhdXNlIHRoZSBjaGlsZHJlbiBvZiB0aGUgYmxvY2sgYXJlIGV2YWx1YXRlZCBiZWZvcmUgYGNyZWF0ZUJsb2NrYCBpdHNlbGZcclxuICogaXMgY2FsbGVkLiBUaGUgZ2VuZXJhdGVkIGNvZGUgdHlwaWNhbGx5IGxvb2tzIGxpa2UgdGhpczpcclxuICpcclxuICogYGBganNcclxuICogZnVuY3Rpb24gcmVuZGVyKCkge1xyXG4gKiAgIHJldHVybiAob3BlbkJsb2NrKCksY3JlYXRlQmxvY2soJ2RpdicsIG51bGwsIFsuLi5dKSlcclxuICogfVxyXG4gKiBgYGBcclxuICogZGlzYWJsZVRyYWNraW5nIGlzIHRydWUgd2hlbiBjcmVhdGluZyBhIHYtZm9yIGZyYWdtZW50IGJsb2NrLCBzaW5jZSBhIHYtZm9yXHJcbiAqIGZyYWdtZW50IGFsd2F5cyBkaWZmcyBpdHMgY2hpbGRyZW4uXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBvcGVuQmxvY2soZGlzYWJsZVRyYWNraW5nID0gZmFsc2UpIHtcclxuICAgIGJsb2NrU3RhY2sucHVzaCgoY3VycmVudEJsb2NrID0gZGlzYWJsZVRyYWNraW5nID8gbnVsbCA6IFtdKSk7XHJcbn1cclxuZnVuY3Rpb24gY2xvc2VCbG9jaygpIHtcclxuICAgIGJsb2NrU3RhY2sucG9wKCk7XHJcbiAgICBjdXJyZW50QmxvY2sgPSBibG9ja1N0YWNrW2Jsb2NrU3RhY2subGVuZ3RoIC0gMV0gfHwgbnVsbDtcclxufVxyXG4vLyBXaGV0aGVyIHdlIHNob3VsZCBiZSB0cmFja2luZyBkeW5hbWljIGNoaWxkIG5vZGVzIGluc2lkZSBhIGJsb2NrLlxyXG4vLyBPbmx5IHRyYWNrcyB3aGVuIHRoaXMgdmFsdWUgaXMgPiAwXHJcbi8vIFdlIGFyZSBub3QgdXNpbmcgYSBzaW1wbGUgYm9vbGVhbiBiZWNhdXNlIHRoaXMgdmFsdWUgbWF5IG5lZWQgdG8gYmVcclxuLy8gaW5jcmVtZW50ZWQvZGVjcmVtZW50ZWQgYnkgbmVzdGVkIHVzYWdlIG9mIHYtb25jZSAoc2VlIGJlbG93KVxyXG5sZXQgaXNCbG9ja1RyZWVFbmFibGVkID0gMTtcclxuLyoqXHJcbiAqIEJsb2NrIHRyYWNraW5nIHNvbWV0aW1lcyBuZWVkcyB0byBiZSBkaXNhYmxlZCwgZm9yIGV4YW1wbGUgZHVyaW5nIHRoZVxyXG4gKiBjcmVhdGlvbiBvZiBhIHRyZWUgdGhhdCBuZWVkcyB0byBiZSBjYWNoZWQgYnkgdi1vbmNlLiBUaGUgY29tcGlsZXIgZ2VuZXJhdGVzXHJcbiAqIGNvZGUgbGlrZSB0aGlzOlxyXG4gKlxyXG4gKiBgYGAganNcclxuICogX2NhY2hlWzFdIHx8IChcclxuICogICBzZXRCbG9ja1RyYWNraW5nKC0xKSxcclxuICogICBfY2FjaGVbMV0gPSBjcmVhdGVWTm9kZSguLi4pLFxyXG4gKiAgIHNldEJsb2NrVHJhY2tpbmcoMSksXHJcbiAqICAgX2NhY2hlWzFdXHJcbiAqIClcclxuICogYGBgXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRCbG9ja1RyYWNraW5nKHZhbHVlKSB7XHJcbiAgICBpc0Jsb2NrVHJlZUVuYWJsZWQgKz0gdmFsdWU7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZSBhIGJsb2NrIHJvb3Qgdm5vZGUuIFRha2VzIHRoZSBzYW1lIGV4YWN0IGFyZ3VtZW50cyBhcyBgY3JlYXRlVk5vZGVgLlxyXG4gKiBBIGJsb2NrIHJvb3Qga2VlcHMgdHJhY2sgb2YgZHluYW1pYyBub2RlcyB3aXRoaW4gdGhlIGJsb2NrIGluIHRoZVxyXG4gKiBgZHluYW1pY0NoaWxkcmVuYCBhcnJheS5cclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZUJsb2NrKHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHMpIHtcclxuICAgIGNvbnN0IHZub2RlID0gY3JlYXRlVk5vZGUodHlwZSwgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wcywgdHJ1ZSAvKiBpc0Jsb2NrOiBwcmV2ZW50IGEgYmxvY2sgZnJvbSB0cmFja2luZyBpdHNlbGYgKi8pO1xyXG4gICAgLy8gc2F2ZSBjdXJyZW50IGJsb2NrIGNoaWxkcmVuIG9uIHRoZSBibG9jayB2bm9kZVxyXG4gICAgdm5vZGUuZHluYW1pY0NoaWxkcmVuID1cclxuICAgICAgICBpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwID8gY3VycmVudEJsb2NrIHx8IEVNUFRZX0FSUiA6IG51bGw7XHJcbiAgICAvLyBjbG9zZSBibG9ja1xyXG4gICAgY2xvc2VCbG9jaygpO1xyXG4gICAgLy8gYSBibG9jayBpcyBhbHdheXMgZ29pbmcgdG8gYmUgcGF0Y2hlZCwgc28gdHJhY2sgaXQgYXMgYSBjaGlsZCBvZiBpdHNcclxuICAgIC8vIHBhcmVudCBibG9ja1xyXG4gICAgaWYgKGlzQmxvY2tUcmVlRW5hYmxlZCA+IDAgJiYgY3VycmVudEJsb2NrKSB7XHJcbiAgICAgICAgY3VycmVudEJsb2NrLnB1c2godm5vZGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZub2RlO1xyXG59XHJcbmZ1bmN0aW9uIGlzVk5vZGUodmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZSA/IHZhbHVlLl9fdl9pc1ZOb2RlID09PSB0cnVlIDogZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgIG4yLnNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovICYmXHJcbiAgICAgICAgaG1yRGlydHlDb21wb25lbnRzLmhhcyhuMi50eXBlKSkge1xyXG4gICAgICAgIC8vIEhNUiBvbmx5OiBpZiB0aGUgY29tcG9uZW50IGhhcyBiZWVuIGhvdC11cGRhdGVkLCBmb3JjZSBhIHJlbG9hZC5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbjEudHlwZSA9PT0gbjIudHlwZSAmJiBuMS5rZXkgPT09IG4yLmtleTtcclxufVxyXG5sZXQgdm5vZGVBcmdzVHJhbnNmb3JtZXI7XHJcbi8qKlxyXG4gKiBJbnRlcm5hbCBBUEkgZm9yIHJlZ2lzdGVyaW5nIGFuIGFyZ3VtZW50cyB0cmFuc2Zvcm0gZm9yIGNyZWF0ZVZOb2RlXHJcbiAqIHVzZWQgZm9yIGNyZWF0aW5nIHN0dWJzIGluIHRoZSB0ZXN0LXV0aWxzXHJcbiAqIEl0IGlzICppbnRlcm5hbCogYnV0IG5lZWRzIHRvIGJlIGV4cG9zZWQgZm9yIHRlc3QtdXRpbHMgdG8gcGljayB1cCBwcm9wZXJcclxuICogdHlwaW5nc1xyXG4gKi9cclxuZnVuY3Rpb24gdHJhbnNmb3JtVk5vZGVBcmdzKHRyYW5zZm9ybWVyKSB7XHJcbiAgICB2bm9kZUFyZ3NUcmFuc2Zvcm1lciA9IHRyYW5zZm9ybWVyO1xyXG59XHJcbmNvbnN0IGNyZWF0ZVZOb2RlV2l0aEFyZ3NUcmFuc2Zvcm0gPSAoLi4uYXJncykgPT4ge1xyXG4gICAgcmV0dXJuIF9jcmVhdGVWTm9kZSguLi4odm5vZGVBcmdzVHJhbnNmb3JtZXJcclxuICAgICAgICA/IHZub2RlQXJnc1RyYW5zZm9ybWVyKGFyZ3MsIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSlcclxuICAgICAgICA6IGFyZ3MpKTtcclxufTtcclxuY29uc3QgSW50ZXJuYWxPYmplY3RLZXkgPSBgX192SW50ZXJuYWxgO1xyXG5jb25zdCBub3JtYWxpemVLZXkgPSAoeyBrZXkgfSkgPT4ga2V5ICE9IG51bGwgPyBrZXkgOiBudWxsO1xyXG5jb25zdCBub3JtYWxpemVSZWYgPSAoeyByZWYgfSkgPT4ge1xyXG4gICAgcmV0dXJuIChyZWYgIT0gbnVsbFxyXG4gICAgICAgID8gaXNTdHJpbmcocmVmKSB8fCBpc1JlZihyZWYpIHx8IGlzRnVuY3Rpb24ocmVmKVxyXG4gICAgICAgICAgICA/IHsgaTogY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLCByOiByZWYgfVxyXG4gICAgICAgICAgICA6IHJlZlxyXG4gICAgICAgIDogbnVsbCk7XHJcbn07XHJcbmNvbnN0IGNyZWF0ZVZOb2RlID0gKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgPyBjcmVhdGVWTm9kZVdpdGhBcmdzVHJhbnNmb3JtXHJcbiAgICA6IF9jcmVhdGVWTm9kZSk7XHJcbmZ1bmN0aW9uIF9jcmVhdGVWTm9kZSh0eXBlLCBwcm9wcyA9IG51bGwsIGNoaWxkcmVuID0gbnVsbCwgcGF0Y2hGbGFnID0gMCwgZHluYW1pY1Byb3BzID0gbnVsbCwgaXNCbG9ja05vZGUgPSBmYWxzZSkge1xyXG4gICAgaWYgKCF0eXBlIHx8IHR5cGUgPT09IE5VTExfRFlOQU1JQ19DT01QT05FTlQpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICF0eXBlKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYEludmFsaWQgdm5vZGUgdHlwZSB3aGVuIGNyZWF0aW5nIHZub2RlOiAke3R5cGV9LmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0eXBlID0gQ29tbWVudCQxO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzVk5vZGUodHlwZSkpIHtcclxuICAgICAgICAvLyBjcmVhdGVWTm9kZSByZWNlaXZpbmcgYW4gZXhpc3Rpbmcgdm5vZGUuIFRoaXMgaGFwcGVucyBpbiBjYXNlcyBsaWtlXHJcbiAgICAgICAgLy8gPGNvbXBvbmVudCA6aXM9XCJ2bm9kZVwiLz5cclxuICAgICAgICAvLyAjMjA3OCBtYWtlIHN1cmUgdG8gbWVyZ2UgcmVmcyBkdXJpbmcgdGhlIGNsb25lIGluc3RlYWQgb2Ygb3ZlcndyaXRpbmcgaXRcclxuICAgICAgICBjb25zdCBjbG9uZWQgPSBjbG9uZVZOb2RlKHR5cGUsIHByb3BzLCB0cnVlIC8qIG1lcmdlUmVmOiB0cnVlICovKTtcclxuICAgICAgICBpZiAoY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgbm9ybWFsaXplQ2hpbGRyZW4oY2xvbmVkLCBjaGlsZHJlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbG9uZWQ7XHJcbiAgICB9XHJcbiAgICAvLyBjbGFzcyBjb21wb25lbnQgbm9ybWFsaXphdGlvbi5cclxuICAgIGlmIChpc0NsYXNzQ29tcG9uZW50KHR5cGUpKSB7XHJcbiAgICAgICAgdHlwZSA9IHR5cGUuX192Y2NPcHRzO1xyXG4gICAgfVxyXG4gICAgLy8gY2xhc3MgJiBzdHlsZSBub3JtYWxpemF0aW9uLlxyXG4gICAgaWYgKHByb3BzKSB7XHJcbiAgICAgICAgLy8gZm9yIHJlYWN0aXZlIG9yIHByb3h5IG9iamVjdHMsIHdlIG5lZWQgdG8gY2xvbmUgaXQgdG8gZW5hYmxlIG11dGF0aW9uLlxyXG4gICAgICAgIGlmIChpc1Byb3h5KHByb3BzKSB8fCBJbnRlcm5hbE9iamVjdEtleSBpbiBwcm9wcykge1xyXG4gICAgICAgICAgICBwcm9wcyA9IGV4dGVuZCh7fSwgcHJvcHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgeyBjbGFzczoga2xhc3MsIHN0eWxlIH0gPSBwcm9wcztcclxuICAgICAgICBpZiAoa2xhc3MgJiYgIWlzU3RyaW5nKGtsYXNzKSkge1xyXG4gICAgICAgICAgICBwcm9wcy5jbGFzcyA9IG5vcm1hbGl6ZUNsYXNzKGtsYXNzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzT2JqZWN0KHN0eWxlKSkge1xyXG4gICAgICAgICAgICAvLyByZWFjdGl2ZSBzdGF0ZSBvYmplY3RzIG5lZWQgdG8gYmUgY2xvbmVkIHNpbmNlIHRoZXkgYXJlIGxpa2VseSB0byBiZVxyXG4gICAgICAgICAgICAvLyBtdXRhdGVkXHJcbiAgICAgICAgICAgIGlmIChpc1Byb3h5KHN0eWxlKSAmJiAhaXNBcnJheShzdHlsZSkpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlID0gZXh0ZW5kKHt9LCBzdHlsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHJvcHMuc3R5bGUgPSBub3JtYWxpemVTdHlsZShzdHlsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gZW5jb2RlIHRoZSB2bm9kZSB0eXBlIGluZm9ybWF0aW9uIGludG8gYSBiaXRtYXBcclxuICAgIGNvbnN0IHNoYXBlRmxhZyA9IGlzU3RyaW5nKHR5cGUpXHJcbiAgICAgICAgPyAxIC8qIEVMRU1FTlQgKi9cclxuICAgICAgICA6IGlzU3VzcGVuc2UodHlwZSlcclxuICAgICAgICAgICAgPyAxMjggLyogU1VTUEVOU0UgKi9cclxuICAgICAgICAgICAgOiBpc1RlbGVwb3J0KHR5cGUpXHJcbiAgICAgICAgICAgICAgICA/IDY0IC8qIFRFTEVQT1JUICovXHJcbiAgICAgICAgICAgICAgICA6IGlzT2JqZWN0KHR5cGUpXHJcbiAgICAgICAgICAgICAgICAgICAgPyA0IC8qIFNUQVRFRlVMX0NPTVBPTkVOVCAqL1xyXG4gICAgICAgICAgICAgICAgICAgIDogaXNGdW5jdGlvbih0eXBlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IDIgLyogRlVOQ1RJT05BTF9DT01QT05FTlQgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgOiAwO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBzaGFwZUZsYWcgJiA0IC8qIFNUQVRFRlVMX0NPTVBPTkVOVCAqLyAmJiBpc1Byb3h5KHR5cGUpKSB7XHJcbiAgICAgICAgdHlwZSA9IHRvUmF3KHR5cGUpO1xyXG4gICAgICAgIHdhcm4oYFZ1ZSByZWNlaXZlZCBhIENvbXBvbmVudCB3aGljaCB3YXMgbWFkZSBhIHJlYWN0aXZlIG9iamVjdC4gVGhpcyBjYW4gYCArXHJcbiAgICAgICAgICAgIGBsZWFkIHRvIHVubmVjZXNzYXJ5IHBlcmZvcm1hbmNlIG92ZXJoZWFkLCBhbmQgc2hvdWxkIGJlIGF2b2lkZWQgYnkgYCArXHJcbiAgICAgICAgICAgIGBtYXJraW5nIHRoZSBjb21wb25lbnQgd2l0aCBcXGBtYXJrUmF3XFxgIG9yIHVzaW5nIFxcYHNoYWxsb3dSZWZcXGAgYCArXHJcbiAgICAgICAgICAgIGBpbnN0ZWFkIG9mIFxcYHJlZlxcYC5gLCBgXFxuQ29tcG9uZW50IHRoYXQgd2FzIG1hZGUgcmVhY3RpdmU6IGAsIHR5cGUpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgdm5vZGUgPSB7XHJcbiAgICAgICAgX192X2lzVk5vZGU6IHRydWUsXHJcbiAgICAgICAgX192X3NraXA6IHRydWUsXHJcbiAgICAgICAgdHlwZSxcclxuICAgICAgICBwcm9wcyxcclxuICAgICAgICBrZXk6IHByb3BzICYmIG5vcm1hbGl6ZUtleShwcm9wcyksXHJcbiAgICAgICAgcmVmOiBwcm9wcyAmJiBub3JtYWxpemVSZWYocHJvcHMpLFxyXG4gICAgICAgIHNjb3BlSWQ6IGN1cnJlbnRTY29wZUlkLFxyXG4gICAgICAgIHNsb3RTY29wZUlkczogbnVsbCxcclxuICAgICAgICBjaGlsZHJlbjogbnVsbCxcclxuICAgICAgICBjb21wb25lbnQ6IG51bGwsXHJcbiAgICAgICAgc3VzcGVuc2U6IG51bGwsXHJcbiAgICAgICAgc3NDb250ZW50OiBudWxsLFxyXG4gICAgICAgIHNzRmFsbGJhY2s6IG51bGwsXHJcbiAgICAgICAgZGlyczogbnVsbCxcclxuICAgICAgICB0cmFuc2l0aW9uOiBudWxsLFxyXG4gICAgICAgIGVsOiBudWxsLFxyXG4gICAgICAgIGFuY2hvcjogbnVsbCxcclxuICAgICAgICB0YXJnZXQ6IG51bGwsXHJcbiAgICAgICAgdGFyZ2V0QW5jaG9yOiBudWxsLFxyXG4gICAgICAgIHN0YXRpY0NvdW50OiAwLFxyXG4gICAgICAgIHNoYXBlRmxhZyxcclxuICAgICAgICBwYXRjaEZsYWcsXHJcbiAgICAgICAgZHluYW1pY1Byb3BzLFxyXG4gICAgICAgIGR5bmFtaWNDaGlsZHJlbjogbnVsbCxcclxuICAgICAgICBhcHBDb250ZXh0OiBudWxsXHJcbiAgICB9O1xyXG4gICAgLy8gdmFsaWRhdGUga2V5XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHZub2RlLmtleSAhPT0gdm5vZGUua2V5KSB7XHJcbiAgICAgICAgd2FybihgVk5vZGUgY3JlYXRlZCB3aXRoIGludmFsaWQga2V5IChOYU4pLiBWTm9kZSB0eXBlOmAsIHZub2RlLnR5cGUpO1xyXG4gICAgfVxyXG4gICAgbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuKTtcclxuICAgIC8vIG5vcm1hbGl6ZSBzdXNwZW5zZSBjaGlsZHJlblxyXG4gICAgaWYgKHNoYXBlRmxhZyAmIDEyOCAvKiBTVVNQRU5TRSAqLykge1xyXG4gICAgICAgIHR5cGUubm9ybWFsaXplKHZub2RlKTtcclxuICAgIH1cclxuICAgIGlmIChpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwICYmXHJcbiAgICAgICAgLy8gYXZvaWQgYSBibG9jayBub2RlIGZyb20gdHJhY2tpbmcgaXRzZWxmXHJcbiAgICAgICAgIWlzQmxvY2tOb2RlICYmXHJcbiAgICAgICAgLy8gaGFzIGN1cnJlbnQgcGFyZW50IGJsb2NrXHJcbiAgICAgICAgY3VycmVudEJsb2NrICYmXHJcbiAgICAgICAgLy8gcHJlc2VuY2Ugb2YgYSBwYXRjaCBmbGFnIGluZGljYXRlcyB0aGlzIG5vZGUgbmVlZHMgcGF0Y2hpbmcgb24gdXBkYXRlcy5cclxuICAgICAgICAvLyBjb21wb25lbnQgbm9kZXMgYWxzbyBzaG91bGQgYWx3YXlzIGJlIHBhdGNoZWQsIGJlY2F1c2UgZXZlbiBpZiB0aGVcclxuICAgICAgICAvLyBjb21wb25lbnQgZG9lc24ndCBuZWVkIHRvIHVwZGF0ZSwgaXQgbmVlZHMgdG8gcGVyc2lzdCB0aGUgaW5zdGFuY2Ugb24gdG9cclxuICAgICAgICAvLyB0aGUgbmV4dCB2bm9kZSBzbyB0aGF0IGl0IGNhbiBiZSBwcm9wZXJseSB1bm1vdW50ZWQgbGF0ZXIuXHJcbiAgICAgICAgKHBhdGNoRmxhZyA+IDAgfHwgc2hhcGVGbGFnICYgNiAvKiBDT01QT05FTlQgKi8pICYmXHJcbiAgICAgICAgLy8gdGhlIEVWRU5UUyBmbGFnIGlzIG9ubHkgZm9yIGh5ZHJhdGlvbiBhbmQgaWYgaXQgaXMgdGhlIG9ubHkgZmxhZywgdGhlXHJcbiAgICAgICAgLy8gdm5vZGUgc2hvdWxkIG5vdCBiZSBjb25zaWRlcmVkIGR5bmFtaWMgZHVlIHRvIGhhbmRsZXIgY2FjaGluZy5cclxuICAgICAgICBwYXRjaEZsYWcgIT09IDMyIC8qIEhZRFJBVEVfRVZFTlRTICovKSB7XHJcbiAgICAgICAgY3VycmVudEJsb2NrLnB1c2godm5vZGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZub2RlO1xyXG59XHJcbmZ1bmN0aW9uIGNsb25lVk5vZGUodm5vZGUsIGV4dHJhUHJvcHMsIG1lcmdlUmVmID0gZmFsc2UpIHtcclxuICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBOT1QgdXNpbmcgc3ByZWFkIG9yIGV4dGVuZCB0byBhdm9pZCB0aGUgcnVudGltZVxyXG4gICAgLy8ga2V5IGVudW1lcmF0aW9uIGNvc3QuXHJcbiAgICBjb25zdCB7IHByb3BzLCByZWYsIHBhdGNoRmxhZywgY2hpbGRyZW4gfSA9IHZub2RlO1xyXG4gICAgY29uc3QgbWVyZ2VkUHJvcHMgPSBleHRyYVByb3BzID8gbWVyZ2VQcm9wcyhwcm9wcyB8fCB7fSwgZXh0cmFQcm9wcykgOiBwcm9wcztcclxuICAgIGNvbnN0IGNsb25lZCA9IHtcclxuICAgICAgICBfX3ZfaXNWTm9kZTogdHJ1ZSxcclxuICAgICAgICBfX3Zfc2tpcDogdHJ1ZSxcclxuICAgICAgICB0eXBlOiB2bm9kZS50eXBlLFxyXG4gICAgICAgIHByb3BzOiBtZXJnZWRQcm9wcyxcclxuICAgICAgICBrZXk6IG1lcmdlZFByb3BzICYmIG5vcm1hbGl6ZUtleShtZXJnZWRQcm9wcyksXHJcbiAgICAgICAgcmVmOiBleHRyYVByb3BzICYmIGV4dHJhUHJvcHMucmVmXHJcbiAgICAgICAgICAgID8gLy8gIzIwNzggaW4gdGhlIGNhc2Ugb2YgPGNvbXBvbmVudCA6aXM9XCJ2bm9kZVwiIHJlZj1cImV4dHJhXCIvPlxyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHZub2RlIGl0c2VsZiBhbHJlYWR5IGhhcyBhIHJlZiwgY2xvbmVWTm9kZSB3aWxsIG5lZWQgdG8gbWVyZ2VcclxuICAgICAgICAgICAgICAgIC8vIHRoZSByZWZzIHNvIHRoZSBzaW5nbGUgdm5vZGUgY2FuIGJlIHNldCBvbiBtdWx0aXBsZSByZWZzXHJcbiAgICAgICAgICAgICAgICBtZXJnZVJlZiAmJiByZWZcclxuICAgICAgICAgICAgICAgICAgICA/IGlzQXJyYXkocmVmKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHJlZi5jb25jYXQobm9ybWFsaXplUmVmKGV4dHJhUHJvcHMpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFtyZWYsIG5vcm1hbGl6ZVJlZihleHRyYVByb3BzKV1cclxuICAgICAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZVJlZihleHRyYVByb3BzKVxyXG4gICAgICAgICAgICA6IHJlZixcclxuICAgICAgICBzY29wZUlkOiB2bm9kZS5zY29wZUlkLFxyXG4gICAgICAgIHNsb3RTY29wZUlkczogdm5vZGUuc2xvdFNjb3BlSWRzLFxyXG4gICAgICAgIGNoaWxkcmVuOiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgcGF0Y2hGbGFnID09PSAtMSAvKiBIT0lTVEVEICovICYmIGlzQXJyYXkoY2hpbGRyZW4pXHJcbiAgICAgICAgICAgID8gY2hpbGRyZW4ubWFwKGRlZXBDbG9uZVZOb2RlKVxyXG4gICAgICAgICAgICA6IGNoaWxkcmVuLFxyXG4gICAgICAgIHRhcmdldDogdm5vZGUudGFyZ2V0LFxyXG4gICAgICAgIHRhcmdldEFuY2hvcjogdm5vZGUudGFyZ2V0QW5jaG9yLFxyXG4gICAgICAgIHN0YXRpY0NvdW50OiB2bm9kZS5zdGF0aWNDb3VudCxcclxuICAgICAgICBzaGFwZUZsYWc6IHZub2RlLnNoYXBlRmxhZyxcclxuICAgICAgICAvLyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIHdpdGggZXh0cmEgcHJvcHMsIHdlIGNhbiBubyBsb25nZXIgYXNzdW1lIGl0c1xyXG4gICAgICAgIC8vIGV4aXN0aW5nIHBhdGNoIGZsYWcgdG8gYmUgcmVsaWFibGUgYW5kIG5lZWQgdG8gYWRkIHRoZSBGVUxMX1BST1BTIGZsYWcuXHJcbiAgICAgICAgLy8gbm90ZTogcGVyc2VydmUgZmxhZyBmb3IgZnJhZ21lbnRzIHNpbmNlIHRoZXkgdXNlIHRoZSBmbGFnIGZvciBjaGlsZHJlblxyXG4gICAgICAgIC8vIGZhc3QgcGF0aHMgb25seS5cclxuICAgICAgICBwYXRjaEZsYWc6IGV4dHJhUHJvcHMgJiYgdm5vZGUudHlwZSAhPT0gRnJhZ21lbnRcclxuICAgICAgICAgICAgPyBwYXRjaEZsYWcgPT09IC0xIC8vIGhvaXN0ZWQgbm9kZVxyXG4gICAgICAgICAgICAgICAgPyAxNiAvKiBGVUxMX1BST1BTICovXHJcbiAgICAgICAgICAgICAgICA6IHBhdGNoRmxhZyB8IDE2IC8qIEZVTExfUFJPUFMgKi9cclxuICAgICAgICAgICAgOiBwYXRjaEZsYWcsXHJcbiAgICAgICAgZHluYW1pY1Byb3BzOiB2bm9kZS5keW5hbWljUHJvcHMsXHJcbiAgICAgICAgZHluYW1pY0NoaWxkcmVuOiB2bm9kZS5keW5hbWljQ2hpbGRyZW4sXHJcbiAgICAgICAgYXBwQ29udGV4dDogdm5vZGUuYXBwQ29udGV4dCxcclxuICAgICAgICBkaXJzOiB2bm9kZS5kaXJzLFxyXG4gICAgICAgIHRyYW5zaXRpb246IHZub2RlLnRyYW5zaXRpb24sXHJcbiAgICAgICAgLy8gVGhlc2Ugc2hvdWxkIHRlY2huaWNhbGx5IG9ubHkgYmUgbm9uLW51bGwgb24gbW91bnRlZCBWTm9kZXMuIEhvd2V2ZXIsXHJcbiAgICAgICAgLy8gdGhleSAqc2hvdWxkKiBiZSBjb3BpZWQgZm9yIGtlcHQtYWxpdmUgdm5vZGVzLiBTbyB3ZSBqdXN0IGFsd2F5cyBjb3B5XHJcbiAgICAgICAgLy8gdGhlbSBzaW5jZSB0aGVtIGJlaW5nIG5vbi1udWxsIGR1cmluZyBhIG1vdW50IGRvZXNuJ3QgYWZmZWN0IHRoZSBsb2dpYyBhc1xyXG4gICAgICAgIC8vIHRoZXkgd2lsbCBzaW1wbHkgYmUgb3ZlcndyaXR0ZW4uXHJcbiAgICAgICAgY29tcG9uZW50OiB2bm9kZS5jb21wb25lbnQsXHJcbiAgICAgICAgc3VzcGVuc2U6IHZub2RlLnN1c3BlbnNlLFxyXG4gICAgICAgIHNzQ29udGVudDogdm5vZGUuc3NDb250ZW50ICYmIGNsb25lVk5vZGUodm5vZGUuc3NDb250ZW50KSxcclxuICAgICAgICBzc0ZhbGxiYWNrOiB2bm9kZS5zc0ZhbGxiYWNrICYmIGNsb25lVk5vZGUodm5vZGUuc3NGYWxsYmFjayksXHJcbiAgICAgICAgZWw6IHZub2RlLmVsLFxyXG4gICAgICAgIGFuY2hvcjogdm5vZGUuYW5jaG9yXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGNsb25lZDtcclxufVxyXG4vKipcclxuICogRGV2IG9ubHksIGZvciBITVIgb2YgaG9pc3RlZCB2bm9kZXMgcmV1c2VkIGluIHYtZm9yXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS92aXRlanMvdml0ZS9pc3N1ZXMvMjAyMlxyXG4gKi9cclxuZnVuY3Rpb24gZGVlcENsb25lVk5vZGUodm5vZGUpIHtcclxuICAgIGNvbnN0IGNsb25lZCA9IGNsb25lVk5vZGUodm5vZGUpO1xyXG4gICAgaWYgKGlzQXJyYXkodm5vZGUuY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgY2xvbmVkLmNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW4ubWFwKGRlZXBDbG9uZVZOb2RlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjbG9uZWQ7XHJcbn1cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUodGV4dCA9ICcgJywgZmxhZyA9IDApIHtcclxuICAgIHJldHVybiBjcmVhdGVWTm9kZShUZXh0LCBudWxsLCB0ZXh0LCBmbGFnKTtcclxufVxyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVN0YXRpY1ZOb2RlKGNvbnRlbnQsIG51bWJlck9mTm9kZXMpIHtcclxuICAgIC8vIEEgc3RhdGljIHZub2RlIGNhbiBjb250YWluIG11bHRpcGxlIHN0cmluZ2lmaWVkIGVsZW1lbnRzLCBhbmQgdGhlIG51bWJlclxyXG4gICAgLy8gb2YgZWxlbWVudHMgaXMgbmVjZXNzYXJ5IGZvciBoeWRyYXRpb24uXHJcbiAgICBjb25zdCB2bm9kZSA9IGNyZWF0ZVZOb2RlKFN0YXRpYywgbnVsbCwgY29udGVudCk7XHJcbiAgICB2bm9kZS5zdGF0aWNDb3VudCA9IG51bWJlck9mTm9kZXM7XHJcbiAgICByZXR1cm4gdm5vZGU7XHJcbn1cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVDb21tZW50Vk5vZGUodGV4dCA9ICcnLCBcclxuLy8gd2hlbiB1c2VkIGFzIHRoZSB2LWVsc2UgYnJhbmNoLCB0aGUgY29tbWVudCBub2RlIG11c3QgYmUgY3JlYXRlZCBhcyBhXHJcbi8vIGJsb2NrIHRvIGVuc3VyZSBjb3JyZWN0IHVwZGF0ZXMuXHJcbmFzQmxvY2sgPSBmYWxzZSkge1xyXG4gICAgcmV0dXJuIGFzQmxvY2tcclxuICAgICAgICA/IChvcGVuQmxvY2soKSwgY3JlYXRlQmxvY2soQ29tbWVudCQxLCBudWxsLCB0ZXh0KSlcclxuICAgICAgICA6IGNyZWF0ZVZOb2RlKENvbW1lbnQkMSwgbnVsbCwgdGV4dCk7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplVk5vZGUoY2hpbGQpIHtcclxuICAgIGlmIChjaGlsZCA9PSBudWxsIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgLy8gZW1wdHkgcGxhY2Vob2xkZXJcclxuICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUoQ29tbWVudCQxKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzQXJyYXkoY2hpbGQpKSB7XHJcbiAgICAgICAgLy8gZnJhZ21lbnRcclxuICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUoRnJhZ21lbnQsIG51bGwsIFxyXG4gICAgICAgIC8vICMzNjY2LCBhdm9pZCByZWZlcmVuY2UgcG9sbHV0aW9uIHdoZW4gcmV1c2luZyB2bm9kZVxyXG4gICAgICAgIGNoaWxkLnNsaWNlKCkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGNoaWxkID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIC8vIGFscmVhZHkgdm5vZGUsIHRoaXMgc2hvdWxkIGJlIHRoZSBtb3N0IGNvbW1vbiBzaW5jZSBjb21waWxlZCB0ZW1wbGF0ZXNcclxuICAgICAgICAvLyBhbHdheXMgcHJvZHVjZSBhbGwtdm5vZGUgY2hpbGRyZW4gYXJyYXlzXHJcbiAgICAgICAgcmV0dXJuIGNsb25lSWZNb3VudGVkKGNoaWxkKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIHN0cmluZ3MgYW5kIG51bWJlcnNcclxuICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUoVGV4dCwgbnVsbCwgU3RyaW5nKGNoaWxkKSk7XHJcbiAgICB9XHJcbn1cclxuLy8gb3B0aW1pemVkIG5vcm1hbGl6YXRpb24gZm9yIHRlbXBsYXRlLWNvbXBpbGVkIHJlbmRlciBmbnNcclxuZnVuY3Rpb24gY2xvbmVJZk1vdW50ZWQoY2hpbGQpIHtcclxuICAgIHJldHVybiBjaGlsZC5lbCA9PT0gbnVsbCA/IGNoaWxkIDogY2xvbmVWTm9kZShjaGlsZCk7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuKSB7XHJcbiAgICBsZXQgdHlwZSA9IDA7XHJcbiAgICBjb25zdCB7IHNoYXBlRmxhZyB9ID0gdm5vZGU7XHJcbiAgICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xyXG4gICAgICAgIGNoaWxkcmVuID0gbnVsbDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgdHlwZSA9IDE2IC8qIEFSUkFZX0NISUxEUkVOICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGNoaWxkcmVuID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxIC8qIEVMRU1FTlQgKi8gfHwgc2hhcGVGbGFnICYgNjQgLyogVEVMRVBPUlQgKi8pIHtcclxuICAgICAgICAgICAgLy8gTm9ybWFsaXplIHNsb3QgdG8gcGxhaW4gY2hpbGRyZW4gZm9yIHBsYWluIGVsZW1lbnQgYW5kIFRlbGVwb3J0XHJcbiAgICAgICAgICAgIGNvbnN0IHNsb3QgPSBjaGlsZHJlbi5kZWZhdWx0O1xyXG4gICAgICAgICAgICBpZiAoc2xvdCkge1xyXG4gICAgICAgICAgICAgICAgLy8gX2MgbWFya2VyIGlzIGFkZGVkIGJ5IHdpdGhDdHgoKSBpbmRpY2F0aW5nIHRoaXMgaXMgYSBjb21waWxlZCBzbG90XHJcbiAgICAgICAgICAgICAgICBzbG90Ll9jICYmIChzbG90Ll9kID0gZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUsIHNsb3QoKSk7XHJcbiAgICAgICAgICAgICAgICBzbG90Ll9jICYmIChzbG90Ll9kID0gdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdHlwZSA9IDMyIC8qIFNMT1RTX0NISUxEUkVOICovO1xyXG4gICAgICAgICAgICBjb25zdCBzbG90RmxhZyA9IGNoaWxkcmVuLl87XHJcbiAgICAgICAgICAgIGlmICghc2xvdEZsYWcgJiYgIShJbnRlcm5hbE9iamVjdEtleSBpbiBjaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLl9jdHggPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2xvdEZsYWcgPT09IDMgLyogRk9SV0FSREVEICovICYmIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gYSBjaGlsZCBjb21wb25lbnQgcmVjZWl2ZXMgZm9yd2FyZGVkIHNsb3RzIGZyb20gdGhlIHBhcmVudC5cclxuICAgICAgICAgICAgICAgIC8vIGl0cyBzbG90IHR5cGUgaXMgZGV0ZXJtaW5lZCBieSBpdHMgcGFyZW50J3Mgc2xvdCB0eXBlLlxyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS5zbG90cy5fID09PSAxIC8qIFNUQUJMRSAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLl8gPSAxIC8qIFNUQUJMRSAqLztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLl8gPSAyIC8qIERZTkFNSUMgKi87XHJcbiAgICAgICAgICAgICAgICAgICAgdm5vZGUucGF0Y2hGbGFnIHw9IDEwMjQgLyogRFlOQU1JQ19TTE9UUyAqLztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgY2hpbGRyZW4gPSB7IGRlZmF1bHQ6IGNoaWxkcmVuLCBfY3R4OiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgfTtcclxuICAgICAgICB0eXBlID0gMzIgLyogU0xPVFNfQ0hJTERSRU4gKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjaGlsZHJlbiA9IFN0cmluZyhjaGlsZHJlbik7XHJcbiAgICAgICAgLy8gZm9yY2UgdGVsZXBvcnQgY2hpbGRyZW4gdG8gYXJyYXkgc28gaXQgY2FuIGJlIG1vdmVkIGFyb3VuZFxyXG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiA2NCAvKiBURUxFUE9SVCAqLykge1xyXG4gICAgICAgICAgICB0eXBlID0gMTYgLyogQVJSQVlfQ0hJTERSRU4gKi87XHJcbiAgICAgICAgICAgIGNoaWxkcmVuID0gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdHlwZSA9IDggLyogVEVYVF9DSElMRFJFTiAqLztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB2bm9kZS5jaGlsZHJlbiA9IGNoaWxkcmVuO1xyXG4gICAgdm5vZGUuc2hhcGVGbGFnIHw9IHR5cGU7XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2VQcm9wcyguLi5hcmdzKSB7XHJcbiAgICBjb25zdCByZXQgPSBleHRlbmQoe30sIGFyZ3NbMF0pO1xyXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgdG9NZXJnZSA9IGFyZ3NbaV07XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdG9NZXJnZSkge1xyXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnY2xhc3MnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmV0LmNsYXNzICE9PSB0b01lcmdlLmNsYXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0LmNsYXNzID0gbm9ybWFsaXplQ2xhc3MoW3JldC5jbGFzcywgdG9NZXJnZS5jbGFzc10pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ3N0eWxlJykge1xyXG4gICAgICAgICAgICAgICAgcmV0LnN0eWxlID0gbm9ybWFsaXplU3R5bGUoW3JldC5zdHlsZSwgdG9NZXJnZS5zdHlsZV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzT24oa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSByZXRba2V5XTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluY29taW5nID0gdG9NZXJnZVtrZXldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nICE9PSBpbmNvbWluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldFtrZXldID0gZXhpc3RpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBbXS5jb25jYXQoZXhpc3RpbmcsIGluY29taW5nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGluY29taW5nO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgIHJldFtrZXldID0gdG9NZXJnZVtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldDtcclxufVxuXG4vKipcclxuICogQWN0dWFsIGltcGxlbWVudGF0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiByZW5kZXJMaXN0KHNvdXJjZSwgcmVuZGVySXRlbSkge1xyXG4gICAgbGV0IHJldDtcclxuICAgIGlmIChpc0FycmF5KHNvdXJjZSkgfHwgaXNTdHJpbmcoc291cmNlKSkge1xyXG4gICAgICAgIHJldCA9IG5ldyBBcnJheShzb3VyY2UubGVuZ3RoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHNvdXJjZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgcmV0W2ldID0gcmVuZGVySXRlbShzb3VyY2VbaV0sIGkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhTnVtYmVyLmlzSW50ZWdlcihzb3VyY2UpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYFRoZSB2LWZvciByYW5nZSBleHBlY3QgYW4gaW50ZWdlciB2YWx1ZSBidXQgZ290ICR7c291cmNlfS5gKTtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXQgPSBuZXcgQXJyYXkoc291cmNlKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJldFtpXSA9IHJlbmRlckl0ZW0oaSArIDEsIGkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHNvdXJjZSkpIHtcclxuICAgICAgICBpZiAoc291cmNlW1N5bWJvbC5pdGVyYXRvcl0pIHtcclxuICAgICAgICAgICAgcmV0ID0gQXJyYXkuZnJvbShzb3VyY2UsIHJlbmRlckl0ZW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XHJcbiAgICAgICAgICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XHJcbiAgICAgICAgICAgICAgICByZXRbaV0gPSByZW5kZXJJdGVtKHNvdXJjZVtrZXldLCBrZXksIGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0ID0gW107XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XG5cbi8qKlxyXG4gKiBDb21waWxlciBydW50aW1lIGhlbHBlciBmb3IgY3JlYXRpbmcgZHluYW1pYyBzbG90cyBvYmplY3RcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVNsb3RzKHNsb3RzLCBkeW5hbWljU2xvdHMpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHluYW1pY1Nsb3RzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3Qgc2xvdCA9IGR5bmFtaWNTbG90c1tpXTtcclxuICAgICAgICAvLyBhcnJheSBvZiBkeW5hbWljIHNsb3QgZ2VuZXJhdGVkIGJ5IDx0ZW1wbGF0ZSB2LWZvcj1cIi4uLlwiICNbLi4uXT5cclxuICAgICAgICBpZiAoaXNBcnJheShzbG90KSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNsb3QubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHNsb3RzW3Nsb3Rbal0ubmFtZV0gPSBzbG90W2pdLmZuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNsb3QpIHtcclxuICAgICAgICAgICAgLy8gY29uZGl0aW9uYWwgc2luZ2xlIHNsb3QgZ2VuZXJhdGVkIGJ5IDx0ZW1wbGF0ZSB2LWlmPVwiLi4uXCIgI2Zvbz5cclxuICAgICAgICAgICAgc2xvdHNbc2xvdC5uYW1lXSA9IHNsb3QuZm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNsb3RzO1xyXG59XG5cbi8qKlxyXG4gKiBDb21waWxlciBydW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIGA8c2xvdC8+YFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gcmVuZGVyU2xvdChzbG90cywgbmFtZSwgcHJvcHMgPSB7fSwgXHJcbi8vIHRoaXMgaXMgbm90IGEgdXNlci1mYWNpbmcgZnVuY3Rpb24sIHNvIHRoZSBmYWxsYmFjayBpcyBhbHdheXMgZ2VuZXJhdGVkIGJ5XHJcbi8vIHRoZSBjb21waWxlciBhbmQgZ3VhcmFudGVlZCB0byBiZSBhIGZ1bmN0aW9uIHJldHVybmluZyBhbiBhcnJheVxyXG5mYWxsYmFjaywgbm9TbG90dGVkKSB7XHJcbiAgICBsZXQgc2xvdCA9IHNsb3RzW25hbWVdO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBzbG90ICYmIHNsb3QubGVuZ3RoID4gMSkge1xyXG4gICAgICAgIHdhcm4oYFNTUi1vcHRpbWl6ZWQgc2xvdCBmdW5jdGlvbiBkZXRlY3RlZCBpbiBhIG5vbi1TU1Itb3B0aW1pemVkIHJlbmRlciBgICtcclxuICAgICAgICAgICAgYGZ1bmN0aW9uLiBZb3UgbmVlZCB0byBtYXJrIHRoaXMgY29tcG9uZW50IHdpdGggJGR5bmFtaWMtc2xvdHMgaW4gdGhlIGAgK1xyXG4gICAgICAgICAgICBgcGFyZW50IHRlbXBsYXRlLmApO1xyXG4gICAgICAgIHNsb3QgPSAoKSA9PiBbXTtcclxuICAgIH1cclxuICAgIC8vIGEgY29tcGlsZWQgc2xvdCBkaXNhYmxlcyBibG9jayB0cmFja2luZyBieSBkZWZhdWx0IHRvIGF2b2lkIG1hbnVhbFxyXG4gICAgLy8gaW52b2NhdGlvbiBpbnRlcmZlcmluZyB3aXRoIHRlbXBsYXRlLWJhc2VkIGJsb2NrIHRyYWNraW5nLCBidXQgaW5cclxuICAgIC8vIGByZW5kZXJTbG90YCB3ZSBjYW4gYmUgc3VyZSB0aGF0IGl0J3MgdGVtcGxhdGUtYmFzZWQgc28gd2UgY2FuIGZvcmNlXHJcbiAgICAvLyBlbmFibGUgaXQuXHJcbiAgICBpZiAoc2xvdCAmJiBzbG90Ll9jKSB7XHJcbiAgICAgICAgc2xvdC5fZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgb3BlbkJsb2NrKCk7XHJcbiAgICBjb25zdCB2YWxpZFNsb3RDb250ZW50ID0gc2xvdCAmJiBlbnN1cmVWYWxpZFZOb2RlKHNsb3QocHJvcHMpKTtcclxuICAgIGNvbnN0IHJlbmRlcmVkID0gY3JlYXRlQmxvY2soRnJhZ21lbnQsIHsga2V5OiBwcm9wcy5rZXkgfHwgYF8ke25hbWV9YCB9LCB2YWxpZFNsb3RDb250ZW50IHx8IChmYWxsYmFjayA/IGZhbGxiYWNrKCkgOiBbXSksIHZhbGlkU2xvdENvbnRlbnQgJiYgc2xvdHMuXyA9PT0gMSAvKiBTVEFCTEUgKi9cclxuICAgICAgICA/IDY0IC8qIFNUQUJMRV9GUkFHTUVOVCAqL1xyXG4gICAgICAgIDogLTIgLyogQkFJTCAqLyk7XHJcbiAgICBpZiAoIW5vU2xvdHRlZCAmJiByZW5kZXJlZC5zY29wZUlkKSB7XHJcbiAgICAgICAgcmVuZGVyZWQuc2xvdFNjb3BlSWRzID0gW3JlbmRlcmVkLnNjb3BlSWQgKyAnLXMnXTtcclxuICAgIH1cclxuICAgIGlmIChzbG90ICYmIHNsb3QuX2MpIHtcclxuICAgICAgICBzbG90Ll9kID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiByZW5kZXJlZDtcclxufVxyXG5mdW5jdGlvbiBlbnN1cmVWYWxpZFZOb2RlKHZub2Rlcykge1xyXG4gICAgcmV0dXJuIHZub2Rlcy5zb21lKGNoaWxkID0+IHtcclxuICAgICAgICBpZiAoIWlzVk5vZGUoY2hpbGQpKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gQ29tbWVudCQxKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IEZyYWdtZW50ICYmXHJcbiAgICAgICAgICAgICFlbnN1cmVWYWxpZFZOb2RlKGNoaWxkLmNoaWxkcmVuKSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSlcclxuICAgICAgICA/IHZub2Rlc1xyXG4gICAgICAgIDogbnVsbDtcclxufVxuXG4vKipcclxuICogRm9yIHByZWZpeGluZyBrZXlzIGluIHYtb249XCJvYmpcIiB3aXRoIFwib25cIlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gdG9IYW5kbGVycyhvYmopIHtcclxuICAgIGNvbnN0IHJldCA9IHt9O1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNPYmplY3Qob2JqKSkge1xyXG4gICAgICAgIHdhcm4oYHYtb24gd2l0aCBubyBhcmd1bWVudCBleHBlY3RzIGFuIG9iamVjdCB2YWx1ZS5gKTtcclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgcmV0W3RvSGFuZGxlcktleShrZXkpXSA9IG9ialtrZXldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldDtcclxufVxuXG4vKipcclxuICogIzI0MzcgSW4gVnVlIDMsIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBkbyBub3QgaGF2ZSBhIHB1YmxpYyBpbnN0YW5jZSBwcm94eSBidXRcclxuICogdGhleSBleGlzdCBpbiB0aGUgaW50ZXJuYWwgcGFyZW50IGNoYWluLiBGb3IgY29kZSB0aGF0IHJlbGllcyBvbiB0cmF2ZXJzaW5nXHJcbiAqIHB1YmxpYyAkcGFyZW50IGNoYWlucywgc2tpcCBmdW5jdGlvbmFsIG9uZXMgYW5kIGdvIHRvIHRoZSBwYXJlbnQgaW5zdGVhZC5cclxuICovXHJcbmNvbnN0IGdldFB1YmxpY0luc3RhbmNlID0gKGkpID0+IHtcclxuICAgIGlmICghaSlcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIGlmIChpc1N0YXRlZnVsQ29tcG9uZW50KGkpKVxyXG4gICAgICAgIHJldHVybiBpLmV4cG9zZWQgPyBpLmV4cG9zZWQgOiBpLnByb3h5O1xyXG4gICAgcmV0dXJuIGdldFB1YmxpY0luc3RhbmNlKGkucGFyZW50KTtcclxufTtcclxuY29uc3QgcHVibGljUHJvcGVydGllc01hcCA9IGV4dGVuZChPYmplY3QuY3JlYXRlKG51bGwpLCB7XHJcbiAgICAkOiBpID0+IGksXHJcbiAgICAkZWw6IGkgPT4gaS52bm9kZS5lbCxcclxuICAgICRkYXRhOiBpID0+IGkuZGF0YSxcclxuICAgICRwcm9wczogaSA9PiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gc2hhbGxvd1JlYWRvbmx5KGkucHJvcHMpIDogaS5wcm9wcyksXHJcbiAgICAkYXR0cnM6IGkgPT4gKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IHNoYWxsb3dSZWFkb25seShpLmF0dHJzKSA6IGkuYXR0cnMpLFxyXG4gICAgJHNsb3RzOiBpID0+ICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBzaGFsbG93UmVhZG9ubHkoaS5zbG90cykgOiBpLnNsb3RzKSxcclxuICAgICRyZWZzOiBpID0+ICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBzaGFsbG93UmVhZG9ubHkoaS5yZWZzKSA6IGkucmVmcyksXHJcbiAgICAkcGFyZW50OiBpID0+IGdldFB1YmxpY0luc3RhbmNlKGkucGFyZW50KSxcclxuICAgICRyb290OiBpID0+IGdldFB1YmxpY0luc3RhbmNlKGkucm9vdCksXHJcbiAgICAkZW1pdDogaSA9PiBpLmVtaXQsXHJcbiAgICAkb3B0aW9uczogaSA9PiAoX19WVUVfT1BUSU9OU19BUElfXyA/IHJlc29sdmVNZXJnZWRPcHRpb25zKGkpIDogaS50eXBlKSxcclxuICAgICRmb3JjZVVwZGF0ZTogaSA9PiAoKSA9PiBxdWV1ZUpvYihpLnVwZGF0ZSksXHJcbiAgICAkbmV4dFRpY2s6IGkgPT4gbmV4dFRpY2suYmluZChpLnByb3h5KSxcclxuICAgICR3YXRjaDogaSA9PiAoX19WVUVfT1BUSU9OU19BUElfXyA/IGluc3RhbmNlV2F0Y2guYmluZChpKSA6IE5PT1ApXHJcbn0pO1xyXG5jb25zdCBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMgPSB7XHJcbiAgICBnZXQoeyBfOiBpbnN0YW5jZSB9LCBrZXkpIHtcclxuICAgICAgICBjb25zdCB7IGN0eCwgc2V0dXBTdGF0ZSwgZGF0YSwgcHJvcHMsIGFjY2Vzc0NhY2hlLCB0eXBlLCBhcHBDb250ZXh0IH0gPSBpbnN0YW5jZTtcclxuICAgICAgICAvLyBsZXQgQHZ1ZS9yZWFjdGl2aXR5IGtub3cgaXQgc2hvdWxkIG5ldmVyIG9ic2VydmUgVnVlIHB1YmxpYyBpbnN0YW5jZXMuXHJcbiAgICAgICAgaWYgKGtleSA9PT0gXCJfX3Zfc2tpcFwiIC8qIFNLSVAgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGZvciBpbnRlcm5hbCBmb3JtYXR0ZXJzIHRvIGtub3cgdGhhdCB0aGlzIGlzIGEgVnVlIGluc3RhbmNlXHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBrZXkgPT09ICdfX2lzVnVlJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZGF0YSAvIHByb3BzIC8gY3R4XHJcbiAgICAgICAgLy8gVGhpcyBnZXR0ZXIgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IHByb3BlcnR5IGFjY2VzcyBvbiB0aGUgcmVuZGVyIGNvbnRleHRcclxuICAgICAgICAvLyBkdXJpbmcgcmVuZGVyIGFuZCBpcyBhIG1ham9yIGhvdHNwb3QuIFRoZSBtb3N0IGV4cGVuc2l2ZSBwYXJ0IG9mIHRoaXNcclxuICAgICAgICAvLyBpcyB0aGUgbXVsdGlwbGUgaGFzT3duKCkgY2FsbHMuIEl0J3MgbXVjaCBmYXN0ZXIgdG8gZG8gYSBzaW1wbGUgcHJvcGVydHlcclxuICAgICAgICAvLyBhY2Nlc3Mgb24gYSBwbGFpbiBvYmplY3QsIHNvIHdlIHVzZSBhbiBhY2Nlc3NDYWNoZSBvYmplY3QgKHdpdGggbnVsbFxyXG4gICAgICAgIC8vIHByb3RvdHlwZSkgdG8gbWVtb2l6ZSB3aGF0IGFjY2VzcyB0eXBlIGEga2V5IGNvcnJlc3BvbmRzIHRvLlxyXG4gICAgICAgIGxldCBub3JtYWxpemVkUHJvcHM7XHJcbiAgICAgICAgaWYgKGtleVswXSAhPT0gJyQnKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG4gPSBhY2Nlc3NDYWNoZVtrZXldO1xyXG4gICAgICAgICAgICBpZiAobiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG4pIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDAgLyogU0VUVVAgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXR1cFN0YXRlW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxIC8qIERBVEEgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzIC8qIENPTlRFWFQgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHhba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDIgLyogUFJPUFMgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wc1trZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQ6IGp1c3QgZmFsbHRocm91Z2hcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzZXR1cFN0YXRlICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKHNldHVwU3RhdGUsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAwIC8qIFNFVFVQICovO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldHVwU3RhdGVba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGRhdGEsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAxIC8qIERBVEEgKi87XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKFxyXG4gICAgICAgICAgICAvLyBvbmx5IGNhY2hlIG90aGVyIHByb3BlcnRpZXMgd2hlbiBpbnN0YW5jZSBoYXMgZGVjbGFyZWQgKHRodXMgc3RhYmxlKVxyXG4gICAgICAgICAgICAvLyBwcm9wc1xyXG4gICAgICAgICAgICAobm9ybWFsaXplZFByb3BzID0gaW5zdGFuY2UucHJvcHNPcHRpb25zWzBdKSAmJlxyXG4gICAgICAgICAgICAgICAgaGFzT3duKG5vcm1hbGl6ZWRQcm9wcywga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDIgLyogUFJPUFMgKi87XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHNba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjdHggIT09IEVNUFRZX09CSiAmJiBoYXNPd24oY3R4LCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMyAvKiBDT05URVhUICovO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eFtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFfX1ZVRV9PUFRJT05TX0FQSV9fIHx8IHNob3VsZENhY2hlQWNjZXNzKSB7XHJcbiAgICAgICAgICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gNCAvKiBPVEhFUiAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwdWJsaWNHZXR0ZXIgPSBwdWJsaWNQcm9wZXJ0aWVzTWFwW2tleV07XHJcbiAgICAgICAgbGV0IGNzc01vZHVsZSwgZ2xvYmFsUHJvcGVydGllcztcclxuICAgICAgICAvLyBwdWJsaWMgJHh4eCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgaWYgKHB1YmxpY0dldHRlcikge1xyXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnJGF0dHJzJykge1xyXG4gICAgICAgICAgICAgICAgdHJhY2soaW5zdGFuY2UsIFwiZ2V0XCIgLyogR0VUICovLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHB1YmxpY0dldHRlcihpbnN0YW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKFxyXG4gICAgICAgIC8vIGNzcyBtb2R1bGUgKGluamVjdGVkIGJ5IHZ1ZS1sb2FkZXIpXHJcbiAgICAgICAgKGNzc01vZHVsZSA9IHR5cGUuX19jc3NNb2R1bGVzKSAmJlxyXG4gICAgICAgICAgICAoY3NzTW9kdWxlID0gY3NzTW9kdWxlW2tleV0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjc3NNb2R1bGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGN0eCAhPT0gRU1QVFlfT0JKICYmIGhhc093bihjdHgsIGtleSkpIHtcclxuICAgICAgICAgICAgLy8gdXNlciBtYXkgc2V0IGN1c3RvbSBwcm9wZXJ0aWVzIHRvIGB0aGlzYCB0aGF0IHN0YXJ0IHdpdGggYCRgXHJcbiAgICAgICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAzIC8qIENPTlRFWFQgKi87XHJcbiAgICAgICAgICAgIHJldHVybiBjdHhba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoXHJcbiAgICAgICAgLy8gZ2xvYmFsIHByb3BlcnRpZXNcclxuICAgICAgICAoKGdsb2JhbFByb3BlcnRpZXMgPSBhcHBDb250ZXh0LmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzKSxcclxuICAgICAgICAgICAgaGFzT3duKGdsb2JhbFByb3BlcnRpZXMsIGtleSkpKSB7XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBnbG9iYWxQcm9wZXJ0aWVzW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSAmJlxyXG4gICAgICAgICAgICAoIWlzU3RyaW5nKGtleSkgfHxcclxuICAgICAgICAgICAgICAgIC8vICMxMDkxIGF2b2lkIGludGVybmFsIGlzUmVmL2lzVk5vZGUgY2hlY2tzIG9uIGNvbXBvbmVudCBpbnN0YW5jZSBsZWFkaW5nXHJcbiAgICAgICAgICAgICAgICAvLyB0byBpbmZpbml0ZSB3YXJuaW5nIGxvb3BcclxuICAgICAgICAgICAgICAgIGtleS5pbmRleE9mKCdfX3YnKSAhPT0gMCkpIHtcclxuICAgICAgICAgICAgaWYgKGRhdGEgIT09IEVNUFRZX09CSiAmJlxyXG4gICAgICAgICAgICAgICAgKGtleVswXSA9PT0gJyQnIHx8IGtleVswXSA9PT0gJ18nKSAmJlxyXG4gICAgICAgICAgICAgICAgaGFzT3duKGRhdGEsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYFByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoa2V5KX0gbXVzdCBiZSBhY2Nlc3NlZCB2aWEgJGRhdGEgYmVjYXVzZSBpdCBzdGFydHMgd2l0aCBhIHJlc2VydmVkIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBjaGFyYWN0ZXIgKFwiJFwiIG9yIFwiX1wiKSBhbmQgaXMgbm90IHByb3hpZWQgb24gdGhlIHJlbmRlciBjb250ZXh0LmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGluc3RhbmNlID09PSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oYFByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoa2V5KX0gd2FzIGFjY2Vzc2VkIGR1cmluZyByZW5kZXIgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYGJ1dCBpcyBub3QgZGVmaW5lZCBvbiBpbnN0YW5jZS5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBzZXQoeyBfOiBpbnN0YW5jZSB9LCBrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgeyBkYXRhLCBzZXR1cFN0YXRlLCBjdHggfSA9IGluc3RhbmNlO1xyXG4gICAgICAgIGlmIChzZXR1cFN0YXRlICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKHNldHVwU3RhdGUsIGtleSkpIHtcclxuICAgICAgICAgICAgc2V0dXBTdGF0ZVtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRhdGEgIT09IEVNUFRZX09CSiAmJiBoYXNPd24oZGF0YSwga2V5KSkge1xyXG4gICAgICAgICAgICBkYXRhW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaGFzT3duKGluc3RhbmNlLnByb3BzLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgd2FybihgQXR0ZW1wdGluZyB0byBtdXRhdGUgcHJvcCBcIiR7a2V5fVwiLiBQcm9wcyBhcmUgcmVhZG9ubHkuYCwgaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChrZXlbMF0gPT09ICckJyAmJiBrZXkuc2xpY2UoMSkgaW4gaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgICAgICB3YXJuKGBBdHRlbXB0aW5nIHRvIG11dGF0ZSBwdWJsaWMgcHJvcGVydHkgXCIke2tleX1cIi4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYFByb3BlcnRpZXMgc3RhcnRpbmcgd2l0aCAkIGFyZSByZXNlcnZlZCBhbmQgcmVhZG9ubHkuYCwgaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGtleSBpbiBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcclxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjdHhba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSxcclxuICAgIGhhcyh7IF86IHsgZGF0YSwgc2V0dXBTdGF0ZSwgYWNjZXNzQ2FjaGUsIGN0eCwgYXBwQ29udGV4dCwgcHJvcHNPcHRpb25zIH0gfSwga2V5KSB7XHJcbiAgICAgICAgbGV0IG5vcm1hbGl6ZWRQcm9wcztcclxuICAgICAgICByZXR1cm4gKGFjY2Vzc0NhY2hlW2tleV0gIT09IHVuZGVmaW5lZCB8fFxyXG4gICAgICAgICAgICAoZGF0YSAhPT0gRU1QVFlfT0JKICYmIGhhc093bihkYXRhLCBrZXkpKSB8fFxyXG4gICAgICAgICAgICAoc2V0dXBTdGF0ZSAhPT0gRU1QVFlfT0JKICYmIGhhc093bihzZXR1cFN0YXRlLCBrZXkpKSB8fFxyXG4gICAgICAgICAgICAoKG5vcm1hbGl6ZWRQcm9wcyA9IHByb3BzT3B0aW9uc1swXSkgJiYgaGFzT3duKG5vcm1hbGl6ZWRQcm9wcywga2V5KSkgfHxcclxuICAgICAgICAgICAgaGFzT3duKGN0eCwga2V5KSB8fFxyXG4gICAgICAgICAgICBoYXNPd24ocHVibGljUHJvcGVydGllc01hcCwga2V5KSB8fFxyXG4gICAgICAgICAgICBoYXNPd24oYXBwQ29udGV4dC5jb25maWcuZ2xvYmFsUHJvcGVydGllcywga2V5KSk7XHJcbiAgICB9XHJcbn07XHJcbmlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWZhbHNlKSB7XHJcbiAgICBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMub3duS2V5cyA9ICh0YXJnZXQpID0+IHtcclxuICAgICAgICB3YXJuKGBBdm9pZCBhcHAgbG9naWMgdGhhdCByZWxpZXMgb24gZW51bWVyYXRpbmcga2V5cyBvbiBhIGNvbXBvbmVudCBpbnN0YW5jZS4gYCArXHJcbiAgICAgICAgICAgIGBUaGUga2V5cyB3aWxsIGJlIGVtcHR5IGluIHByb2R1Y3Rpb24gbW9kZSB0byBhdm9pZCBwZXJmb3JtYW5jZSBvdmVyaGVhZC5gKTtcclxuICAgICAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldCk7XHJcbiAgICB9O1xyXG59XHJcbmNvbnN0IFJ1bnRpbWVDb21waWxlZFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyA9IGV4dGVuZCh7fSwgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLCB7XHJcbiAgICBnZXQodGFyZ2V0LCBrZXkpIHtcclxuICAgICAgICAvLyBmYXN0IHBhdGggZm9yIHVuc2NvcGFibGVzIHdoZW4gdXNpbmcgYHdpdGhgIGJsb2NrXHJcbiAgICAgICAgaWYgKGtleSA9PT0gU3ltYm9sLnVuc2NvcGFibGVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycy5nZXQodGFyZ2V0LCBrZXksIHRhcmdldCk7XHJcbiAgICB9LFxyXG4gICAgaGFzKF8sIGtleSkge1xyXG4gICAgICAgIGNvbnN0IGhhcyA9IGtleVswXSAhPT0gJ18nICYmICFpc0dsb2JhbGx5V2hpdGVsaXN0ZWQoa2V5KTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFoYXMgJiYgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLmhhcyhfLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYFByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoa2V5KX0gc2hvdWxkIG5vdCBzdGFydCB3aXRoIF8gd2hpY2ggaXMgYSByZXNlcnZlZCBwcmVmaXggZm9yIFZ1ZSBpbnRlcm5hbHMuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBoYXM7XHJcbiAgICB9XHJcbn0pO1xyXG4vLyBJbiBkZXYgbW9kZSwgdGhlIHByb3h5IHRhcmdldCBleHBvc2VzIHRoZSBzYW1lIHByb3BlcnRpZXMgYXMgc2VlbiBvbiBgdGhpc2BcclxuLy8gZm9yIGVhc2llciBjb25zb2xlIGluc3BlY3Rpb24uIEluIHByb2QgbW9kZSBpdCB3aWxsIGJlIGFuIGVtcHR5IG9iamVjdCBzb1xyXG4vLyB0aGVzZSBwcm9wZXJ0aWVzIGRlZmluaXRpb25zIGNhbiBiZSBza2lwcGVkLlxyXG5mdW5jdGlvbiBjcmVhdGVSZW5kZXJDb250ZXh0KGluc3RhbmNlKSB7XHJcbiAgICBjb25zdCB0YXJnZXQgPSB7fTtcclxuICAgIC8vIGV4cG9zZSBpbnRlcm5hbCBpbnN0YW5jZSBmb3IgcHJveHkgaGFuZGxlcnNcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGBfYCwge1xyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBnZXQ6ICgpID0+IGluc3RhbmNlXHJcbiAgICB9KTtcclxuICAgIC8vIGV4cG9zZSBwdWJsaWMgcHJvcGVydGllc1xyXG4gICAgT2JqZWN0LmtleXMocHVibGljUHJvcGVydGllc01hcCkuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwge1xyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBnZXQ6ICgpID0+IHB1YmxpY1Byb3BlcnRpZXNNYXBba2V5XShpbnN0YW5jZSksXHJcbiAgICAgICAgICAgIC8vIGludGVyY2VwdGVkIGJ5IHRoZSBwcm94eSBzbyBubyBuZWVkIGZvciBpbXBsZW1lbnRhdGlvbixcclxuICAgICAgICAgICAgLy8gYnV0IG5lZWRlZCB0byBwcmV2ZW50IHNldCBlcnJvcnNcclxuICAgICAgICAgICAgc2V0OiBOT09QXHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn1cclxuLy8gZGV2IG9ubHlcclxuZnVuY3Rpb24gZXhwb3NlUHJvcHNPblJlbmRlckNvbnRleHQoaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IHsgY3R4LCBwcm9wc09wdGlvbnM6IFtwcm9wc09wdGlvbnNdIH0gPSBpbnN0YW5jZTtcclxuICAgIGlmIChwcm9wc09wdGlvbnMpIHtcclxuICAgICAgICBPYmplY3Qua2V5cyhwcm9wc09wdGlvbnMpLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiBpbnN0YW5jZS5wcm9wc1trZXldLFxyXG4gICAgICAgICAgICAgICAgc2V0OiBOT09QXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbi8vIGRldiBvbmx5XHJcbmZ1bmN0aW9uIGV4cG9zZVNldHVwU3RhdGVPblJlbmRlckNvbnRleHQoaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IHsgY3R4LCBzZXR1cFN0YXRlIH0gPSBpbnN0YW5jZTtcclxuICAgIE9iamVjdC5rZXlzKHRvUmF3KHNldHVwU3RhdGUpKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgaWYgKGtleVswXSA9PT0gJyQnIHx8IGtleVswXSA9PT0gJ18nKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYHNldHVwKCkgcmV0dXJuIHByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoa2V5KX0gc2hvdWxkIG5vdCBzdGFydCB3aXRoIFwiJFwiIG9yIFwiX1wiIGAgK1xyXG4gICAgICAgICAgICAgICAgYHdoaWNoIGFyZSByZXNlcnZlZCBwcmVmaXhlcyBmb3IgVnVlIGludGVybmFscy5gKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBnZXQ6ICgpID0+IHNldHVwU3RhdGVba2V5XSxcclxuICAgICAgICAgICAgc2V0OiBOT09QXHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxuXG5jb25zdCBlbXB0eUFwcENvbnRleHQgPSBjcmVhdGVBcHBDb250ZXh0KCk7XHJcbmxldCB1aWQkMSA9IDA7XHJcbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlKHZub2RlLCBwYXJlbnQsIHN1c3BlbnNlKSB7XHJcbiAgICBjb25zdCB0eXBlID0gdm5vZGUudHlwZTtcclxuICAgIC8vIGluaGVyaXQgcGFyZW50IGFwcCBjb250ZXh0IC0gb3IgLSBpZiByb290LCBhZG9wdCBmcm9tIHJvb3Qgdm5vZGVcclxuICAgIGNvbnN0IGFwcENvbnRleHQgPSAocGFyZW50ID8gcGFyZW50LmFwcENvbnRleHQgOiB2bm9kZS5hcHBDb250ZXh0KSB8fCBlbXB0eUFwcENvbnRleHQ7XHJcbiAgICBjb25zdCBpbnN0YW5jZSA9IHtcclxuICAgICAgICB1aWQ6IHVpZCQxKyssXHJcbiAgICAgICAgdm5vZGUsXHJcbiAgICAgICAgdHlwZSxcclxuICAgICAgICBwYXJlbnQsXHJcbiAgICAgICAgYXBwQ29udGV4dCxcclxuICAgICAgICByb290OiBudWxsLFxyXG4gICAgICAgIG5leHQ6IG51bGwsXHJcbiAgICAgICAgc3ViVHJlZTogbnVsbCxcclxuICAgICAgICB1cGRhdGU6IG51bGwsXHJcbiAgICAgICAgcmVuZGVyOiBudWxsLFxyXG4gICAgICAgIHByb3h5OiBudWxsLFxyXG4gICAgICAgIGV4cG9zZWQ6IG51bGwsXHJcbiAgICAgICAgd2l0aFByb3h5OiBudWxsLFxyXG4gICAgICAgIGVmZmVjdHM6IG51bGwsXHJcbiAgICAgICAgcHJvdmlkZXM6IHBhcmVudCA/IHBhcmVudC5wcm92aWRlcyA6IE9iamVjdC5jcmVhdGUoYXBwQ29udGV4dC5wcm92aWRlcyksXHJcbiAgICAgICAgYWNjZXNzQ2FjaGU6IG51bGwsXHJcbiAgICAgICAgcmVuZGVyQ2FjaGU6IFtdLFxyXG4gICAgICAgIC8vIGxvY2FsIHJlc292bGVkIGFzc2V0c1xyXG4gICAgICAgIGNvbXBvbmVudHM6IG51bGwsXHJcbiAgICAgICAgZGlyZWN0aXZlczogbnVsbCxcclxuICAgICAgICAvLyByZXNvbHZlZCBwcm9wcyBhbmQgZW1pdHMgb3B0aW9uc1xyXG4gICAgICAgIHByb3BzT3B0aW9uczogbm9ybWFsaXplUHJvcHNPcHRpb25zKHR5cGUsIGFwcENvbnRleHQpLFxyXG4gICAgICAgIGVtaXRzT3B0aW9uczogbm9ybWFsaXplRW1pdHNPcHRpb25zKHR5cGUsIGFwcENvbnRleHQpLFxyXG4gICAgICAgIC8vIGVtaXRcclxuICAgICAgICBlbWl0OiBudWxsLFxyXG4gICAgICAgIGVtaXR0ZWQ6IG51bGwsXHJcbiAgICAgICAgLy8gcHJvcHMgZGVmYXVsdCB2YWx1ZVxyXG4gICAgICAgIHByb3BzRGVmYXVsdHM6IEVNUFRZX09CSixcclxuICAgICAgICAvLyBpbmhlcml0QXR0cnNcclxuICAgICAgICBpbmhlcml0QXR0cnM6IHR5cGUuaW5oZXJpdEF0dHJzLFxyXG4gICAgICAgIC8vIHN0YXRlXHJcbiAgICAgICAgY3R4OiBFTVBUWV9PQkosXHJcbiAgICAgICAgZGF0YTogRU1QVFlfT0JKLFxyXG4gICAgICAgIHByb3BzOiBFTVBUWV9PQkosXHJcbiAgICAgICAgYXR0cnM6IEVNUFRZX09CSixcclxuICAgICAgICBzbG90czogRU1QVFlfT0JKLFxyXG4gICAgICAgIHJlZnM6IEVNUFRZX09CSixcclxuICAgICAgICBzZXR1cFN0YXRlOiBFTVBUWV9PQkosXHJcbiAgICAgICAgc2V0dXBDb250ZXh0OiBudWxsLFxyXG4gICAgICAgIC8vIHN1c3BlbnNlIHJlbGF0ZWRcclxuICAgICAgICBzdXNwZW5zZSxcclxuICAgICAgICBzdXNwZW5zZUlkOiBzdXNwZW5zZSA/IHN1c3BlbnNlLnBlbmRpbmdJZCA6IDAsXHJcbiAgICAgICAgYXN5bmNEZXA6IG51bGwsXHJcbiAgICAgICAgYXN5bmNSZXNvbHZlZDogZmFsc2UsXHJcbiAgICAgICAgLy8gbGlmZWN5Y2xlIGhvb2tzXHJcbiAgICAgICAgLy8gbm90IHVzaW5nIGVudW1zIGhlcmUgYmVjYXVzZSBpdCByZXN1bHRzIGluIGNvbXB1dGVkIHByb3BlcnRpZXNcclxuICAgICAgICBpc01vdW50ZWQ6IGZhbHNlLFxyXG4gICAgICAgIGlzVW5tb3VudGVkOiBmYWxzZSxcclxuICAgICAgICBpc0RlYWN0aXZhdGVkOiBmYWxzZSxcclxuICAgICAgICBiYzogbnVsbCxcclxuICAgICAgICBjOiBudWxsLFxyXG4gICAgICAgIGJtOiBudWxsLFxyXG4gICAgICAgIG06IG51bGwsXHJcbiAgICAgICAgYnU6IG51bGwsXHJcbiAgICAgICAgdTogbnVsbCxcclxuICAgICAgICB1bTogbnVsbCxcclxuICAgICAgICBidW06IG51bGwsXHJcbiAgICAgICAgZGE6IG51bGwsXHJcbiAgICAgICAgYTogbnVsbCxcclxuICAgICAgICBydGc6IG51bGwsXHJcbiAgICAgICAgcnRjOiBudWxsLFxyXG4gICAgICAgIGVjOiBudWxsLFxyXG4gICAgICAgIHNwOiBudWxsXHJcbiAgICB9O1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGluc3RhbmNlLmN0eCA9IGNyZWF0ZVJlbmRlckNvbnRleHQoaW5zdGFuY2UpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaW5zdGFuY2UuY3R4ID0geyBfOiBpbnN0YW5jZSB9O1xyXG4gICAgfVxyXG4gICAgaW5zdGFuY2Uucm9vdCA9IHBhcmVudCA/IHBhcmVudC5yb290IDogaW5zdGFuY2U7XHJcbiAgICBpbnN0YW5jZS5lbWl0ID0gZW1pdC5iaW5kKG51bGwsIGluc3RhbmNlKTtcclxuICAgIHJldHVybiBpbnN0YW5jZTtcclxufVxyXG5sZXQgY3VycmVudEluc3RhbmNlID0gbnVsbDtcclxuY29uc3QgZ2V0Q3VycmVudEluc3RhbmNlID0gKCkgPT4gY3VycmVudEluc3RhbmNlIHx8IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcclxuY29uc3Qgc2V0Q3VycmVudEluc3RhbmNlID0gKGluc3RhbmNlKSA9PiB7XHJcbiAgICBjdXJyZW50SW5zdGFuY2UgPSBpbnN0YW5jZTtcclxufTtcclxuY29uc3QgaXNCdWlsdEluVGFnID0gLyojX19QVVJFX18qLyBtYWtlTWFwKCdzbG90LGNvbXBvbmVudCcpO1xyXG5mdW5jdGlvbiB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSwgY29uZmlnKSB7XHJcbiAgICBjb25zdCBhcHBJc05hdGl2ZVRhZyA9IGNvbmZpZy5pc05hdGl2ZVRhZyB8fCBOTztcclxuICAgIGlmIChpc0J1aWx0SW5UYWcobmFtZSkgfHwgYXBwSXNOYXRpdmVUYWcobmFtZSkpIHtcclxuICAgICAgICB3YXJuKCdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50IGlkOiAnICsgbmFtZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaXNTdGF0ZWZ1bENvbXBvbmVudChpbnN0YW5jZSkge1xyXG4gICAgcmV0dXJuIGluc3RhbmNlLnZub2RlLnNoYXBlRmxhZyAmIDQgLyogU1RBVEVGVUxfQ09NUE9ORU5UICovO1xyXG59XHJcbmxldCBpc0luU1NSQ29tcG9uZW50U2V0dXAgPSBmYWxzZTtcclxuZnVuY3Rpb24gc2V0dXBDb21wb25lbnQoaW5zdGFuY2UsIGlzU1NSID0gZmFsc2UpIHtcclxuICAgIGlzSW5TU1JDb21wb25lbnRTZXR1cCA9IGlzU1NSO1xyXG4gICAgY29uc3QgeyBwcm9wcywgY2hpbGRyZW4gfSA9IGluc3RhbmNlLnZub2RlO1xyXG4gICAgY29uc3QgaXNTdGF0ZWZ1bCA9IGlzU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UpO1xyXG4gICAgaW5pdFByb3BzKGluc3RhbmNlLCBwcm9wcywgaXNTdGF0ZWZ1bCwgaXNTU1IpO1xyXG4gICAgaW5pdFNsb3RzKGluc3RhbmNlLCBjaGlsZHJlbik7XHJcbiAgICBjb25zdCBzZXR1cFJlc3VsdCA9IGlzU3RhdGVmdWxcclxuICAgICAgICA/IHNldHVwU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UsIGlzU1NSKVxyXG4gICAgICAgIDogdW5kZWZpbmVkO1xyXG4gICAgaXNJblNTUkNvbXBvbmVudFNldHVwID0gZmFsc2U7XHJcbiAgICByZXR1cm4gc2V0dXBSZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gc2V0dXBTdGF0ZWZ1bENvbXBvbmVudChpbnN0YW5jZSwgaXNTU1IpIHtcclxuICAgIGNvbnN0IENvbXBvbmVudCA9IGluc3RhbmNlLnR5cGU7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgaWYgKENvbXBvbmVudC5uYW1lKSB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShDb21wb25lbnQubmFtZSwgaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoQ29tcG9uZW50LmNvbXBvbmVudHMpIHtcclxuICAgICAgICAgICAgY29uc3QgbmFtZXMgPSBPYmplY3Qua2V5cyhDb21wb25lbnQuY29tcG9uZW50cyk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lc1tpXSwgaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChDb21wb25lbnQuZGlyZWN0aXZlcykge1xyXG4gICAgICAgICAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKENvbXBvbmVudC5kaXJlY3RpdmVzKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFsaWRhdGVEaXJlY3RpdmVOYW1lKG5hbWVzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoQ29tcG9uZW50LmNvbXBpbGVyT3B0aW9ucyAmJiBpc1J1bnRpbWVPbmx5KCkpIHtcclxuICAgICAgICAgICAgd2FybihgXCJjb21waWxlck9wdGlvbnNcIiBpcyBvbmx5IHN1cHBvcnRlZCB3aGVuIHVzaW5nIGEgYnVpbGQgb2YgVnVlIHRoYXQgYCArXHJcbiAgICAgICAgICAgICAgICBgaW5jbHVkZXMgdGhlIHJ1bnRpbWUgY29tcGlsZXIuIFNpbmNlIHlvdSBhcmUgdXNpbmcgYSBydW50aW1lLW9ubHkgYCArXHJcbiAgICAgICAgICAgICAgICBgYnVpbGQsIHRoZSBvcHRpb25zIHNob3VsZCBiZSBwYXNzZWQgdmlhIHlvdXIgYnVpbGQgdG9vbCBjb25maWcgaW5zdGVhZC5gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyAwLiBjcmVhdGUgcmVuZGVyIHByb3h5IHByb3BlcnR5IGFjY2VzcyBjYWNoZVxyXG4gICAgaW5zdGFuY2UuYWNjZXNzQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgLy8gMS4gY3JlYXRlIHB1YmxpYyBpbnN0YW5jZSAvIHJlbmRlciBwcm94eVxyXG4gICAgLy8gYWxzbyBtYXJrIGl0IHJhdyBzbyBpdCdzIG5ldmVyIG9ic2VydmVkXHJcbiAgICBpbnN0YW5jZS5wcm94eSA9IG5ldyBQcm94eShpbnN0YW5jZS5jdHgsIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyk7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgZXhwb3NlUHJvcHNPblJlbmRlckNvbnRleHQoaW5zdGFuY2UpO1xyXG4gICAgfVxyXG4gICAgLy8gMi4gY2FsbCBzZXR1cCgpXHJcbiAgICBjb25zdCB7IHNldHVwIH0gPSBDb21wb25lbnQ7XHJcbiAgICBpZiAoc2V0dXApIHtcclxuICAgICAgICBjb25zdCBzZXR1cENvbnRleHQgPSAoaW5zdGFuY2Uuc2V0dXBDb250ZXh0ID1cclxuICAgICAgICAgICAgc2V0dXAubGVuZ3RoID4gMSA/IGNyZWF0ZVNldHVwQ29udGV4dChpbnN0YW5jZSkgOiBudWxsKTtcclxuICAgICAgICBjdXJyZW50SW5zdGFuY2UgPSBpbnN0YW5jZTtcclxuICAgICAgICBwYXVzZVRyYWNraW5nKCk7XHJcbiAgICAgICAgY29uc3Qgc2V0dXBSZXN1bHQgPSBjYWxsV2l0aEVycm9ySGFuZGxpbmcoc2V0dXAsIGluc3RhbmNlLCAwIC8qIFNFVFVQX0ZVTkNUSU9OICovLCBbKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gc2hhbGxvd1JlYWRvbmx5KGluc3RhbmNlLnByb3BzKSA6IGluc3RhbmNlLnByb3BzLCBzZXR1cENvbnRleHRdKTtcclxuICAgICAgICByZXNldFRyYWNraW5nKCk7XHJcbiAgICAgICAgY3VycmVudEluc3RhbmNlID0gbnVsbDtcclxuICAgICAgICBpZiAoaXNQcm9taXNlKHNldHVwUmVzdWx0KSkge1xyXG4gICAgICAgICAgICBpZiAoaXNTU1IpIHtcclxuICAgICAgICAgICAgICAgIC8vIHJldHVybiB0aGUgcHJvbWlzZSBzbyBzZXJ2ZXItcmVuZGVyZXIgY2FuIHdhaXQgb24gaXRcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZXR1cFJlc3VsdFxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChyZXNvbHZlZFJlc3VsdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCByZXNvbHZlZFJlc3VsdCwgaXNTU1IpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoZSwgaW5zdGFuY2UsIDAgLyogU0VUVVBfRlVOQ1RJT04gKi8pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhc3luYyBzZXR1cCByZXR1cm5lZCBQcm9taXNlLlxyXG4gICAgICAgICAgICAgICAgLy8gYmFpbCBoZXJlIGFuZCB3YWl0IGZvciByZS1lbnRyeS5cclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmFzeW5jRGVwID0gc2V0dXBSZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCBzZXR1cFJlc3VsdCwgaXNTU1IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGZpbmlzaENvbXBvbmVudFNldHVwKGluc3RhbmNlLCBpc1NTUik7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIHNldHVwUmVzdWx0LCBpc1NTUikge1xyXG4gICAgaWYgKGlzRnVuY3Rpb24oc2V0dXBSZXN1bHQpKSB7XHJcbiAgICAgICAgLy8gc2V0dXAgcmV0dXJuZWQgYW4gaW5saW5lIHJlbmRlciBmdW5jdGlvblxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UucmVuZGVyID0gc2V0dXBSZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYmplY3Qoc2V0dXBSZXN1bHQpKSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpc1ZOb2RlKHNldHVwUmVzdWx0KSkge1xyXG4gICAgICAgICAgICB3YXJuKGBzZXR1cCgpIHNob3VsZCBub3QgcmV0dXJuIFZOb2RlcyBkaXJlY3RseSAtIGAgK1xyXG4gICAgICAgICAgICAgICAgYHJldHVybiBhIHJlbmRlciBmdW5jdGlvbiBpbnN0ZWFkLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzZXR1cCByZXR1cm5lZCBiaW5kaW5ncy5cclxuICAgICAgICAvLyBhc3N1bWluZyBhIHJlbmRlciBmdW5jdGlvbiBjb21waWxlZCBmcm9tIHRlbXBsYXRlIGlzIHByZXNlbnQuXHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UuZGV2dG9vbHNSYXdTZXR1cFN0YXRlID0gc2V0dXBSZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluc3RhbmNlLnNldHVwU3RhdGUgPSBwcm94eVJlZnMoc2V0dXBSZXN1bHQpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgZXhwb3NlU2V0dXBTdGF0ZU9uUmVuZGVyQ29udGV4dChpbnN0YW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHNldHVwUmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB3YXJuKGBzZXR1cCgpIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0LiBSZWNlaXZlZDogJHtzZXR1cFJlc3VsdCA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBzZXR1cFJlc3VsdH1gKTtcclxuICAgIH1cclxuICAgIGZpbmlzaENvbXBvbmVudFNldHVwKGluc3RhbmNlLCBpc1NTUik7XHJcbn1cclxubGV0IGNvbXBpbGU7XHJcbi8vIGRldiBvbmx5XHJcbmNvbnN0IGlzUnVudGltZU9ubHkgPSAoKSA9PiAhY29tcGlsZTtcclxuLyoqXHJcbiAqIEZvciBydW50aW1lLWRvbSB0byByZWdpc3RlciB0aGUgY29tcGlsZXIuXHJcbiAqIE5vdGUgdGhlIGV4cG9ydGVkIG1ldGhvZCB1c2VzIGFueSB0byBhdm9pZCBkLnRzIHJlbHlpbmcgb24gdGhlIGNvbXBpbGVyIHR5cGVzLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVnaXN0ZXJSdW50aW1lQ29tcGlsZXIoX2NvbXBpbGUpIHtcclxuICAgIGNvbXBpbGUgPSBfY29tcGlsZTtcclxufVxyXG5mdW5jdGlvbiBmaW5pc2hDb21wb25lbnRTZXR1cChpbnN0YW5jZSwgaXNTU1IsIHNraXBPcHRpb25zKSB7XHJcbiAgICBjb25zdCBDb21wb25lbnQgPSBpbnN0YW5jZS50eXBlO1xyXG4gICAgLy8gdGVtcGxhdGUgLyByZW5kZXIgZnVuY3Rpb24gbm9ybWFsaXphdGlvblxyXG4gICAgaWYgKCFpbnN0YW5jZS5yZW5kZXIpIHtcclxuICAgICAgICAvLyBjb3VsZCBiZSBzZXQgZnJvbSBzZXR1cCgpXHJcbiAgICAgICAgaWYgKGNvbXBpbGUgJiYgIUNvbXBvbmVudC5yZW5kZXIpIHtcclxuICAgICAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBDb21wb25lbnQudGVtcGxhdGU7XHJcbiAgICAgICAgICAgIGlmICh0ZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYGNvbXBpbGVgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgaXNDdXN0b21FbGVtZW50LCBjb21waWxlck9wdGlvbnMgfSA9IGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBkZWxpbWl0ZXJzLCBjb21waWxlck9wdGlvbnM6IGNvbXBvbmVudENvbXBpbGVyT3B0aW9ucyB9ID0gQ29tcG9uZW50O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZmluYWxDb21waWxlck9wdGlvbnMgPSBleHRlbmQoZXh0ZW5kKHtcclxuICAgICAgICAgICAgICAgICAgICBpc0N1c3RvbUVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgZGVsaW1pdGVyc1xyXG4gICAgICAgICAgICAgICAgfSwgY29tcGlsZXJPcHRpb25zKSwgY29tcG9uZW50Q29tcGlsZXJPcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIENvbXBvbmVudC5yZW5kZXIgPSBjb21waWxlKHRlbXBsYXRlLCBmaW5hbENvbXBpbGVyT3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYGNvbXBpbGVgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpbnN0YW5jZS5yZW5kZXIgPSAoQ29tcG9uZW50LnJlbmRlciB8fCBOT09QKTtcclxuICAgICAgICAvLyBmb3IgcnVudGltZS1jb21waWxlZCByZW5kZXIgZnVuY3Rpb25zIHVzaW5nIGB3aXRoYCBibG9ja3MsIHRoZSByZW5kZXJcclxuICAgICAgICAvLyBwcm94eSB1c2VkIG5lZWRzIGEgZGlmZmVyZW50IGBoYXNgIGhhbmRsZXIgd2hpY2ggaXMgbW9yZSBwZXJmb3JtYW50IGFuZFxyXG4gICAgICAgIC8vIGFsc28gb25seSBhbGxvd3MgYSB3aGl0ZWxpc3Qgb2YgZ2xvYmFscyB0byBmYWxsdGhyb3VnaC5cclxuICAgICAgICBpZiAoaW5zdGFuY2UucmVuZGVyLl9yYykge1xyXG4gICAgICAgICAgICBpbnN0YW5jZS53aXRoUHJveHkgPSBuZXcgUHJveHkoaW5zdGFuY2UuY3R4LCBSdW50aW1lQ29tcGlsZWRQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHN1cHBvcnQgZm9yIDIueCBvcHRpb25zXHJcbiAgICBpZiAoX19WVUVfT1BUSU9OU19BUElfXyAmJiAhKGZhbHNlICkpIHtcclxuICAgICAgICBjdXJyZW50SW5zdGFuY2UgPSBpbnN0YW5jZTtcclxuICAgICAgICBwYXVzZVRyYWNraW5nKCk7XHJcbiAgICAgICAgYXBwbHlPcHRpb25zKGluc3RhbmNlKTtcclxuICAgICAgICByZXNldFRyYWNraW5nKCk7XHJcbiAgICAgICAgY3VycmVudEluc3RhbmNlID0gbnVsbDtcclxuICAgIH1cclxuICAgIC8vIHdhcm4gbWlzc2luZyB0ZW1wbGF0ZS9yZW5kZXJcclxuICAgIC8vIHRoZSBydW50aW1lIGNvbXBpbGF0aW9uIG9mIHRlbXBsYXRlIGluIFNTUiBpcyBkb25lIGJ5IHNlcnZlci1yZW5kZXJcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIUNvbXBvbmVudC5yZW5kZXIgJiYgaW5zdGFuY2UucmVuZGVyID09PSBOT09QICYmICFpc1NTUikge1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgIGlmICghY29tcGlsZSAmJiBDb21wb25lbnQudGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgd2FybihgQ29tcG9uZW50IHByb3ZpZGVkIHRlbXBsYXRlIG9wdGlvbiBidXQgYCArXHJcbiAgICAgICAgICAgICAgICBgcnVudGltZSBjb21waWxhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnVpbGQgb2YgVnVlLmAgK1xyXG4gICAgICAgICAgICAgICAgKGAgQ29uZmlndXJlIHlvdXIgYnVuZGxlciB0byBhbGlhcyBcInZ1ZVwiIHRvIFwidnVlL2Rpc3QvdnVlLmVzbS1idW5kbGVyLmpzXCIuYFxyXG4gICAgICAgICAgICAgICAgICAgICkgLyogc2hvdWxkIG5vdCBoYXBwZW4gKi8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgd2FybihgQ29tcG9uZW50IGlzIG1pc3NpbmcgdGVtcGxhdGUgb3IgcmVuZGVyIGZ1bmN0aW9uLmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5jb25zdCBhdHRySGFuZGxlcnMgPSB7XHJcbiAgICBnZXQ6ICh0YXJnZXQsIGtleSkgPT4ge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgbWFya0F0dHJzQWNjZXNzZWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldFtrZXldO1xyXG4gICAgfSxcclxuICAgIHNldDogKCkgPT4ge1xyXG4gICAgICAgIHdhcm4oYHNldHVwQ29udGV4dC5hdHRycyBpcyByZWFkb25seS5gKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9LFxyXG4gICAgZGVsZXRlUHJvcGVydHk6ICgpID0+IHtcclxuICAgICAgICB3YXJuKGBzZXR1cENvbnRleHQuYXR0cnMgaXMgcmVhZG9ubHkuYCk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiBjcmVhdGVTZXR1cENvbnRleHQoaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IGV4cG9zZSA9IGV4cG9zZWQgPT4ge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaW5zdGFuY2UuZXhwb3NlZCkge1xyXG4gICAgICAgICAgICB3YXJuKGBleHBvc2UoKSBzaG91bGQgYmUgY2FsbGVkIG9ubHkgb25jZSBwZXIgc2V0dXAoKS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5zdGFuY2UuZXhwb3NlZCA9IHByb3h5UmVmcyhleHBvc2VkKTtcclxuICAgIH07XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgLy8gV2UgdXNlIGdldHRlcnMgaW4gZGV2IGluIGNhc2UgbGlicyBsaWtlIHRlc3QtdXRpbHMgb3ZlcndyaXRlIGluc3RhbmNlXHJcbiAgICAgICAgLy8gcHJvcGVydGllcyAob3ZlcndyaXRlcyBzaG91bGQgbm90IGJlIGRvbmUgaW4gcHJvZClcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XHJcbiAgICAgICAgICAgIGdldCBhdHRycygpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJveHkoaW5zdGFuY2UuYXR0cnMsIGF0dHJIYW5kbGVycyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGdldCBzbG90cygpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzaGFsbG93UmVhZG9ubHkoaW5zdGFuY2Uuc2xvdHMpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBnZXQgZW1pdCgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoZXZlbnQsIC4uLmFyZ3MpID0+IGluc3RhbmNlLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBleHBvc2VcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGF0dHJzOiBpbnN0YW5jZS5hdHRycyxcclxuICAgICAgICAgICAgc2xvdHM6IGluc3RhbmNlLnNsb3RzLFxyXG4gICAgICAgICAgICBlbWl0OiBpbnN0YW5jZS5lbWl0LFxyXG4gICAgICAgICAgICBleHBvc2VcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbi8vIHJlY29yZCBlZmZlY3RzIGNyZWF0ZWQgZHVyaW5nIGEgY29tcG9uZW50J3Mgc2V0dXAoKSBzbyB0aGF0IHRoZXkgY2FuIGJlXHJcbi8vIHN0b3BwZWQgd2hlbiB0aGUgY29tcG9uZW50IHVubW91bnRzXHJcbmZ1bmN0aW9uIHJlY29yZEluc3RhbmNlQm91bmRFZmZlY3QoZWZmZWN0LCBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZSkge1xyXG4gICAgaWYgKGluc3RhbmNlKSB7XHJcbiAgICAgICAgKGluc3RhbmNlLmVmZmVjdHMgfHwgKGluc3RhbmNlLmVmZmVjdHMgPSBbXSkpLnB1c2goZWZmZWN0KTtcclxuICAgIH1cclxufVxyXG5jb25zdCBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fXSkoXFx3KS9nO1xyXG5jb25zdCBjbGFzc2lmeSA9IChzdHIpID0+IHN0ci5yZXBsYWNlKGNsYXNzaWZ5UkUsIGMgPT4gYy50b1VwcGVyQ2FzZSgpKS5yZXBsYWNlKC9bLV9dL2csICcnKTtcclxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHtcclxuICAgIHJldHVybiBpc0Z1bmN0aW9uKENvbXBvbmVudClcclxuICAgICAgICA/IENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZVxyXG4gICAgICAgIDogQ29tcG9uZW50Lm5hbWU7XHJcbn1cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuZnVuY3Rpb24gZm9ybWF0Q29tcG9uZW50TmFtZShpbnN0YW5jZSwgQ29tcG9uZW50LCBpc1Jvb3QgPSBmYWxzZSkge1xyXG4gICAgbGV0IG5hbWUgPSBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCk7XHJcbiAgICBpZiAoIW5hbWUgJiYgQ29tcG9uZW50Ll9fZmlsZSkge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gQ29tcG9uZW50Ll9fZmlsZS5tYXRjaCgvKFteL1xcXFxdKylcXC5cXHcrJC8pO1xyXG4gICAgICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgICAgICBuYW1lID0gbWF0Y2hbMV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFuYW1lICYmIGluc3RhbmNlICYmIGluc3RhbmNlLnBhcmVudCkge1xyXG4gICAgICAgIC8vIHRyeSB0byBpbmZlciB0aGUgbmFtZSBiYXNlZCBvbiByZXZlcnNlIHJlc29sdXRpb25cclxuICAgICAgICBjb25zdCBpbmZlckZyb21SZWdpc3RyeSA9IChyZWdpc3RyeSkgPT4ge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiByZWdpc3RyeSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlZ2lzdHJ5W2tleV0gPT09IENvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIG5hbWUgPVxyXG4gICAgICAgICAgICBpbmZlckZyb21SZWdpc3RyeShpbnN0YW5jZS5jb21wb25lbnRzIHx8XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5wYXJlbnQudHlwZS5jb21wb25lbnRzKSB8fCBpbmZlckZyb21SZWdpc3RyeShpbnN0YW5jZS5hcHBDb250ZXh0LmNvbXBvbmVudHMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5hbWUgPyBjbGFzc2lmeShuYW1lKSA6IGlzUm9vdCA/IGBBcHBgIDogYEFub255bW91c2A7XHJcbn1cclxuZnVuY3Rpb24gaXNDbGFzc0NvbXBvbmVudCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGlzRnVuY3Rpb24odmFsdWUpICYmICdfX3ZjY09wdHMnIGluIHZhbHVlO1xyXG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVkKGdldHRlck9yT3B0aW9ucykge1xyXG4gICAgY29uc3QgYyA9IGNvbXB1dGVkJDEoZ2V0dGVyT3JPcHRpb25zKTtcclxuICAgIHJlY29yZEluc3RhbmNlQm91bmRFZmZlY3QoYy5lZmZlY3QpO1xyXG4gICAgcmV0dXJuIGM7XHJcbn1cblxuLy8gaW1wbGVtZW50YXRpb25cclxuZnVuY3Rpb24gZGVmaW5lUHJvcHMoKSB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgd2FybihgZGVmaW5lUHJvcHMoKSBpcyBhIGNvbXBpbGVyLWhpbnQgaGVscGVyIHRoYXQgaXMgb25seSB1c2FibGUgaW5zaWRlIGAgK1xyXG4gICAgICAgICAgICBgPHNjcmlwdCBzZXR1cD4gb2YgYSBzaW5nbGUgZmlsZSBjb21wb25lbnQuIEl0cyBhcmd1bWVudHMgc2hvdWxkIGJlIGAgK1xyXG4gICAgICAgICAgICBgY29tcGlsZWQgYXdheSBhbmQgcGFzc2luZyBpdCBhdCBydW50aW1lIGhhcyBubyBlZmZlY3QuYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG4vLyBpbXBsZW1lbnRhdGlvblxyXG5mdW5jdGlvbiBkZWZpbmVFbWl0KCkge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHdhcm4oYGRlZmluZUVtaXQoKSBpcyBhIGNvbXBpbGVyLWhpbnQgaGVscGVyIHRoYXQgaXMgb25seSB1c2FibGUgaW5zaWRlIGAgK1xyXG4gICAgICAgICAgICBgPHNjcmlwdCBzZXR1cD4gb2YgYSBzaW5nbGUgZmlsZSBjb21wb25lbnQuIEl0cyBhcmd1bWVudHMgc2hvdWxkIGJlIGAgK1xyXG4gICAgICAgICAgICBgY29tcGlsZWQgYXdheSBhbmQgcGFzc2luZyBpdCBhdCBydW50aW1lIGhhcyBubyBlZmZlY3QuYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5mdW5jdGlvbiB1c2VDb250ZXh0KCkge1xyXG4gICAgY29uc3QgaSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaSkge1xyXG4gICAgICAgIHdhcm4oYHVzZUNvbnRleHQoKSBjYWxsZWQgd2l0aG91dCBhY3RpdmUgaW5zdGFuY2UuYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaS5zZXR1cENvbnRleHQgfHwgKGkuc2V0dXBDb250ZXh0ID0gY3JlYXRlU2V0dXBDb250ZXh0KGkpKTtcclxufVxuXG4vLyBBY3R1YWwgaW1wbGVtZW50YXRpb25cclxuZnVuY3Rpb24gaCh0eXBlLCBwcm9wc09yQ2hpbGRyZW4sIGNoaWxkcmVuKSB7XHJcbiAgICBjb25zdCBsID0gYXJndW1lbnRzLmxlbmd0aDtcclxuICAgIGlmIChsID09PSAyKSB7XHJcbiAgICAgICAgaWYgKGlzT2JqZWN0KHByb3BzT3JDaGlsZHJlbikgJiYgIWlzQXJyYXkocHJvcHNPckNoaWxkcmVuKSkge1xyXG4gICAgICAgICAgICAvLyBzaW5nbGUgdm5vZGUgd2l0aG91dCBwcm9wc1xyXG4gICAgICAgICAgICBpZiAoaXNWTm9kZShwcm9wc09yQ2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgbnVsbCwgW3Byb3BzT3JDaGlsZHJlbl0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHByb3BzIHdpdGhvdXQgY2hpbGRyZW5cclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIHByb3BzT3JDaGlsZHJlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBvbWl0IHByb3BzXHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBudWxsLCBwcm9wc09yQ2hpbGRyZW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChsID4gMykge1xyXG4gICAgICAgICAgICBjaGlsZHJlbiA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGwgPT09IDMgJiYgaXNWTm9kZShjaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgY2hpbGRyZW4gPSBbY2hpbGRyZW5dO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgcHJvcHNPckNoaWxkcmVuLCBjaGlsZHJlbik7XHJcbiAgICB9XHJcbn1cblxuY29uc3Qgc3NyQ29udGV4dEtleSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgc3NyQ29udGV4dGAgOiBgYCk7XHJcbmNvbnN0IHVzZVNTUkNvbnRleHQgPSAoKSA9PiB7XHJcbiAgICB7XHJcbiAgICAgICAgY29uc3QgY3R4ID0gaW5qZWN0KHNzckNvbnRleHRLZXkpO1xyXG4gICAgICAgIGlmICghY3R4KSB7XHJcbiAgICAgICAgICAgIHdhcm4oYFNlcnZlciByZW5kZXJpbmcgY29udGV4dCBub3QgcHJvdmlkZWQuIE1ha2Ugc3VyZSB0byBvbmx5IGNhbGwgYCArXHJcbiAgICAgICAgICAgICAgICBgdXNlU1NSQ29udGV4dCgpIGNvbmRpdGlvbmFsbHkgaW4gdGhlIHNlcnZlciBidWlsZC5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGN0eDtcclxuICAgIH1cclxufTtcblxuZnVuY3Rpb24gaW5pdEN1c3RvbUZvcm1hdHRlcigpIHtcclxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAqL1xyXG4gICAgaWYgKCEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCB2dWVTdHlsZSA9IHsgc3R5bGU6ICdjb2xvcjojM2JhNzc2JyB9O1xyXG4gICAgY29uc3QgbnVtYmVyU3R5bGUgPSB7IHN0eWxlOiAnY29sb3I6IzBiMWJjOScgfTtcclxuICAgIGNvbnN0IHN0cmluZ1N0eWxlID0geyBzdHlsZTogJ2NvbG9yOiNiNjJlMjQnIH07XHJcbiAgICBjb25zdCBrZXl3b3JkU3R5bGUgPSB7IHN0eWxlOiAnY29sb3I6IzlkMjg4YycgfTtcclxuICAgIC8vIGN1c3RvbSBmb3JtYXR0ZXIgZm9yIENocm9tZVxyXG4gICAgLy8gaHR0cHM6Ly93d3cubWF0dHpldW5lcnQuY29tLzIwMTYvMDIvMTkvY3VzdG9tLWNocm9tZS1kZXZ0b29scy1vYmplY3QtZm9ybWF0dGVycy5odG1sXHJcbiAgICBjb25zdCBmb3JtYXR0ZXIgPSB7XHJcbiAgICAgICAgaGVhZGVyKG9iaikge1xyXG4gICAgICAgICAgICAvLyBUT0RPIGFsc28gZm9ybWF0IENvbXBvbmVudFB1YmxpY0luc3RhbmNlICYgY3R4LnNsb3RzL2F0dHJzIGluIHNldHVwXHJcbiAgICAgICAgICAgIGlmICghaXNPYmplY3Qob2JqKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9iai5fX2lzVnVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWydkaXYnLCB2dWVTdHlsZSwgYFZ1ZUluc3RhbmNlYF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNSZWYob2JqKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgICAgICAnZGl2JyxcclxuICAgICAgICAgICAgICAgICAgICB7fSxcclxuICAgICAgICAgICAgICAgICAgICBbJ3NwYW4nLCB2dWVTdHlsZSwgZ2VuUmVmRmxhZyhvYmopXSxcclxuICAgICAgICAgICAgICAgICAgICAnPCcsXHJcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0VmFsdWUob2JqLnZhbHVlKSxcclxuICAgICAgICAgICAgICAgICAgICBgPmBcclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNSZWFjdGl2ZShvYmopKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgICAgICdkaXYnLFxyXG4gICAgICAgICAgICAgICAgICAgIHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIFsnc3BhbicsIHZ1ZVN0eWxlLCAnUmVhY3RpdmUnXSxcclxuICAgICAgICAgICAgICAgICAgICAnPCcsXHJcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0VmFsdWUob2JqKSxcclxuICAgICAgICAgICAgICAgICAgICBgPiR7aXNSZWFkb25seShvYmopID8gYCAocmVhZG9ubHkpYCA6IGBgfWBcclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNSZWFkb25seShvYmopKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgICAgICdkaXYnLFxyXG4gICAgICAgICAgICAgICAgICAgIHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIFsnc3BhbicsIHZ1ZVN0eWxlLCAnUmVhZG9ubHknXSxcclxuICAgICAgICAgICAgICAgICAgICAnPCcsXHJcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0VmFsdWUob2JqKSxcclxuICAgICAgICAgICAgICAgICAgICAnPidcclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBoYXNCb2R5KG9iaikge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqICYmIG9iai5fX2lzVnVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYm9keShvYmopIHtcclxuICAgICAgICAgICAgaWYgKG9iaiAmJiBvYmouX19pc1Z1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgICAgICAnZGl2JyxcclxuICAgICAgICAgICAgICAgICAgICB7fSxcclxuICAgICAgICAgICAgICAgICAgICAuLi5mb3JtYXRJbnN0YW5jZShvYmouJClcclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZnVuY3Rpb24gZm9ybWF0SW5zdGFuY2UoaW5zdGFuY2UpIHtcclxuICAgICAgICBjb25zdCBibG9ja3MgPSBbXTtcclxuICAgICAgICBpZiAoaW5zdGFuY2UudHlwZS5wcm9wcyAmJiBpbnN0YW5jZS5wcm9wcykge1xyXG4gICAgICAgICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKCdwcm9wcycsIHRvUmF3KGluc3RhbmNlLnByb3BzKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW5zdGFuY2Uuc2V0dXBTdGF0ZSAhPT0gRU1QVFlfT0JKKSB7XHJcbiAgICAgICAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soJ3NldHVwJywgaW5zdGFuY2Uuc2V0dXBTdGF0ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW5zdGFuY2UuZGF0YSAhPT0gRU1QVFlfT0JKKSB7XHJcbiAgICAgICAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soJ2RhdGEnLCB0b1JhdyhpbnN0YW5jZS5kYXRhKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjb21wdXRlZCA9IGV4dHJhY3RLZXlzKGluc3RhbmNlLCAnY29tcHV0ZWQnKTtcclxuICAgICAgICBpZiAoY29tcHV0ZWQpIHtcclxuICAgICAgICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jaygnY29tcHV0ZWQnLCBjb21wdXRlZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpbmplY3RlZCA9IGV4dHJhY3RLZXlzKGluc3RhbmNlLCAnaW5qZWN0Jyk7XHJcbiAgICAgICAgaWYgKGluamVjdGVkKSB7XHJcbiAgICAgICAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soJ2luamVjdGVkJywgaW5qZWN0ZWQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYmxvY2tzLnB1c2goW1xyXG4gICAgICAgICAgICAnZGl2JyxcclxuICAgICAgICAgICAge30sXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgICdzcGFuJyxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZToga2V5d29yZFN0eWxlLnN0eWxlICsgJztvcGFjaXR5OjAuNjYnXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgJyQgKGludGVybmFsKTogJ1xyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBbJ29iamVjdCcsIHsgb2JqZWN0OiBpbnN0YW5jZSB9XVxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIHJldHVybiBibG9ja3M7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZUJsb2NrKHR5cGUsIHRhcmdldCkge1xyXG4gICAgICAgIHRhcmdldCA9IGV4dGVuZCh7fSwgdGFyZ2V0KTtcclxuICAgICAgICBpZiAoIU9iamVjdC5rZXlzKHRhcmdldCkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCB7fV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICdkaXYnLFxyXG4gICAgICAgICAgICB7IHN0eWxlOiAnbGluZS1oZWlnaHQ6MS4yNWVtO21hcmdpbi1ib3R0b206MC42ZW0nIH0sXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgICdkaXYnLFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiAnY29sb3I6IzQ3NjU4MidcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB0eXBlXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgICdkaXYnLFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiAncGFkZGluZy1sZWZ0OjEuMjVlbSdcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAuLi5PYmplY3Qua2V5cyh0YXJnZXQpLm1hcChrZXkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdkaXYnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7fSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgWydzcGFuJywga2V5d29yZFN0eWxlLCBrZXkgKyAnOiAnXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0VmFsdWUodGFyZ2V0W2tleV0sIGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGZvcm1hdFZhbHVlKHYsIGFzUmF3ID0gdHJ1ZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIG51bWJlclN0eWxlLCB2XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCBzdHJpbmdTdHlsZSwgSlNPTi5zdHJpbmdpZnkodildO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdiA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCBrZXl3b3JkU3R5bGUsIHZdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc09iamVjdCh2KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gWydvYmplY3QnLCB7IG9iamVjdDogYXNSYXcgPyB0b1Jhdyh2KSA6IHYgfV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gWydzcGFuJywgc3RyaW5nU3R5bGUsIFN0cmluZyh2KV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZXh0cmFjdEtleXMoaW5zdGFuY2UsIHR5cGUpIHtcclxuICAgICAgICBjb25zdCBDb21wID0gaW5zdGFuY2UudHlwZTtcclxuICAgICAgICBpZiAoaXNGdW5jdGlvbihDb21wKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGV4dHJhY3RlZCA9IHt9O1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGluc3RhbmNlLmN0eCkge1xyXG4gICAgICAgICAgICBpZiAoaXNLZXlPZlR5cGUoQ29tcCwga2V5LCB0eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgZXh0cmFjdGVkW2tleV0gPSBpbnN0YW5jZS5jdHhba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXh0cmFjdGVkO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXNLZXlPZlR5cGUoQ29tcCwga2V5LCB0eXBlKSB7XHJcbiAgICAgICAgY29uc3Qgb3B0cyA9IENvbXBbdHlwZV07XHJcbiAgICAgICAgaWYgKChpc0FycmF5KG9wdHMpICYmIG9wdHMuaW5jbHVkZXMoa2V5KSkgfHxcclxuICAgICAgICAgICAgKGlzT2JqZWN0KG9wdHMpICYmIGtleSBpbiBvcHRzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKENvbXAuZXh0ZW5kcyAmJiBpc0tleU9mVHlwZShDb21wLmV4dGVuZHMsIGtleSwgdHlwZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChDb21wLm1peGlucyAmJiBDb21wLm1peGlucy5zb21lKG0gPT4gaXNLZXlPZlR5cGUobSwga2V5LCB0eXBlKSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2VuUmVmRmxhZyh2KSB7XHJcbiAgICAgICAgaWYgKHYuX3NoYWxsb3cpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGBTaGFsbG93UmVmYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHYuZWZmZWN0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgQ29tcHV0ZWRSZWZgO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYFJlZmA7XHJcbiAgICB9XHJcbiAgICBpZiAod2luZG93LmRldnRvb2xzRm9ybWF0dGVycykge1xyXG4gICAgICAgIHdpbmRvdy5kZXZ0b29sc0Zvcm1hdHRlcnMucHVzaChmb3JtYXR0ZXIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgd2luZG93LmRldnRvb2xzRm9ybWF0dGVycyA9IFtmb3JtYXR0ZXJdO1xyXG4gICAgfVxyXG59XG5cbi8vIENvcmUgQVBJIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5jb25zdCB2ZXJzaW9uID0gXCIzLjEuMVwiO1xyXG4vKipcclxuICogU1NSIHV0aWxzIGZvciBcXEB2dWUvc2VydmVyLXJlbmRlcmVyLiBPbmx5IGV4cG9zZWQgaW4gY2pzIGJ1aWxkcy5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCBzc3JVdGlscyA9IChudWxsKTtcclxuLyoqXHJcbiAqIEBpbnRlcm5hbCBvbmx5IGV4cG9zZWQgaW4gY29tcGF0IGJ1aWxkc1xyXG4gKi9cclxuY29uc3QgcmVzb2x2ZUZpbHRlciA9IG51bGw7XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWwgb25seSBleHBvc2VkIGluIGNvbXBhdCBidWlsZHMuXHJcbiAqL1xyXG5jb25zdCBjb21wYXRVdGlscyA9IChudWxsKTtcblxuZXhwb3J0IHsgQmFzZVRyYW5zaXRpb24sIENvbW1lbnQkMSBhcyBDb21tZW50LCBGcmFnbWVudCwgS2VlcEFsaXZlLCBTdGF0aWMsIFN1c3BlbnNlLCBUZWxlcG9ydCwgVGV4dCwgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcsIGNhbGxXaXRoRXJyb3JIYW5kbGluZywgY2xvbmVWTm9kZSwgY29tcGF0VXRpbHMsIGNvbXB1dGVkLCBjcmVhdGVCbG9jaywgY3JlYXRlQ29tbWVudFZOb2RlLCBjcmVhdGVIeWRyYXRpb25SZW5kZXJlciwgY3JlYXRlUmVuZGVyZXIsIGNyZWF0ZVNsb3RzLCBjcmVhdGVTdGF0aWNWTm9kZSwgY3JlYXRlVGV4dFZOb2RlLCBjcmVhdGVWTm9kZSwgZGVmaW5lQXN5bmNDb21wb25lbnQsIGRlZmluZUNvbXBvbmVudCwgZGVmaW5lRW1pdCwgZGVmaW5lUHJvcHMsIGRldnRvb2xzLCBnZXRDdXJyZW50SW5zdGFuY2UsIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbiwgaCwgaGFuZGxlRXJyb3IsIGluaXRDdXN0b21Gb3JtYXR0ZXIsIGluamVjdCwgaXNSdW50aW1lT25seSwgaXNWTm9kZSwgbWVyZ2VQcm9wcywgbmV4dFRpY2ssIG9uQWN0aXZhdGVkLCBvbkJlZm9yZU1vdW50LCBvbkJlZm9yZVVubW91bnQsIG9uQmVmb3JlVXBkYXRlLCBvbkRlYWN0aXZhdGVkLCBvbkVycm9yQ2FwdHVyZWQsIG9uTW91bnRlZCwgb25SZW5kZXJUcmFja2VkLCBvblJlbmRlclRyaWdnZXJlZCwgb25TZXJ2ZXJQcmVmZXRjaCwgb25Vbm1vdW50ZWQsIG9uVXBkYXRlZCwgb3BlbkJsb2NrLCBwb3BTY29wZUlkLCBwcm92aWRlLCBwdXNoU2NvcGVJZCwgcXVldWVQb3N0Rmx1c2hDYiwgcmVnaXN0ZXJSdW50aW1lQ29tcGlsZXIsIHJlbmRlckxpc3QsIHJlbmRlclNsb3QsIHJlc29sdmVDb21wb25lbnQsIHJlc29sdmVEaXJlY3RpdmUsIHJlc29sdmVEeW5hbWljQ29tcG9uZW50LCByZXNvbHZlRmlsdGVyLCByZXNvbHZlVHJhbnNpdGlvbkhvb2tzLCBzZXRCbG9ja1RyYWNraW5nLCBzZXREZXZ0b29sc0hvb2ssIHNldFRyYW5zaXRpb25Ib29rcywgc3NyQ29udGV4dEtleSwgc3NyVXRpbHMsIHRvSGFuZGxlcnMsIHRyYW5zZm9ybVZOb2RlQXJncywgdXNlQ29udGV4dCwgdXNlU1NSQ29udGV4dCwgdXNlVHJhbnNpdGlvblN0YXRlLCB2ZXJzaW9uLCB3YXJuLCB3YXRjaCwgd2F0Y2hFZmZlY3QsIHdpdGhDdHgsIHdpdGhEaXJlY3RpdmVzLCB3aXRoU2NvcGVJZCB9O1xuIiwiaW1wb3J0IHsgY2FtZWxpemUsIHdhcm4sIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nLCBnZXRDdXJyZW50SW5zdGFuY2UsIG9uTW91bnRlZCwgd2F0Y2hFZmZlY3QsIG9uVXBkYXRlZCwgRnJhZ21lbnQsIGgsIEJhc2VUcmFuc2l0aW9uLCB1c2VUcmFuc2l0aW9uU3RhdGUsIHRvUmF3LCBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4sIHNldFRyYW5zaXRpb25Ib29rcywgcmVzb2x2ZVRyYW5zaXRpb25Ib29rcywgY3JlYXRlVk5vZGUsIGNyZWF0ZVJlbmRlcmVyLCBpc1J1bnRpbWVPbmx5LCBjcmVhdGVIeWRyYXRpb25SZW5kZXJlciB9IGZyb20gJ0B2dWUvcnVudGltZS1jb3JlJztcbmV4cG9ydCAqIGZyb20gJ0B2dWUvcnVudGltZS1jb3JlJztcbmltcG9ydCB7IGlzU3RyaW5nLCBpc0FycmF5LCBoeXBoZW5hdGUsIGNhcGl0YWxpemUsIGlzU3BlY2lhbEJvb2xlYW5BdHRyLCBpc09uLCBpc01vZGVsTGlzdGVuZXIsIGlzRnVuY3Rpb24sIEVNUFRZX09CSiwgZXh0ZW5kLCBpc09iamVjdCwgdG9OdW1iZXIsIGludm9rZUFycmF5Rm5zLCBsb29zZUluZGV4T2YsIGlzU2V0LCBsb29zZUVxdWFsLCBpc0hUTUxUYWcsIGlzU1ZHVGFnIH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuXG5jb25zdCBzdmdOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XHJcbmNvbnN0IGRvYyA9ICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiBudWxsKTtcclxubGV0IHRlbXBDb250YWluZXI7XHJcbmxldCB0ZW1wU1ZHQ29udGFpbmVyO1xyXG5jb25zdCBub2RlT3BzID0ge1xyXG4gICAgaW5zZXJ0OiAoY2hpbGQsIHBhcmVudCwgYW5jaG9yKSA9PiB7XHJcbiAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZCwgYW5jaG9yIHx8IG51bGwpO1xyXG4gICAgfSxcclxuICAgIHJlbW92ZTogY2hpbGQgPT4ge1xyXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IGNoaWxkLnBhcmVudE5vZGU7XHJcbiAgICAgICAgaWYgKHBhcmVudCkge1xyXG4gICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoY2hpbGQpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjcmVhdGVFbGVtZW50OiAodGFnLCBpc1NWRywgaXMsIHByb3BzKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZWwgPSBpc1NWR1xyXG4gICAgICAgICAgICA/IGRvYy5jcmVhdGVFbGVtZW50TlMoc3ZnTlMsIHRhZylcclxuICAgICAgICAgICAgOiBkb2MuY3JlYXRlRWxlbWVudCh0YWcsIGlzID8geyBpcyB9IDogdW5kZWZpbmVkKTtcclxuICAgICAgICBpZiAodGFnID09PSAnc2VsZWN0JyAmJiBwcm9wcyAmJiBwcm9wcy5tdWx0aXBsZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnbXVsdGlwbGUnLCBwcm9wcy5tdWx0aXBsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlbDtcclxuICAgIH0sXHJcbiAgICBjcmVhdGVUZXh0OiB0ZXh0ID0+IGRvYy5jcmVhdGVUZXh0Tm9kZSh0ZXh0KSxcclxuICAgIGNyZWF0ZUNvbW1lbnQ6IHRleHQgPT4gZG9jLmNyZWF0ZUNvbW1lbnQodGV4dCksXHJcbiAgICBzZXRUZXh0OiAobm9kZSwgdGV4dCkgPT4ge1xyXG4gICAgICAgIG5vZGUubm9kZVZhbHVlID0gdGV4dDtcclxuICAgIH0sXHJcbiAgICBzZXRFbGVtZW50VGV4dDogKGVsLCB0ZXh0KSA9PiB7XHJcbiAgICAgICAgZWwudGV4dENvbnRlbnQgPSB0ZXh0O1xyXG4gICAgfSxcclxuICAgIHBhcmVudE5vZGU6IG5vZGUgPT4gbm9kZS5wYXJlbnROb2RlLFxyXG4gICAgbmV4dFNpYmxpbmc6IG5vZGUgPT4gbm9kZS5uZXh0U2libGluZyxcclxuICAgIHF1ZXJ5U2VsZWN0b3I6IHNlbGVjdG9yID0+IGRvYy5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSxcclxuICAgIHNldFNjb3BlSWQoZWwsIGlkKSB7XHJcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKGlkLCAnJyk7XHJcbiAgICB9LFxyXG4gICAgY2xvbmVOb2RlKGVsKSB7XHJcbiAgICAgICAgY29uc3QgY2xvbmVkID0gZWwuY2xvbmVOb2RlKHRydWUpO1xyXG4gICAgICAgIC8vICMzMDcyXHJcbiAgICAgICAgLy8gLSBpbiBgcGF0Y2hET01Qcm9wYCwgd2Ugc3RvcmUgdGhlIGFjdHVhbCB2YWx1ZSBpbiB0aGUgYGVsLl92YWx1ZWAgcHJvcGVydHkuXHJcbiAgICAgICAgLy8gLSBub3JtYWxseSwgZWxlbWVudHMgdXNpbmcgYDp2YWx1ZWAgYmluZGluZ3Mgd2lsbCBub3QgYmUgaG9pc3RlZCwgYnV0IGlmXHJcbiAgICAgICAgLy8gICB0aGUgYm91bmQgdmFsdWUgaXMgYSBjb25zdGFudCwgZS5nLiBgOnZhbHVlPVwidHJ1ZVwiYCAtIHRoZXkgZG8gZ2V0XHJcbiAgICAgICAgLy8gICBob2lzdGVkLlxyXG4gICAgICAgIC8vIC0gaW4gcHJvZHVjdGlvbiwgaG9pc3RlZCBub2RlcyBhcmUgY2xvbmVkIHdoZW4gc3Vic2VxdWVudCBpbnNlcnRzLCBidXRcclxuICAgICAgICAvLyAgIGNsb25lTm9kZSgpIGRvZXMgbm90IGNvcHkgdGhlIGN1c3RvbSBwcm9wZXJ0eSB3ZSBhdHRhY2hlZC5cclxuICAgICAgICAvLyAtIFRoaXMgbWF5IG5lZWQgdG8gYWNjb3VudCBmb3Igb3RoZXIgY3VzdG9tIERPTSBwcm9wZXJ0aWVzIHdlIGF0dGFjaCB0b1xyXG4gICAgICAgIC8vICAgZWxlbWVudHMgaW4gYWRkaXRpb24gdG8gYF92YWx1ZWAgaW4gdGhlIGZ1dHVyZS5cclxuICAgICAgICBpZiAoYF92YWx1ZWAgaW4gZWwpIHtcclxuICAgICAgICAgICAgY2xvbmVkLl92YWx1ZSA9IGVsLl92YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNsb25lZDtcclxuICAgIH0sXHJcbiAgICAvLyBfX1VOU0FGRV9fXHJcbiAgICAvLyBSZWFzb246IGlubmVySFRNTC5cclxuICAgIC8vIFN0YXRpYyBjb250ZW50IGhlcmUgY2FuIG9ubHkgY29tZSBmcm9tIGNvbXBpbGVkIHRlbXBsYXRlcy5cclxuICAgIC8vIEFzIGxvbmcgYXMgdGhlIHVzZXIgb25seSB1c2VzIHRydXN0ZWQgdGVtcGxhdGVzLCB0aGlzIGlzIHNhZmUuXHJcbiAgICBpbnNlcnRTdGF0aWNDb250ZW50KGNvbnRlbnQsIHBhcmVudCwgYW5jaG9yLCBpc1NWRykge1xyXG4gICAgICAgIGNvbnN0IHRlbXAgPSBpc1NWR1xyXG4gICAgICAgICAgICA/IHRlbXBTVkdDb250YWluZXIgfHxcclxuICAgICAgICAgICAgICAgICh0ZW1wU1ZHQ29udGFpbmVyID0gZG9jLmNyZWF0ZUVsZW1lbnROUyhzdmdOUywgJ3N2ZycpKVxyXG4gICAgICAgICAgICA6IHRlbXBDb250YWluZXIgfHwgKHRlbXBDb250YWluZXIgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2JykpO1xyXG4gICAgICAgIHRlbXAuaW5uZXJIVE1MID0gY29udGVudDtcclxuICAgICAgICBjb25zdCBmaXJzdCA9IHRlbXAuZmlyc3RDaGlsZDtcclxuICAgICAgICBsZXQgbm9kZSA9IGZpcnN0O1xyXG4gICAgICAgIGxldCBsYXN0ID0gbm9kZTtcclxuICAgICAgICB3aGlsZSAobm9kZSkge1xyXG4gICAgICAgICAgICBsYXN0ID0gbm9kZTtcclxuICAgICAgICAgICAgbm9kZU9wcy5pbnNlcnQobm9kZSwgcGFyZW50LCBhbmNob3IpO1xyXG4gICAgICAgICAgICBub2RlID0gdGVtcC5maXJzdENoaWxkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW2ZpcnN0LCBsYXN0XTtcclxuICAgIH1cclxufTtcblxuLy8gY29tcGlsZXIgc2hvdWxkIG5vcm1hbGl6ZSBjbGFzcyArIDpjbGFzcyBiaW5kaW5ncyBvbiB0aGUgc2FtZSBlbGVtZW50XHJcbi8vIGludG8gYSBzaW5nbGUgYmluZGluZyBbJ3N0YXRpY0NsYXNzJywgZHluYW1pY11cclxuZnVuY3Rpb24gcGF0Y2hDbGFzcyhlbCwgdmFsdWUsIGlzU1ZHKSB7XHJcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgIHZhbHVlID0gJyc7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNTVkcpIHtcclxuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gZGlyZWN0bHkgc2V0dGluZyBjbGFzc05hbWUgc2hvdWxkIGJlIGZhc3RlciB0aGFuIHNldEF0dHJpYnV0ZSBpbiB0aGVvcnlcclxuICAgICAgICAvLyBpZiB0aGlzIGlzIGFuIGVsZW1lbnQgZHVyaW5nIGEgdHJhbnNpdGlvbiwgdGFrZSB0aGUgdGVtcG9yYXJ5IHRyYW5zaXRpb25cclxuICAgICAgICAvLyBjbGFzc2VzIGludG8gYWNjb3VudC5cclxuICAgICAgICBjb25zdCB0cmFuc2l0aW9uQ2xhc3NlcyA9IGVsLl92dGM7XHJcbiAgICAgICAgaWYgKHRyYW5zaXRpb25DbGFzc2VzKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gKHZhbHVlXHJcbiAgICAgICAgICAgICAgICA/IFt2YWx1ZSwgLi4udHJhbnNpdGlvbkNsYXNzZXNdXHJcbiAgICAgICAgICAgICAgICA6IFsuLi50cmFuc2l0aW9uQ2xhc3Nlc10pLmpvaW4oJyAnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWwuY2xhc3NOYW1lID0gdmFsdWU7XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gcGF0Y2hTdHlsZShlbCwgcHJldiwgbmV4dCkge1xyXG4gICAgY29uc3Qgc3R5bGUgPSBlbC5zdHlsZTtcclxuICAgIGlmICghbmV4dCkge1xyXG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzU3RyaW5nKG5leHQpKSB7XHJcbiAgICAgICAgaWYgKHByZXYgIT09IG5leHQpIHtcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IHN0eWxlLmRpc3BsYXk7XHJcbiAgICAgICAgICAgIHN0eWxlLmNzc1RleHQgPSBuZXh0O1xyXG4gICAgICAgICAgICAvLyBpbmRpY2F0ZXMgdGhhdCB0aGUgYGRpc3BsYXlgIG9mIHRoZSBlbGVtZW50IGlzIGNvbnRyb2xsZWQgYnkgYHYtc2hvd2AsXHJcbiAgICAgICAgICAgIC8vIHNvIHdlIGFsd2F5cyBrZWVwIHRoZSBjdXJyZW50IGBkaXNwbGF5YCB2YWx1ZSByZWdhcmRsZXNzIG9mIHRoZSBgc3R5bGVgIHZhbHVlLFxyXG4gICAgICAgICAgICAvLyB0aHVzIGhhbmRpbmcgb3ZlciBjb250cm9sIHRvIGB2LXNob3dgLlxyXG4gICAgICAgICAgICBpZiAoJ192b2QnIGluIGVsKSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZS5kaXNwbGF5ID0gY3VycmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5leHQpIHtcclxuICAgICAgICAgICAgc2V0U3R5bGUoc3R5bGUsIGtleSwgbmV4dFtrZXldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByZXYgJiYgIWlzU3RyaW5nKHByZXYpKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByZXYpIHtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0W2tleV0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFN0eWxlKHN0eWxlLCBrZXksICcnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5jb25zdCBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xyXG5mdW5jdGlvbiBzZXRTdHlsZShzdHlsZSwgbmFtZSwgdmFsKSB7XHJcbiAgICBpZiAoaXNBcnJheSh2YWwpKSB7XHJcbiAgICAgICAgdmFsLmZvckVhY2godiA9PiBzZXRTdHlsZShzdHlsZSwgbmFtZSwgdikpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aCgnLS0nKSkge1xyXG4gICAgICAgICAgICAvLyBjdXN0b20gcHJvcGVydHkgZGVmaW5pdGlvblxyXG4gICAgICAgICAgICBzdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgcHJlZml4ZWQgPSBhdXRvUHJlZml4KHN0eWxlLCBuYW1lKTtcclxuICAgICAgICAgICAgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gIWltcG9ydGFudFxyXG4gICAgICAgICAgICAgICAgc3R5bGUuc2V0UHJvcGVydHkoaHlwaGVuYXRlKHByZWZpeGVkKSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3R5bGVbcHJlZml4ZWRdID0gdmFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNvbnN0IHByZWZpeGVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ107XHJcbmNvbnN0IHByZWZpeENhY2hlID0ge307XHJcbmZ1bmN0aW9uIGF1dG9QcmVmaXgoc3R5bGUsIHJhd05hbWUpIHtcclxuICAgIGNvbnN0IGNhY2hlZCA9IHByZWZpeENhY2hlW3Jhd05hbWVdO1xyXG4gICAgaWYgKGNhY2hlZCkge1xyXG4gICAgICAgIHJldHVybiBjYWNoZWQ7XHJcbiAgICB9XHJcbiAgICBsZXQgbmFtZSA9IGNhbWVsaXplKHJhd05hbWUpO1xyXG4gICAgaWYgKG5hbWUgIT09ICdmaWx0ZXInICYmIG5hbWUgaW4gc3R5bGUpIHtcclxuICAgICAgICByZXR1cm4gKHByZWZpeENhY2hlW3Jhd05hbWVdID0gbmFtZSk7XHJcbiAgICB9XHJcbiAgICBuYW1lID0gY2FwaXRhbGl6ZShuYW1lKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBwcmVmaXhlZCA9IHByZWZpeGVzW2ldICsgbmFtZTtcclxuICAgICAgICBpZiAocHJlZml4ZWQgaW4gc3R5bGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChwcmVmaXhDYWNoZVtyYXdOYW1lXSA9IHByZWZpeGVkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmF3TmFtZTtcclxufVxuXG5jb25zdCB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xyXG5mdW5jdGlvbiBwYXRjaEF0dHIoZWwsIGtleSwgdmFsdWUsIGlzU1ZHLCBpbnN0YW5jZSkge1xyXG4gICAgaWYgKGlzU1ZHICYmIGtleS5zdGFydHNXaXRoKCd4bGluazonKSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleS5zbGljZSg2LCBrZXkubGVuZ3RoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBub3RlIHdlIGFyZSBvbmx5IGNoZWNraW5nIGJvb2xlYW4gYXR0cmlidXRlcyB0aGF0IGRvbid0IGhhdmUgYVxyXG4gICAgICAgIC8vIGNvcnJlc3BvbmRpbmcgZG9tIHByb3Agb2YgdGhlIHNhbWUgbmFtZSBoZXJlLlxyXG4gICAgICAgIGNvbnN0IGlzQm9vbGVhbiA9IGlzU3BlY2lhbEJvb2xlYW5BdHRyKGtleSk7XHJcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgfHwgKGlzQm9vbGVhbiAmJiB2YWx1ZSA9PT0gZmFsc2UpKSB7XHJcbiAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgaXNCb29sZWFuID8gJycgOiB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8vIF9fVU5TQUZFX19cclxuLy8gZnVuY3Rpb25zLiBUaGUgdXNlciBpcyByZXNwb25zaWJsZSBmb3IgdXNpbmcgdGhlbSB3aXRoIG9ubHkgdHJ1c3RlZCBjb250ZW50LlxyXG5mdW5jdGlvbiBwYXRjaERPTVByb3AoZWwsIGtleSwgdmFsdWUsIFxyXG4vLyB0aGUgZm9sbG93aW5nIGFyZ3MgYXJlIHBhc3NlZCBvbmx5IGR1ZSB0byBwb3RlbnRpYWwgaW5uZXJIVE1ML3RleHRDb250ZW50XHJcbi8vIG92ZXJyaWRpbmcgZXhpc3RpbmcgVk5vZGVzLCBpbiB3aGljaCBjYXNlIHRoZSBvbGQgdHJlZSBtdXN0IGJlIHByb3Blcmx5XHJcbi8vIHVubW91bnRlZC5cclxucHJldkNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB1bm1vdW50Q2hpbGRyZW4pIHtcclxuICAgIGlmIChrZXkgPT09ICdpbm5lckhUTUwnIHx8IGtleSA9PT0gJ3RleHRDb250ZW50Jykge1xyXG4gICAgICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgdW5tb3VudENoaWxkcmVuKHByZXZDaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsW2tleV0gPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoa2V5ID09PSAndmFsdWUnICYmIGVsLnRhZ05hbWUgIT09ICdQUk9HUkVTUycpIHtcclxuICAgICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxyXG4gICAgICAgIC8vIG5vbi1zdHJpbmcgdmFsdWVzIHdpbGwgYmUgc3RyaW5naWZpZWQuXHJcbiAgICAgICAgZWwuX3ZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgY29uc3QgbmV3VmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcclxuICAgICAgICBpZiAoZWwudmFsdWUgIT09IG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgICAgIGVsLnZhbHVlID0gbmV3VmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICBjb25zdCB0eXBlID0gdHlwZW9mIGVsW2tleV07XHJcbiAgICAgICAgaWYgKHZhbHVlID09PSAnJyAmJiB0eXBlID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgLy8gZS5nLiA8c2VsZWN0IG11bHRpcGxlPiBjb21waWxlcyB0byB7IG11bHRpcGxlOiAnJyB9XHJcbiAgICAgICAgICAgIGVsW2tleV0gPSB0cnVlO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID09IG51bGwgJiYgdHlwZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgLy8gZS5nLiA8ZGl2IDppZD1cIm51bGxcIj5cclxuICAgICAgICAgICAgZWxba2V5XSA9ICcnO1xyXG4gICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAvLyBlLmcuIDxpbWcgOndpZHRoPVwibnVsbFwiPlxyXG4gICAgICAgICAgICBlbFtrZXldID0gMDtcclxuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBzb21lIHByb3BlcnRpZXMgcGVyZm9ybSB2YWx1ZSB2YWxpZGF0aW9uIGFuZCB0aHJvd1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBlbFtrZXldID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgd2FybihgRmFpbGVkIHNldHRpbmcgcHJvcCBcIiR7a2V5fVwiIG9uIDwke2VsLnRhZ05hbWUudG9Mb3dlckNhc2UoKX0+OiBgICtcclxuICAgICAgICAgICAgICAgIGB2YWx1ZSAke3ZhbHVlfSBpcyBpbnZhbGlkLmAsIGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vLyBBc3luYyBlZGdlIGNhc2UgZml4IHJlcXVpcmVzIHN0b3JpbmcgYW4gZXZlbnQgbGlzdGVuZXIncyBhdHRhY2ggdGltZXN0YW1wLlxyXG5sZXQgX2dldE5vdyA9IERhdGUubm93O1xyXG5sZXQgc2tpcFRpbWVzdGFtcENoZWNrID0gZmFsc2U7XHJcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgLy8gRGV0ZXJtaW5lIHdoYXQgZXZlbnQgdGltZXN0YW1wIHRoZSBicm93c2VyIGlzIHVzaW5nLiBBbm5veWluZ2x5LCB0aGVcclxuICAgIC8vIHRpbWVzdGFtcCBjYW4gZWl0aGVyIGJlIGhpLXJlcyAocmVsYXRpdmUgdG8gcGFnZSBsb2FkKSBvciBsb3ctcmVzXHJcbiAgICAvLyAocmVsYXRpdmUgdG8gVU5JWCBlcG9jaCksIHNvIGluIG9yZGVyIHRvIGNvbXBhcmUgdGltZSB3ZSBoYXZlIHRvIHVzZSB0aGVcclxuICAgIC8vIHNhbWUgdGltZXN0YW1wIHR5cGUgd2hlbiBzYXZpbmcgdGhlIGZsdXNoIHRpbWVzdGFtcC5cclxuICAgIGlmIChfZ2V0Tm93KCkgPiBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKS50aW1lU3RhbXApIHtcclxuICAgICAgICAvLyBpZiB0aGUgbG93LXJlcyB0aW1lc3RhbXAgd2hpY2ggaXMgYmlnZ2VyIHRoYW4gdGhlIGV2ZW50IHRpbWVzdGFtcFxyXG4gICAgICAgIC8vICh3aGljaCBpcyBldmFsdWF0ZWQgQUZURVIpIGl0IG1lYW5zIHRoZSBldmVudCBpcyB1c2luZyBhIGhpLXJlcyB0aW1lc3RhbXAsXHJcbiAgICAgICAgLy8gYW5kIHdlIG5lZWQgdG8gdXNlIHRoZSBoaS1yZXMgdmVyc2lvbiBmb3IgZXZlbnQgbGlzdGVuZXJzIGFzIHdlbGwuXHJcbiAgICAgICAgX2dldE5vdyA9ICgpID0+IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgfVxyXG4gICAgLy8gIzM0ODU6IEZpcmVmb3ggPD0gNTMgaGFzIGluY29ycmVjdCBFdmVudC50aW1lU3RhbXAgaW1wbGVtZW50YXRpb25cclxuICAgIC8vIGFuZCBkb2VzIG5vdCBmaXJlIG1pY3JvdGFza3MgaW4gYmV0d2VlbiBldmVudCBwcm9wYWdhdGlvbiwgc28gc2FmZSB0byBleGNsdWRlLlxyXG4gICAgY29uc3QgZmZNYXRjaCA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvaSk7XHJcbiAgICBza2lwVGltZXN0YW1wQ2hlY2sgPSAhIShmZk1hdGNoICYmIE51bWJlcihmZk1hdGNoWzFdKSA8PSA1Myk7XHJcbn1cclxuLy8gVG8gYXZvaWQgdGhlIG92ZXJoZWFkIG9mIHJlcGVhdGVkbHkgY2FsbGluZyBwZXJmb3JtYW5jZS5ub3coKSwgd2UgY2FjaGVcclxuLy8gYW5kIHVzZSB0aGUgc2FtZSB0aW1lc3RhbXAgZm9yIGFsbCBldmVudCBsaXN0ZW5lcnMgYXR0YWNoZWQgaW4gdGhlIHNhbWUgdGljay5cclxubGV0IGNhY2hlZE5vdyA9IDA7XHJcbmNvbnN0IHAgPSBQcm9taXNlLnJlc29sdmUoKTtcclxuY29uc3QgcmVzZXQgPSAoKSA9PiB7XHJcbiAgICBjYWNoZWROb3cgPSAwO1xyXG59O1xyXG5jb25zdCBnZXROb3cgPSAoKSA9PiBjYWNoZWROb3cgfHwgKHAudGhlbihyZXNldCksIChjYWNoZWROb3cgPSBfZ2V0Tm93KCkpKTtcclxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihlbCwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcclxuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xyXG59XHJcbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoZWwsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKSB7XHJcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcclxufVxyXG5mdW5jdGlvbiBwYXRjaEV2ZW50KGVsLCByYXdOYW1lLCBwcmV2VmFsdWUsIG5leHRWYWx1ZSwgaW5zdGFuY2UgPSBudWxsKSB7XHJcbiAgICAvLyB2ZWkgPSB2dWUgZXZlbnQgaW52b2tlcnNcclxuICAgIGNvbnN0IGludm9rZXJzID0gZWwuX3ZlaSB8fCAoZWwuX3ZlaSA9IHt9KTtcclxuICAgIGNvbnN0IGV4aXN0aW5nSW52b2tlciA9IGludm9rZXJzW3Jhd05hbWVdO1xyXG4gICAgaWYgKG5leHRWYWx1ZSAmJiBleGlzdGluZ0ludm9rZXIpIHtcclxuICAgICAgICAvLyBwYXRjaFxyXG4gICAgICAgIGV4aXN0aW5nSW52b2tlci52YWx1ZSA9IG5leHRWYWx1ZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IFtuYW1lLCBvcHRpb25zXSA9IHBhcnNlTmFtZShyYXdOYW1lKTtcclxuICAgICAgICBpZiAobmV4dFZhbHVlKSB7XHJcbiAgICAgICAgICAgIC8vIGFkZFxyXG4gICAgICAgICAgICBjb25zdCBpbnZva2VyID0gKGludm9rZXJzW3Jhd05hbWVdID0gY3JlYXRlSW52b2tlcihuZXh0VmFsdWUsIGluc3RhbmNlKSk7XHJcbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGludm9rZXIsIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChleGlzdGluZ0ludm9rZXIpIHtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlXHJcbiAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGV4aXN0aW5nSW52b2tlciwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGludm9rZXJzW3Jhd05hbWVdID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5jb25zdCBvcHRpb25zTW9kaWZpZXJSRSA9IC8oPzpPbmNlfFBhc3NpdmV8Q2FwdHVyZSkkLztcclxuZnVuY3Rpb24gcGFyc2VOYW1lKG5hbWUpIHtcclxuICAgIGxldCBvcHRpb25zO1xyXG4gICAgaWYgKG9wdGlvbnNNb2RpZmllclJFLnRlc3QobmFtZSkpIHtcclxuICAgICAgICBvcHRpb25zID0ge307XHJcbiAgICAgICAgbGV0IG07XHJcbiAgICAgICAgd2hpbGUgKChtID0gbmFtZS5tYXRjaChvcHRpb25zTW9kaWZpZXJSRSkpKSB7XHJcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIG5hbWUubGVuZ3RoIC0gbVswXS5sZW5ndGgpO1xyXG4gICAgICAgICAgICBvcHRpb25zW21bMF0udG9Mb3dlckNhc2UoKV0gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBbaHlwaGVuYXRlKG5hbWUuc2xpY2UoMikpLCBvcHRpb25zXTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVJbnZva2VyKGluaXRpYWxWYWx1ZSwgaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IGludm9rZXIgPSAoZSkgPT4ge1xyXG4gICAgICAgIC8vIGFzeW5jIGVkZ2UgY2FzZSAjNjU2NjogaW5uZXIgY2xpY2sgZXZlbnQgdHJpZ2dlcnMgcGF0Y2gsIGV2ZW50IGhhbmRsZXJcclxuICAgICAgICAvLyBhdHRhY2hlZCB0byBvdXRlciBlbGVtZW50IGR1cmluZyBwYXRjaCwgYW5kIHRyaWdnZXJlZCBhZ2Fpbi4gVGhpc1xyXG4gICAgICAgIC8vIGhhcHBlbnMgYmVjYXVzZSBicm93c2VycyBmaXJlIG1pY3JvdGFzayB0aWNrcyBiZXR3ZWVuIGV2ZW50IHByb3BhZ2F0aW9uLlxyXG4gICAgICAgIC8vIHRoZSBzb2x1dGlvbiBpcyBzaW1wbGU6IHdlIHNhdmUgdGhlIHRpbWVzdGFtcCB3aGVuIGEgaGFuZGxlciBpcyBhdHRhY2hlZCxcclxuICAgICAgICAvLyBhbmQgdGhlIGhhbmRsZXIgd291bGQgb25seSBmaXJlIGlmIHRoZSBldmVudCBwYXNzZWQgdG8gaXQgd2FzIGZpcmVkXHJcbiAgICAgICAgLy8gQUZURVIgaXQgd2FzIGF0dGFjaGVkLlxyXG4gICAgICAgIGNvbnN0IHRpbWVTdGFtcCA9IGUudGltZVN0YW1wIHx8IF9nZXROb3coKTtcclxuICAgICAgICBpZiAoc2tpcFRpbWVzdGFtcENoZWNrIHx8IHRpbWVTdGFtcCA+PSBpbnZva2VyLmF0dGFjaGVkIC0gMSkge1xyXG4gICAgICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhwYXRjaFN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbihlLCBpbnZva2VyLnZhbHVlKSwgaW5zdGFuY2UsIDUgLyogTkFUSVZFX0VWRU5UX0hBTkRMRVIgKi8sIFtlXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGludm9rZXIudmFsdWUgPSBpbml0aWFsVmFsdWU7XHJcbiAgICBpbnZva2VyLmF0dGFjaGVkID0gZ2V0Tm93KCk7XHJcbiAgICByZXR1cm4gaW52b2tlcjtcclxufVxyXG5mdW5jdGlvbiBwYXRjaFN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbihlLCB2YWx1ZSkge1xyXG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxTdG9wID0gZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb247XHJcbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsU3RvcC5jYWxsKGUpO1xyXG4gICAgICAgICAgICBlLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXAoZm4gPT4gKGUpID0+ICFlLl9zdG9wcGVkICYmIGZuKGUpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxufVxuXG5jb25zdCBuYXRpdmVPblJFID0gL15vblthLXpdLztcclxuY29uc3QgZm9yY2VQYXRjaFByb3AgPSAoXywga2V5KSA9PiBrZXkgPT09ICd2YWx1ZSc7XHJcbmNvbnN0IHBhdGNoUHJvcCA9IChlbCwga2V5LCBwcmV2VmFsdWUsIG5leHRWYWx1ZSwgaXNTVkcgPSBmYWxzZSwgcHJldkNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB1bm1vdW50Q2hpbGRyZW4pID0+IHtcclxuICAgIHN3aXRjaCAoa2V5KSB7XHJcbiAgICAgICAgLy8gc3BlY2lhbFxyXG4gICAgICAgIGNhc2UgJ2NsYXNzJzpcclxuICAgICAgICAgICAgcGF0Y2hDbGFzcyhlbCwgbmV4dFZhbHVlLCBpc1NWRyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ3N0eWxlJzpcclxuICAgICAgICAgICAgcGF0Y2hTdHlsZShlbCwgcHJldlZhbHVlLCBuZXh0VmFsdWUpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBpZiAoaXNPbihrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgdi1tb2RlbCBsaXN0ZW5lcnNcclxuICAgICAgICAgICAgICAgIGlmICghaXNNb2RlbExpc3RlbmVyKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRjaEV2ZW50KGVsLCBrZXksIHByZXZWYWx1ZSwgbmV4dFZhbHVlLCBwYXJlbnRDb21wb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNob3VsZFNldEFzUHJvcChlbCwga2V5LCBuZXh0VmFsdWUsIGlzU1ZHKSkge1xyXG4gICAgICAgICAgICAgICAgcGF0Y2hET01Qcm9wKGVsLCBrZXksIG5leHRWYWx1ZSwgcHJldkNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB1bm1vdW50Q2hpbGRyZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciA8aW5wdXQgdi1tb2RlbCB0eXBlPVwiY2hlY2tib3hcIj4gd2l0aFxyXG4gICAgICAgICAgICAgICAgLy8gOnRydWUtdmFsdWUgJiA6ZmFsc2UtdmFsdWVcclxuICAgICAgICAgICAgICAgIC8vIHN0b3JlIHZhbHVlIGFzIGRvbSBwcm9wZXJ0aWVzIHNpbmNlIG5vbi1zdHJpbmcgdmFsdWVzIHdpbGwgYmVcclxuICAgICAgICAgICAgICAgIC8vIHN0cmluZ2lmaWVkLlxyXG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3RydWUtdmFsdWUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWwuX3RydWVWYWx1ZSA9IG5leHRWYWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ2ZhbHNlLXZhbHVlJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsLl9mYWxzZVZhbHVlID0gbmV4dFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcGF0Y2hBdHRyKGVsLCBrZXksIG5leHRWYWx1ZSwgaXNTVkcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiBzaG91bGRTZXRBc1Byb3AoZWwsIGtleSwgdmFsdWUsIGlzU1ZHKSB7XHJcbiAgICBpZiAoaXNTVkcpIHtcclxuICAgICAgICAvLyBtb3N0IGtleXMgbXVzdCBiZSBzZXQgYXMgYXR0cmlidXRlIG9uIHN2ZyBlbGVtZW50cyB0byB3b3JrXHJcbiAgICAgICAgLy8gLi4uZXhjZXB0IGlubmVySFRNTFxyXG4gICAgICAgIGlmIChrZXkgPT09ICdpbm5lckhUTUwnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBvciBuYXRpdmUgb25jbGljayB3aXRoIGZ1bmN0aW9uIHZhbHVlc1xyXG4gICAgICAgIGlmIChrZXkgaW4gZWwgJiYgbmF0aXZlT25SRS50ZXN0KGtleSkgJiYgaXNGdW5jdGlvbih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vIHNwZWxsY2hlY2sgYW5kIGRyYWdnYWJsZSBhcmUgbnVtZXJhdGVkIGF0dHJzLCBob3dldmVyIHRoZWlyXHJcbiAgICAvLyBjb3JyZXNwb25kaW5nIERPTSBwcm9wZXJ0aWVzIGFyZSBhY3R1YWxseSBib29sZWFucyAtIHRoaXMgbGVhZHMgdG9cclxuICAgIC8vIHNldHRpbmcgaXQgd2l0aCBhIHN0cmluZyBcImZhbHNlXCIgdmFsdWUgbGVhZGluZyBpdCB0byBiZSBjb2VyY2VkIHRvXHJcbiAgICAvLyBgdHJ1ZWAsIHNvIHdlIG5lZWQgdG8gYWx3YXlzIHRyZWF0IHRoZW0gYXMgYXR0cmlidXRlcy5cclxuICAgIC8vIE5vdGUgdGhhdCBgY29udGVudEVkaXRhYmxlYCBkb2Vzbid0IGhhdmUgdGhpcyBwcm9ibGVtOiBpdHMgRE9NXHJcbiAgICAvLyBwcm9wZXJ0eSBpcyBhbHNvIGVudW1lcmF0ZWQgc3RyaW5nIHZhbHVlcy5cclxuICAgIGlmIChrZXkgPT09ICdzcGVsbGNoZWNrJyB8fCBrZXkgPT09ICdkcmFnZ2FibGUnKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gIzE3ODcsICMyODQwIGZvcm0gcHJvcGVydHkgb24gZm9ybSBlbGVtZW50cyBpcyByZWFkb25seSBhbmQgbXVzdCBiZSBzZXQgYXNcclxuICAgIC8vIGF0dHJpYnV0ZS5cclxuICAgIGlmIChrZXkgPT09ICdmb3JtJykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vICMxNTI2IDxpbnB1dCBsaXN0PiBtdXN0IGJlIHNldCBhcyBhdHRyaWJ1dGVcclxuICAgIGlmIChrZXkgPT09ICdsaXN0JyAmJiBlbC50YWdOYW1lID09PSAnSU5QVVQnKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gIzI3NjYgPHRleHRhcmVhIHR5cGU+IG11c3QgYmUgc2V0IGFzIGF0dHJpYnV0ZVxyXG4gICAgaWYgKGtleSA9PT0gJ3R5cGUnICYmIGVsLnRhZ05hbWUgPT09ICdURVhUQVJFQScpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyBuYXRpdmUgb25jbGljayB3aXRoIHN0cmluZyB2YWx1ZSwgbXVzdCBiZSBzZXQgYXMgYXR0cmlidXRlXHJcbiAgICBpZiAobmF0aXZlT25SRS50ZXN0KGtleSkgJiYgaXNTdHJpbmcodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGtleSBpbiBlbDtcclxufVxuXG5mdW5jdGlvbiB1c2VDc3NNb2R1bGUobmFtZSA9ICckc3R5bGUnKSB7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG4gICAge1xyXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XHJcbiAgICAgICAgaWYgKCFpbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybihgdXNlQ3NzTW9kdWxlIG11c3QgYmUgY2FsbGVkIGluc2lkZSBzZXR1cCgpYCk7XHJcbiAgICAgICAgICAgIHJldHVybiBFTVBUWV9PQko7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG1vZHVsZXMgPSBpbnN0YW5jZS50eXBlLl9fY3NzTW9kdWxlcztcclxuICAgICAgICBpZiAoIW1vZHVsZXMpIHtcclxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm4oYEN1cnJlbnQgaW5zdGFuY2UgZG9lcyBub3QgaGF2ZSBDU1MgbW9kdWxlcyBpbmplY3RlZC5gKTtcclxuICAgICAgICAgICAgcmV0dXJuIEVNUFRZX09CSjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbW9kID0gbW9kdWxlc1tuYW1lXTtcclxuICAgICAgICBpZiAoIW1vZCkge1xyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgIHdhcm4oYEN1cnJlbnQgaW5zdGFuY2UgZG9lcyBub3QgaGF2ZSBDU1MgbW9kdWxlIG5hbWVkIFwiJHtuYW1lfVwiLmApO1xyXG4gICAgICAgICAgICByZXR1cm4gRU1QVFlfT0JKO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbW9kO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgU0ZDJ3MgQ1NTIHZhcmlhYmxlIGluamVjdGlvbiBmZWF0dXJlLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gdXNlQ3NzVmFycyhnZXR0ZXIpIHtcclxuICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgaWYgKCFpbnN0YW5jZSkge1xyXG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICB3YXJuKGB1c2VDc3NWYXJzIGlzIGNhbGxlZCB3aXRob3V0IGN1cnJlbnQgYWN0aXZlIGNvbXBvbmVudCBpbnN0YW5jZS5gKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBzZXRWYXJzID0gKCkgPT4gc2V0VmFyc09uVk5vZGUoaW5zdGFuY2Uuc3ViVHJlZSwgZ2V0dGVyKGluc3RhbmNlLnByb3h5KSk7XHJcbiAgICBvbk1vdW50ZWQoKCkgPT4gd2F0Y2hFZmZlY3Qoc2V0VmFycywgeyBmbHVzaDogJ3Bvc3QnIH0pKTtcclxuICAgIG9uVXBkYXRlZChzZXRWYXJzKTtcclxufVxyXG5mdW5jdGlvbiBzZXRWYXJzT25WTm9kZSh2bm9kZSwgdmFycykge1xyXG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEyOCAvKiBTVVNQRU5TRSAqLykge1xyXG4gICAgICAgIGNvbnN0IHN1c3BlbnNlID0gdm5vZGUuc3VzcGVuc2U7XHJcbiAgICAgICAgdm5vZGUgPSBzdXNwZW5zZS5hY3RpdmVCcmFuY2g7XHJcbiAgICAgICAgaWYgKHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggJiYgIXN1c3BlbnNlLmlzSHlkcmF0aW5nKSB7XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmVmZmVjdHMucHVzaCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzZXRWYXJzT25WTm9kZShzdXNwZW5zZS5hY3RpdmVCcmFuY2gsIHZhcnMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBkcmlsbCBkb3duIEhPQ3MgdW50aWwgaXQncyBhIG5vbi1jb21wb25lbnQgdm5vZGVcclxuICAgIHdoaWxlICh2bm9kZS5jb21wb25lbnQpIHtcclxuICAgICAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudC5zdWJUcmVlO1xyXG4gICAgfVxyXG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEgLyogRUxFTUVOVCAqLyAmJiB2bm9kZS5lbCkge1xyXG4gICAgICAgIGNvbnN0IHN0eWxlID0gdm5vZGUuZWwuc3R5bGU7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFycykge1xyXG4gICAgICAgICAgICBzdHlsZS5zZXRQcm9wZXJ0eShgLS0ke2tleX1gLCB2YXJzW2tleV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZub2RlLnR5cGUgPT09IEZyYWdtZW50KSB7XHJcbiAgICAgICAgdm5vZGUuY2hpbGRyZW4uZm9yRWFjaChjID0+IHNldFZhcnNPblZOb2RlKGMsIHZhcnMpKTtcclxuICAgIH1cclxufVxuXG5jb25zdCBUUkFOU0lUSU9OID0gJ3RyYW5zaXRpb24nO1xyXG5jb25zdCBBTklNQVRJT04gPSAnYW5pbWF0aW9uJztcclxuLy8gRE9NIFRyYW5zaXRpb24gaXMgYSBoaWdoZXItb3JkZXItY29tcG9uZW50IGJhc2VkIG9uIHRoZSBwbGF0Zm9ybS1hZ25vc3RpY1xyXG4vLyBiYXNlIFRyYW5zaXRpb24gY29tcG9uZW50LCB3aXRoIERPTS1zcGVjaWZpYyBsb2dpYy5cclxuY29uc3QgVHJhbnNpdGlvbiA9IChwcm9wcywgeyBzbG90cyB9KSA9PiBoKEJhc2VUcmFuc2l0aW9uLCByZXNvbHZlVHJhbnNpdGlvblByb3BzKHByb3BzKSwgc2xvdHMpO1xyXG5UcmFuc2l0aW9uLmRpc3BsYXlOYW1lID0gJ1RyYW5zaXRpb24nO1xyXG5jb25zdCBET01UcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzID0ge1xyXG4gICAgbmFtZTogU3RyaW5nLFxyXG4gICAgdHlwZTogU3RyaW5nLFxyXG4gICAgY3NzOiB7XHJcbiAgICAgICAgdHlwZTogQm9vbGVhbixcclxuICAgICAgICBkZWZhdWx0OiB0cnVlXHJcbiAgICB9LFxyXG4gICAgZHVyYXRpb246IFtTdHJpbmcsIE51bWJlciwgT2JqZWN0XSxcclxuICAgIGVudGVyRnJvbUNsYXNzOiBTdHJpbmcsXHJcbiAgICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXHJcbiAgICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcclxuICAgIGFwcGVhckZyb21DbGFzczogU3RyaW5nLFxyXG4gICAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcclxuICAgIGFwcGVhclRvQ2xhc3M6IFN0cmluZyxcclxuICAgIGxlYXZlRnJvbUNsYXNzOiBTdHJpbmcsXHJcbiAgICBsZWF2ZUFjdGl2ZUNsYXNzOiBTdHJpbmcsXHJcbiAgICBsZWF2ZVRvQ2xhc3M6IFN0cmluZ1xyXG59O1xyXG5jb25zdCBUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzID0gKFRyYW5zaXRpb24ucHJvcHMgPSAvKiNfX1BVUkVfXyovIGV4dGVuZCh7fSwgQmFzZVRyYW5zaXRpb24ucHJvcHMsIERPTVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMpKTtcclxuLyoqXHJcbiAqICMzMjI3IEluY29taW5nIGhvb2tzIG1heSBiZSBtZXJnZWQgaW50byBhcnJheXMgd2hlbiB3cmFwcGluZyBUcmFuc2l0aW9uXHJcbiAqIHdpdGggY3VzdG9tIEhPQ3MuXHJcbiAqL1xyXG5jb25zdCBjYWxsSG9vayA9IChob29rLCBhcmdzID0gW10pID0+IHtcclxuICAgIGlmIChpc0FycmF5KGhvb2spKSB7XHJcbiAgICAgICAgaG9vay5mb3JFYWNoKGggPT4gaCguLi5hcmdzKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChob29rKSB7XHJcbiAgICAgICAgaG9vayguLi5hcmdzKTtcclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIENoZWNrIGlmIGEgaG9vayBleHBlY3RzIGEgY2FsbGJhY2sgKDJuZCBhcmcpLCB3aGljaCBtZWFucyB0aGUgdXNlclxyXG4gKiBpbnRlbmRzIHRvIGV4cGxpY2l0bHkgY29udHJvbCB0aGUgZW5kIG9mIHRoZSB0cmFuc2l0aW9uLlxyXG4gKi9cclxuY29uc3QgaGFzRXhwbGljaXRDYWxsYmFjayA9IChob29rKSA9PiB7XHJcbiAgICByZXR1cm4gaG9va1xyXG4gICAgICAgID8gaXNBcnJheShob29rKVxyXG4gICAgICAgICAgICA/IGhvb2suc29tZShoID0+IGgubGVuZ3RoID4gMSlcclxuICAgICAgICAgICAgOiBob29rLmxlbmd0aCA+IDFcclxuICAgICAgICA6IGZhbHNlO1xyXG59O1xyXG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvblByb3BzKHJhd1Byb3BzKSB7XHJcbiAgICBjb25zdCBiYXNlUHJvcHMgPSB7fTtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIHJhd1Byb3BzKSB7XHJcbiAgICAgICAgaWYgKCEoa2V5IGluIERPTVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMpKSB7XHJcbiAgICAgICAgICAgIGJhc2VQcm9wc1trZXldID0gcmF3UHJvcHNba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocmF3UHJvcHMuY3NzID09PSBmYWxzZSkge1xyXG4gICAgICAgIHJldHVybiBiYXNlUHJvcHM7XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IG5hbWUgPSAndicsIHR5cGUsIGR1cmF0aW9uLCBlbnRlckZyb21DbGFzcyA9IGAke25hbWV9LWVudGVyLWZyb21gLCBlbnRlckFjdGl2ZUNsYXNzID0gYCR7bmFtZX0tZW50ZXItYWN0aXZlYCwgZW50ZXJUb0NsYXNzID0gYCR7bmFtZX0tZW50ZXItdG9gLCBhcHBlYXJGcm9tQ2xhc3MgPSBlbnRlckZyb21DbGFzcywgYXBwZWFyQWN0aXZlQ2xhc3MgPSBlbnRlckFjdGl2ZUNsYXNzLCBhcHBlYXJUb0NsYXNzID0gZW50ZXJUb0NsYXNzLCBsZWF2ZUZyb21DbGFzcyA9IGAke25hbWV9LWxlYXZlLWZyb21gLCBsZWF2ZUFjdGl2ZUNsYXNzID0gYCR7bmFtZX0tbGVhdmUtYWN0aXZlYCwgbGVhdmVUb0NsYXNzID0gYCR7bmFtZX0tbGVhdmUtdG9gIH0gPSByYXdQcm9wcztcclxuICAgIGNvbnN0IGR1cmF0aW9ucyA9IG5vcm1hbGl6ZUR1cmF0aW9uKGR1cmF0aW9uKTtcclxuICAgIGNvbnN0IGVudGVyRHVyYXRpb24gPSBkdXJhdGlvbnMgJiYgZHVyYXRpb25zWzBdO1xyXG4gICAgY29uc3QgbGVhdmVEdXJhdGlvbiA9IGR1cmF0aW9ucyAmJiBkdXJhdGlvbnNbMV07XHJcbiAgICBjb25zdCB7IG9uQmVmb3JlRW50ZXIsIG9uRW50ZXIsIG9uRW50ZXJDYW5jZWxsZWQsIG9uTGVhdmUsIG9uTGVhdmVDYW5jZWxsZWQsIG9uQmVmb3JlQXBwZWFyID0gb25CZWZvcmVFbnRlciwgb25BcHBlYXIgPSBvbkVudGVyLCBvbkFwcGVhckNhbmNlbGxlZCA9IG9uRW50ZXJDYW5jZWxsZWQgfSA9IGJhc2VQcm9wcztcclxuICAgIGNvbnN0IGZpbmlzaEVudGVyID0gKGVsLCBpc0FwcGVhciwgZG9uZSkgPT4ge1xyXG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgaXNBcHBlYXIgPyBhcHBlYXJUb0NsYXNzIDogZW50ZXJUb0NsYXNzKTtcclxuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyQWN0aXZlQ2xhc3MgOiBlbnRlckFjdGl2ZUNsYXNzKTtcclxuICAgICAgICBkb25lICYmIGRvbmUoKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBmaW5pc2hMZWF2ZSA9IChlbCwgZG9uZSkgPT4ge1xyXG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcclxuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xyXG4gICAgICAgIGRvbmUgJiYgZG9uZSgpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IG1ha2VFbnRlckhvb2sgPSAoaXNBcHBlYXIpID0+IHtcclxuICAgICAgICByZXR1cm4gKGVsLCBkb25lKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhvb2sgPSBpc0FwcGVhciA/IG9uQXBwZWFyIDogb25FbnRlcjtcclxuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZSA9ICgpID0+IGZpbmlzaEVudGVyKGVsLCBpc0FwcGVhciwgZG9uZSk7XHJcbiAgICAgICAgICAgIGNhbGxIb29rKGhvb2ssIFtlbCwgcmVzb2x2ZV0pO1xyXG4gICAgICAgICAgICBuZXh0RnJhbWUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhckZyb21DbGFzcyA6IGVudGVyRnJvbUNsYXNzKTtcclxuICAgICAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgaXNBcHBlYXIgPyBhcHBlYXJUb0NsYXNzIDogZW50ZXJUb0NsYXNzKTtcclxuICAgICAgICAgICAgICAgIGlmICghaGFzRXhwbGljaXRDYWxsYmFjayhob29rKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgZW50ZXJEdXJhdGlvbiwgcmVzb2x2ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZChiYXNlUHJvcHMsIHtcclxuICAgICAgICBvbkJlZm9yZUVudGVyKGVsKSB7XHJcbiAgICAgICAgICAgIGNhbGxIb29rKG9uQmVmb3JlRW50ZXIsIFtlbF0pO1xyXG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGVudGVyRnJvbUNsYXNzKTtcclxuICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBlbnRlckFjdGl2ZUNsYXNzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQmVmb3JlQXBwZWFyKGVsKSB7XHJcbiAgICAgICAgICAgIGNhbGxIb29rKG9uQmVmb3JlQXBwZWFyLCBbZWxdKTtcclxuICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhcHBlYXJGcm9tQ2xhc3MpO1xyXG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFwcGVhckFjdGl2ZUNsYXNzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uRW50ZXI6IG1ha2VFbnRlckhvb2soZmFsc2UpLFxyXG4gICAgICAgIG9uQXBwZWFyOiBtYWtlRW50ZXJIb29rKHRydWUpLFxyXG4gICAgICAgIG9uTGVhdmUoZWwsIGRvbmUpIHtcclxuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZSA9ICgpID0+IGZpbmlzaExlYXZlKGVsLCBkb25lKTtcclxuICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUZyb21DbGFzcyk7XHJcbiAgICAgICAgICAgIC8vIGZvcmNlIHJlZmxvdyBzbyAqLWxlYXZlLWZyb20gY2xhc3NlcyBpbW1lZGlhdGVseSB0YWtlIGVmZmVjdCAoIzI1OTMpXHJcbiAgICAgICAgICAgIGZvcmNlUmVmbG93KCk7XHJcbiAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XHJcbiAgICAgICAgICAgIG5leHRGcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlRnJvbUNsYXNzKTtcclxuICAgICAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcclxuICAgICAgICAgICAgICAgIGlmICghaGFzRXhwbGljaXRDYWxsYmFjayhvbkxlYXZlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgbGVhdmVEdXJhdGlvbiwgcmVzb2x2ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjYWxsSG9vayhvbkxlYXZlLCBbZWwsIHJlc29sdmVdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uRW50ZXJDYW5jZWxsZWQoZWwpIHtcclxuICAgICAgICAgICAgZmluaXNoRW50ZXIoZWwsIGZhbHNlKTtcclxuICAgICAgICAgICAgY2FsbEhvb2sob25FbnRlckNhbmNlbGxlZCwgW2VsXSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkFwcGVhckNhbmNlbGxlZChlbCkge1xyXG4gICAgICAgICAgICBmaW5pc2hFbnRlcihlbCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGNhbGxIb29rKG9uQXBwZWFyQ2FuY2VsbGVkLCBbZWxdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uTGVhdmVDYW5jZWxsZWQoZWwpIHtcclxuICAgICAgICAgICAgZmluaXNoTGVhdmUoZWwpO1xyXG4gICAgICAgICAgICBjYWxsSG9vayhvbkxlYXZlQ2FuY2VsbGVkLCBbZWxdKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVEdXJhdGlvbihkdXJhdGlvbikge1xyXG4gICAgaWYgKGR1cmF0aW9uID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KGR1cmF0aW9uKSkge1xyXG4gICAgICAgIHJldHVybiBbTnVtYmVyT2YoZHVyYXRpb24uZW50ZXIpLCBOdW1iZXJPZihkdXJhdGlvbi5sZWF2ZSldO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgbiA9IE51bWJlck9mKGR1cmF0aW9uKTtcclxuICAgICAgICByZXR1cm4gW24sIG5dO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIE51bWJlck9mKHZhbCkge1xyXG4gICAgY29uc3QgcmVzID0gdG9OdW1iZXIodmFsKTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpXHJcbiAgICAgICAgdmFsaWRhdGVEdXJhdGlvbihyZXMpO1xyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0ZUR1cmF0aW9uKHZhbCkge1xyXG4gICAgaWYgKHR5cGVvZiB2YWwgIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgd2FybihgPHRyYW5zaXRpb24+IGV4cGxpY2l0IGR1cmF0aW9uIGlzIG5vdCBhIHZhbGlkIG51bWJlciAtIGAgK1xyXG4gICAgICAgICAgICBgZ290ICR7SlNPTi5zdHJpbmdpZnkodmFsKX0uYCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc05hTih2YWwpKSB7XHJcbiAgICAgICAgd2FybihgPHRyYW5zaXRpb24+IGV4cGxpY2l0IGR1cmF0aW9uIGlzIE5hTiAtIGAgK1xyXG4gICAgICAgICAgICAndGhlIGR1cmF0aW9uIGV4cHJlc3Npb24gbWlnaHQgYmUgaW5jb3JyZWN0LicpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgY2xzKSB7XHJcbiAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGMgPT4gYyAmJiBlbC5jbGFzc0xpc3QuYWRkKGMpKTtcclxuICAgIChlbC5fdnRjIHx8XHJcbiAgICAgICAgKGVsLl92dGMgPSBuZXcgU2V0KCkpKS5hZGQoY2xzKTtcclxufVxyXG5mdW5jdGlvbiByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGNscykge1xyXG4gICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChjID0+IGMgJiYgZWwuY2xhc3NMaXN0LnJlbW92ZShjKSk7XHJcbiAgICBjb25zdCB7IF92dGMgfSA9IGVsO1xyXG4gICAgaWYgKF92dGMpIHtcclxuICAgICAgICBfdnRjLmRlbGV0ZShjbHMpO1xyXG4gICAgICAgIGlmICghX3Z0Yy5zaXplKSB7XHJcbiAgICAgICAgICAgIGVsLl92dGMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG5leHRGcmFtZShjYikge1xyXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2IpO1xyXG4gICAgfSk7XHJcbn1cclxubGV0IGVuZElkID0gMDtcclxuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzKGVsLCBleHBlY3RlZFR5cGUsIGV4cGxpY2l0VGltZW91dCwgcmVzb2x2ZSkge1xyXG4gICAgY29uc3QgaWQgPSAoZWwuX2VuZElkID0gKytlbmRJZCk7XHJcbiAgICBjb25zdCByZXNvbHZlSWZOb3RTdGFsZSA9ICgpID0+IHtcclxuICAgICAgICBpZiAoaWQgPT09IGVsLl9lbmRJZCkge1xyXG4gICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGlmIChleHBsaWNpdFRpbWVvdXQpIHtcclxuICAgICAgICByZXR1cm4gc2V0VGltZW91dChyZXNvbHZlSWZOb3RTdGFsZSwgZXhwbGljaXRUaW1lb3V0KTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgdHlwZSwgdGltZW91dCwgcHJvcENvdW50IH0gPSBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKTtcclxuICAgIGlmICghdHlwZSkge1xyXG4gICAgICAgIHJldHVybiByZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBlbmRFdmVudCA9IHR5cGUgKyAnZW5kJztcclxuICAgIGxldCBlbmRlZCA9IDA7XHJcbiAgICBjb25zdCBlbmQgPSAoKSA9PiB7XHJcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihlbmRFdmVudCwgb25FbmQpO1xyXG4gICAgICAgIHJlc29sdmVJZk5vdFN0YWxlKCk7XHJcbiAgICB9O1xyXG4gICAgY29uc3Qgb25FbmQgPSAoZSkgPT4ge1xyXG4gICAgICAgIGlmIChlLnRhcmdldCA9PT0gZWwgJiYgKytlbmRlZCA+PSBwcm9wQ291bnQpIHtcclxuICAgICAgICAgICAgZW5kKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIGlmIChlbmRlZCA8IHByb3BDb3VudCkge1xyXG4gICAgICAgICAgICBlbmQoKTtcclxuICAgICAgICB9XHJcbiAgICB9LCB0aW1lb3V0ICsgMSk7XHJcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKGVuZEV2ZW50LCBvbkVuZCk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSkge1xyXG4gICAgY29uc3Qgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xyXG4gICAgLy8gSlNET00gbWF5IHJldHVybiB1bmRlZmluZWQgZm9yIHRyYW5zaXRpb24gcHJvcGVydGllc1xyXG4gICAgY29uc3QgZ2V0U3R5bGVQcm9wZXJ0aWVzID0gKGtleSkgPT4gKHN0eWxlc1trZXldIHx8ICcnKS5zcGxpdCgnLCAnKTtcclxuICAgIGNvbnN0IHRyYW5zaXRpb25EZWxheXMgPSBnZXRTdHlsZVByb3BlcnRpZXMoVFJBTlNJVElPTiArICdEZWxheScpO1xyXG4gICAgY29uc3QgdHJhbnNpdGlvbkR1cmF0aW9ucyA9IGdldFN0eWxlUHJvcGVydGllcyhUUkFOU0lUSU9OICsgJ0R1cmF0aW9uJyk7XHJcbiAgICBjb25zdCB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XHJcbiAgICBjb25zdCBhbmltYXRpb25EZWxheXMgPSBnZXRTdHlsZVByb3BlcnRpZXMoQU5JTUFUSU9OICsgJ0RlbGF5Jyk7XHJcbiAgICBjb25zdCBhbmltYXRpb25EdXJhdGlvbnMgPSBnZXRTdHlsZVByb3BlcnRpZXMoQU5JTUFUSU9OICsgJ0R1cmF0aW9uJyk7XHJcbiAgICBjb25zdCBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XHJcbiAgICBsZXQgdHlwZSA9IG51bGw7XHJcbiAgICBsZXQgdGltZW91dCA9IDA7XHJcbiAgICBsZXQgcHJvcENvdW50ID0gMDtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xyXG4gICAgICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcclxuICAgICAgICAgICAgdHlwZSA9IFRSQU5TSVRJT047XHJcbiAgICAgICAgICAgIHRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcclxuICAgICAgICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBBTklNQVRJT04pIHtcclxuICAgICAgICBpZiAoYW5pbWF0aW9uVGltZW91dCA+IDApIHtcclxuICAgICAgICAgICAgdHlwZSA9IEFOSU1BVElPTjtcclxuICAgICAgICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XHJcbiAgICAgICAgICAgIHByb3BDb3VudCA9IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGltZW91dCA9IE1hdGgubWF4KHRyYW5zaXRpb25UaW1lb3V0LCBhbmltYXRpb25UaW1lb3V0KTtcclxuICAgICAgICB0eXBlID1cclxuICAgICAgICAgICAgdGltZW91dCA+IDBcclxuICAgICAgICAgICAgICAgID8gdHJhbnNpdGlvblRpbWVvdXQgPiBhbmltYXRpb25UaW1lb3V0XHJcbiAgICAgICAgICAgICAgICAgICAgPyBUUkFOU0lUSU9OXHJcbiAgICAgICAgICAgICAgICAgICAgOiBBTklNQVRJT05cclxuICAgICAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgICBwcm9wQ291bnQgPSB0eXBlXHJcbiAgICAgICAgICAgID8gdHlwZSA9PT0gVFJBTlNJVElPTlxyXG4gICAgICAgICAgICAgICAgPyB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aFxyXG4gICAgICAgICAgICAgICAgOiBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoXHJcbiAgICAgICAgICAgIDogMDtcclxuICAgIH1cclxuICAgIGNvbnN0IGhhc1RyYW5zZm9ybSA9IHR5cGUgPT09IFRSQU5TSVRJT04gJiZcclxuICAgICAgICAvXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvLnRlc3Qoc3R5bGVzW1RSQU5TSVRJT04gKyAnUHJvcGVydHknXSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGUsXHJcbiAgICAgICAgdGltZW91dCxcclxuICAgICAgICBwcm9wQ291bnQsXHJcbiAgICAgICAgaGFzVHJhbnNmb3JtXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGdldFRpbWVvdXQoZGVsYXlzLCBkdXJhdGlvbnMpIHtcclxuICAgIHdoaWxlIChkZWxheXMubGVuZ3RoIDwgZHVyYXRpb25zLmxlbmd0aCkge1xyXG4gICAgICAgIGRlbGF5cyA9IGRlbGF5cy5jb25jYXQoZGVsYXlzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBNYXRoLm1heCguLi5kdXJhdGlvbnMubWFwKChkLCBpKSA9PiB0b01zKGQpICsgdG9NcyhkZWxheXNbaV0pKSk7XHJcbn1cclxuLy8gT2xkIHZlcnNpb25zIG9mIENocm9taXVtIChiZWxvdyA2MS4wLjMxNjMuMTAwKSBmb3JtYXRzIGZsb2F0aW5nIHBvaW50ZXJcclxuLy8gbnVtYmVycyBpbiBhIGxvY2FsZS1kZXBlbmRlbnQgd2F5LCB1c2luZyBhIGNvbW1hIGluc3RlYWQgb2YgYSBkb3QuXHJcbi8vIElmIGNvbW1hIGlzIG5vdCByZXBsYWNlZCB3aXRoIGEgZG90LCB0aGUgaW5wdXQgd2lsbCBiZSByb3VuZGVkIGRvd25cclxuLy8gKGkuZS4gYWN0aW5nIGFzIGEgZmxvb3IgZnVuY3Rpb24pIGNhdXNpbmcgdW5leHBlY3RlZCBiZWhhdmlvcnNcclxuZnVuY3Rpb24gdG9NcyhzKSB7XHJcbiAgICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpLnJlcGxhY2UoJywnLCAnLicpKSAqIDEwMDA7XHJcbn1cclxuLy8gc3luY2hyb25vdXNseSBmb3JjZSBsYXlvdXQgdG8gcHV0IGVsZW1lbnRzIGludG8gYSBjZXJ0YWluIHN0YXRlXHJcbmZ1bmN0aW9uIGZvcmNlUmVmbG93KCkge1xyXG4gICAgcmV0dXJuIGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0O1xyXG59XG5cbmNvbnN0IHBvc2l0aW9uTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuY29uc3QgbmV3UG9zaXRpb25NYXAgPSBuZXcgV2Vha01hcCgpO1xyXG5jb25zdCBUcmFuc2l0aW9uR3JvdXBJbXBsID0ge1xyXG4gICAgbmFtZTogJ1RyYW5zaXRpb25Hcm91cCcsXHJcbiAgICBwcm9wczogLyojX19QVVJFX18qLyBleHRlbmQoe30sIFRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMsIHtcclxuICAgICAgICB0YWc6IFN0cmluZyxcclxuICAgICAgICBtb3ZlQ2xhc3M6IFN0cmluZ1xyXG4gICAgfSksXHJcbiAgICBzZXR1cChwcm9wcywgeyBzbG90cyB9KSB7XHJcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgICAgICBjb25zdCBzdGF0ZSA9IHVzZVRyYW5zaXRpb25TdGF0ZSgpO1xyXG4gICAgICAgIGxldCBwcmV2Q2hpbGRyZW47XHJcbiAgICAgICAgbGV0IGNoaWxkcmVuO1xyXG4gICAgICAgIG9uVXBkYXRlZCgoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIGNoaWxkcmVuIGlzIGd1YXJhbnRlZWQgdG8gZXhpc3QgYWZ0ZXIgaW5pdGlhbCByZW5kZXJcclxuICAgICAgICAgICAgaWYgKCFwcmV2Q2hpbGRyZW4ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbW92ZUNsYXNzID0gcHJvcHMubW92ZUNsYXNzIHx8IGAke3Byb3BzLm5hbWUgfHwgJ3YnfS1tb3ZlYDtcclxuICAgICAgICAgICAgaWYgKCFoYXNDU1NUcmFuc2Zvcm0ocHJldkNoaWxkcmVuWzBdLmVsLCBpbnN0YW5jZS52bm9kZS5lbCwgbW92ZUNsYXNzKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHdlIGRpdmlkZSB0aGUgd29yayBpbnRvIHRocmVlIGxvb3BzIHRvIGF2b2lkIG1peGluZyBET00gcmVhZHMgYW5kIHdyaXRlc1xyXG4gICAgICAgICAgICAvLyBpbiBlYWNoIGl0ZXJhdGlvbiAtIHdoaWNoIGhlbHBzIHByZXZlbnQgbGF5b3V0IHRocmFzaGluZy5cclxuICAgICAgICAgICAgcHJldkNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xyXG4gICAgICAgICAgICBwcmV2Q2hpbGRyZW4uZm9yRWFjaChyZWNvcmRQb3NpdGlvbik7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vdmVkQ2hpbGRyZW4gPSBwcmV2Q2hpbGRyZW4uZmlsdGVyKGFwcGx5VHJhbnNsYXRpb24pO1xyXG4gICAgICAgICAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cclxuICAgICAgICAgICAgZm9yY2VSZWZsb3coKTtcclxuICAgICAgICAgICAgbW92ZWRDaGlsZHJlbi5mb3JFYWNoKGMgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZWwgPSBjLmVsO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBlbC5zdHlsZTtcclxuICAgICAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcclxuICAgICAgICAgICAgICAgIHN0eWxlLnRyYW5zZm9ybSA9IHN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcnO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2IgPSAoZWwuX21vdmVDYiA9IChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUgJiYgZS50YXJnZXQgIT09IGVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlIHx8IC90cmFuc2Zvcm0kLy50ZXN0KGUucHJvcGVydHlOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgY2IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5fbW92ZUNiID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGNiKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcmF3UHJvcHMgPSB0b1Jhdyhwcm9wcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNzc1RyYW5zaXRpb25Qcm9wcyA9IHJlc29sdmVUcmFuc2l0aW9uUHJvcHMocmF3UHJvcHMpO1xyXG4gICAgICAgICAgICBsZXQgdGFnID0gcmF3UHJvcHMudGFnIHx8IEZyYWdtZW50O1xyXG4gICAgICAgICAgICBwcmV2Q2hpbGRyZW4gPSBjaGlsZHJlbjtcclxuICAgICAgICAgICAgY2hpbGRyZW4gPSBzbG90cy5kZWZhdWx0ID8gZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKHNsb3RzLmRlZmF1bHQoKSkgOiBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5rZXkgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyhjaGlsZCwgcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhjaGlsZCwgY3NzVHJhbnNpdGlvblByb3BzLCBzdGF0ZSwgaW5zdGFuY2UpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYDxUcmFuc2l0aW9uR3JvdXA+IGNoaWxkcmVuIG11c3QgYmUga2V5ZWQuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHByZXZDaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IHByZXZDaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3MoY2hpbGQsIHJlc29sdmVUcmFuc2l0aW9uSG9va3MoY2hpbGQsIGNzc1RyYW5zaXRpb25Qcm9wcywgc3RhdGUsIGluc3RhbmNlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25NYXAuc2V0KGNoaWxkLCBjaGlsZC5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHRhZywgbnVsbCwgY2hpbGRyZW4pO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IFRyYW5zaXRpb25Hcm91cCA9IFRyYW5zaXRpb25Hcm91cEltcGw7XHJcbmZ1bmN0aW9uIGNhbGxQZW5kaW5nQ2JzKGMpIHtcclxuICAgIGNvbnN0IGVsID0gYy5lbDtcclxuICAgIGlmIChlbC5fbW92ZUNiKSB7XHJcbiAgICAgICAgZWwuX21vdmVDYigpO1xyXG4gICAgfVxyXG4gICAgaWYgKGVsLl9lbnRlckNiKSB7XHJcbiAgICAgICAgZWwuX2VudGVyQ2IoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiByZWNvcmRQb3NpdGlvbihjKSB7XHJcbiAgICBuZXdQb3NpdGlvbk1hcC5zZXQoYywgYy5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XHJcbn1cclxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbihjKSB7XHJcbiAgICBjb25zdCBvbGRQb3MgPSBwb3NpdGlvbk1hcC5nZXQoYyk7XHJcbiAgICBjb25zdCBuZXdQb3MgPSBuZXdQb3NpdGlvbk1hcC5nZXQoYyk7XHJcbiAgICBjb25zdCBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XHJcbiAgICBjb25zdCBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xyXG4gICAgaWYgKGR4IHx8IGR5KSB7XHJcbiAgICAgICAgY29uc3QgcyA9IGMuZWwuc3R5bGU7XHJcbiAgICAgICAgcy50cmFuc2Zvcm0gPSBzLndlYmtpdFRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHtkeH1weCwke2R5fXB4KWA7XHJcbiAgICAgICAgcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xyXG4gICAgICAgIHJldHVybiBjO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGhhc0NTU1RyYW5zZm9ybShlbCwgcm9vdCwgbW92ZUNsYXNzKSB7XHJcbiAgICAvLyBEZXRlY3Qgd2hldGhlciBhbiBlbGVtZW50IHdpdGggdGhlIG1vdmUgY2xhc3MgYXBwbGllZCBoYXNcclxuICAgIC8vIENTUyB0cmFuc2l0aW9ucy4gU2luY2UgdGhlIGVsZW1lbnQgbWF5IGJlIGluc2lkZSBhbiBlbnRlcmluZ1xyXG4gICAgLy8gdHJhbnNpdGlvbiBhdCB0aGlzIHZlcnkgbW9tZW50LCB3ZSBtYWtlIGEgY2xvbmUgb2YgaXQgYW5kIHJlbW92ZVxyXG4gICAgLy8gYWxsIG90aGVyIHRyYW5zaXRpb24gY2xhc3NlcyBhcHBsaWVkIHRvIGVuc3VyZSBvbmx5IHRoZSBtb3ZlIGNsYXNzXHJcbiAgICAvLyBpcyBhcHBsaWVkLlxyXG4gICAgY29uc3QgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcclxuICAgIGlmIChlbC5fdnRjKSB7XHJcbiAgICAgICAgZWwuX3Z0Yy5mb3JFYWNoKGNscyA9PiB7XHJcbiAgICAgICAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goYyA9PiBjICYmIGNsb25lLmNsYXNzTGlzdC5yZW1vdmUoYykpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgbW92ZUNsYXNzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChjID0+IGMgJiYgY2xvbmUuY2xhc3NMaXN0LmFkZChjKSk7XHJcbiAgICBjbG9uZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgY29uc3QgY29udGFpbmVyID0gKHJvb3Qubm9kZVR5cGUgPT09IDFcclxuICAgICAgICA/IHJvb3RcclxuICAgICAgICA6IHJvb3QucGFyZW50Tm9kZSk7XHJcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY2xvbmUpO1xyXG4gICAgY29uc3QgeyBoYXNUcmFuc2Zvcm0gfSA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcclxuICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjbG9uZSk7XHJcbiAgICByZXR1cm4gaGFzVHJhbnNmb3JtO1xyXG59XG5cbmNvbnN0IGdldE1vZGVsQXNzaWduZXIgPSAodm5vZGUpID0+IHtcclxuICAgIGNvbnN0IGZuID0gdm5vZGUucHJvcHNbJ29uVXBkYXRlOm1vZGVsVmFsdWUnXTtcclxuICAgIHJldHVybiBpc0FycmF5KGZuKSA/IHZhbHVlID0+IGludm9rZUFycmF5Rm5zKGZuLCB2YWx1ZSkgOiBmbjtcclxufTtcclxuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0KGUpIHtcclxuICAgIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XHJcbn1cclxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZChlKSB7XHJcbiAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldDtcclxuICAgIGlmICh0YXJnZXQuY29tcG9zaW5nKSB7XHJcbiAgICAgICAgdGFyZ2V0LmNvbXBvc2luZyA9IGZhbHNlO1xyXG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCAnaW5wdXQnKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0cmlnZ2VyKGVsLCB0eXBlKSB7XHJcbiAgICBjb25zdCBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcclxuICAgIGUuaW5pdEV2ZW50KHR5cGUsIHRydWUsIHRydWUpO1xyXG4gICAgZWwuZGlzcGF0Y2hFdmVudChlKTtcclxufVxyXG4vLyBXZSBhcmUgZXhwb3J0aW5nIHRoZSB2LW1vZGVsIHJ1bnRpbWUgZGlyZWN0bHkgYXMgdm5vZGUgaG9va3Mgc28gdGhhdCBpdCBjYW5cclxuLy8gYmUgdHJlZS1zaGFrZW4gaW4gY2FzZSB2LW1vZGVsIGlzIG5ldmVyIHVzZWQuXHJcbmNvbnN0IHZNb2RlbFRleHQgPSB7XHJcbiAgICBjcmVhdGVkKGVsLCB7IG1vZGlmaWVyczogeyBsYXp5LCB0cmltLCBudW1iZXIgfSB9LCB2bm9kZSkge1xyXG4gICAgICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcclxuICAgICAgICBjb25zdCBjYXN0VG9OdW1iZXIgPSBudW1iZXIgfHwgZWwudHlwZSA9PT0gJ251bWJlcic7XHJcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgbGF6eSA/ICdjaGFuZ2UnIDogJ2lucHV0JywgZSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlLnRhcmdldC5jb21wb3NpbmcpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIGxldCBkb21WYWx1ZSA9IGVsLnZhbHVlO1xyXG4gICAgICAgICAgICBpZiAodHJpbSkge1xyXG4gICAgICAgICAgICAgICAgZG9tVmFsdWUgPSBkb21WYWx1ZS50cmltKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2FzdFRvTnVtYmVyKSB7XHJcbiAgICAgICAgICAgICAgICBkb21WYWx1ZSA9IHRvTnVtYmVyKGRvbVZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbC5fYXNzaWduKGRvbVZhbHVlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAodHJpbSkge1xyXG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCAnY2hhbmdlJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZWwudmFsdWUgPSBlbC52YWx1ZS50cmltKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWxhenkpIHtcclxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xyXG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCAnY29tcG9zaXRpb25lbmQnLCBvbkNvbXBvc2l0aW9uRW5kKTtcclxuICAgICAgICAgICAgLy8gU2FmYXJpIDwgMTAuMiAmIFVJV2ViVmlldyBkb2Vzbid0IGZpcmUgY29tcG9zaXRpb25lbmQgd2hlblxyXG4gICAgICAgICAgICAvLyBzd2l0Y2hpbmcgZm9jdXMgYmVmb3JlIGNvbmZpcm1pbmcgY29tcG9zaXRpb24gY2hvaWNlXHJcbiAgICAgICAgICAgIC8vIHRoaXMgYWxzbyBmaXhlcyB0aGUgaXNzdWUgd2hlcmUgc29tZSBicm93c2VycyBlLmcuIGlPUyBDaHJvbWVcclxuICAgICAgICAgICAgLy8gZmlyZXMgXCJjaGFuZ2VcIiBpbnN0ZWFkIG9mIFwiaW5wdXRcIiBvbiBhdXRvY29tcGxldGUuXHJcbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsICdjaGFuZ2UnLCBvbkNvbXBvc2l0aW9uRW5kKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgLy8gc2V0IHZhbHVlIG9uIG1vdW50ZWQgc28gaXQncyBhZnRlciBtaW4vbWF4IGZvciB0eXBlPVwicmFuZ2VcIlxyXG4gICAgbW91bnRlZChlbCwgeyB2YWx1ZSB9KSB7XHJcbiAgICAgICAgZWwudmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcclxuICAgIH0sXHJcbiAgICBiZWZvcmVVcGRhdGUoZWwsIHsgdmFsdWUsIG1vZGlmaWVyczogeyB0cmltLCBudW1iZXIgfSB9LCB2bm9kZSkge1xyXG4gICAgICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcclxuICAgICAgICAvLyBhdm9pZCBjbGVhcmluZyB1bnJlc29sdmVkIHRleHQuICMyMzAyXHJcbiAgICAgICAgaWYgKGVsLmNvbXBvc2luZylcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBlbCkge1xyXG4gICAgICAgICAgICBpZiAodHJpbSAmJiBlbC52YWx1ZS50cmltKCkgPT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKChudW1iZXIgfHwgZWwudHlwZSA9PT0gJ251bWJlcicpICYmIHRvTnVtYmVyKGVsLnZhbHVlKSA9PT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xyXG4gICAgICAgIGlmIChlbC52YWx1ZSAhPT0gbmV3VmFsdWUpIHtcclxuICAgICAgICAgICAgZWwudmFsdWUgPSBuZXdWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IHZNb2RlbENoZWNrYm94ID0ge1xyXG4gICAgY3JlYXRlZChlbCwgXywgdm5vZGUpIHtcclxuICAgICAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XHJcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ2NoYW5nZScsICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9kZWxWYWx1ZSA9IGVsLl9tb2RlbFZhbHVlO1xyXG4gICAgICAgICAgICBjb25zdCBlbGVtZW50VmFsdWUgPSBnZXRWYWx1ZShlbCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrZWQgPSBlbC5jaGVja2VkO1xyXG4gICAgICAgICAgICBjb25zdCBhc3NpZ24gPSBlbC5fYXNzaWduO1xyXG4gICAgICAgICAgICBpZiAoaXNBcnJheShtb2RlbFZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBsb29zZUluZGV4T2YobW9kZWxWYWx1ZSwgZWxlbWVudFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZvdW5kID0gaW5kZXggIT09IC0xO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrZWQgJiYgIWZvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXNzaWduKG1vZGVsVmFsdWUuY29uY2F0KGVsZW1lbnRWYWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWNoZWNrZWQgJiYgZm91bmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IFsuLi5tb2RlbFZhbHVlXTtcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZC5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFzc2lnbihmaWx0ZXJlZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNTZXQobW9kZWxWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNsb25lZCA9IG5ldyBTZXQobW9kZWxWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsb25lZC5hZGQoZWxlbWVudFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsb25lZC5kZWxldGUoZWxlbWVudFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFzc2lnbihjbG9uZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYXNzaWduKGdldENoZWNrYm94VmFsdWUoZWwsIGNoZWNrZWQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIC8vIHNldCBpbml0aWFsIGNoZWNrZWQgb24gbW91bnQgdG8gd2FpdCBmb3IgdHJ1ZS12YWx1ZS9mYWxzZS12YWx1ZVxyXG4gICAgbW91bnRlZDogc2V0Q2hlY2tlZCxcclxuICAgIGJlZm9yZVVwZGF0ZShlbCwgYmluZGluZywgdm5vZGUpIHtcclxuICAgICAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XHJcbiAgICAgICAgc2V0Q2hlY2tlZChlbCwgYmluZGluZywgdm5vZGUpO1xyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiBzZXRDaGVja2VkKGVsLCB7IHZhbHVlLCBvbGRWYWx1ZSB9LCB2bm9kZSkge1xyXG4gICAgZWwuX21vZGVsVmFsdWUgPSB2YWx1ZTtcclxuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIGVsLmNoZWNrZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKSA+IC0xO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNTZXQodmFsdWUpKSB7XHJcbiAgICAgICAgZWwuY2hlY2tlZCA9IHZhbHVlLmhhcyh2bm9kZS5wcm9wcy52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2YWx1ZSAhPT0gb2xkVmFsdWUpIHtcclxuICAgICAgICBlbC5jaGVja2VkID0gbG9vc2VFcXVhbCh2YWx1ZSwgZ2V0Q2hlY2tib3hWYWx1ZShlbCwgdHJ1ZSkpO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IHZNb2RlbFJhZGlvID0ge1xyXG4gICAgY3JlYXRlZChlbCwgeyB2YWx1ZSB9LCB2bm9kZSkge1xyXG4gICAgICAgIGVsLmNoZWNrZWQgPSBsb29zZUVxdWFsKHZhbHVlLCB2bm9kZS5wcm9wcy52YWx1ZSk7XHJcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xyXG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsICdjaGFuZ2UnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGVsLl9hc3NpZ24oZ2V0VmFsdWUoZWwpKTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBiZWZvcmVVcGRhdGUoZWwsIHsgdmFsdWUsIG9sZFZhbHVlIH0sIHZub2RlKSB7XHJcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gb2xkVmFsdWUpIHtcclxuICAgICAgICAgICAgZWwuY2hlY2tlZCA9IGxvb3NlRXF1YWwodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IHZNb2RlbFNlbGVjdCA9IHtcclxuICAgIGNyZWF0ZWQoZWwsIHsgdmFsdWUsIG1vZGlmaWVyczogeyBudW1iZXIgfSB9LCB2bm9kZSkge1xyXG4gICAgICAgIGNvbnN0IGlzU2V0TW9kZWwgPSBpc1NldCh2YWx1ZSk7XHJcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ2NoYW5nZScsICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRWYWwgPSBBcnJheS5wcm90b3R5cGUuZmlsdGVyXHJcbiAgICAgICAgICAgICAgICAuY2FsbChlbC5vcHRpb25zLCAobykgPT4gby5zZWxlY3RlZClcclxuICAgICAgICAgICAgICAgIC5tYXAoKG8pID0+IG51bWJlciA/IHRvTnVtYmVyKGdldFZhbHVlKG8pKSA6IGdldFZhbHVlKG8pKTtcclxuICAgICAgICAgICAgZWwuX2Fzc2lnbihlbC5tdWx0aXBsZVxyXG4gICAgICAgICAgICAgICAgPyBpc1NldE1vZGVsXHJcbiAgICAgICAgICAgICAgICAgICAgPyBuZXcgU2V0KHNlbGVjdGVkVmFsKVxyXG4gICAgICAgICAgICAgICAgICAgIDogc2VsZWN0ZWRWYWxcclxuICAgICAgICAgICAgICAgIDogc2VsZWN0ZWRWYWxbMF0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcclxuICAgIH0sXHJcbiAgICAvLyBzZXQgdmFsdWUgaW4gbW91bnRlZCAmIHVwZGF0ZWQgYmVjYXVzZSA8c2VsZWN0PiByZWxpZXMgb24gaXRzIGNoaWxkcmVuXHJcbiAgICAvLyA8b3B0aW9uPnMuXHJcbiAgICBtb3VudGVkKGVsLCB7IHZhbHVlIH0pIHtcclxuICAgICAgICBzZXRTZWxlY3RlZChlbCwgdmFsdWUpO1xyXG4gICAgfSxcclxuICAgIGJlZm9yZVVwZGF0ZShlbCwgX2JpbmRpbmcsIHZub2RlKSB7XHJcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xyXG4gICAgfSxcclxuICAgIHVwZGF0ZWQoZWwsIHsgdmFsdWUgfSkge1xyXG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCB2YWx1ZSk7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIHNldFNlbGVjdGVkKGVsLCB2YWx1ZSkge1xyXG4gICAgY29uc3QgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xyXG4gICAgaWYgKGlzTXVsdGlwbGUgJiYgIWlzQXJyYXkodmFsdWUpICYmICFpc1NldCh2YWx1ZSkpIHtcclxuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgd2FybihgPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPiBleHBlY3RzIGFuIEFycmF5IG9yIFNldCB2YWx1ZSBmb3IgaXRzIGJpbmRpbmcsIGAgK1xyXG4gICAgICAgICAgICAgICAgYGJ1dCBnb3QgJHtPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKX0uYCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XHJcbiAgICAgICAgY29uc3Qgb3B0aW9uVmFsdWUgPSBnZXRWYWx1ZShvcHRpb24pO1xyXG4gICAgICAgIGlmIChpc011bHRpcGxlKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBvcHRpb25WYWx1ZSkgPiAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHZhbHVlLmhhcyhvcHRpb25WYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpXHJcbiAgICAgICAgICAgICAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzTXVsdGlwbGUgJiYgZWwuc2VsZWN0ZWRJbmRleCAhPT0gLTEpIHtcclxuICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XHJcbiAgICB9XHJcbn1cclxuLy8gcmV0cmlldmUgcmF3IHZhbHVlIHNldCB2aWEgOnZhbHVlIGJpbmRpbmdzXHJcbmZ1bmN0aW9uIGdldFZhbHVlKGVsKSB7XHJcbiAgICByZXR1cm4gJ192YWx1ZScgaW4gZWwgPyBlbC5fdmFsdWUgOiBlbC52YWx1ZTtcclxufVxyXG4vLyByZXRyaWV2ZSByYXcgdmFsdWUgZm9yIHRydWUtdmFsdWUgYW5kIGZhbHNlLXZhbHVlIHNldCB2aWEgOnRydWUtdmFsdWUgb3IgOmZhbHNlLXZhbHVlIGJpbmRpbmdzXHJcbmZ1bmN0aW9uIGdldENoZWNrYm94VmFsdWUoZWwsIGNoZWNrZWQpIHtcclxuICAgIGNvbnN0IGtleSA9IGNoZWNrZWQgPyAnX3RydWVWYWx1ZScgOiAnX2ZhbHNlVmFsdWUnO1xyXG4gICAgcmV0dXJuIGtleSBpbiBlbCA/IGVsW2tleV0gOiBjaGVja2VkO1xyXG59XHJcbmNvbnN0IHZNb2RlbER5bmFtaWMgPSB7XHJcbiAgICBjcmVhdGVkKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xyXG4gICAgICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBudWxsLCAnY3JlYXRlZCcpO1xyXG4gICAgfSxcclxuICAgIG1vdW50ZWQoZWwsIGJpbmRpbmcsIHZub2RlKSB7XHJcbiAgICAgICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIG51bGwsICdtb3VudGVkJyk7XHJcbiAgICB9LFxyXG4gICAgYmVmb3JlVXBkYXRlKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlKSB7XHJcbiAgICAgICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSwgJ2JlZm9yZVVwZGF0ZScpO1xyXG4gICAgfSxcclxuICAgIHVwZGF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUpIHtcclxuICAgICAgICBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlLCAndXBkYXRlZCcpO1xyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlLCBob29rKSB7XHJcbiAgICBsZXQgbW9kZWxUb1VzZTtcclxuICAgIHN3aXRjaCAoZWwudGFnTmFtZSkge1xyXG4gICAgICAgIGNhc2UgJ1NFTEVDVCc6XHJcbiAgICAgICAgICAgIG1vZGVsVG9Vc2UgPSB2TW9kZWxTZWxlY3Q7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ1RFWFRBUkVBJzpcclxuICAgICAgICAgICAgbW9kZWxUb1VzZSA9IHZNb2RlbFRleHQ7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHN3aXRjaCAodm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnY2hlY2tib3gnOlxyXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsVG9Vc2UgPSB2TW9kZWxDaGVja2JveDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3JhZGlvJzpcclxuICAgICAgICAgICAgICAgICAgICBtb2RlbFRvVXNlID0gdk1vZGVsUmFkaW87XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsVG9Vc2UgPSB2TW9kZWxUZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBmbiA9IG1vZGVsVG9Vc2VbaG9va107XHJcbiAgICBmbiAmJiBmbihlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSk7XHJcbn1cblxuY29uc3Qgc3lzdGVtTW9kaWZpZXJzID0gWydjdHJsJywgJ3NoaWZ0JywgJ2FsdCcsICdtZXRhJ107XHJcbmNvbnN0IG1vZGlmaWVyR3VhcmRzID0ge1xyXG4gICAgc3RvcDogZSA9PiBlLnN0b3BQcm9wYWdhdGlvbigpLFxyXG4gICAgcHJldmVudDogZSA9PiBlLnByZXZlbnREZWZhdWx0KCksXHJcbiAgICBzZWxmOiBlID0+IGUudGFyZ2V0ICE9PSBlLmN1cnJlbnRUYXJnZXQsXHJcbiAgICBjdHJsOiBlID0+ICFlLmN0cmxLZXksXHJcbiAgICBzaGlmdDogZSA9PiAhZS5zaGlmdEtleSxcclxuICAgIGFsdDogZSA9PiAhZS5hbHRLZXksXHJcbiAgICBtZXRhOiBlID0+ICFlLm1ldGFLZXksXHJcbiAgICBsZWZ0OiBlID0+ICdidXR0b24nIGluIGUgJiYgZS5idXR0b24gIT09IDAsXHJcbiAgICBtaWRkbGU6IGUgPT4gJ2J1dHRvbicgaW4gZSAmJiBlLmJ1dHRvbiAhPT0gMSxcclxuICAgIHJpZ2h0OiBlID0+ICdidXR0b24nIGluIGUgJiYgZS5idXR0b24gIT09IDIsXHJcbiAgICBleGFjdDogKGUsIG1vZGlmaWVycykgPT4gc3lzdGVtTW9kaWZpZXJzLnNvbWUobSA9PiBlW2Ake219S2V5YF0gJiYgIW1vZGlmaWVycy5pbmNsdWRlcyhtKSlcclxufTtcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCB3aXRoTW9kaWZpZXJzID0gKGZuLCBtb2RpZmllcnMpID0+IHtcclxuICAgIHJldHVybiAoZXZlbnQsIC4uLmFyZ3MpID0+IHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZGlmaWVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBndWFyZCA9IG1vZGlmaWVyR3VhcmRzW21vZGlmaWVyc1tpXV07XHJcbiAgICAgICAgICAgIGlmIChndWFyZCAmJiBndWFyZChldmVudCwgbW9kaWZpZXJzKSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZuKGV2ZW50LCAuLi5hcmdzKTtcclxuICAgIH07XHJcbn07XHJcbi8vIEtlcHQgZm9yIDIueCBjb21wYXQuXHJcbi8vIE5vdGU6IElFMTEgY29tcGF0IGZvciBgc3BhY2ViYXJgIGFuZCBgZGVsYCBpcyByZW1vdmVkIGZvciBub3cuXHJcbmNvbnN0IGtleU5hbWVzID0ge1xyXG4gICAgZXNjOiAnZXNjYXBlJyxcclxuICAgIHNwYWNlOiAnICcsXHJcbiAgICB1cDogJ2Fycm93LXVwJyxcclxuICAgIGxlZnQ6ICdhcnJvdy1sZWZ0JyxcclxuICAgIHJpZ2h0OiAnYXJyb3ctcmlnaHQnLFxyXG4gICAgZG93bjogJ2Fycm93LWRvd24nLFxyXG4gICAgZGVsZXRlOiAnYmFja3NwYWNlJ1xyXG59O1xyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IHdpdGhLZXlzID0gKGZuLCBtb2RpZmllcnMpID0+IHtcclxuICAgIHJldHVybiAoZXZlbnQpID0+IHtcclxuICAgICAgICBpZiAoISgna2V5JyBpbiBldmVudCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBldmVudEtleSA9IGh5cGhlbmF0ZShldmVudC5rZXkpO1xyXG4gICAgICAgIGlmIChtb2RpZmllcnMuc29tZShrID0+IGsgPT09IGV2ZW50S2V5IHx8IGtleU5hbWVzW2tdID09PSBldmVudEtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZuKGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59O1xuXG5jb25zdCB2U2hvdyA9IHtcclxuICAgIGJlZm9yZU1vdW50KGVsLCB7IHZhbHVlIH0sIHsgdHJhbnNpdGlvbiB9KSB7XHJcbiAgICAgICAgZWwuX3ZvZCA9IGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICcnIDogZWwuc3R5bGUuZGlzcGxheTtcclxuICAgICAgICBpZiAodHJhbnNpdGlvbiAmJiB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNldERpc3BsYXkoZWwsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbW91bnRlZChlbCwgeyB2YWx1ZSB9LCB7IHRyYW5zaXRpb24gfSkge1xyXG4gICAgICAgIGlmICh0cmFuc2l0aW9uICYmIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICB1cGRhdGVkKGVsLCB7IHZhbHVlLCBvbGRWYWx1ZSB9LCB7IHRyYW5zaXRpb24gfSkge1xyXG4gICAgICAgIGlmICghdmFsdWUgPT09ICFvbGRWYWx1ZSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGlmICh0cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihlbCk7XHJcbiAgICAgICAgICAgICAgICBzZXREaXNwbGF5KGVsLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbi5sZWF2ZShlbCwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldERpc3BsYXkoZWwsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzZXREaXNwbGF5KGVsLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGJlZm9yZVVubW91bnQoZWwsIHsgdmFsdWUgfSkge1xyXG4gICAgICAgIHNldERpc3BsYXkoZWwsIHZhbHVlKTtcclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gc2V0RGlzcGxheShlbCwgdmFsdWUpIHtcclxuICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl92b2QgOiAnbm9uZSc7XHJcbn1cblxuY29uc3QgcmVuZGVyZXJPcHRpb25zID0gZXh0ZW5kKHsgcGF0Y2hQcm9wLCBmb3JjZVBhdGNoUHJvcCB9LCBub2RlT3BzKTtcclxuLy8gbGF6eSBjcmVhdGUgdGhlIHJlbmRlcmVyIC0gdGhpcyBtYWtlcyBjb3JlIHJlbmRlcmVyIGxvZ2ljIHRyZWUtc2hha2FibGVcclxuLy8gaW4gY2FzZSB0aGUgdXNlciBvbmx5IGltcG9ydHMgcmVhY3Rpdml0eSB1dGlsaXRpZXMgZnJvbSBWdWUuXHJcbmxldCByZW5kZXJlcjtcclxubGV0IGVuYWJsZWRIeWRyYXRpb24gPSBmYWxzZTtcclxuZnVuY3Rpb24gZW5zdXJlUmVuZGVyZXIoKSB7XHJcbiAgICByZXR1cm4gcmVuZGVyZXIgfHwgKHJlbmRlcmVyID0gY3JlYXRlUmVuZGVyZXIocmVuZGVyZXJPcHRpb25zKSk7XHJcbn1cclxuZnVuY3Rpb24gZW5zdXJlSHlkcmF0aW9uUmVuZGVyZXIoKSB7XHJcbiAgICByZW5kZXJlciA9IGVuYWJsZWRIeWRyYXRpb25cclxuICAgICAgICA/IHJlbmRlcmVyXHJcbiAgICAgICAgOiBjcmVhdGVIeWRyYXRpb25SZW5kZXJlcihyZW5kZXJlck9wdGlvbnMpO1xyXG4gICAgZW5hYmxlZEh5ZHJhdGlvbiA9IHRydWU7XHJcbiAgICByZXR1cm4gcmVuZGVyZXI7XHJcbn1cclxuLy8gdXNlIGV4cGxpY2l0IHR5cGUgY2FzdHMgaGVyZSB0byBhdm9pZCBpbXBvcnQoKSBjYWxscyBpbiByb2xsZWQtdXAgZC50c1xyXG5jb25zdCByZW5kZXIgPSAoKC4uLmFyZ3MpID0+IHtcclxuICAgIGVuc3VyZVJlbmRlcmVyKCkucmVuZGVyKC4uLmFyZ3MpO1xyXG59KTtcclxuY29uc3QgaHlkcmF0ZSA9ICgoLi4uYXJncykgPT4ge1xyXG4gICAgZW5zdXJlSHlkcmF0aW9uUmVuZGVyZXIoKS5oeWRyYXRlKC4uLmFyZ3MpO1xyXG59KTtcclxuY29uc3QgY3JlYXRlQXBwID0gKCguLi5hcmdzKSA9PiB7XHJcbiAgICBjb25zdCBhcHAgPSBlbnN1cmVSZW5kZXJlcigpLmNyZWF0ZUFwcCguLi5hcmdzKTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBpbmplY3ROYXRpdmVUYWdDaGVjayhhcHApO1xyXG4gICAgICAgIGluamVjdENvbXBpbGVyT3B0aW9uc0NoZWNrKGFwcCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IG1vdW50IH0gPSBhcHA7XHJcbiAgICBhcHAubW91bnQgPSAoY29udGFpbmVyT3JTZWxlY3RvcikgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IG5vcm1hbGl6ZUNvbnRhaW5lcihjb250YWluZXJPclNlbGVjdG9yKTtcclxuICAgICAgICBpZiAoIWNvbnRhaW5lcilcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGFwcC5fY29tcG9uZW50O1xyXG4gICAgICAgIGlmICghaXNGdW5jdGlvbihjb21wb25lbnQpICYmICFjb21wb25lbnQucmVuZGVyICYmICFjb21wb25lbnQudGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgLy8gX19VTlNBRkVfX1xyXG4gICAgICAgICAgICAvLyBSZWFzb246IHBvdGVudGlhbCBleGVjdXRpb24gb2YgSlMgZXhwcmVzc2lvbnMgaW4gaW4tRE9NIHRlbXBsYXRlLlxyXG4gICAgICAgICAgICAvLyBUaGUgdXNlciBtdXN0IG1ha2Ugc3VyZSB0aGUgaW4tRE9NIHRlbXBsYXRlIGlzIHRydXN0ZWQuIElmIGl0J3NcclxuICAgICAgICAgICAgLy8gcmVuZGVyZWQgYnkgdGhlIHNlcnZlciwgdGhlIHRlbXBsYXRlIHNob3VsZCBub3QgY29udGFpbiBhbnkgdXNlciBkYXRhLlxyXG4gICAgICAgICAgICBjb21wb25lbnQudGVtcGxhdGUgPSBjb250YWluZXIuaW5uZXJIVE1MO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjbGVhciBjb250ZW50IGJlZm9yZSBtb3VudGluZ1xyXG4gICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcclxuICAgICAgICBjb25zdCBwcm94eSA9IG1vdW50KGNvbnRhaW5lciwgZmFsc2UsIGNvbnRhaW5lciBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpO1xyXG4gICAgICAgIGlmIChjb250YWluZXIgaW5zdGFuY2VvZiBFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5yZW1vdmVBdHRyaWJ1dGUoJ3YtY2xvYWsnKTtcclxuICAgICAgICAgICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnZGF0YS12LWFwcCcsICcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByb3h5O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBhcHA7XHJcbn0pO1xyXG5jb25zdCBjcmVhdGVTU1JBcHAgPSAoKC4uLmFyZ3MpID0+IHtcclxuICAgIGNvbnN0IGFwcCA9IGVuc3VyZUh5ZHJhdGlvblJlbmRlcmVyKCkuY3JlYXRlQXBwKC4uLmFyZ3MpO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGluamVjdE5hdGl2ZVRhZ0NoZWNrKGFwcCk7XHJcbiAgICAgICAgaW5qZWN0Q29tcGlsZXJPcHRpb25zQ2hlY2soYXBwKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgbW91bnQgfSA9IGFwcDtcclxuICAgIGFwcC5tb3VudCA9IChjb250YWluZXJPclNlbGVjdG9yKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gbm9ybWFsaXplQ29udGFpbmVyKGNvbnRhaW5lck9yU2VsZWN0b3IpO1xyXG4gICAgICAgIGlmIChjb250YWluZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1vdW50KGNvbnRhaW5lciwgdHJ1ZSwgY29udGFpbmVyIGluc3RhbmNlb2YgU1ZHRWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBhcHA7XHJcbn0pO1xyXG5mdW5jdGlvbiBpbmplY3ROYXRpdmVUYWdDaGVjayhhcHApIHtcclxuICAgIC8vIEluamVjdCBgaXNOYXRpdmVUYWdgXHJcbiAgICAvLyB0aGlzIGlzIHVzZWQgZm9yIGNvbXBvbmVudCBuYW1lIHZhbGlkYXRpb24gKGRldiBvbmx5KVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwcC5jb25maWcsICdpc05hdGl2ZVRhZycsIHtcclxuICAgICAgICB2YWx1ZTogKHRhZykgPT4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkdUYWcodGFnKSxcclxuICAgICAgICB3cml0YWJsZTogZmFsc2VcclxuICAgIH0pO1xyXG59XHJcbi8vIGRldiBvbmx5XHJcbmZ1bmN0aW9uIGluamVjdENvbXBpbGVyT3B0aW9uc0NoZWNrKGFwcCkge1xyXG4gICAgaWYgKGlzUnVudGltZU9ubHkoKSkge1xyXG4gICAgICAgIGNvbnN0IGlzQ3VzdG9tRWxlbWVudCA9IGFwcC5jb25maWcuaXNDdXN0b21FbGVtZW50O1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcHAuY29uZmlnLCAnaXNDdXN0b21FbGVtZW50Jywge1xyXG4gICAgICAgICAgICBnZXQoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNDdXN0b21FbGVtZW50O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQoKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGBUaGUgXFxgaXNDdXN0b21FbGVtZW50XFxgIGNvbmZpZyBvcHRpb24gaXMgZGVwcmVjYXRlZC4gVXNlIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBcXGBjb21waWxlck9wdGlvbnMuaXNDdXN0b21FbGVtZW50XFxgIGluc3RlYWQuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBjb21waWxlck9wdGlvbnMgPSBhcHAuY29uZmlnLmNvbXBpbGVyT3B0aW9ucztcclxuICAgICAgICBjb25zdCBtc2cgPSBgVGhlIFxcYGNvbXBpbGVyT3B0aW9uc1xcYCBjb25maWcgb3B0aW9uIGlzIG9ubHkgcmVzcGVjdGVkIHdoZW4gdXNpbmcgYCArXHJcbiAgICAgICAgICAgIGBhIGJ1aWxkIG9mIFZ1ZS5qcyB0aGF0IGluY2x1ZGVzIHRoZSBydW50aW1lIGNvbXBpbGVyIChha2EgXCJmdWxsIGJ1aWxkXCIpLiBgICtcclxuICAgICAgICAgICAgYFNpbmNlIHlvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCwgXFxgY29tcGlsZXJPcHRpb25zXFxgIGAgK1xyXG4gICAgICAgICAgICBgbXVzdCBiZSBwYXNzZWQgdG8gXFxgQHZ1ZS9jb21waWxlci1kb21cXGAgaW4gdGhlIGJ1aWxkIHNldHVwIGluc3RlYWQuXFxuYCArXHJcbiAgICAgICAgICAgIGAtIEZvciB2dWUtbG9hZGVyOiBwYXNzIGl0IHZpYSB2dWUtbG9hZGVyJ3MgXFxgY29tcGlsZXJPcHRpb25zXFxgIGxvYWRlciBvcHRpb24uXFxuYCArXHJcbiAgICAgICAgICAgIGAtIEZvciB2dWUtY2xpOiBzZWUgaHR0cHM6Ly9jbGkudnVlanMub3JnL2d1aWRlL3dlYnBhY2suaHRtbCNtb2RpZnlpbmctb3B0aW9ucy1vZi1hLWxvYWRlclxcbmAgK1xyXG4gICAgICAgICAgICBgLSBGb3Igdml0ZTogcGFzcyBpdCB2aWEgQHZpdGVqcy9wbHVnaW4tdnVlIG9wdGlvbnMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdml0ZWpzL3ZpdGUvdHJlZS9tYWluL3BhY2thZ2VzL3BsdWdpbi12dWUjZXhhbXBsZS1mb3ItcGFzc2luZy1vcHRpb25zLXRvLXZ1ZWNvbXBpbGVyLWRvbWA7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwcC5jb25maWcsICdjb21waWxlck9wdGlvbnMnLCB7XHJcbiAgICAgICAgICAgIGdldCgpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4obXNnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21waWxlck9wdGlvbnM7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldCgpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4obXNnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbnRhaW5lcihjb250YWluZXIpIHtcclxuICAgIGlmIChpc1N0cmluZyhjb250YWluZXIpKSB7XHJcbiAgICAgICAgY29uc3QgcmVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihjb250YWluZXIpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIXJlcykge1xyXG4gICAgICAgICAgICB3YXJuKGBGYWlsZWQgdG8gbW91bnQgYXBwOiBtb3VudCB0YXJnZXQgc2VsZWN0b3IgXCIke2NvbnRhaW5lcn1cIiByZXR1cm5lZCBudWxsLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgIGNvbnRhaW5lciBpbnN0YW5jZW9mIHdpbmRvdy5TaGFkb3dSb290ICYmXHJcbiAgICAgICAgY29udGFpbmVyLm1vZGUgPT09ICdjbG9zZWQnKSB7XHJcbiAgICAgICAgd2FybihgbW91bnRpbmcgb24gYSBTaGFkb3dSb290IHdpdGggXFxge21vZGU6IFwiY2xvc2VkXCJ9XFxgIG1heSBsZWFkIHRvIHVucHJlZGljdGFibGUgYnVnc2ApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcclxufVxuXG5leHBvcnQgeyBUcmFuc2l0aW9uLCBUcmFuc2l0aW9uR3JvdXAsIGNyZWF0ZUFwcCwgY3JlYXRlU1NSQXBwLCBoeWRyYXRlLCByZW5kZXIsIHVzZUNzc01vZHVsZSwgdXNlQ3NzVmFycywgdk1vZGVsQ2hlY2tib3gsIHZNb2RlbER5bmFtaWMsIHZNb2RlbFJhZGlvLCB2TW9kZWxTZWxlY3QsIHZNb2RlbFRleHQsIHZTaG93LCB3aXRoS2V5cywgd2l0aE1vZGlmaWVycyB9O1xuIiwiLyoqXHJcbiAqIE1ha2UgYSBtYXAgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIGtleVxyXG4gKiBpcyBpbiB0aGF0IG1hcC5cclxuICogSU1QT1JUQU5UOiBhbGwgY2FsbHMgb2YgdGhpcyBmdW5jdGlvbiBtdXN0IGJlIHByZWZpeGVkIHdpdGhcclxuICogXFwvXFwqI1xcX1xcX1BVUkVcXF9cXF9cXCpcXC9cclxuICogU28gdGhhdCByb2xsdXAgY2FuIHRyZWUtc2hha2UgdGhlbSBpZiBuZWNlc3NhcnkuXHJcbiAqL1xyXG5mdW5jdGlvbiBtYWtlTWFwKHN0ciwgZXhwZWN0c0xvd2VyQ2FzZSkge1xyXG4gICAgY29uc3QgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIGNvbnN0IGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZSA/IHZhbCA9PiAhIW1hcFt2YWwudG9Mb3dlckNhc2UoKV0gOiB2YWwgPT4gISFtYXBbdmFsXTtcclxufVxuXG4vKipcclxuICogZGV2IG9ubHkgZmxhZyAtPiBuYW1lIG1hcHBpbmdcclxuICovXHJcbmNvbnN0IFBhdGNoRmxhZ05hbWVzID0ge1xyXG4gICAgWzEgLyogVEVYVCAqL106IGBURVhUYCxcclxuICAgIFsyIC8qIENMQVNTICovXTogYENMQVNTYCxcclxuICAgIFs0IC8qIFNUWUxFICovXTogYFNUWUxFYCxcclxuICAgIFs4IC8qIFBST1BTICovXTogYFBST1BTYCxcclxuICAgIFsxNiAvKiBGVUxMX1BST1BTICovXTogYEZVTExfUFJPUFNgLFxyXG4gICAgWzMyIC8qIEhZRFJBVEVfRVZFTlRTICovXTogYEhZRFJBVEVfRVZFTlRTYCxcclxuICAgIFs2NCAvKiBTVEFCTEVfRlJBR01FTlQgKi9dOiBgU1RBQkxFX0ZSQUdNRU5UYCxcclxuICAgIFsxMjggLyogS0VZRURfRlJBR01FTlQgKi9dOiBgS0VZRURfRlJBR01FTlRgLFxyXG4gICAgWzI1NiAvKiBVTktFWUVEX0ZSQUdNRU5UICovXTogYFVOS0VZRURfRlJBR01FTlRgLFxyXG4gICAgWzUxMiAvKiBORUVEX1BBVENIICovXTogYE5FRURfUEFUQ0hgLFxyXG4gICAgWzEwMjQgLyogRFlOQU1JQ19TTE9UUyAqL106IGBEWU5BTUlDX1NMT1RTYCxcclxuICAgIFsyMDQ4IC8qIERFVl9ST09UX0ZSQUdNRU5UICovXTogYERFVl9ST09UX0ZSQUdNRU5UYCxcclxuICAgIFstMSAvKiBIT0lTVEVEICovXTogYEhPSVNURURgLFxyXG4gICAgWy0yIC8qIEJBSUwgKi9dOiBgQkFJTGBcclxufTtcblxuLyoqXHJcbiAqIERldiBvbmx5XHJcbiAqL1xyXG5jb25zdCBzbG90RmxhZ3NUZXh0ID0ge1xyXG4gICAgWzEgLyogU1RBQkxFICovXTogJ1NUQUJMRScsXHJcbiAgICBbMiAvKiBEWU5BTUlDICovXTogJ0RZTkFNSUMnLFxyXG4gICAgWzMgLyogRk9SV0FSREVEICovXTogJ0ZPUldBUkRFRCdcclxufTtcblxuY29uc3QgR0xPQkFMU19XSElURV9MSVNURUQgPSAnSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTixwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSwnICtcclxuICAgICdkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCxNYXRoLE51bWJlcixEYXRlLEFycmF5LCcgK1xyXG4gICAgJ09iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsQmlnSW50JztcclxuY29uc3QgaXNHbG9iYWxseVdoaXRlbGlzdGVkID0gLyojX19QVVJFX18qLyBtYWtlTWFwKEdMT0JBTFNfV0hJVEVfTElTVEVEKTtcblxuY29uc3QgcmFuZ2UgPSAyO1xyXG5mdW5jdGlvbiBnZW5lcmF0ZUNvZGVGcmFtZShzb3VyY2UsIHN0YXJ0ID0gMCwgZW5kID0gc291cmNlLmxlbmd0aCkge1xyXG4gICAgY29uc3QgbGluZXMgPSBzb3VyY2Uuc3BsaXQoL1xccj9cXG4vKTtcclxuICAgIGxldCBjb3VudCA9IDA7XHJcbiAgICBjb25zdCByZXMgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb3VudCArPSBsaW5lc1tpXS5sZW5ndGggKyAxO1xyXG4gICAgICAgIGlmIChjb3VudCA+PSBzdGFydCkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaSAtIHJhbmdlOyBqIDw9IGkgKyByYW5nZSB8fCBlbmQgPiBjb3VudDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaiA8IDAgfHwgaiA+PSBsaW5lcy5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lID0gaiArIDE7XHJcbiAgICAgICAgICAgICAgICByZXMucHVzaChgJHtsaW5lfSR7JyAnLnJlcGVhdChNYXRoLm1heCgzIC0gU3RyaW5nKGxpbmUpLmxlbmd0aCwgMCkpfXwgICR7bGluZXNbal19YCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lTGVuZ3RoID0gbGluZXNbal0ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgaWYgKGogPT09IGkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBwdXNoIHVuZGVybGluZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhZCA9IHN0YXJ0IC0gKGNvdW50IC0gbGluZUxlbmd0aCkgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KDEsIGVuZCA+IGNvdW50ID8gbGluZUxlbmd0aCAtIHBhZCA6IGVuZCAtIHN0YXJ0KTtcclxuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChgICAgfCAgYCArICcgJy5yZXBlYXQocGFkKSArICdeJy5yZXBlYXQobGVuZ3RoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChqID4gaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmQgPiBjb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heChNYXRoLm1pbihlbmQgLSBjb3VudCwgbGluZUxlbmd0aCksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMucHVzaChgICAgfCAgYCArICdeJy5yZXBlYXQobGVuZ3RoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ICs9IGxpbmVMZW5ndGggKyAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXMuam9pbignXFxuJyk7XHJcbn1cblxuLyoqXHJcbiAqIE9uIHRoZSBjbGllbnQgd2Ugb25seSBuZWVkIHRvIG9mZmVyIHNwZWNpYWwgY2FzZXMgZm9yIGJvb2xlYW4gYXR0cmlidXRlcyB0aGF0XHJcbiAqIGhhdmUgZGlmZmVyZW50IG5hbWVzIGZyb20gdGhlaXIgY29ycmVzcG9uZGluZyBkb20gcHJvcGVydGllczpcclxuICogLSBpdGVtc2NvcGUgLT4gTi9BXHJcbiAqIC0gYWxsb3dmdWxsc2NyZWVuIC0+IGFsbG93RnVsbHNjcmVlblxyXG4gKiAtIGZvcm1ub3ZhbGlkYXRlIC0+IGZvcm1Ob1ZhbGlkYXRlXHJcbiAqIC0gaXNtYXAgLT4gaXNNYXBcclxuICogLSBub21vZHVsZSAtPiBub01vZHVsZVxyXG4gKiAtIG5vdmFsaWRhdGUgLT4gbm9WYWxpZGF0ZVxyXG4gKiAtIHJlYWRvbmx5IC0+IHJlYWRPbmx5XHJcbiAqL1xyXG5jb25zdCBzcGVjaWFsQm9vbGVhbkF0dHJzID0gYGl0ZW1zY29wZSxhbGxvd2Z1bGxzY3JlZW4sZm9ybW5vdmFsaWRhdGUsaXNtYXAsbm9tb2R1bGUsbm92YWxpZGF0ZSxyZWFkb25seWA7XHJcbmNvbnN0IGlzU3BlY2lhbEJvb2xlYW5BdHRyID0gLyojX19QVVJFX18qLyBtYWtlTWFwKHNwZWNpYWxCb29sZWFuQXR0cnMpO1xyXG4vKipcclxuICogVGhlIGZ1bGwgbGlzdCBpcyBuZWVkZWQgZHVyaW5nIFNTUiB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IGluaXRpYWwgbWFya3VwLlxyXG4gKi9cclxuY29uc3QgaXNCb29sZWFuQXR0ciA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChzcGVjaWFsQm9vbGVhbkF0dHJzICtcclxuICAgIGAsYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNvbnRyb2xzLGRlZmF1bHQsZGVmZXIsZGlzYWJsZWQsaGlkZGVuLGAgK1xyXG4gICAgYGxvb3Asb3BlbixyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3MsYCArXHJcbiAgICBgY2hlY2tlZCxtdXRlZCxtdWx0aXBsZSxzZWxlY3RlZGApO1xyXG5jb25zdCB1bnNhZmVBdHRyQ2hhclJFID0gL1s+Lz1cIidcXHUwMDA5XFx1MDAwYVxcdTAwMGNcXHUwMDIwXS87XHJcbmNvbnN0IGF0dHJWYWxpZGF0aW9uQ2FjaGUgPSB7fTtcclxuZnVuY3Rpb24gaXNTU1JTYWZlQXR0ck5hbWUobmFtZSkge1xyXG4gICAgaWYgKGF0dHJWYWxpZGF0aW9uQ2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcclxuICAgICAgICByZXR1cm4gYXR0clZhbGlkYXRpb25DYWNoZVtuYW1lXTtcclxuICAgIH1cclxuICAgIGNvbnN0IGlzVW5zYWZlID0gdW5zYWZlQXR0ckNoYXJSRS50ZXN0KG5hbWUpO1xyXG4gICAgaWYgKGlzVW5zYWZlKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgdW5zYWZlIGF0dHJpYnV0ZSBuYW1lOiAke25hbWV9YCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKGF0dHJWYWxpZGF0aW9uQ2FjaGVbbmFtZV0gPSAhaXNVbnNhZmUpO1xyXG59XHJcbmNvbnN0IHByb3BzVG9BdHRyTWFwID0ge1xyXG4gICAgYWNjZXB0Q2hhcnNldDogJ2FjY2VwdC1jaGFyc2V0JyxcclxuICAgIGNsYXNzTmFtZTogJ2NsYXNzJyxcclxuICAgIGh0bWxGb3I6ICdmb3InLFxyXG4gICAgaHR0cEVxdWl2OiAnaHR0cC1lcXVpdidcclxufTtcclxuLyoqXHJcbiAqIENTUyBwcm9wZXJ0aWVzIHRoYXQgYWNjZXB0IHBsYWluIG51bWJlcnNcclxuICovXHJcbmNvbnN0IGlzTm9Vbml0TnVtZXJpY1N0eWxlUHJvcCA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChgYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudCxib3JkZXItaW1hZ2Utb3V0c2V0LGJvcmRlci1pbWFnZS1zbGljZSxgICtcclxuICAgIGBib3JkZXItaW1hZ2Utd2lkdGgsYm94LWZsZXgsYm94LWZsZXgtZ3JvdXAsYm94LW9yZGluYWwtZ3JvdXAsY29sdW1uLWNvdW50LGAgK1xyXG4gICAgYGNvbHVtbnMsZmxleCxmbGV4LWdyb3csZmxleC1wb3NpdGl2ZSxmbGV4LXNocmluayxmbGV4LW5lZ2F0aXZlLGZsZXgtb3JkZXIsYCArXHJcbiAgICBgZ3JpZC1yb3csZ3JpZC1yb3ctZW5kLGdyaWQtcm93LXNwYW4sZ3JpZC1yb3ctc3RhcnQsZ3JpZC1jb2x1bW4sYCArXHJcbiAgICBgZ3JpZC1jb2x1bW4tZW5kLGdyaWQtY29sdW1uLXNwYW4sZ3JpZC1jb2x1bW4tc3RhcnQsZm9udC13ZWlnaHQsbGluZS1jbGFtcCxgICtcclxuICAgIGBsaW5lLWhlaWdodCxvcGFjaXR5LG9yZGVyLG9ycGhhbnMsdGFiLXNpemUsd2lkb3dzLHotaW5kZXgsem9vbSxgICtcclxuICAgIC8vIFNWR1xyXG4gICAgYGZpbGwtb3BhY2l0eSxmbG9vZC1vcGFjaXR5LHN0b3Atb3BhY2l0eSxzdHJva2UtZGFzaGFycmF5LHN0cm9rZS1kYXNob2Zmc2V0LGAgK1xyXG4gICAgYHN0cm9rZS1taXRlcmxpbWl0LHN0cm9rZS1vcGFjaXR5LHN0cm9rZS13aWR0aGApO1xyXG4vKipcclxuICogS25vd24gYXR0cmlidXRlcywgdGhpcyBpcyB1c2VkIGZvciBzdHJpbmdpZmljYXRpb24gb2YgcnVudGltZSBzdGF0aWMgbm9kZXNcclxuICogc28gdGhhdCB3ZSBkb24ndCBzdHJpbmdpZnkgYmluZGluZ3MgdGhhdCBjYW5ub3QgYmUgc2V0IGZyb20gSFRNTC5cclxuICogRG9uJ3QgYWxzbyBmb3JnZXQgdG8gYWxsb3cgYGRhdGEtKmAgYW5kIGBhcmlhLSpgIVxyXG4gKiBHZW5lcmF0ZWQgZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0F0dHJpYnV0ZXNcclxuICovXHJcbmNvbnN0IGlzS25vd25BdHRyID0gLyojX19QVVJFX18qLyBtYWtlTWFwKGBhY2NlcHQsYWNjZXB0LWNoYXJzZXQsYWNjZXNza2V5LGFjdGlvbixhbGlnbixhbGxvdyxhbHQsYXN5bmMsYCArXHJcbiAgICBgYXV0b2NhcGl0YWxpemUsYXV0b2NvbXBsZXRlLGF1dG9mb2N1cyxhdXRvcGxheSxiYWNrZ3JvdW5kLGJnY29sb3IsYCArXHJcbiAgICBgYm9yZGVyLGJ1ZmZlcmVkLGNhcHR1cmUsY2hhbGxlbmdlLGNoYXJzZXQsY2hlY2tlZCxjaXRlLGNsYXNzLGNvZGUsYCArXHJcbiAgICBgY29kZWJhc2UsY29sb3IsY29scyxjb2xzcGFuLGNvbnRlbnQsY29udGVudGVkaXRhYmxlLGNvbnRleHRtZW51LGNvbnRyb2xzLGAgK1xyXG4gICAgYGNvb3Jkcyxjcm9zc29yaWdpbixjc3AsZGF0YSxkYXRldGltZSxkZWNvZGluZyxkZWZhdWx0LGRlZmVyLGRpcixkaXJuYW1lLGAgK1xyXG4gICAgYGRpc2FibGVkLGRvd25sb2FkLGRyYWdnYWJsZSxkcm9wem9uZSxlbmN0eXBlLGVudGVya2V5aGludCxmb3IsZm9ybSxgICtcclxuICAgIGBmb3JtYWN0aW9uLGZvcm1lbmN0eXBlLGZvcm1tZXRob2QsZm9ybW5vdmFsaWRhdGUsZm9ybXRhcmdldCxoZWFkZXJzLGAgK1xyXG4gICAgYGhlaWdodCxoaWRkZW4saGlnaCxocmVmLGhyZWZsYW5nLGh0dHAtZXF1aXYsaWNvbixpZCxpbXBvcnRhbmNlLGludGVncml0eSxgICtcclxuICAgIGBpc21hcCxpdGVtcHJvcCxrZXl0eXBlLGtpbmQsbGFiZWwsbGFuZyxsYW5ndWFnZSxsb2FkaW5nLGxpc3QsbG9vcCxsb3csYCArXHJcbiAgICBgbWFuaWZlc3QsbWF4LG1heGxlbmd0aCxtaW5sZW5ndGgsbWVkaWEsbWluLG11bHRpcGxlLG11dGVkLG5hbWUsbm92YWxpZGF0ZSxgICtcclxuICAgIGBvcGVuLG9wdGltdW0scGF0dGVybixwaW5nLHBsYWNlaG9sZGVyLHBvc3RlcixwcmVsb2FkLHJhZGlvZ3JvdXAscmVhZG9ubHksYCArXHJcbiAgICBgcmVmZXJyZXJwb2xpY3kscmVsLHJlcXVpcmVkLHJldmVyc2VkLHJvd3Mscm93c3BhbixzYW5kYm94LHNjb3BlLHNjb3BlZCxgICtcclxuICAgIGBzZWxlY3RlZCxzaGFwZSxzaXplLHNpemVzLHNsb3Qsc3BhbixzcGVsbGNoZWNrLHNyYyxzcmNkb2Msc3JjbGFuZyxzcmNzZXQsYCArXHJcbiAgICBgc3RhcnQsc3RlcCxzdHlsZSxzdW1tYXJ5LHRhYmluZGV4LHRhcmdldCx0aXRsZSx0cmFuc2xhdGUsdHlwZSx1c2VtYXAsYCArXHJcbiAgICBgdmFsdWUsd2lkdGgsd3JhcGApO1xuXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZSh2YWx1ZSkge1xyXG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgY29uc3QgcmVzID0ge307XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdmFsdWVbaV07XHJcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVTdHlsZShpc1N0cmluZyhpdGVtKSA/IHBhcnNlU3RyaW5nU3R5bGUoaXRlbSkgOiBpdGVtKTtcclxuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5vcm1hbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNba2V5XSA9IG5vcm1hbGl6ZWRba2V5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGxpc3REZWxpbWl0ZXJSRSA9IC87KD8hW14oXSpcXCkpL2c7XHJcbmNvbnN0IHByb3BlcnR5RGVsaW1pdGVyUkUgPSAvOiguKykvO1xyXG5mdW5jdGlvbiBwYXJzZVN0cmluZ1N0eWxlKGNzc1RleHQpIHtcclxuICAgIGNvbnN0IHJldCA9IHt9O1xyXG4gICAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyUkUpLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgICAgaWYgKGl0ZW0pIHtcclxuICAgICAgICAgICAgY29uc3QgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlclJFKTtcclxuICAgICAgICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJldFt0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJldDtcclxufVxyXG5mdW5jdGlvbiBzdHJpbmdpZnlTdHlsZShzdHlsZXMpIHtcclxuICAgIGxldCByZXQgPSAnJztcclxuICAgIGlmICghc3R5bGVzKSB7XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3Qga2V5IGluIHN0eWxlcykge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gc3R5bGVzW2tleV07XHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGtleS5zdGFydHNXaXRoKGAtLWApID8ga2V5IDogaHlwaGVuYXRlKGtleSk7XHJcbiAgICAgICAgaWYgKGlzU3RyaW5nKHZhbHVlKSB8fFxyXG4gICAgICAgICAgICAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc05vVW5pdE51bWVyaWNTdHlsZVByb3Aobm9ybWFsaXplZEtleSkpKSB7XHJcbiAgICAgICAgICAgIC8vIG9ubHkgcmVuZGVyIHZhbGlkIHZhbHVlc1xyXG4gICAgICAgICAgICByZXQgKz0gYCR7bm9ybWFsaXplZEtleX06JHt2YWx1ZX07YDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUNsYXNzKHZhbHVlKSB7XHJcbiAgICBsZXQgcmVzID0gJyc7XHJcbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XHJcbiAgICAgICAgcmVzID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZUNsYXNzKHZhbHVlW2ldKTtcclxuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgIHJlcyArPSBub3JtYWxpemVkICsgJyAnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZVtuYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgcmVzICs9IG5hbWUgKyAnICc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzLnRyaW0oKTtcclxufVxuXG4vLyBUaGVzZSB0YWcgY29uZmlncyBhcmUgc2hhcmVkIGJldHdlZW4gY29tcGlsZXItZG9tIGFuZCBydW50aW1lLWRvbSwgc28gdGhleVxyXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnRcclxuY29uc3QgSFRNTF9UQUdTID0gJ2h0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLGFkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsJyArXHJcbiAgICAnaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbixkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbiwnICtcclxuICAgICdmaWd1cmUscGljdHVyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCxhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSwnICtcclxuICAgICdkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnRjLHJ1YnkscyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsJyArXHJcbiAgICAndGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSwnICtcclxuICAgICdjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsJyArXHJcbiAgICAndGgsdHIsYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLCcgK1xyXG4gICAgJ29wdGlvbixvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLGRldGFpbHMsZGlhbG9nLG1lbnUsJyArXHJcbiAgICAnc3VtbWFyeSx0ZW1wbGF0ZSxibG9ja3F1b3RlLGlmcmFtZSx0Zm9vdCc7XHJcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9FbGVtZW50XHJcbmNvbnN0IFNWR19UQUdTID0gJ3N2ZyxhbmltYXRlLGFuaW1hdGVNb3Rpb24sYW5pbWF0ZVRyYW5zZm9ybSxjaXJjbGUsY2xpcFBhdGgsY29sb3ItcHJvZmlsZSwnICtcclxuICAgICdkZWZzLGRlc2MsZGlzY2FyZCxlbGxpcHNlLGZlQmxlbmQsZmVDb2xvck1hdHJpeCxmZUNvbXBvbmVudFRyYW5zZmVyLCcgK1xyXG4gICAgJ2ZlQ29tcG9zaXRlLGZlQ29udm9sdmVNYXRyaXgsZmVEaWZmdXNlTGlnaHRpbmcsZmVEaXNwbGFjZW1lbnRNYXAsJyArXHJcbiAgICAnZmVEaXN0YW5jZUxpZ2h0LGZlRHJvcFNoYWRvdyxmZUZsb29kLGZlRnVuY0EsZmVGdW5jQixmZUZ1bmNHLGZlRnVuY1IsJyArXHJcbiAgICAnZmVHYXVzc2lhbkJsdXIsZmVJbWFnZSxmZU1lcmdlLGZlTWVyZ2VOb2RlLGZlTW9ycGhvbG9neSxmZU9mZnNldCwnICtcclxuICAgICdmZVBvaW50TGlnaHQsZmVTcGVjdWxhckxpZ2h0aW5nLGZlU3BvdExpZ2h0LGZlVGlsZSxmZVR1cmJ1bGVuY2UsZmlsdGVyLCcgK1xyXG4gICAgJ2ZvcmVpZ25PYmplY3QsZyxoYXRjaCxoYXRjaHBhdGgsaW1hZ2UsbGluZSxsaW5lYXJHcmFkaWVudCxtYXJrZXIsbWFzaywnICtcclxuICAgICdtZXNoLG1lc2hncmFkaWVudCxtZXNocGF0Y2gsbWVzaHJvdyxtZXRhZGF0YSxtcGF0aCxwYXRoLHBhdHRlcm4sJyArXHJcbiAgICAncG9seWdvbixwb2x5bGluZSxyYWRpYWxHcmFkaWVudCxyZWN0LHNldCxzb2xpZGNvbG9yLHN0b3Asc3dpdGNoLHN5bWJvbCwnICtcclxuICAgICd0ZXh0LHRleHRQYXRoLHRpdGxlLHRzcGFuLHVua25vd24sdXNlLHZpZXcnO1xyXG5jb25zdCBWT0lEX1RBR1MgPSAnYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxocixpbWcsaW5wdXQsbGluayxtZXRhLHBhcmFtLHNvdXJjZSx0cmFjayx3YnInO1xyXG5jb25zdCBpc0hUTUxUYWcgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoSFRNTF9UQUdTKTtcclxuY29uc3QgaXNTVkdUYWcgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoU1ZHX1RBR1MpO1xyXG5jb25zdCBpc1ZvaWRUYWcgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoVk9JRF9UQUdTKTtcblxuY29uc3QgZXNjYXBlUkUgPSAvW1wiJyY8Pl0vO1xyXG5mdW5jdGlvbiBlc2NhcGVIdG1sKHN0cmluZykge1xyXG4gICAgY29uc3Qgc3RyID0gJycgKyBzdHJpbmc7XHJcbiAgICBjb25zdCBtYXRjaCA9IGVzY2FwZVJFLmV4ZWMoc3RyKTtcclxuICAgIGlmICghbWF0Y2gpIHtcclxuICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgfVxyXG4gICAgbGV0IGh0bWwgPSAnJztcclxuICAgIGxldCBlc2NhcGVkO1xyXG4gICAgbGV0IGluZGV4O1xyXG4gICAgbGV0IGxhc3RJbmRleCA9IDA7XHJcbiAgICBmb3IgKGluZGV4ID0gbWF0Y2guaW5kZXg7IGluZGV4IDwgc3RyLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgIHN3aXRjaCAoc3RyLmNoYXJDb2RlQXQoaW5kZXgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMzQ6IC8vIFwiXHJcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gJyZxdW90Oyc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAzODogLy8gJlxyXG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICcmYW1wOyc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAzOTogLy8gJ1xyXG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICcmIzM5Oyc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA2MDogLy8gPFxyXG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICcmbHQ7JztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDYyOiAvLyA+XHJcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gJyZndDsnO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhc3RJbmRleCAhPT0gaW5kZXgpIHtcclxuICAgICAgICAgICAgaHRtbCArPSBzdHIuc3Vic3RyaW5nKGxhc3RJbmRleCwgaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsYXN0SW5kZXggPSBpbmRleCArIDE7XHJcbiAgICAgICAgaHRtbCArPSBlc2NhcGVkO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxhc3RJbmRleCAhPT0gaW5kZXggPyBodG1sICsgc3RyLnN1YnN0cmluZyhsYXN0SW5kZXgsIGluZGV4KSA6IGh0bWw7XHJcbn1cclxuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1Mi9zeW50YXguaHRtbCNjb21tZW50c1xyXG5jb25zdCBjb21tZW50U3RyaXBSRSA9IC9eLT8+fDwhLS18LS0+fC0tIT58PCEtJC9nO1xyXG5mdW5jdGlvbiBlc2NhcGVIdG1sQ29tbWVudChzcmMpIHtcclxuICAgIHJldHVybiBzcmMucmVwbGFjZShjb21tZW50U3RyaXBSRSwgJycpO1xyXG59XG5cbmZ1bmN0aW9uIGxvb3NlQ29tcGFyZUFycmF5cyhhLCBiKSB7XHJcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGxldCBlcXVhbCA9IHRydWU7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgZXF1YWwgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBlcXVhbCA9IGxvb3NlRXF1YWwoYVtpXSwgYltpXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXF1YWw7XHJcbn1cclxuZnVuY3Rpb24gbG9vc2VFcXVhbChhLCBiKSB7XHJcbiAgICBpZiAoYSA9PT0gYilcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIGxldCBhVmFsaWRUeXBlID0gaXNEYXRlKGEpO1xyXG4gICAgbGV0IGJWYWxpZFR5cGUgPSBpc0RhdGUoYik7XHJcbiAgICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIGFWYWxpZFR5cGUgJiYgYlZhbGlkVHlwZSA/IGEuZ2V0VGltZSgpID09PSBiLmdldFRpbWUoKSA6IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgYVZhbGlkVHlwZSA9IGlzQXJyYXkoYSk7XHJcbiAgICBiVmFsaWRUeXBlID0gaXNBcnJheShiKTtcclxuICAgIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcclxuICAgICAgICByZXR1cm4gYVZhbGlkVHlwZSAmJiBiVmFsaWRUeXBlID8gbG9vc2VDb21wYXJlQXJyYXlzKGEsIGIpIDogZmFsc2U7XHJcbiAgICB9XHJcbiAgICBhVmFsaWRUeXBlID0gaXNPYmplY3QoYSk7XHJcbiAgICBiVmFsaWRUeXBlID0gaXNPYmplY3QoYik7XHJcbiAgICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmOiB0aGlzIGlmIHdpbGwgcHJvYmFibHkgbmV2ZXIgYmUgY2FsbGVkICovXHJcbiAgICAgICAgaWYgKCFhVmFsaWRUeXBlIHx8ICFiVmFsaWRUeXBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYUtleXNDb3VudCA9IE9iamVjdC5rZXlzKGEpLmxlbmd0aDtcclxuICAgICAgICBjb25zdCBiS2V5c0NvdW50ID0gT2JqZWN0LmtleXMoYikubGVuZ3RoO1xyXG4gICAgICAgIGlmIChhS2V5c0NvdW50ICE9PSBiS2V5c0NvdW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gYSkge1xyXG4gICAgICAgICAgICBjb25zdCBhSGFzS2V5ID0gYS5oYXNPd25Qcm9wZXJ0eShrZXkpO1xyXG4gICAgICAgICAgICBjb25zdCBiSGFzS2V5ID0gYi5oYXNPd25Qcm9wZXJ0eShrZXkpO1xyXG4gICAgICAgICAgICBpZiAoKGFIYXNLZXkgJiYgIWJIYXNLZXkpIHx8XHJcbiAgICAgICAgICAgICAgICAoIWFIYXNLZXkgJiYgYkhhc0tleSkgfHxcclxuICAgICAgICAgICAgICAgICFsb29zZUVxdWFsKGFba2V5XSwgYltrZXldKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpO1xyXG59XHJcbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZihhcnIsIHZhbCkge1xyXG4gICAgcmV0dXJuIGFyci5maW5kSW5kZXgoaXRlbSA9PiBsb29zZUVxdWFsKGl0ZW0sIHZhbCkpO1xyXG59XG5cbi8qKlxyXG4gKiBGb3IgY29udmVydGluZyB7eyBpbnRlcnBvbGF0aW9uIH19IHZhbHVlcyB0byBkaXNwbGF5ZWQgc3RyaW5ncy5cclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IHRvRGlzcGxheVN0cmluZyA9ICh2YWwpID0+IHtcclxuICAgIHJldHVybiB2YWwgPT0gbnVsbFxyXG4gICAgICAgID8gJydcclxuICAgICAgICA6IGlzT2JqZWN0KHZhbClcclxuICAgICAgICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWwsIHJlcGxhY2VyLCAyKVxyXG4gICAgICAgICAgICA6IFN0cmluZyh2YWwpO1xyXG59O1xyXG5jb25zdCByZXBsYWNlciA9IChfa2V5LCB2YWwpID0+IHtcclxuICAgIGlmIChpc01hcCh2YWwpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgW2BNYXAoJHt2YWwuc2l6ZX0pYF06IFsuLi52YWwuZW50cmllcygpXS5yZWR1Y2UoKGVudHJpZXMsIFtrZXksIHZhbF0pID0+IHtcclxuICAgICAgICAgICAgICAgIGVudHJpZXNbYCR7a2V5fSA9PmBdID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJpZXM7XHJcbiAgICAgICAgICAgIH0sIHt9KVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1NldCh2YWwpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgW2BTZXQoJHt2YWwuc2l6ZX0pYF06IFsuLi52YWwudmFsdWVzKCldXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkgJiYgIWlzQXJyYXkodmFsKSAmJiAhaXNQbGFpbk9iamVjdCh2YWwpKSB7XHJcbiAgICAgICAgcmV0dXJuIFN0cmluZyh2YWwpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbDtcclxufTtcblxuLyoqXHJcbiAqIExpc3Qgb2YgQGJhYmVsL3BhcnNlciBwbHVnaW5zIHRoYXQgYXJlIHVzZWQgZm9yIHRlbXBsYXRlIGV4cHJlc3Npb25cclxuICogdHJhbnNmb3JtcyBhbmQgU0ZDIHNjcmlwdCB0cmFuc2Zvcm1zLiBCeSBkZWZhdWx0IHdlIGVuYWJsZSBwcm9wb3NhbHMgc2xhdGVkXHJcbiAqIGZvciBFUzIwMjAuIFRoaXMgd2lsbCBuZWVkIHRvIGJlIHVwZGF0ZWQgYXMgdGhlIHNwZWMgbW92ZXMgZm9yd2FyZC5cclxuICogRnVsbCBsaXN0IGF0IGh0dHBzOi8vYmFiZWxqcy5pby9kb2NzL2VuL25leHQvYmFiZWwtcGFyc2VyI3BsdWdpbnNcclxuICovXHJcbmNvbnN0IGJhYmVsUGFyc2VyRGVmYXVsdFBsdWdpbnMgPSBbXHJcbiAgICAnYmlnSW50JyxcclxuICAgICdvcHRpb25hbENoYWluaW5nJyxcclxuICAgICdudWxsaXNoQ29hbGVzY2luZ09wZXJhdG9yJ1xyXG5dO1xyXG5jb25zdCBFTVBUWV9PQkogPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgID8gT2JqZWN0LmZyZWV6ZSh7fSlcclxuICAgIDoge307XHJcbmNvbnN0IEVNUFRZX0FSUiA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IE9iamVjdC5mcmVlemUoW10pIDogW107XHJcbmNvbnN0IE5PT1AgPSAoKSA9PiB7IH07XHJcbi8qKlxyXG4gKiBBbHdheXMgcmV0dXJuIGZhbHNlLlxyXG4gKi9cclxuY29uc3QgTk8gPSAoKSA9PiBmYWxzZTtcclxuY29uc3Qgb25SRSA9IC9eb25bXmEtel0vO1xyXG5jb25zdCBpc09uID0gKGtleSkgPT4gb25SRS50ZXN0KGtleSk7XHJcbmNvbnN0IGlzTW9kZWxMaXN0ZW5lciA9IChrZXkpID0+IGtleS5zdGFydHNXaXRoKCdvblVwZGF0ZTonKTtcclxuY29uc3QgZXh0ZW5kID0gT2JqZWN0LmFzc2lnbjtcclxuY29uc3QgcmVtb3ZlID0gKGFyciwgZWwpID0+IHtcclxuICAgIGNvbnN0IGkgPSBhcnIuaW5kZXhPZihlbCk7XHJcbiAgICBpZiAoaSA+IC0xKSB7XHJcbiAgICAgICAgYXJyLnNwbGljZShpLCAxKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xyXG5jb25zdCBoYXNPd24gPSAodmFsLCBrZXkpID0+IGhhc093blByb3BlcnR5LmNhbGwodmFsLCBrZXkpO1xyXG5jb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcclxuY29uc3QgaXNNYXAgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gJ1tvYmplY3QgTWFwXSc7XHJcbmNvbnN0IGlzU2V0ID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09ICdbb2JqZWN0IFNldF0nO1xyXG5jb25zdCBpc0RhdGUgPSAodmFsKSA9PiB2YWwgaW5zdGFuY2VvZiBEYXRlO1xyXG5jb25zdCBpc0Z1bmN0aW9uID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJztcclxuY29uc3QgaXNTdHJpbmcgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcclxuY29uc3QgaXNTeW1ib2wgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3ltYm9sJztcclxuY29uc3QgaXNPYmplY3QgPSAodmFsKSA9PiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCc7XHJcbmNvbnN0IGlzUHJvbWlzZSA9ICh2YWwpID0+IHtcclxuICAgIHJldHVybiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnRoZW4pICYmIGlzRnVuY3Rpb24odmFsLmNhdGNoKTtcclxufTtcclxuY29uc3Qgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xyXG5jb25zdCB0b1R5cGVTdHJpbmcgPSAodmFsdWUpID0+IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xyXG5jb25zdCB0b1Jhd1R5cGUgPSAodmFsdWUpID0+IHtcclxuICAgIC8vIGV4dHJhY3QgXCJSYXdUeXBlXCIgZnJvbSBzdHJpbmdzIGxpa2UgXCJbb2JqZWN0IFJhd1R5cGVdXCJcclxuICAgIHJldHVybiB0b1R5cGVTdHJpbmcodmFsdWUpLnNsaWNlKDgsIC0xKTtcclxufTtcclxuY29uc3QgaXNQbGFpbk9iamVjdCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSAnW29iamVjdCBPYmplY3RdJztcclxuY29uc3QgaXNJbnRlZ2VyS2V5ID0gKGtleSkgPT4gaXNTdHJpbmcoa2V5KSAmJlxyXG4gICAga2V5ICE9PSAnTmFOJyAmJlxyXG4gICAga2V5WzBdICE9PSAnLScgJiZcclxuICAgICcnICsgcGFyc2VJbnQoa2V5LCAxMCkgPT09IGtleTtcclxuY29uc3QgaXNSZXNlcnZlZFByb3AgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoXHJcbi8vIHRoZSBsZWFkaW5nIGNvbW1hIGlzIGludGVudGlvbmFsIHNvIGVtcHR5IHN0cmluZyBcIlwiIGlzIGFsc28gaW5jbHVkZWRcclxuJyxrZXkscmVmLCcgK1xyXG4gICAgJ29uVm5vZGVCZWZvcmVNb3VudCxvblZub2RlTW91bnRlZCwnICtcclxuICAgICdvblZub2RlQmVmb3JlVXBkYXRlLG9uVm5vZGVVcGRhdGVkLCcgK1xyXG4gICAgJ29uVm5vZGVCZWZvcmVVbm1vdW50LG9uVm5vZGVVbm1vdW50ZWQnKTtcclxuY29uc3QgY2FjaGVTdHJpbmdGdW5jdGlvbiA9IChmbikgPT4ge1xyXG4gICAgY29uc3QgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgcmV0dXJuICgoc3RyKSA9PiB7XHJcbiAgICAgICAgY29uc3QgaGl0ID0gY2FjaGVbc3RyXTtcclxuICAgICAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSk7XHJcbiAgICB9KTtcclxufTtcclxuY29uc3QgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCBjYW1lbGl6ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4ge1xyXG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIChfLCBjKSA9PiAoYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnKSk7XHJcbn0pO1xyXG5jb25zdCBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgaHlwaGVuYXRlID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJy0kMScpLnRvTG93ZXJDYXNlKCkpO1xyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IGNhcGl0YWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKSk7XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgdG9IYW5kbGVyS2V5ID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiAoc3RyID8gYG9uJHtjYXBpdGFsaXplKHN0cil9YCA6IGBgKSk7XHJcbi8vIGNvbXBhcmUgd2hldGhlciBhIHZhbHVlIGhhcyBjaGFuZ2VkLCBhY2NvdW50aW5nIGZvciBOYU4uXHJcbmNvbnN0IGhhc0NoYW5nZWQgPSAodmFsdWUsIG9sZFZhbHVlKSA9PiB2YWx1ZSAhPT0gb2xkVmFsdWUgJiYgKHZhbHVlID09PSB2YWx1ZSB8fCBvbGRWYWx1ZSA9PT0gb2xkVmFsdWUpO1xyXG5jb25zdCBpbnZva2VBcnJheUZucyA9IChmbnMsIGFyZykgPT4ge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBmbnNbaV0oYXJnKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgZGVmID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIHZhbHVlXHJcbiAgICB9KTtcclxufTtcclxuY29uc3QgdG9OdW1iZXIgPSAodmFsKSA9PiB7XHJcbiAgICBjb25zdCBuID0gcGFyc2VGbG9hdCh2YWwpO1xyXG4gICAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogbjtcclxufTtcclxubGV0IF9nbG9iYWxUaGlzO1xyXG5jb25zdCBnZXRHbG9iYWxUaGlzID0gKCkgPT4ge1xyXG4gICAgcmV0dXJuIChfZ2xvYmFsVGhpcyB8fFxyXG4gICAgICAgIChfZ2xvYmFsVGhpcyA9XHJcbiAgICAgICAgICAgIHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgICAgICAgICAgPyBnbG9iYWxUaGlzXHJcbiAgICAgICAgICAgICAgICA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgICAgICAgICAgICAgID8gc2VsZlxyXG4gICAgICAgICAgICAgICAgICAgIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB3aW5kb3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBnbG9iYWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoge30pKTtcclxufTtcblxuZXhwb3J0IHsgRU1QVFlfQVJSLCBFTVBUWV9PQkosIE5PLCBOT09QLCBQYXRjaEZsYWdOYW1lcywgYmFiZWxQYXJzZXJEZWZhdWx0UGx1Z2lucywgY2FtZWxpemUsIGNhcGl0YWxpemUsIGRlZiwgZXNjYXBlSHRtbCwgZXNjYXBlSHRtbENvbW1lbnQsIGV4dGVuZCwgZ2VuZXJhdGVDb2RlRnJhbWUsIGdldEdsb2JhbFRoaXMsIGhhc0NoYW5nZWQsIGhhc093biwgaHlwaGVuYXRlLCBpbnZva2VBcnJheUZucywgaXNBcnJheSwgaXNCb29sZWFuQXR0ciwgaXNEYXRlLCBpc0Z1bmN0aW9uLCBpc0dsb2JhbGx5V2hpdGVsaXN0ZWQsIGlzSFRNTFRhZywgaXNJbnRlZ2VyS2V5LCBpc0tub3duQXR0ciwgaXNNYXAsIGlzTW9kZWxMaXN0ZW5lciwgaXNOb1VuaXROdW1lcmljU3R5bGVQcm9wLCBpc09iamVjdCwgaXNPbiwgaXNQbGFpbk9iamVjdCwgaXNQcm9taXNlLCBpc1Jlc2VydmVkUHJvcCwgaXNTU1JTYWZlQXR0ck5hbWUsIGlzU1ZHVGFnLCBpc1NldCwgaXNTcGVjaWFsQm9vbGVhbkF0dHIsIGlzU3RyaW5nLCBpc1N5bWJvbCwgaXNWb2lkVGFnLCBsb29zZUVxdWFsLCBsb29zZUluZGV4T2YsIG1ha2VNYXAsIG5vcm1hbGl6ZUNsYXNzLCBub3JtYWxpemVTdHlsZSwgb2JqZWN0VG9TdHJpbmcsIHBhcnNlU3RyaW5nU3R5bGUsIHByb3BzVG9BdHRyTWFwLCByZW1vdmUsIHNsb3RGbGFnc1RleHQsIHN0cmluZ2lmeVN0eWxlLCB0b0Rpc3BsYXlTdHJpbmcsIHRvSGFuZGxlcktleSwgdG9OdW1iZXIsIHRvUmF3VHlwZSwgdG9UeXBlU3RyaW5nIH07XG4iLCJjb25zdCB7IHNlbGYsIGNvbnN0YW50IH0gPSByZXF1aXJlKFwib3JiLWZ1bmN0aW9uc1wiKVxuXG5jb25zdCBnZXQgPSBhID0+IGEgfHwgW11cblxuY29uc3Qgc3BsaXQgPSAobyA9IFtdLCB3YXlzID0gMikgPT4ge1xuICBjb25zdCBjaHVuayA9IE1hdGguY2VpbChvLmxlbmd0aCAvIHdheXMpXG5cbiAgcmV0dXJuIHJhbmdlKHdheXMpLm1hcCgodikgPT4ge1xuICAgIHJldHVybiBvLnNsaWNlKHYqY2h1bmssICh2KzEpKmNodW5rKVxuICB9KVxufVxuXG5jb25zdCByYW5nZSA9IChuID0gMCkgPT4gbmV3IEFycmF5KG4gPCAwPyAwOiBuKS5maWxsKDApLm1hcCgoXywgaW5kZXgpID0+IGluZGV4KVxuY29uc3QgZmlsbCA9IChuLCBmbiA9IHNlbGYpID0+IHJhbmdlKG4pLm1hcCgodikgPT4gKHR5cGVvZiBmbiA9PT0gXCJmdW5jdGlvblwiPyBmbih2KTogZm4pKVxuY29uc3QgemlwID0gKC4uLmFycmF5cykgPT4ge1xuICBhcnJheXMgPSBnZXQoYXJyYXlzKVxuICAvLyBPdXRwdXQgbGVuZ3RoIGlzIHRoZSBzbWFsbGVzdCBvZiBhbGwgaW5wdXQgbGVuZ3Roc1xuICBjb25zdCBuID0gYXJyYXlzLmxlbmd0aCA+IDA/IE1hdGgubWluKC4uLmFycmF5cy5tYXAoKGEpID0+IGdldChhKS5sZW5ndGgpKTogMFxuXG4gIHJldHVybiByYW5nZShuKS5tYXAoKGluZGV4KSA9PiBhcnJheXMubWFwKChhKSA9PiBhW2luZGV4XSkpXG59XG5cbmNvbnN0IHJlZHVjZSA9IHtcbiAgbzogKGl0ZW1zID0gW10sIHtrZXk6IGtmbiA9IHNlbGYsIHZhbHVlOiB2Zm4gPSBzZWxmfSA9IHt9KSA9PlxuICBpdGVtcy5yZWR1Y2UoKGMgLyoqIGNvbnRhaW5lciAqLywgdiwgaW5kZXgpID0+IChjW2tmbih2LCBpbmRleCldID0gdmZuKHYsIGluZGV4KSwgYyksIHt9KSxcblxuICBhOiAoaXRlbXMgPSBbXSwge3ZhbHVlOiB2Zm4gPSBzZWxmLCBjb250YWluZXIgPSBbXX0gPSB7fSkgPT5cbiAgaXRlbXMucmVkdWNlKChjIC8qKiBjb250YWluZXIgKi8sIHYsIGluZGV4KSA9PiAoYy5wdXNoKHZmbih2LCBpbmRleCkpLCBjKSwgY29udGFpbmVyKSxcblxuICBtdWw6IChpdGVtcyA9IFtdKSA9PiBpdGVtcy5yZWR1Y2UoKHYsIHZpKSA9PiB2KnZpLCAxKSxcbiAgcm9sbGluZ211bDogKFtmaXJzdCwgLi4ucmVzdF0gPSBbXSkgPT4gcmVzdC5yZWR1Y2UoXG4gICAgKGNvbnRhaW5lciwgaXRlbSkgPT4gKFxuICAgICAgY29udGFpbmVyLnB1c2goaXRlbSpsYXN0KGNvbnRhaW5lcikpLFxuICAgICAgY29udGFpbmVyXG4gICAgKSxcbiAgICBmaXJzdD8gW2ZpcnN0XTogW11cbiAgKSxcbiAgc3VtOiAoaXRlbXMgPSBbXSkgPT4gaXRlbXMucmVkdWNlKCh2LCB2aSkgPT4gdit2aSwgMClcbn1cblxuY29uc3QgbWFwID0ge1xuICBzY2FsZTogKGl0ZW1zID0gW10sIGZhY3RvciA9IDEpID0+IGl0ZW1zLm1hcCgoaXRlbSkgPT4gaXRlbSpmYWN0b3IpLFxufVxuXG5jb25zdCByYW5nZXMgPSAoLi4ubnMgLyoqIHJhbmdlIHNpemVzICovKSA9PiB7XG4gIGNvbnN0IGNzID0gcmVkdWNlLnJvbGxpbmdtdWwobnMucmV2ZXJzZSgpKS5yZXZlcnNlKCkgLy8gcmFuZ2UgY29udGFpbmVyIHNpemVzIGluIGRlY3JlYXNpbmcgb3JkZXJcbiAgY29uc3QgbmVzID0gY3Muc2hpZnQoKSAvLyB0b3RhbCBudW1iZXIgb2YgZWxlbWVudHMuXG4gIGNvbnN0IGFkZHJlc3NGbiA9IChpbmRleCkgPT4gY3MucmVkdWNlKFxuICAgIChbcnMgLyoqcmVtYWluaW5nIHNpemUgKi8sIGFkZHJlc3NdLCBjc2kpID0+IHtcbiAgICAgIHJldHVybiBbcnMlY3NpLCAoYWRkcmVzcy5wdXNoKE1hdGguZmxvb3IocnMvY3NpKSksIGFkZHJlc3MpXVxuICAgIH0sXG4gICAgW2luZGV4LCBbXV1cbiAgKVxuXG4gIGNzLnB1c2goMSkgLy8gRGVlcGVzdCBjb250YWluZXIgc2l6ZVxuICByZXR1cm4gcmFuZ2UobmVzKS5tYXAoKGluZGV4KSA9PiBhZGRyZXNzRm4oaW5kZXgpWzFdKVxufVxuXG5jb25zdCBsYXN0ID0gKGFycmF5ID0gW10pID0+ICEoYXJyYXkgaW5zdGFuY2VvZiBBcnJheSk/IGFycmF5OiBhcnJheVthcnJheS5sZW5ndGggLSAxXVxuXG4vKipcbiAqIEl0IHJlc29sdmVzIGFuIGFkZHJlc3MgaW4gYW4gQXJyYXkvT2JqZWN0XG4gKiBcbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlIFxuICogQHBhcmFtIHtBcnJheX0gYWRkcmVzcyBcbiAqIEByZXR1cm5zIFxuICovXG5jb25zdCByZXNvbHZlQWRkcmVzcyA9ICh2YWx1ZSA9IFtdLCBhZGRyZXNzID0gW10pID0+IGFkZHJlc3MucmVkdWNlKCh2LCBhaSkgPT4gdlthaV0sIHZhbHVlKVxuXG4vKipcbiAqIFJlcGVhdHMgdGhlIGlucHV0IG9iamVjdCB7Y291bnR9IHRpbWVzLiBcbiAqIFxuICogQHBhcmFtIHtPYmplY3R9IG8gXG4gKiBAcGFyYW0ge251bWJlcn0gY291bnRcbiAqIEByZXR1cm5zIFxuICovXG4gY29uc3QgcmVwZWF0ID0gKG8sIGNvdW50ID0gMSkgPT4gZmlsbChjb3VudCArIDEsIGNvbnN0YW50KG8pKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc3BsaXQsXG4gIHJhbmdlLFxuICByZWR1Y2UsXG4gIG1hcCxcbiAgZmlsbCxcbiAgemlwLFxuICBsYXN0LFxuICByYW5nZXMsXG4gIHJlc29sdmVBZGRyZXNzLFxuICByZXBlYXRcbn0iLCJjb25zdCBzZWxmID0gKHgpID0+IHhcbmNvbnN0IGNvbnN0YW50ID0gKHgpID0+IF8gPT4geFxuXG5tb2R1bGUuZXhwb3J0cyA9IHtzZWxmLCBjb25zdGFudH0iLCJpbXBvcnQgKiBhcyBydW50aW1lRG9tIGZyb20gJ0B2dWUvcnVudGltZS1kb20nO1xuaW1wb3J0IHsgaW5pdEN1c3RvbUZvcm1hdHRlciwgd2FybiwgcmVnaXN0ZXJSdW50aW1lQ29tcGlsZXIgfSBmcm9tICdAdnVlL3J1bnRpbWUtZG9tJztcbmV4cG9ydCAqIGZyb20gJ0B2dWUvcnVudGltZS1kb20nO1xuaW1wb3J0IHsgY29tcGlsZSB9IGZyb20gJ0B2dWUvY29tcGlsZXItZG9tJztcbmltcG9ydCB7IGlzU3RyaW5nLCBOT09QLCBleHRlbmQsIGdlbmVyYXRlQ29kZUZyYW1lIH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuXG5mdW5jdGlvbiBpbml0RGV2KCkge1xyXG4gICAge1xyXG4gICAgICAgIGluaXRDdXN0b21Gb3JtYXR0ZXIoKTtcclxuICAgIH1cclxufVxuXG4vLyBUaGlzIGVudHJ5IGlzIHRoZSBcImZ1bGwtYnVpbGRcIiB0aGF0IGluY2x1ZGVzIGJvdGggdGhlIHJ1bnRpbWVcclxuaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgaW5pdERldigpO1xyXG59XHJcbmNvbnN0IGNvbXBpbGVDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbmZ1bmN0aW9uIGNvbXBpbGVUb0Z1bmN0aW9uKHRlbXBsYXRlLCBvcHRpb25zKSB7XHJcbiAgICBpZiAoIWlzU3RyaW5nKHRlbXBsYXRlKSkge1xyXG4gICAgICAgIGlmICh0ZW1wbGF0ZS5ub2RlVHlwZSkge1xyXG4gICAgICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLmlubmVySFRNTDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuKGBpbnZhbGlkIHRlbXBsYXRlIG9wdGlvbjogYCwgdGVtcGxhdGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gTk9PUDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBrZXkgPSB0ZW1wbGF0ZTtcclxuICAgIGNvbnN0IGNhY2hlZCA9IGNvbXBpbGVDYWNoZVtrZXldO1xyXG4gICAgaWYgKGNhY2hlZCkge1xyXG4gICAgICAgIHJldHVybiBjYWNoZWQ7XHJcbiAgICB9XHJcbiAgICBpZiAodGVtcGxhdGVbMF0gPT09ICcjJykge1xyXG4gICAgICAgIGNvbnN0IGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0ZW1wbGF0ZSk7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhZWwpIHtcclxuICAgICAgICAgICAgd2FybihgVGVtcGxhdGUgZWxlbWVudCBub3QgZm91bmQgb3IgaXMgZW1wdHk6ICR7dGVtcGxhdGV9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIF9fVU5TQUZFX19cclxuICAgICAgICAvLyBSZWFzb246IHBvdGVudGlhbCBleGVjdXRpb24gb2YgSlMgZXhwcmVzc2lvbnMgaW4gaW4tRE9NIHRlbXBsYXRlLlxyXG4gICAgICAgIC8vIFRoZSB1c2VyIG11c3QgbWFrZSBzdXJlIHRoZSBpbi1ET00gdGVtcGxhdGUgaXMgdHJ1c3RlZC4gSWYgaXQncyByZW5kZXJlZFxyXG4gICAgICAgIC8vIGJ5IHRoZSBzZXJ2ZXIsIHRoZSB0ZW1wbGF0ZSBzaG91bGQgbm90IGNvbnRhaW4gYW55IHVzZXIgZGF0YS5cclxuICAgICAgICB0ZW1wbGF0ZSA9IGVsID8gZWwuaW5uZXJIVE1MIDogYGA7XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IGNvZGUgfSA9IGNvbXBpbGUodGVtcGxhdGUsIGV4dGVuZCh7XHJcbiAgICAgICAgaG9pc3RTdGF0aWM6IHRydWUsXHJcbiAgICAgICAgb25FcnJvcjogKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gb25FcnJvciA6IHVuZGVmaW5lZCxcclxuICAgICAgICBvbldhcm46IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGUgPT4gb25FcnJvcihlLCB0cnVlKSA6IE5PT1BcclxuICAgIH0sIG9wdGlvbnMpKTtcclxuICAgIGZ1bmN0aW9uIG9uRXJyb3IoZXJyLCBhc1dhcm5pbmcgPSBmYWxzZSkge1xyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBhc1dhcm5pbmdcclxuICAgICAgICAgICAgPyBlcnIubWVzc2FnZVxyXG4gICAgICAgICAgICA6IGBUZW1wbGF0ZSBjb21waWxhdGlvbiBlcnJvcjogJHtlcnIubWVzc2FnZX1gO1xyXG4gICAgICAgIGNvbnN0IGNvZGVGcmFtZSA9IGVyci5sb2MgJiZcclxuICAgICAgICAgICAgZ2VuZXJhdGVDb2RlRnJhbWUodGVtcGxhdGUsIGVyci5sb2Muc3RhcnQub2Zmc2V0LCBlcnIubG9jLmVuZC5vZmZzZXQpO1xyXG4gICAgICAgIHdhcm4oY29kZUZyYW1lID8gYCR7bWVzc2FnZX1cXG4ke2NvZGVGcmFtZX1gIDogbWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgICAvLyBUaGUgd2lsZGNhcmQgaW1wb3J0IHJlc3VsdHMgaW4gYSBodWdlIG9iamVjdCB3aXRoIGV2ZXJ5IGV4cG9ydFxyXG4gICAgLy8gd2l0aCBrZXlzIHRoYXQgY2Fubm90IGJlIG1hbmdsZWQsIGFuZCBjYW4gYmUgcXVpdGUgaGVhdnkgc2l6ZS13aXNlLlxyXG4gICAgLy8gSW4gdGhlIGdsb2JhbCBidWlsZCB3ZSBrbm93IGBWdWVgIGlzIGF2YWlsYWJsZSBnbG9iYWxseSBzbyB3ZSBjYW4gYXZvaWRcclxuICAgIC8vIHRoZSB3aWxkY2FyZCBvYmplY3QuXHJcbiAgICBjb25zdCByZW5kZXIgPSAobmV3IEZ1bmN0aW9uKCdWdWUnLCBjb2RlKShydW50aW1lRG9tKSk7XHJcbiAgICByZW5kZXIuX3JjID0gdHJ1ZTtcclxuICAgIHJldHVybiAoY29tcGlsZUNhY2hlW2tleV0gPSByZW5kZXIpO1xyXG59XHJcbnJlZ2lzdGVyUnVudGltZUNvbXBpbGVyKGNvbXBpbGVUb0Z1bmN0aW9uKTtcblxuZXhwb3J0IHsgY29tcGlsZVRvRnVuY3Rpb24gYXMgY29tcGlsZSB9O1xuIiwiaW1wb3J0IHtyZWR1Y2V9IGZyb20gJ29yYi1hcnJheSdcbmltcG9ydCB7IHJlYWN0aXZlIH0gZnJvbSAndnVlJ1xuXG5jbGFzcyBBcnJheU1hcCB7XG4gIGNvbnN0cnVjdG9yKGl0ZW1zID0gW10sIHtrZXl9ID0ge2tleTogb3JiZm5zLnNlbGZ9KSB7XG4gICAgdGhpcy5rZXlGbiA9IGtleVxuICAgIHRoaXMubWFwID0gcmVhY3RpdmUocmVkdWNlLm8oaXRlbXMsIHtrZXl9KSlcbiAgICB0aGlzLml0ZW1zID0gcmVhY3RpdmUoaXRlbXMpXG4gIH1cblxuICBwdXNoID0gKHYpID0+IHtcbiAgICBjb25zdCBrZXkgPSB0aGlzLmtleUZuKHYpXG5cbiAgICB0aGlzLm1hcFtrZXldID0gdlxuICAgIHJldHVybiB0aGlzLml0ZW1zLnB1c2godilcbiAgfVxuXG4gIHBvcCA9IF8gPT4ge1xuICAgIGNvbnN0IHBvcHBlZCA9IHRoaXMuaXRlbXMucG9wKClcbiAgICBjb25zdCBrZXkgPSB0aGlzLmtleUZuKHBvcHBlZClcbiAgICBcbiAgICBkZWxldGUgdGhpcy5tYXBba2V5XVxuICAgIHJldHVybiBwb3BwZWRcbiAgfVxuXG4gIHJlbW92ZSA9IChrZXkpID0+IHtcbiAgICBjb25zdCByZW1vdmVkID0gdGhpcy5tYXBba2V5XVxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pdGVtcy5pbmRleE9mKHJlbW92ZWQpXG5cbiAgICB0aGlzLml0ZW1zLnNwbGljZShpbmRleCwgMSlcbiAgICBkZWxldGUgdGhpcy5tYXBba2V5XVxuXG4gICAgcmV0dXJuIHJlbW92ZWRcbiAgfVxuXG4gIGF0ID0gaW5kZXggPT4gdGhpcy5pdGVtc1tpbmRleF1cbiAgZ2V0ID0ga2V5ID0+IHRoaXMubWFwW2tleV1cbiAgbGVuZ3RoID0gXyA9PiB0aGlzLml0ZW1zLmxlbmd0aFxufVxuXG5leHBvcnQgY29uc3QgYXJyYXltYXAgPSAoaXRlbXMsIGtleSkgPT4gbmV3IEFycmF5TWFwKGl0ZW1zLCBrZXkpIiwiXG5jb25zdCBkYXRhVHJhbnNmZXIgPSB7XG4gIGRyYWdnZWQ6IHVuZGVmaW5lZFxufVxuXG5leHBvcnQgY29uc3QgZHJhZyA9IHtcbiAgZW1pdHM6IFtdLFxuICBtZXRob2RzOiB7XG4gICAgZHJhZ2dpbmcoZXZ0KSB7IGRhdGFUcmFuc2Zlci5kcmFnZ2VkID0gZXZ0LnRhcmdldCB9XG4gIH0sXG5cbiAgdGVtcGxhdGU6IGBcbiAgPGRpdiBkcmFnZ2FibGU9XCJ0cnVlXCIgQGRyYWdzdGFydD1cImRyYWdnaW5nXCI+XG4gICAgPHNsb3Q+PC9zbG90PlxuICA8L2Rpdj5cbiAgYFxufVxuXG5leHBvcnQgY29uc3QgZHJvcCA9IHtcbiAgZW1pdHM6IFsnZHJvcHBlZCcsICdkcmFnb3ZlciddLFxuICBtZXRob2RzOiB7XG4gICAgc291cmNlKCkge3JldHVybiBkYXRhVHJhbnNmZXIuZHJhZ2dlZH0sXG4gICAgZHJvcChldnQpIHtcbiAgICAgIGV2dC5jdXJyZW50VGFyZ2V0LmlzU2FtZU5vZGUodGhpcy5zb3VyY2UoKSlcbiAgICAgID8gKHt9KVxuICAgICAgOiB0aGlzLiRlbWl0KCdkcm9wcGVkJywge3RhcmdldDogZXZ0LmN1cnJlbnRUYXJnZXQsIHNvdXJjZTogdGhpcy5zb3VyY2UoKX0pXG4gICAgfSxcbiAgICBvdmVyKGV2dCkgeyB0aGlzLiRlbWl0KCdkcmFnb3ZlcicsIGV2dCkgfVxuICB9LFxuXG4gIHRlbXBsYXRlOiBgXG4gIDxkaXYgQGRyb3AucHJldmVudD1cImRyb3BcIiBAZHJhZ292ZXIucHJldmVudD1cIm92ZXJcIj5cbiAgICA8c2xvdD48L3Nsb3Q+XG4gIDwvZGl2PlxuICBgXG59XG5cbmV4cG9ydCBjb25zdCBkcmFnZHJvcCA9IHtcbiAgZW1pdHM6IFsuLi5kcmFnLmVtaXRzLCAuLi5kcm9wLmVtaXRzXSxcblxuICBtZXRob2RzOiB7XG4gICAgLi4uZHJhZy5tZXRob2RzLFxuICAgIC4uLmRyb3AubWV0aG9kc1xuICB9LFxuXG4gIHRlbXBsYXRlOiBgXG4gIDxkaXYgZHJhZ2dhYmxlPVwidHJ1ZVwiIEBkcmFnc3RhcnQ9XCJkcmFnZ2luZ1wiIEBkcm9wLnByZXZlbnQ9XCJkcm9wXCIgQGRyYWdvdmVyLnByZXZlbnQ9XCJvdmVyXCI+XG4gICAgPHNsb3Q+PC9zbG90PlxuICA8L2Rpdj5cbiAgYFxufSIsIlxuZXhwb3J0IGNvbnN0IGV4dGVybmFsVmFsdWUgPSB7XG4gIHByb3BzOiBbJ2l0ZW0nLCAnc2hvdyddLFxuICBlbWl0czogWyd1cGRhdGU6c2hvdyddLFxuICBtZXRob2RzOiB7XG4gICAgdmFsdWVkKCkge1xuICAgICAgdGhpcy4kZW1pdCgndXBkYXRlOnNob3cnLCBmYWxzZSlcbiAgICB9LFxuICB9LFxuXG4gIHRlbXBsYXRlOiBgXG4gIDxkaXYgY2xhc3M9XCJ2YWx1ZVwiPlxuICAgIDx0ZXh0YXJlYSB2LW1vZGVsPVwiaXRlbS52YWx1ZVwiPjwvdGV4dGFyZWE+XG4gICAgPGRpdj5cbiAgICAgIDxidXR0b24+Q2FuY2VsPC9idXR0b24+XG4gICAgICA8YnV0dG9uIEBjbGljaz1cInZhbHVlZFwiPlNldDwvYnV0dG9uPlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbiAgYFxufSIsImltcG9ydCB7ZHJhZywgZHJvcCwgZHJhZ2Ryb3B9IGZyb20gJy4vZHJhZydcbmltcG9ydCB7IGV4dGVybmFsVmFsdWUgfSBmcm9tICcuL2V4dGVybmFsVmFsdWUnXG5pbXBvcnQgeyB3dG9iamVjdCB9IGZyb20gJy4vd3RvYmplY3QnXG5pbXBvcnQgeyB3dHlwZSB9IGZyb20gJy4vd3R5cGUnXG5pbXBvcnQgeyB3b2JqZWN0IH0gZnJvbSAnLi93b2JqZWN0J1xuaW1wb3J0IHsgYXJyYXltYXAgfSBmcm9tICcuLi9hcnJheW1hcCdcbmltcG9ydCB7IG1ha2VJZCB9IGZyb20gJy4uL3JhbmRvbSdcblxuZXhwb3J0IGNvbnN0IHdiZW5jaCA9IHtcbiAgY29tcG9uZW50czoge2RyYWcsIGRyb3AsIGRyYWdkcm9wLCBleHRlcm5hbFZhbHVlLCB3dHlwZSwgd29iamVjdCwgd3RvYmplY3R9LFxuICBwcm9wczogWyd0eXBlcycsICdvYmplY3RzJ10sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdvYmplY3RzOiB7fSxcbiAgICAgIGJlbmNoT2JqZWN0czogYXJyYXltYXAoW10sIHtrZXk6ICh7aWR9KSA9PiBpZH0pLFxuICAgICAgZXh0ZXJuYWxWYWx1ZToge1xuICAgICAgICBzaG93VWk6IGZhbHNlLFxuICAgICAgICBzb3VyY2U6IHt9XG4gICAgICB9LFxuICAgIH1cbiAgfSxcbiAgXG4gIGNvbXB1dGVkOiB7XG4gICAgd2F0Y2hhYmxlQm9zKCkge3JldHVybiB0aGlzLmJlbmNoT2JqZWN0cy5pdGVtc30sXG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGVsaWQoZWwpIHtyZXR1cm4gZWwuZ2V0QXR0cmlidXRlKCdpZCcpIH0sXG4gICAgZWxuYW1lKGVsKSB7IHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoJ25hbWUnKSB9LFxuICAgIGVsY25hbWUoZWwpIHsgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSgnY25hbWUnKSB9LFxuICAgIGVscHJvcHMoZWwpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkOiB0aGlzLmVsaWQoZWwpLFxuICAgICAgICBuYW1lOiB0aGlzLmVsbmFtZShlbCksXG4gICAgICAgIGNuYW1lOiB0aGlzLmVsY25hbWUoZWwpXG4gICAgICB9XG4gICAgfSwgLy8gZHJvcHBlZCBvYmplY3QgcHJvcHNcblxuICAgIGNocHJvcHMoZWwpIHtcbiAgICAgIGNvbnN0IFtjaGVsXSA9IGVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdkaXYnKSAvLyBjaGlsZCBlbGVtZW50XG5cbiAgICAgIHJldHVybiB0aGlzLmVscHJvcHMoY2hlbClcbiAgICB9LCAvLyBjaGlsZCBlbGVtZW50IHByb3BzXG5cbiAgICBiZW5jaGVkKHtzb3VyY2U6IGVsIC8qKmRyb3BwZWQgZWxlbWVudCAqL30pIHtcbiAgICAgIC8vIGNvbnN0IHdpdGhJbiA9IChibykgPT4gYm8uaXNTYW1lTm9kZShibylcbiAgICAgIC8vIGNvbnN0IHdpdGhJbkluZGV4ID0gdGhpcy5iZW5jaE9iamVjdHMuZmluZEluZGV4KHdpdGhJbilcblxuICAgICAgLy8gd2l0aEluSW5kZXggIT0gLTE/IHRoaXMuYmVuY2hPYmplY3RzLnNwbGljZSh3aXRoSW5JbmRleCwgMSk6ICh7fSk7XG4gICAgICBjb25zdCBibyA9IHRoaXMuY2hwcm9wcyhlbCkgLy8gYmVuY2ggb2JqZWN0XG4gICAgICBjb25zdCBkcm9wRWxlbWVudHMgPSBbJ3d0eXBlJywgJ3dvYmplY3QnXVxuXG4gICAgICBkcm9wRWxlbWVudHMuc29tZSgodHlwZSkgPT4gdHlwZSA9PT0gYm8uY25hbWUpXG4gICAgICA/IHRoaXMuYmVuY2hPYmplY3RzLnB1c2goe1xuICAgICAgICBpZDogbWFrZUlkKCksXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIGl0ZW1zOiBbYm9dXG4gICAgICB9KVxuICAgICAgOiAoe30pXG4gICAgfSxcblxuICAgIGNvbWJpbmF0aW9uKHt0YXJnZXQsIHNvdXJjZSAvKipkcm9wcGVkIGVsZW1lbnQgKi99KSB7XG4gICAgICBjb25zdCBjb3AgPSB0aGlzLmNocHJvcHMoc291cmNlKSAvLyBjb21iaW5hdGlvbiBjYW5kaWRhdGUgcHJvcHNcbiAgICAgIGNvbnN0IGN0cCA9IHRoaXMuY2hwcm9wcyh0YXJnZXQpIC8vIGNvbWJpbmF0aW9uIHRhcmdldCBwcm9wc1xuICAgICAgY29uc3QgZHJvcEVsZW1lbnRzID0gWyd3dG9iamVjdCddXG4gICAgICBjb25zdCBjb21iaW5lID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBjbyA9IHRoaXMuYmVuY2hPYmplY3RzLmdldChjb3AuaWQpXG4gICAgICAgIGNvbnN0IGN0ID0gdGhpcy5iZW5jaE9iamVjdHMuZ2V0KGN0cC5pZClcblxuICAgICAgICAvLyBSZW1vdmUgdGhlIGRyYWdnZWQgb2JqZWN0IGZyb20gdGhlIGJlbmNoXG4gICAgICAgIHRoaXMuYmVuY2hPYmplY3RzLnJlbW92ZShjb3AuaWQpXG5cbiAgICAgICAgLy8gQ29tYmluZSBkcmFnZ2VkIGFuZCBkcmFnb3ZlciBvYmplY3RzXG4gICAgICAgIGN0Lml0ZW1zLnB1c2goLi4uY28uaXRlbXMpXG4gICAgICB9XG5cbiAgICAgIGRyb3BFbGVtZW50cy5zb21lKCh0eXBlKSA9PiB0eXBlID09PSBjb3AuY25hbWUpXG4gICAgICA/IGNvbWJpbmUoKVxuICAgICAgOiAoe30pXG4gICAgfSxcblxuICAgIGRyYWdvdmVyKGV2dCAvKiogZHJhZ292ZXIgZXZlbnQgb2JqZWN0Ki8pIHtcbiAgICAgIGV2dC5kYXRhVHJhbnNmZXIuYWN0aW9uID0gXCJtb3ZlXCJcbiAgICB9XG4gIH0sXG4gIHRlbXBsYXRlOiBgXG4gIDxleHRlcm5hbFZhbHVlXG4gICAgdi1pZj1cInRoaXMuZXh0ZXJuYWxWYWx1ZS5zaG93VWlcIlxuICAgIHYtbW9kZWw6c2hvdz1cInRoaXMuZXh0ZXJuYWxWYWx1ZS5zaG93VWlcIlxuICAgIDppdGVtPVwidGhpcy5leHRlcm5hbFZhbHVlLnNvdXJjZVwiXG4gID5cbiAgPC9leHRlcm5hbFZhbHVlPlxuICA8ZHJvcCB2LWVsc2UgY2xhc3M9XCJ3YmVuY2hcIiBAZHJvcHBlZD1cImJlbmNoZWRcIiBAZHJhZ292ZXI9XCJkcmFnb3ZlclwiPlxuICAgIDxwIHYtaWY9XCJiZW5jaE9iamVjdHMubGVuZ3RoKCkgPT0gMFwiPkRyb3AgdHlwZXMgYW5kIG9iamVjdHMuLi48L3A+XG4gICAgPHVsPlxuICAgICAgPGxpIHYtZm9yPVwiYm8gaW4gYmVuY2hPYmplY3RzLml0ZW1zXCI+XG4gICAgICAgIDxkcmFnZHJvcCBAZHJvcHBlZD1cImNvbWJpbmF0aW9uXCIgQGRyYWdvdmVyPVwiZHJhZ292ZXJcIj5cbiAgICAgICAgICA8d3RvYmplY3RcbiAgICAgICAgICAgIDpiYXNlPVwiYm9cIlxuICAgICAgICAgICAgQGV4dGVybmFsVmFsdWU9XCIodGhpcy5leHRlcm5hbFZhbHVlLnNvdXJjZSA9IGJvLCB0aGlzLmV4dGVybmFsVmFsdWUuc2hvd1VpID0gdHJ1ZSlcIlxuICAgICAgICAgID5cbiAgICAgICAgICA8L3d0b2JqZWN0PlxuICAgICAgICAgIHt7Ym99fVxuICAgICAgICA8L2RyYWdkcm9wPlxuICAgICAgPC9saT5cbiAgICA8L3VsPlxuICA8L2Ryb3A+XG4gIGBcbn0iLCJleHBvcnQgY29uc3Qgd29iamVjdCA9IHtcbiAgcHJvcHM6IFsnbmFtZSddLFxuXG4gIHRlbXBsYXRlOiBgXG4gIDxkaXYgOm5hbWU9XCJuYW1lXCIgY2xhc3M9XCJ3b2JqZWN0XCIgY25hbWU9XCJ3b2JqZWN0XCI+XG4gICAge3tuYW1lfX1cbiAgPC9kaXY+XG4gIGBcbn0iLCJpbXBvcnQgeyB3dHlwZSB9IGZyb20gXCIuL3d0eXBlXCJcbmltcG9ydCB7IHdvYmplY3QgfSBmcm9tIFwiLi93b2JqZWN0XCJcbmltcG9ydCB7IHd0b2JqZWN0IH0gZnJvbSBcIi4vd3RvYmplY3RcIlxuaW1wb3J0IHsgd2JlbmNoIH0gZnJvbSBcIi4vd2JlbmNoXCJcbmltcG9ydCB7IGRyYWcgfSBmcm9tIFwiLi9kcmFnXCJcbmltcG9ydCB7c3RyaW5nLCBudW1iZXIsIGFycmF5LCBvYmplY3QsIHZhbHVlfSBmcm9tICcuLi90eXBlcy9iYXNpYydcblxuZXhwb3J0IGNvbnN0IHdvcmtzaG9wID0ge1xuICBjb21wb25lbnRzOiB7XG4gICAgd3R5cGUsXG4gICAgd29iamVjdCxcbiAgICB3dG9iamVjdCxcbiAgICB3YmVuY2gsXG4gICAgZHJhZ1xuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlRGVmOiAnJyxcbiAgICAgIHR5cGVFcnJvcjogZmFsc2UsXG4gICAgICB0eXBlczoge1xuICAgICAgICBbc3RyaW5nLm5hbWVdOiBzdHJpbmcuZnVuYyxcbiAgICAgICAgW251bWJlci5uYW1lXTogbnVtYmVyLmZ1bmMsXG4gICAgICAgIFthcnJheS5uYW1lXTogYXJyYXkuZnVuYyxcbiAgICAgICAgW29iamVjdC5uYW1lXTogb2JqZWN0LmZ1bmMsXG4gICAgICAgIFt2YWx1ZS5uYW1lXTogdmFsdWUuZnVuYyxcbiAgICAgICAgJ3RmLm1vZGVsJzogdGYubW9kZWwsXG4gICAgICB9LFxuICAgICAgb2JqZWN0czogW11cbiAgICB9XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIG5ld1R5cGUoKSB7XG4gICAgICB0cnkge1xuICAgICAgICAodGhpcy50eXBlRGVmID09IHVuZGVmaW5lZCB8fCB0aGlzLnR5cGVEZWYgPT0gJycpXG4gICAgICAgID8gdGhpcy5zZXRFcnJvcigpXG4gICAgICAgIDogdGhpcy50eXBlc1t0aGlzLnR5cGVEZWZdID0gbmV3IEZ1bmN0aW9uKGByZXR1cm4gJHt0aGlzLnR5cGVEZWZ9YCkoKVxuICAgICAgfVxuICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlKVxuICAgICAgICB0aGlzLnNldEVycm9yKClcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0RXJyb3IoKSB7dGhpcy50eXBlRXJyb3IgPSB0cnVlfSxcbiAgICByZXNldEVycm9yKCkge3RoaXMudHlwZUVycm9yID0gZmFsc2V9XG4gIH0sXG5cbiAgdGVtcGxhdGU6IGBcbiAgPGRpdiBjbGFzcz1cIndvcmtzaG9wLWhlYWRlclwiPlxuICAgIDxpbnB1dFxuICAgICAgcGxhY2Vob2xkZXI9XCJUeXBlIFJlZmVyZW5jZVwiXG4gICAgICB2LW1vZGVsLnRyaW09XCJ0eXBlRGVmXCJcbiAgICAgIHYtb246a2V5dXAuZW50ZXI9XCJuZXdUeXBlXCJcbiAgICAgIEBpbnB1dD1cInJlc2V0RXJyb3JcIlxuICAgICAgY2xhc3M9XCJ3b3Jrc2hvcC1mb3JtLWVsZW1zXCJcbiAgICAgID5cbiAgICA8IS0tPGJ1dHRvblxuICAgICAgQGNsaWNrPVwibmV3VHlwZVwiXG4gICAgICB0aXRsZT1cIk5ldyB0eXBlXCJcbiAgICAgIGNsYXNzPVwid29ya3Nob3AtZm9ybS1lbGVtc1wiXG4gICAgICA+TmV3IFR5cGU8L2J1dHRvbj4tLT5cbiAgXG4gICAgPHAgdi1pZj1cInR5cGVFcnJvclwiPnt7dHlwZURlZn19IDxlbT5pcyBpbnZhbGlkPC9lbT48L3A+XG4gICAgPHAgdi1lbHNlPVwiIXR5cGVFcnJvclwiPjwvcD5cbiAgICA8aDU+VHlwZXM8L2g1PlxuICAgIDx1bD5cbiAgICAgIDxsaSB2LWZvcj1cIih0eXBlLCBuYW1lKSBpbiB0eXBlc1wiPlxuICAgICAgICA8ZHJhZz5cbiAgICAgICAgICA8d3R5cGUgOm5hbWU9XCJuYW1lXCI+PC93dHlwZT5cbiAgICAgICAgPC9kcmFnPlxuICAgICAgPC9saT5cbiAgICA8L3VsPlxuICAgIDxoNT5CZW5jaDwvaDU+XG4gICAgPHdiZW5jaCA6dHlwZXM9XCJ0eXBlc1wiIDpvYmplY3RzPVwib2JqZWN0c1wiPjwvd2JlbmNoPlxuICAgIDxoNT5PYmplY3RzPC9oNT5cbiAgICA8dWw+XG4gICAgICA8bGkgdi1mb3I9XCJvYiBpbiBvYmplY3RzXCI+XG4gICAgICAgIDxkcmFnPlxuICAgICAgICAgIDx3b2JqZWN0Pjwvd29iamVjdD5cbiAgICAgICAgPC9kcmFnPlxuICAgICAgPC9saT5cbiAgICA8L3VsPlxuICA8L2Rpdj5cbiAgYFxufSIsImltcG9ydCB7IHd0eXBlIH0gZnJvbSBcIi4vd3R5cGVcIlxuaW1wb3J0IHsgd29iamVjdCB9IGZyb20gXCIuL3dvYmplY3RcIlxuXG5leHBvcnQgY29uc3Qgd3RvYmplY3QgPSB7XG4gIGNvbXBvbmVudHM6IHt3dHlwZSwgd29iamVjdH0sXG4gIHByb3BzOiBbJ2Jhc2UnXSxcbiAgZW1pdHM6IFsnZXh0ZXJuYWxWYWx1ZSddLFxuXG4gIG1ldGhvZHM6IHtcbiAgICB2YWx1ZVR5cGUoKSB7dGhpcy5iYXNlLml0ZW1zLmxlbmd0aCA9PSAxICYmIHRoaXMuYmFzZS5pdGVtc1swXS5uYW1lID09PSAndmFsdWUnfSxcbiAgICBleHRlcm5hbFZhbHVlKCkgeyB0aGlzLnZhbHVlVHlwZSgpPyB0aGlzLiRlbWl0KCdleHRlcm5hbFZhbHVlJyk6ICh7fSkgfSxcbiAgICBldmFsdWF0ZSgpIHsgcmV0dXJuIHRoaXMudmFsdWVUeXBlKCkgPyB0aGlzLmJhc2UudmFsdWUgOiBncmFwaFZhbHVlKHRoaXMuYmFzZS5pdGVtcykgfVxuICB9LFxuXG4gIHRlbXBsYXRlOiBgXG4gIDxkaXZcbiAgICBjbGFzcz1cInd0b2JqZWN0XCJcbiAgICBjbmFtZT1cInd0b2JqZWN0XCJcbiAgICA6aWQ9XCJiYXNlLmlkXCJcbiAgICA6dmFsdWU9XCJiYXNlLnZhbHVlXCJcbiAgICBAZGJsY2xpY2suc3RvcC5wcmV2ZW50PVwiZXh0ZXJuYWxWYWx1ZVwiXG4gID5cbiAgICA8aW5wdXQgcGxhY2Vob2xkZXI9XCJuYW1lXCIgdi1tb2RlbD1cImJhc2UubmFtZVwiPlxuICAgIHt7YmFzZS52YWx1ZX19XG5cblxuICAgIDwhLS0gSXRlcmF0ZSBvdmVyIGJlbmNoIG9iamVjdCBpdGVtcyAtLT5cbiAgICA8Y29tcG9uZW50IHYtZm9yPVwiaXRlbSBpbiBiYXNlLml0ZW1zXCIgOmlzPVwiaXRlbS5jbmFtZVwiIDpuYW1lPVwiaXRlbS5uYW1lXCI+PC9jb21wb25lbnQ+XG4gICAgPGJ1dHRvbiBAY2xpY2s9XCJldmFsdWF0ZVwiPkV2YWx1YXRlPC9idXR0b24+XG4gIDwvZGl2PlxuICBgXG59IiwiZXhwb3J0IGNvbnN0IHd0eXBlID0ge1xuICBjb21wb25lbnRzOiB7fSxcbiAgcHJvcHM6IFsnbmFtZSddLFxuXG4gIHRlbXBsYXRlOiBgXG4gIDxkaXYgOm5hbWU9XCJuYW1lXCIgY2xhc3M9XCJ3dHlwZVwiIGNuYW1lPVwid3R5cGVcIj5cbiAgICB7e25hbWV9fVxuICA8L2Rpdj5cbiAgYFxufSIsImltcG9ydCB7cmFuZ2V9IGZyb20gJ29yYi1hcnJheSdcblxuZXhwb3J0IGNvbnN0IG1ha2VJZCA9IChjaGFycyA9IFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5XCIsIHNpemUgPSAxMCkgPT5cbnJhbmdlKHNpemUpXG4ucmVkdWNlKFxuICAoY2lkLyoqY3VycmVudCBpZCAqLykgPT4gY2lkICsgY2hhcnMuY2hhckF0KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoYXJzLmxlbmd0aCkpLFxuICBcIlwiXG4pIiwiaW1wb3J0IHtzZWxmfSBmcm9tICdvcmItZnVuY3Rpb25zJ1xuXG5cbmNvbnN0IGZ1bmNzID0ge1xuICBudW1iZXI6IHYgPT4gTnVtYmVyKHYpLFxuICBhcnJheTogXyA9PiBbXSxcbiAgb2JqZWN0OiBfID0+IHt9LFxuICB2YWx1ZTogdiA9PiBuZXcgRnVuY3Rpb24oYHJldHVybiAoJHt2fSlgKSgpXG59XG5cbmV4cG9ydCBjb25zdCBzdHJpbmcgPSB7bmFtZTogJ3N0cmluZycsIGZ1bmM6IHNlbGZ9XG5leHBvcnQgY29uc3QgbnVtYmVyID0ge25hbWU6ICdudW1iZXInLCBmdW5jOiBmdW5jcy5udW1iZXJ9XG5leHBvcnQgY29uc3QgYXJyYXkgPSB7bmFtZTogJ2FycmF5JywgZnVuYzogZnVuY3MuYXJyYXl9XG5leHBvcnQgY29uc3Qgb2JqZWN0ID0ge25hbWU6ICdvYmplY3QnLCBmdW5jOiBmdW5jcy5vYmplY3R9XG5leHBvcnQgY29uc3QgdmFsdWUgPSB7bmFtZTogJ3ZhbHVlJywgZnVuYzogZnVuY3MudmFsdWV9IiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuXHRcdCgpID0+IChtb2R1bGUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcblx0dHJ5IHtcblx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcblx0fVxufSkoKTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiaW1wb3J0IHtjcmVhdGVBcHB9IGZyb20gJ3Z1ZSdcbmltcG9ydCB7IHdvcmtzaG9wIH0gZnJvbSAnLi9jb21wb25lbnRzL3dvcmtzaG9wJ1xuXG5jb25zdCBhcHAgPSBjcmVhdGVBcHAoe1xuICBkYXRhKCkge1xuICAgIHJldHVybiB7fVxuICB9XG59KVxuXG5hcHAuY29tcG9uZW50KCd3b3Jrc2hvcCcsIHdvcmtzaG9wKVxuYXBwLm1vdW50KCcjYXBwJykiXSwic291cmNlUm9vdCI6IiJ9